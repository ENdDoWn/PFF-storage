// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = import.meta.require;

// node_modules/strtok3/lib/stream/Errors.js
var defaultMessages = "End-Of-Stream", EndOfStreamError, AbortError;
var init_Errors = __esm(() => {
  EndOfStreamError = class EndOfStreamError extends Error {
    constructor() {
      super(defaultMessages);
      this.name = "EndOfStreamError";
    }
  };
  AbortError = class AbortError extends Error {
    constructor(message = "The operation was aborted") {
      super(message);
      this.name = "AbortError";
    }
  };
});

// node_modules/strtok3/lib/stream/Deferred.js
class Deferred {
  constructor() {
    this.resolve = () => null;
    this.reject = () => null;
    this.promise = new Promise((resolve, reject) => {
      this.reject = reject;
      this.resolve = resolve;
    });
  }
}

// node_modules/strtok3/lib/stream/AbstractStreamReader.js
class AbstractStreamReader {
  constructor() {
    this.endOfStream = false;
    this.interrupted = false;
    this.peekQueue = [];
  }
  async peek(uint8Array, mayBeLess = false) {
    const bytesRead = await this.read(uint8Array, mayBeLess);
    this.peekQueue.push(uint8Array.subarray(0, bytesRead));
    return bytesRead;
  }
  async read(buffer, mayBeLess = false) {
    if (buffer.length === 0) {
      return 0;
    }
    let bytesRead = this.readFromPeekBuffer(buffer);
    if (!this.endOfStream) {
      bytesRead += await this.readRemainderFromStream(buffer.subarray(bytesRead), mayBeLess);
    }
    if (bytesRead === 0 && !mayBeLess) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
  readFromPeekBuffer(buffer) {
    let remaining = buffer.length;
    let bytesRead = 0;
    while (this.peekQueue.length > 0 && remaining > 0) {
      const peekData = this.peekQueue.pop();
      if (!peekData)
        throw new Error("peekData should be defined");
      const lenCopy = Math.min(peekData.length, remaining);
      buffer.set(peekData.subarray(0, lenCopy), bytesRead);
      bytesRead += lenCopy;
      remaining -= lenCopy;
      if (lenCopy < peekData.length) {
        this.peekQueue.push(peekData.subarray(lenCopy));
      }
    }
    return bytesRead;
  }
  async readRemainderFromStream(buffer, mayBeLess) {
    let bytesRead = 0;
    while (bytesRead < buffer.length && !this.endOfStream) {
      if (this.interrupted) {
        throw new AbortError;
      }
      const chunkLen = await this.readFromStream(buffer.subarray(bytesRead), mayBeLess);
      if (chunkLen === 0)
        break;
      bytesRead += chunkLen;
    }
    if (!mayBeLess && bytesRead < buffer.length) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
}
var init_AbstractStreamReader = __esm(() => {
  init_Errors();
});

// node_modules/strtok3/lib/stream/StreamReader.js
var StreamReader;
var init_StreamReader = __esm(() => {
  init_Errors();
  init_AbstractStreamReader();
  StreamReader = class StreamReader extends AbstractStreamReader {
    constructor(s) {
      super();
      this.s = s;
      this.deferred = null;
      if (!s.read || !s.once) {
        throw new Error("Expected an instance of stream.Readable");
      }
      this.s.once("end", () => {
        this.endOfStream = true;
        if (this.deferred) {
          this.deferred.resolve(0);
        }
      });
      this.s.once("error", (err) => this.reject(err));
      this.s.once("close", () => this.abort());
    }
    async readFromStream(buffer, mayBeLess) {
      if (buffer.length === 0)
        return 0;
      const readBuffer = this.s.read(buffer.length);
      if (readBuffer) {
        buffer.set(readBuffer);
        return readBuffer.length;
      }
      const request = {
        buffer,
        mayBeLess,
        deferred: new Deferred
      };
      this.deferred = request.deferred;
      this.s.once("readable", () => {
        this.readDeferred(request);
      });
      return request.deferred.promise;
    }
    readDeferred(request) {
      const readBuffer = this.s.read(request.buffer.length);
      if (readBuffer) {
        request.buffer.set(readBuffer);
        request.deferred.resolve(readBuffer.length);
        this.deferred = null;
      } else {
        this.s.once("readable", () => {
          this.readDeferred(request);
        });
      }
    }
    reject(err) {
      this.interrupted = true;
      if (this.deferred) {
        this.deferred.reject(err);
        this.deferred = null;
      }
    }
    async abort() {
      this.reject(new AbortError);
    }
    async close() {
      return this.abort();
    }
  };
});

// node_modules/strtok3/lib/stream/WebStreamReader.js
var WebStreamReader;
var init_WebStreamReader = __esm(() => {
  init_AbstractStreamReader();
  WebStreamReader = class WebStreamReader extends AbstractStreamReader {
    constructor(reader) {
      super();
      this.reader = reader;
    }
    async abort() {
      return this.close();
    }
    async close() {
      this.reader.releaseLock();
    }
  };
});

// node_modules/strtok3/lib/stream/WebStreamByobReader.js
var WebStreamByobReader;
var init_WebStreamByobReader = __esm(() => {
  init_WebStreamReader();
  WebStreamByobReader = class WebStreamByobReader extends WebStreamReader {
    async readFromStream(buffer, mayBeLess) {
      if (buffer.length === 0)
        return 0;
      const result = await this.reader.read(new Uint8Array(buffer.length), { min: mayBeLess ? undefined : buffer.length });
      if (result.done) {
        this.endOfStream = result.done;
      }
      if (result.value) {
        buffer.set(result.value);
        return result.value.length;
      }
      return 0;
    }
  };
});

// node_modules/strtok3/lib/stream/WebStreamDefaultReader.js
var WebStreamDefaultReader;
var init_WebStreamDefaultReader = __esm(() => {
  init_Errors();
  init_AbstractStreamReader();
  WebStreamDefaultReader = class WebStreamDefaultReader extends AbstractStreamReader {
    constructor(reader) {
      super();
      this.reader = reader;
      this.buffer = null;
    }
    writeChunk(target, chunk) {
      const written = Math.min(chunk.length, target.length);
      target.set(chunk.subarray(0, written));
      if (written < chunk.length) {
        this.buffer = chunk.subarray(written);
      } else {
        this.buffer = null;
      }
      return written;
    }
    async readFromStream(buffer, mayBeLess) {
      if (buffer.length === 0)
        return 0;
      let totalBytesRead = 0;
      if (this.buffer) {
        totalBytesRead += this.writeChunk(buffer, this.buffer);
      }
      while (totalBytesRead < buffer.length && !this.endOfStream) {
        const result = await this.reader.read();
        if (result.done) {
          this.endOfStream = true;
          break;
        }
        if (result.value) {
          totalBytesRead += this.writeChunk(buffer.subarray(totalBytesRead), result.value);
        }
      }
      if (!mayBeLess && totalBytesRead === 0 && this.endOfStream) {
        throw new EndOfStreamError;
      }
      return totalBytesRead;
    }
    abort() {
      this.interrupted = true;
      return this.reader.cancel();
    }
    async close() {
      await this.abort();
      this.reader.releaseLock();
    }
  };
});

// node_modules/strtok3/lib/stream/WebStreamReaderFactory.js
function makeWebStreamReader(stream) {
  try {
    const reader = stream.getReader({ mode: "byob" });
    if (reader instanceof ReadableStreamDefaultReader) {
      return new WebStreamDefaultReader(reader);
    }
    return new WebStreamByobReader(reader);
  } catch (error) {
    if (error instanceof TypeError) {
      return new WebStreamDefaultReader(stream.getReader());
    }
    throw error;
  }
}
var init_WebStreamReaderFactory = __esm(() => {
  init_WebStreamByobReader();
  init_WebStreamDefaultReader();
});

// node_modules/strtok3/lib/stream/index.js
var init_stream = __esm(() => {
  init_Errors();
  init_StreamReader();
  init_WebStreamByobReader();
  init_WebStreamDefaultReader();
  init_WebStreamReaderFactory();
});

// node_modules/strtok3/lib/AbstractTokenizer.js
class AbstractTokenizer {
  constructor(options) {
    this.numBuffer = new Uint8Array(8);
    this.position = 0;
    this.onClose = options?.onClose;
    if (options?.abortSignal) {
      options.abortSignal.addEventListener("abort", () => {
        this.abort();
      });
    }
  }
  async readToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.readBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(uint8Array, 0);
  }
  async peekToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.peekBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(uint8Array, 0);
  }
  async readNumber(token) {
    const len = await this.readBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(this.numBuffer, 0);
  }
  async peekNumber(token) {
    const len = await this.peekBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(this.numBuffer, 0);
  }
  async ignore(length) {
    if (this.fileInfo.size !== undefined) {
      const bytesLeft = this.fileInfo.size - this.position;
      if (length > bytesLeft) {
        this.position += bytesLeft;
        return bytesLeft;
      }
    }
    this.position += length;
    return length;
  }
  async close() {
    await this.abort();
    await this.onClose?.();
  }
  normalizeOptions(uint8Array, options) {
    if (!this.supportsRandomAccess() && options && options.position !== undefined && options.position < this.position) {
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    }
    return {
      ...{
        mayBeLess: false,
        offset: 0,
        length: uint8Array.length,
        position: this.position
      },
      ...options
    };
  }
  abort() {
    return Promise.resolve();
  }
}
var init_AbstractTokenizer = __esm(() => {
  init_stream();
});

// node_modules/strtok3/lib/ReadStreamTokenizer.js
var maxBufferSize = 256000, ReadStreamTokenizer;
var init_ReadStreamTokenizer = __esm(() => {
  init_AbstractTokenizer();
  init_stream();
  ReadStreamTokenizer = class ReadStreamTokenizer extends AbstractTokenizer {
    constructor(streamReader, options) {
      super(options);
      this.streamReader = streamReader;
      this.fileInfo = options?.fileInfo ?? {};
    }
    async readBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const skipBytes = normOptions.position - this.position;
      if (skipBytes > 0) {
        await this.ignore(skipBytes);
        return this.readBuffer(uint8Array, options);
      }
      if (skipBytes < 0) {
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      }
      if (normOptions.length === 0) {
        return 0;
      }
      const bytesRead = await this.streamReader.read(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
      this.position += bytesRead;
      if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
        throw new EndOfStreamError;
      }
      return bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      let bytesRead = 0;
      if (normOptions.position) {
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
          const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
          bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
          uint8Array.set(skipBuffer.subarray(skipBytes));
          return bytesRead - skipBytes;
        }
        if (skipBytes < 0) {
          throw new Error("Cannot peek from a negative offset in a stream");
        }
      }
      if (normOptions.length > 0) {
        try {
          bytesRead = await this.streamReader.peek(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
        } catch (err) {
          if (options?.mayBeLess && err instanceof EndOfStreamError) {
            return 0;
          }
          throw err;
        }
        if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
          throw new EndOfStreamError;
        }
      }
      return bytesRead;
    }
    async ignore(length) {
      const bufSize = Math.min(maxBufferSize, length);
      const buf = new Uint8Array(bufSize);
      let totBytesRead = 0;
      while (totBytesRead < length) {
        const remaining = length - totBytesRead;
        const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
        if (bytesRead < 0) {
          return bytesRead;
        }
        totBytesRead += bytesRead;
      }
      return totBytesRead;
    }
    abort() {
      return this.streamReader.abort();
    }
    async close() {
      return this.streamReader.close();
    }
    supportsRandomAccess() {
      return false;
    }
  };
});

// node_modules/strtok3/lib/BufferTokenizer.js
var BufferTokenizer;
var init_BufferTokenizer = __esm(() => {
  init_stream();
  init_AbstractTokenizer();
  BufferTokenizer = class BufferTokenizer extends AbstractTokenizer {
    constructor(uint8Array, options) {
      super(options);
      this.uint8Array = uint8Array;
      this.fileInfo = { ...options?.fileInfo ?? {}, ...{ size: uint8Array.length } };
    }
    async readBuffer(uint8Array, options) {
      if (options?.position) {
        this.position = options.position;
      }
      const bytesRead = await this.peekBuffer(uint8Array, options);
      this.position += bytesRead;
      return bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
      if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
        throw new EndOfStreamError;
      }
      uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read));
      return bytes2read;
    }
    close() {
      return super.close();
    }
    supportsRandomAccess() {
      return true;
    }
    setPosition(position) {
      this.position = position;
    }
  };
});

// node_modules/strtok3/lib/BlobTokenizer.js
var init_BlobTokenizer = __esm(() => {
  init_stream();
  init_AbstractTokenizer();
});

// node_modules/strtok3/lib/core.js
function fromStream(stream, options) {
  const streamReader = new StreamReader(stream);
  const _options = options ?? {};
  const chainedClose = _options.onClose;
  _options.onClose = async () => {
    await streamReader.close();
    if (chainedClose) {
      return chainedClose();
    }
  };
  return new ReadStreamTokenizer(streamReader, _options);
}
function fromWebStream(webStream, options) {
  const webStreamReader = makeWebStreamReader(webStream);
  const _options = options ?? {};
  const chainedClose = _options.onClose;
  _options.onClose = async () => {
    await webStreamReader.close();
    if (chainedClose) {
      return chainedClose();
    }
  };
  return new ReadStreamTokenizer(webStreamReader, _options);
}
function fromBuffer(uint8Array, options) {
  return new BufferTokenizer(uint8Array, options);
}
var init_core = __esm(() => {
  init_stream();
  init_ReadStreamTokenizer();
  init_BufferTokenizer();
  init_BlobTokenizer();
  init_stream();
  init_AbstractTokenizer();
});

// node_modules/strtok3/lib/FileTokenizer.js
import { open as fsOpen } from "fs/promises";
var FileTokenizer;
var init_FileTokenizer = __esm(() => {
  init_AbstractTokenizer();
  init_stream();
  FileTokenizer = class FileTokenizer extends AbstractTokenizer {
    static async fromFile(sourceFilePath) {
      const fileHandle = await fsOpen(sourceFilePath, "r");
      const stat = await fileHandle.stat();
      return new FileTokenizer(fileHandle, { fileInfo: { path: sourceFilePath, size: stat.size } });
    }
    constructor(fileHandle, options) {
      super(options);
      this.fileHandle = fileHandle;
      this.fileInfo = options.fileInfo;
    }
    async readBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      this.position = normOptions.position;
      if (normOptions.length === 0)
        return 0;
      const res = await this.fileHandle.read(uint8Array, 0, normOptions.length, normOptions.position);
      this.position += res.bytesRead;
      if (res.bytesRead < normOptions.length && (!options || !options.mayBeLess)) {
        throw new EndOfStreamError;
      }
      return res.bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const res = await this.fileHandle.read(uint8Array, 0, normOptions.length, normOptions.position);
      if (!normOptions.mayBeLess && res.bytesRead < normOptions.length) {
        throw new EndOfStreamError;
      }
      return res.bytesRead;
    }
    async close() {
      await this.fileHandle.close();
      return super.close();
    }
    setPosition(position) {
      this.position = position;
    }
    supportsRandomAccess() {
      return true;
    }
  };
});

// node_modules/strtok3/lib/index.js
import { stat as fsStat } from "fs/promises";
async function fromStream2(stream, options) {
  const rst = fromStream(stream, options);
  if (stream.path) {
    const stat = await fsStat(stream.path);
    rst.fileInfo.path = stream.path;
    rst.fileInfo.size = stat.size;
  }
  return rst;
}
var fromFile;
var init_lib = __esm(() => {
  init_core();
  init_FileTokenizer();
  init_FileTokenizer();
  init_core();
  fromFile = FileTokenizer.fromFile;
});

// node_modules/ieee754/index.js
var init_ieee754 = __esm(() => {
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/@borewit/text-codec/lib/index.js
function textDecode(bytes, encoding = "utf-8") {
  switch (encoding.toLowerCase()) {
    case "utf-8":
    case "utf8":
      if (typeof globalThis.TextDecoder !== "undefined") {
        return new globalThis.TextDecoder("utf-8").decode(bytes);
      }
      return decodeUTF8(bytes);
    case "utf-16le":
      return decodeUTF16LE(bytes);
    case "ascii":
      return decodeASCII(bytes);
    case "latin1":
    case "iso-8859-1":
      return decodeLatin1(bytes);
    case "windows-1252":
      return decodeWindows1252(bytes);
    default:
      throw new RangeError(`Encoding '${encoding}' not supported`);
  }
}
function decodeUTF8(bytes) {
  let out = "";
  let i = 0;
  while (i < bytes.length) {
    const b1 = bytes[i++];
    if (b1 < 128) {
      out += String.fromCharCode(b1);
    } else if (b1 < 224) {
      const b2 = bytes[i++] & 63;
      out += String.fromCharCode((b1 & 31) << 6 | b2);
    } else if (b1 < 240) {
      const b2 = bytes[i++] & 63;
      const b3 = bytes[i++] & 63;
      out += String.fromCharCode((b1 & 15) << 12 | b2 << 6 | b3);
    } else {
      const b2 = bytes[i++] & 63;
      const b3 = bytes[i++] & 63;
      const b4 = bytes[i++] & 63;
      let cp = (b1 & 7) << 18 | b2 << 12 | b3 << 6 | b4;
      cp -= 65536;
      out += String.fromCharCode(55296 + (cp >> 10 & 1023), 56320 + (cp & 1023));
    }
  }
  return out;
}
function decodeUTF16LE(bytes) {
  let out = "";
  for (let i = 0;i < bytes.length; i += 2) {
    out += String.fromCharCode(bytes[i] | bytes[i + 1] << 8);
  }
  return out;
}
function decodeASCII(bytes) {
  return String.fromCharCode(...bytes.map((b) => b & 127));
}
function decodeLatin1(bytes) {
  return String.fromCharCode(...bytes);
}
function decodeWindows1252(bytes) {
  let out = "";
  for (const b of bytes) {
    if (b >= 128 && b <= 159 && WINDOWS_1252_EXTRA[b]) {
      out += WINDOWS_1252_EXTRA[b];
    } else {
      out += String.fromCharCode(b);
    }
  }
  return out;
}
var WINDOWS_1252_EXTRA, WINDOWS_1252_REVERSE;
var init_lib2 = __esm(() => {
  WINDOWS_1252_EXTRA = {
    128: "\u20AC",
    130: "\u201A",
    131: "\u0192",
    132: "\u201E",
    133: "\u2026",
    134: "\u2020",
    135: "\u2021",
    136: "\u02C6",
    137: "\u2030",
    138: "\u0160",
    139: "\u2039",
    140: "\u0152",
    142: "\u017D",
    145: "\u2018",
    146: "\u2019",
    147: "\u201C",
    148: "\u201D",
    149: "\u2022",
    150: "\u2013",
    151: "\u2014",
    152: "\u02DC",
    153: "\u2122",
    154: "\u0161",
    155: "\u203A",
    156: "\u0153",
    158: "\u017E",
    159: "\u0178"
  };
  WINDOWS_1252_REVERSE = {};
  for (const [code, char] of Object.entries(WINDOWS_1252_EXTRA)) {
    WINDOWS_1252_REVERSE[char] = Number.parseInt(code);
  }
});

// node_modules/token-types/lib/index.js
function dv(array) {
  return new DataView(array.buffer, array.byteOffset);
}

class StringType2 {
  constructor(len, encoding) {
    this.len = len;
    this.encoding = encoding;
  }
  get(data, offset = 0) {
    const bytes = data.subarray(offset, offset + this.len);
    return textDecode(bytes, this.encoding);
  }
}
var UINT8, UINT16_LE, UINT16_BE, UINT32_LE, UINT32_BE, INT32_BE, UINT64_LE;
var init_lib3 = __esm(() => {
  init_ieee754();
  init_lib2();
  UINT8 = {
    len: 1,
    get(array, offset) {
      return dv(array).getUint8(offset);
    },
    put(array, offset, value) {
      dv(array).setUint8(offset, value);
      return offset + 1;
    }
  };
  UINT16_LE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset, true);
    },
    put(array, offset, value) {
      dv(array).setUint16(offset, value, true);
      return offset + 2;
    }
  };
  UINT16_BE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset);
    },
    put(array, offset, value) {
      dv(array).setUint16(offset, value);
      return offset + 2;
    }
  };
  UINT32_LE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset, true);
    },
    put(array, offset, value) {
      dv(array).setUint32(offset, value, true);
      return offset + 4;
    }
  };
  UINT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset);
    },
    put(array, offset, value) {
      dv(array).setUint32(offset, value);
      return offset + 4;
    }
  };
  INT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getInt32(offset);
    },
    put(array, offset, value) {
      dv(array).setInt32(offset, value);
      return offset + 4;
    }
  };
  UINT64_LE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigUint64(offset, true);
    },
    put(array, offset, value) {
      dv(array).setBigUint64(offset, value, true);
      return offset + 8;
    }
  };
});

// node_modules/fflate/esm/index.mjs
import { createRequire } from "module";
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function gunzipSync(data, opts) {
  var st = gzs(data);
  if (st + 8 > data.length)
    err(6, "invalid gzip data");
  return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
}
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function decompressSync(data, opts) {
  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
}
var require2, Worker, u8, u16, i32, fleb, fdeb, clim, freb = function(eb, start) {
  var b = new u16(31);
  for (var i = 0;i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  }
  var r = new i32(b[30]);
  for (var i = 1;i < 30; ++i) {
    for (var j = b[i];j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return { b, r };
}, _a, fl, revfl, _b, fd, revfd, rev, x, i, hMap = function(cd, mb, r) {
  var s = cd.length;
  var i2 = 0;
  var l = new u16(mb);
  for (;i2 < s; ++i2) {
    if (cd[i2])
      ++l[cd[i2] - 1];
  }
  var le = new u16(mb);
  for (i2 = 1;i2 < mb; ++i2) {
    le[i2] = le[i2 - 1] + l[i2 - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i2 = 0;i2 < s; ++i2) {
      if (cd[i2]) {
        var sv = i2 << 4 | cd[i2];
        var r_1 = mb - cd[i2];
        var v = le[cd[i2] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1;v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i2 = 0;i2 < s; ++i2) {
      if (cd[i2]) {
        co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];
      }
    }
  }
  return co;
}, flt, i, i, i, i, fdt, i, flrm, fdrm, max = function(a) {
  var m = a[0];
  for (var i2 = 1;i2 < a.length; ++i2) {
    if (a[i2] > m)
      m = a[i2];
  }
  return m;
}, bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
}, bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
}, shft = function(p) {
  return (p + 7) / 8 | 0;
}, slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  return new u8(v.subarray(s, e));
}, ec, err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
}, inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
        if (t > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t), bt);
        st.b = bt += l, st.p = pos = t * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i2 = 0;i2 < hcLen; ++i2) {
          clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i2 = 0;i2 < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >> 4;
          if (s < 16) {
            ldt[i2++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i2++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (;; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i2 = sym - 257, b = fleb[i2];
          add = bits(dat, pos, (1 << b) - 1) + fl[i2];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
        if (!d)
          err(3);
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (;bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (;bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
}, et, gzs = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    err(6, "invalid gzip data");
  var flg = d[3];
  var st = 10;
  if (flg & 4)
    st += (d[10] | d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1);zs > 0; zs -= !d[st++])
    ;
  return st + (flg & 2);
}, gzl = function(d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
}, zls = function(d, dict) {
  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    err(6, "invalid zlib data");
  if ((d[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d[1] >> 3 & 4) + 2;
}, td, tds = 0;
var init_esm = __esm(() => {
  require2 = createRequire("/");
  try {
    Worker = require2("worker_threads").Worker;
  } catch (e) {}
  u8 = Uint8Array;
  u16 = Uint16Array;
  i32 = Int32Array;
  fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
  fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
  clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  _a = freb(fleb, 2);
  fl = _a.b;
  revfl = _a.r;
  fl[28] = 258, revfl[258] = 28;
  _b = freb(fdeb, 0);
  fd = _b.b;
  revfd = _b.r;
  rev = new u16(32768);
  for (i = 0;i < 32768; ++i) {
    x = (i & 43690) >> 1 | (i & 21845) << 1;
    x = (x & 52428) >> 2 | (x & 13107) << 2;
    x = (x & 61680) >> 4 | (x & 3855) << 4;
    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
  }
  flt = new u8(288);
  for (i = 0;i < 144; ++i)
    flt[i] = 8;
  for (i = 144;i < 256; ++i)
    flt[i] = 9;
  for (i = 256;i < 280; ++i)
    flt[i] = 7;
  for (i = 280;i < 288; ++i)
    flt[i] = 8;
  fdt = new u8(32);
  for (i = 0;i < 32; ++i)
    fdt[i] = 5;
  flrm = /* @__PURE__ */ hMap(flt, 9, 1);
  fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
  ec = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
  ];
  et = /* @__PURE__ */ new u8(0);
  td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder;
  try {
    td.decode(et, { stream: true });
    tds = 1;
  } catch (e) {}
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash2 = 0;
      for (let i2 = 0;i2 < namespace.length; i2++) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i2);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {}
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
    } catch (error) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = (()=>{throw new Error("Cannot require module "+"supports-color");})();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i2 = 0;i2 < keys.length; i2++) {
      debug.inspectOpts[keys[i2]] = exports.inspectOpts[keys[i2]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/@tokenizer/inflate/lib/ZipToken.js
var Signature, DataDescriptor, LocalFileHeaderToken, EndOfCentralDirectoryRecordToken, FileHeader;
var init_ZipToken = __esm(() => {
  init_lib3();
  Signature = {
    LocalFileHeader: 67324752,
    DataDescriptor: 134695760,
    CentralFileHeader: 33639248,
    EndOfCentralDirectory: 101010256
  };
  DataDescriptor = {
    get(array) {
      const flags = UINT16_LE.get(array, 6);
      return {
        signature: UINT32_LE.get(array, 0),
        compressedSize: UINT32_LE.get(array, 8),
        uncompressedSize: UINT32_LE.get(array, 12)
      };
    },
    len: 16
  };
  LocalFileHeaderToken = {
    get(array) {
      const flags = UINT16_LE.get(array, 6);
      return {
        signature: UINT32_LE.get(array, 0),
        minVersion: UINT16_LE.get(array, 4),
        dataDescriptor: !!(flags & 8),
        compressedMethod: UINT16_LE.get(array, 8),
        compressedSize: UINT32_LE.get(array, 18),
        uncompressedSize: UINT32_LE.get(array, 22),
        filenameLength: UINT16_LE.get(array, 26),
        extraFieldLength: UINT16_LE.get(array, 28),
        filename: null
      };
    },
    len: 30
  };
  EndOfCentralDirectoryRecordToken = {
    get(array) {
      return {
        signature: UINT32_LE.get(array, 0),
        nrOfThisDisk: UINT16_LE.get(array, 4),
        nrOfThisDiskWithTheStart: UINT16_LE.get(array, 6),
        nrOfEntriesOnThisDisk: UINT16_LE.get(array, 8),
        nrOfEntriesOfSize: UINT16_LE.get(array, 10),
        sizeOfCd: UINT32_LE.get(array, 12),
        offsetOfStartOfCd: UINT32_LE.get(array, 16),
        zipFileCommentLength: UINT16_LE.get(array, 20)
      };
    },
    len: 22
  };
  FileHeader = {
    get(array) {
      const flags = UINT16_LE.get(array, 8);
      return {
        signature: UINT32_LE.get(array, 0),
        minVersion: UINT16_LE.get(array, 6),
        dataDescriptor: !!(flags & 8),
        compressedMethod: UINT16_LE.get(array, 10),
        compressedSize: UINT32_LE.get(array, 20),
        uncompressedSize: UINT32_LE.get(array, 24),
        filenameLength: UINT16_LE.get(array, 28),
        extraFieldLength: UINT16_LE.get(array, 30),
        fileCommentLength: UINT16_LE.get(array, 32),
        relativeOffsetOfLocalHeader: UINT32_LE.get(array, 42),
        filename: null
      };
    },
    len: 46
  };
});

// node_modules/@tokenizer/inflate/lib/index.js
function signatureToArray(signature) {
  const signatureBytes = new Uint8Array(UINT32_LE.len);
  UINT32_LE.put(signatureBytes, 0, signature);
  return signatureBytes;
}

class ZipHandler {
  constructor(tokenizer) {
    this.tokenizer = tokenizer;
    this.syncBuffer = new Uint8Array(syncBufferSize);
  }
  async isZip() {
    return await this.peekSignature() === Signature.LocalFileHeader;
  }
  peekSignature() {
    return this.tokenizer.peekToken(UINT32_LE);
  }
  async findEndOfCentralDirectoryLocator() {
    const randomReadTokenizer = this.tokenizer;
    const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);
    const buffer = this.syncBuffer.subarray(0, chunkLength);
    await this.tokenizer.readBuffer(buffer, { position: randomReadTokenizer.fileInfo.size - chunkLength });
    for (let i2 = buffer.length - 4;i2 >= 0; i2--) {
      if (buffer[i2] === eocdSignatureBytes[0] && buffer[i2 + 1] === eocdSignatureBytes[1] && buffer[i2 + 2] === eocdSignatureBytes[2] && buffer[i2 + 3] === eocdSignatureBytes[3]) {
        return randomReadTokenizer.fileInfo.size - chunkLength + i2;
      }
    }
    return -1;
  }
  async readCentralDirectory() {
    if (!this.tokenizer.supportsRandomAccess()) {
      debug("Cannot reading central-directory without random-read support");
      return;
    }
    debug("Reading central-directory...");
    const pos = this.tokenizer.position;
    const offset = await this.findEndOfCentralDirectoryLocator();
    if (offset > 0) {
      debug("Central-directory 32-bit signature found");
      const eocdHeader = await this.tokenizer.readToken(EndOfCentralDirectoryRecordToken, offset);
      const files = [];
      this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);
      for (let n = 0;n < eocdHeader.nrOfEntriesOfSize; ++n) {
        const entry = await this.tokenizer.readToken(FileHeader);
        if (entry.signature !== Signature.CentralFileHeader) {
          throw new Error("Expected Central-File-Header signature");
        }
        entry.filename = await this.tokenizer.readToken(new StringType2(entry.filenameLength, "utf-8"));
        await this.tokenizer.ignore(entry.extraFieldLength);
        await this.tokenizer.ignore(entry.fileCommentLength);
        files.push(entry);
        debug(`Add central-directory file-entry: n=${n + 1}/${files.length}: filename=${files[n].filename}`);
      }
      this.tokenizer.setPosition(pos);
      return files;
    }
    this.tokenizer.setPosition(pos);
  }
  async unzip(fileCb) {
    const entries = await this.readCentralDirectory();
    if (entries) {
      return this.iterateOverCentralDirectory(entries, fileCb);
    }
    let stop = false;
    do {
      const zipHeader = await this.readLocalFileHeader();
      if (!zipHeader)
        break;
      const next = fileCb(zipHeader);
      stop = !!next.stop;
      let fileData = undefined;
      await this.tokenizer.ignore(zipHeader.extraFieldLength);
      if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {
        const chunks = [];
        let len = syncBufferSize;
        debug("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
        let nextHeaderIndex = -1;
        while (nextHeaderIndex < 0 && len === syncBufferSize) {
          len = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true });
          nextHeaderIndex = indexOf(this.syncBuffer.subarray(0, len), ddSignatureArray);
          const size = nextHeaderIndex >= 0 ? nextHeaderIndex : len;
          if (next.handler) {
            const data = new Uint8Array(size);
            await this.tokenizer.readBuffer(data);
            chunks.push(data);
          } else {
            await this.tokenizer.ignore(size);
          }
        }
        debug(`Found data-descriptor-signature at pos=${this.tokenizer.position}`);
        if (next.handler) {
          await this.inflate(zipHeader, mergeArrays(chunks), next.handler);
        }
      } else {
        if (next.handler) {
          debug(`Reading compressed-file-data: ${zipHeader.compressedSize} bytes`);
          fileData = new Uint8Array(zipHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next.handler);
        } else {
          debug(`Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`);
          await this.tokenizer.ignore(zipHeader.compressedSize);
        }
      }
      debug(`Reading data-descriptor at pos=${this.tokenizer.position}`);
      if (zipHeader.dataDescriptor) {
        const dataDescriptor = await this.tokenizer.readToken(DataDescriptor);
        if (dataDescriptor.signature !== 134695760) {
          throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - DataDescriptor.len}`);
        }
      }
    } while (!stop);
  }
  async iterateOverCentralDirectory(entries, fileCb) {
    for (const fileHeader of entries) {
      const next = fileCb(fileHeader);
      if (next.handler) {
        this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);
        const zipHeader = await this.readLocalFileHeader();
        if (zipHeader) {
          await this.tokenizer.ignore(zipHeader.extraFieldLength);
          const fileData = new Uint8Array(fileHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next.handler);
        }
      }
      if (next.stop)
        break;
    }
  }
  inflate(zipHeader, fileData, cb) {
    if (zipHeader.compressedMethod === 0) {
      return cb(fileData);
    }
    debug(`Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`);
    const uncompressedData = decompressSync(fileData);
    return cb(uncompressedData);
  }
  async readLocalFileHeader() {
    const signature = await this.tokenizer.peekToken(UINT32_LE);
    if (signature === Signature.LocalFileHeader) {
      const header = await this.tokenizer.readToken(LocalFileHeaderToken);
      header.filename = await this.tokenizer.readToken(new StringType2(header.filenameLength, "utf-8"));
      return header;
    }
    if (signature === Signature.CentralFileHeader) {
      return false;
    }
    if (signature === 3759263696) {
      throw new Error("Encrypted ZIP");
    }
    throw new Error("Unexpected signature");
  }
}
function indexOf(buffer, portion) {
  const bufferLength = buffer.length;
  const portionLength = portion.length;
  if (portionLength > bufferLength)
    return -1;
  for (let i2 = 0;i2 <= bufferLength - portionLength; i2++) {
    let found = true;
    for (let j = 0;j < portionLength; j++) {
      if (buffer[i2 + j] !== portion[j]) {
        found = false;
        break;
      }
    }
    if (found) {
      return i2;
    }
  }
  return -1;
}
function mergeArrays(chunks) {
  const totalLength = chunks.reduce((acc, curr) => acc + curr.length, 0);
  const mergedArray = new Uint8Array(totalLength);
  let offset = 0;
  for (const chunk of chunks) {
    mergedArray.set(chunk, offset);
    offset += chunk.length;
  }
  return mergedArray;
}
var import_debug, debug, syncBufferSize, ddSignatureArray, eocdSignatureBytes;
var init_lib4 = __esm(() => {
  init_lib3();
  init_esm();
  init_ZipToken();
  import_debug = __toESM(require_src(), 1);
  debug = import_debug.default("tokenizer:inflate");
  syncBufferSize = 256 * 1024;
  ddSignatureArray = signatureToArray(Signature.DataDescriptor);
  eocdSignatureBytes = signatureToArray(Signature.EndOfCentralDirectory);
});

// node_modules/uint8array-extras/index.js
function getUintBE(view) {
  const { byteLength } = view;
  if (byteLength === 6) {
    return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
  }
  if (byteLength === 5) {
    return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
  }
  if (byteLength === 4) {
    return view.getUint32(0);
  }
  if (byteLength === 3) {
    return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
  }
  if (byteLength === 2) {
    return view.getUint16(0);
  }
  if (byteLength === 1) {
    return view.getUint8(0);
  }
}
var cachedDecoders, cachedEncoder, byteToHexLookupTable;
var init_uint8array_extras = __esm(() => {
  cachedDecoders = {
    utf8: new globalThis.TextDecoder("utf8")
  };
  cachedEncoder = new globalThis.TextEncoder;
  byteToHexLookupTable = Array.from({ length: 256 }, (_, index) => index.toString(16).padStart(2, "0"));
});

// node_modules/file-type/util.js
function stringToBytes(string) {
  return [...string].map((character) => character.charCodeAt(0));
}
function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
  const readSum = Number.parseInt(new StringType2(6).get(arrayBuffer, 148).replace(/\0.*$/, "").trim(), 8);
  if (Number.isNaN(readSum)) {
    return false;
  }
  let sum = 8 * 32;
  for (let index = offset;index < offset + 148; index++) {
    sum += arrayBuffer[index];
  }
  for (let index = offset + 156;index < offset + 512; index++) {
    sum += arrayBuffer[index];
  }
  return readSum === sum;
}
var uint32SyncSafeToken;
var init_util = __esm(() => {
  init_lib3();
  uint32SyncSafeToken = {
    get: (buffer, offset) => buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,
    len: 4
  };
});

// node_modules/file-type/supported.js
var extensions, mimeTypes;
var init_supported = __esm(() => {
  extensions = [
    "jpg",
    "png",
    "apng",
    "gif",
    "webp",
    "flif",
    "xcf",
    "cr2",
    "cr3",
    "orf",
    "arw",
    "dng",
    "nef",
    "rw2",
    "raf",
    "tif",
    "bmp",
    "icns",
    "jxr",
    "psd",
    "indd",
    "zip",
    "tar",
    "rar",
    "gz",
    "bz2",
    "7z",
    "dmg",
    "mp4",
    "mid",
    "mkv",
    "webm",
    "mov",
    "avi",
    "mpg",
    "mp2",
    "mp3",
    "m4a",
    "oga",
    "ogg",
    "ogv",
    "opus",
    "flac",
    "wav",
    "spx",
    "amr",
    "pdf",
    "epub",
    "elf",
    "macho",
    "exe",
    "swf",
    "rtf",
    "wasm",
    "woff",
    "woff2",
    "eot",
    "ttf",
    "otf",
    "ttc",
    "ico",
    "flv",
    "ps",
    "xz",
    "sqlite",
    "nes",
    "crx",
    "xpi",
    "cab",
    "deb",
    "ar",
    "rpm",
    "Z",
    "lz",
    "cfb",
    "mxf",
    "mts",
    "blend",
    "bpg",
    "docx",
    "pptx",
    "xlsx",
    "3gp",
    "3g2",
    "j2c",
    "jp2",
    "jpm",
    "jpx",
    "mj2",
    "aif",
    "qcp",
    "odt",
    "ods",
    "odp",
    "xml",
    "mobi",
    "heic",
    "cur",
    "ktx",
    "ape",
    "wv",
    "dcm",
    "ics",
    "glb",
    "pcap",
    "dsf",
    "lnk",
    "alias",
    "voc",
    "ac3",
    "m4v",
    "m4p",
    "m4b",
    "f4v",
    "f4p",
    "f4b",
    "f4a",
    "mie",
    "asf",
    "ogm",
    "ogx",
    "mpc",
    "arrow",
    "shp",
    "aac",
    "mp1",
    "it",
    "s3m",
    "xm",
    "skp",
    "avif",
    "eps",
    "lzh",
    "pgp",
    "asar",
    "stl",
    "chm",
    "3mf",
    "zst",
    "jxl",
    "vcf",
    "jls",
    "pst",
    "dwg",
    "parquet",
    "class",
    "arj",
    "cpio",
    "ace",
    "avro",
    "icc",
    "fbx",
    "vsdx",
    "vtt",
    "apk",
    "drc",
    "lz4",
    "potx",
    "xltx",
    "dotx",
    "xltm",
    "ott",
    "ots",
    "otp",
    "odg",
    "otg",
    "xlsm",
    "docm",
    "dotm",
    "potm",
    "pptm",
    "jar",
    "rm",
    "ppsm",
    "ppsx"
  ];
  mimeTypes = [
    "image/jpeg",
    "image/png",
    "image/gif",
    "image/webp",
    "image/flif",
    "image/x-xcf",
    "image/x-canon-cr2",
    "image/x-canon-cr3",
    "image/tiff",
    "image/bmp",
    "image/vnd.ms-photo",
    "image/vnd.adobe.photoshop",
    "application/x-indesign",
    "application/epub+zip",
    "application/x-xpinstall",
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
    "application/vnd.oasis.opendocument.text",
    "application/vnd.oasis.opendocument.spreadsheet",
    "application/vnd.oasis.opendocument.presentation",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
    "application/zip",
    "application/x-tar",
    "application/x-rar-compressed",
    "application/gzip",
    "application/x-bzip2",
    "application/x-7z-compressed",
    "application/x-apple-diskimage",
    "application/vnd.apache.arrow.file",
    "video/mp4",
    "audio/midi",
    "video/matroska",
    "video/webm",
    "video/quicktime",
    "video/vnd.avi",
    "audio/wav",
    "audio/qcelp",
    "audio/x-ms-asf",
    "video/x-ms-asf",
    "application/vnd.ms-asf",
    "video/mpeg",
    "video/3gpp",
    "audio/mpeg",
    "audio/mp4",
    "video/ogg",
    "audio/ogg",
    "audio/ogg; codecs=opus",
    "application/ogg",
    "audio/flac",
    "audio/ape",
    "audio/wavpack",
    "audio/amr",
    "application/pdf",
    "application/x-elf",
    "application/x-mach-binary",
    "application/x-msdownload",
    "application/x-shockwave-flash",
    "application/rtf",
    "application/wasm",
    "font/woff",
    "font/woff2",
    "application/vnd.ms-fontobject",
    "font/ttf",
    "font/otf",
    "font/collection",
    "image/x-icon",
    "video/x-flv",
    "application/postscript",
    "application/eps",
    "application/x-xz",
    "application/x-sqlite3",
    "application/x-nintendo-nes-rom",
    "application/x-google-chrome-extension",
    "application/vnd.ms-cab-compressed",
    "application/x-deb",
    "application/x-unix-archive",
    "application/x-rpm",
    "application/x-compress",
    "application/x-lzip",
    "application/x-cfb",
    "application/x-mie",
    "application/mxf",
    "video/mp2t",
    "application/x-blender",
    "image/bpg",
    "image/j2c",
    "image/jp2",
    "image/jpx",
    "image/jpm",
    "image/mj2",
    "audio/aiff",
    "application/xml",
    "application/x-mobipocket-ebook",
    "image/heif",
    "image/heif-sequence",
    "image/heic",
    "image/heic-sequence",
    "image/icns",
    "image/ktx",
    "application/dicom",
    "audio/x-musepack",
    "text/calendar",
    "text/vcard",
    "text/vtt",
    "model/gltf-binary",
    "application/vnd.tcpdump.pcap",
    "audio/x-dsf",
    "application/x.ms.shortcut",
    "application/x.apple.alias",
    "audio/x-voc",
    "audio/vnd.dolby.dd-raw",
    "audio/x-m4a",
    "image/apng",
    "image/x-olympus-orf",
    "image/x-sony-arw",
    "image/x-adobe-dng",
    "image/x-nikon-nef",
    "image/x-panasonic-rw2",
    "image/x-fujifilm-raf",
    "video/x-m4v",
    "video/3gpp2",
    "application/x-esri-shape",
    "audio/aac",
    "audio/x-it",
    "audio/x-s3m",
    "audio/x-xm",
    "video/MP1S",
    "video/MP2P",
    "application/vnd.sketchup.skp",
    "image/avif",
    "application/x-lzh-compressed",
    "application/pgp-encrypted",
    "application/x-asar",
    "model/stl",
    "application/vnd.ms-htmlhelp",
    "model/3mf",
    "image/jxl",
    "application/zstd",
    "image/jls",
    "application/vnd.ms-outlook",
    "image/vnd.dwg",
    "application/vnd.apache.parquet",
    "application/java-vm",
    "application/x-arj",
    "application/x-cpio",
    "application/x-ace-compressed",
    "application/avro",
    "application/vnd.iccprofile",
    "application/x.autodesk.fbx",
    "application/vnd.visio",
    "application/vnd.android.package-archive",
    "application/vnd.google.draco",
    "application/x-lz4",
    "application/vnd.openxmlformats-officedocument.presentationml.template",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
    "application/vnd.ms-excel.template.macroenabled.12",
    "application/vnd.oasis.opendocument.text-template",
    "application/vnd.oasis.opendocument.spreadsheet-template",
    "application/vnd.oasis.opendocument.presentation-template",
    "application/vnd.oasis.opendocument.graphics",
    "application/vnd.oasis.opendocument.graphics-template",
    "application/vnd.ms-excel.sheet.macroenabled.12",
    "application/vnd.ms-word.document.macroenabled.12",
    "application/vnd.ms-word.template.macroenabled.12",
    "application/vnd.ms-powerpoint.template.macroenabled.12",
    "application/vnd.ms-powerpoint.presentation.macroenabled.12",
    "application/java-archive",
    "application/vnd.rn-realmedia"
  ];
});

// node_modules/file-type/core.js
async function fileTypeFromBuffer(input, options) {
  return new FileTypeParser(options).fromBuffer(input);
}
async function fileTypeFromBlob(blob, options) {
  return new FileTypeParser(options).fromBlob(blob);
}
function getFileTypeFromMimeType(mimeType) {
  mimeType = mimeType.toLowerCase();
  switch (mimeType) {
    case "application/epub+zip":
      return {
        ext: "epub",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.text":
      return {
        ext: "odt",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.text-template":
      return {
        ext: "ott",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.spreadsheet":
      return {
        ext: "ods",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.spreadsheet-template":
      return {
        ext: "ots",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.presentation":
      return {
        ext: "odp",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.presentation-template":
      return {
        ext: "otp",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.graphics":
      return {
        ext: "odg",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.graphics-template":
      return {
        ext: "otg",
        mime: mimeType
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
      return {
        ext: "ppsx",
        mime: mimeType
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
      return {
        ext: "xlsx",
        mime: mimeType
      };
    case "application/vnd.ms-excel.sheet.macroenabled":
      return {
        ext: "xlsm",
        mime: "application/vnd.ms-excel.sheet.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
      return {
        ext: "xltx",
        mime: mimeType
      };
    case "application/vnd.ms-excel.template.macroenabled":
      return {
        ext: "xltm",
        mime: "application/vnd.ms-excel.template.macroenabled.12"
      };
    case "application/vnd.ms-powerpoint.slideshow.macroenabled":
      return {
        ext: "ppsm",
        mime: "application/vnd.ms-powerpoint.slideshow.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
      return {
        ext: "docx",
        mime: mimeType
      };
    case "application/vnd.ms-word.document.macroenabled":
      return {
        ext: "docm",
        mime: "application/vnd.ms-word.document.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
      return {
        ext: "dotx",
        mime: mimeType
      };
    case "application/vnd.ms-word.template.macroenabledtemplate":
      return {
        ext: "dotm",
        mime: "application/vnd.ms-word.template.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.template":
      return {
        ext: "potx",
        mime: mimeType
      };
    case "application/vnd.ms-powerpoint.template.macroenabled":
      return {
        ext: "potm",
        mime: "application/vnd.ms-powerpoint.template.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
      return {
        ext: "pptx",
        mime: mimeType
      };
    case "application/vnd.ms-powerpoint.presentation.macroenabled":
      return {
        ext: "pptm",
        mime: "application/vnd.ms-powerpoint.presentation.macroenabled.12"
      };
    case "application/vnd.ms-visio.drawing":
      return {
        ext: "vsdx",
        mime: "application/vnd.visio"
      };
    case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
      return {
        ext: "3mf",
        mime: "model/3mf"
      };
    default:
  }
}
function _check(buffer, headers, options) {
  options = {
    offset: 0,
    ...options
  };
  for (const [index, header] of headers.entries()) {
    if (options.mask) {
      if (header !== (options.mask[index] & buffer[index + options.offset])) {
        return false;
      }
    } else if (header !== buffer[index + options.offset]) {
      return false;
    }
  }
  return true;
}
async function fileTypeFromTokenizer(tokenizer, options) {
  return new FileTypeParser(options).fromTokenizer(tokenizer);
}

class FileTypeParser {
  constructor(options) {
    this.options = {
      mpegOffsetTolerance: 0,
      ...options
    };
    this.detectors = [
      ...options?.customDetectors ?? [],
      { id: "core", detect: this.detectConfident },
      { id: "core.imprecise", detect: this.detectImprecise }
    ];
    this.tokenizerOptions = {
      abortSignal: options?.signal
    };
  }
  async fromTokenizer(tokenizer) {
    const initialPosition = tokenizer.position;
    for (const detector of this.detectors) {
      const fileType = await detector.detect(tokenizer);
      if (fileType) {
        return fileType;
      }
      if (initialPosition !== tokenizer.position) {
        return;
      }
    }
  }
  async fromBuffer(input) {
    if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
      throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
    }
    const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
    if (!(buffer?.length > 1)) {
      return;
    }
    return this.fromTokenizer(fromBuffer(buffer, this.tokenizerOptions));
  }
  async fromBlob(blob) {
    return this.fromStream(blob.stream());
  }
  async fromStream(stream) {
    const tokenizer = await fromWebStream(stream, this.tokenizerOptions);
    try {
      return await this.fromTokenizer(tokenizer);
    } finally {
      await tokenizer.close();
    }
  }
  async toDetectionStream(stream, options) {
    const { sampleSize = reasonableDetectionSizeInBytes } = options;
    let detectedFileType;
    let firstChunk;
    const reader = stream.getReader({ mode: "byob" });
    try {
      const { value: chunk, done } = await reader.read(new Uint8Array(sampleSize));
      firstChunk = chunk;
      if (!done && chunk) {
        try {
          detectedFileType = await this.fromBuffer(chunk.subarray(0, sampleSize));
        } catch (error) {
          if (!(error instanceof EndOfStreamError)) {
            throw error;
          }
          detectedFileType = undefined;
        }
      }
      firstChunk = chunk;
    } finally {
      reader.releaseLock();
    }
    const transformStream = new TransformStream({
      async start(controller) {
        controller.enqueue(firstChunk);
      },
      transform(chunk, controller) {
        controller.enqueue(chunk);
      }
    });
    const newStream = stream.pipeThrough(transformStream);
    newStream.fileType = detectedFileType;
    return newStream;
  }
  check(header, options) {
    return _check(this.buffer, header, options);
  }
  checkString(header, options) {
    return this.check(stringToBytes(header), options);
  }
  detectConfident = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    if (tokenizer.fileInfo.size === undefined) {
      tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
    }
    this.tokenizer = tokenizer;
    await tokenizer.peekBuffer(this.buffer, { length: 12, mayBeLess: true });
    if (this.check([66, 77])) {
      return {
        ext: "bmp",
        mime: "image/bmp"
      };
    }
    if (this.check([11, 119])) {
      return {
        ext: "ac3",
        mime: "audio/vnd.dolby.dd-raw"
      };
    }
    if (this.check([120, 1])) {
      return {
        ext: "dmg",
        mime: "application/x-apple-diskimage"
      };
    }
    if (this.check([77, 90])) {
      return {
        ext: "exe",
        mime: "application/x-msdownload"
      };
    }
    if (this.check([37, 33])) {
      await tokenizer.peekBuffer(this.buffer, { length: 24, mayBeLess: true });
      if (this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 })) {
        return {
          ext: "eps",
          mime: "application/eps"
        };
      }
      return {
        ext: "ps",
        mime: "application/postscript"
      };
    }
    if (this.check([31, 160]) || this.check([31, 157])) {
      return {
        ext: "Z",
        mime: "application/x-compress"
      };
    }
    if (this.check([199, 113])) {
      return {
        ext: "cpio",
        mime: "application/x-cpio"
      };
    }
    if (this.check([96, 234])) {
      return {
        ext: "arj",
        mime: "application/x-arj"
      };
    }
    if (this.check([239, 187, 191])) {
      this.tokenizer.ignore(3);
      return this.detectConfident(tokenizer);
    }
    if (this.check([71, 73, 70])) {
      return {
        ext: "gif",
        mime: "image/gif"
      };
    }
    if (this.check([73, 73, 188])) {
      return {
        ext: "jxr",
        mime: "image/vnd.ms-photo"
      };
    }
    if (this.check([31, 139, 8])) {
      return {
        ext: "gz",
        mime: "application/gzip"
      };
    }
    if (this.check([66, 90, 104])) {
      return {
        ext: "bz2",
        mime: "application/x-bzip2"
      };
    }
    if (this.checkString("ID3")) {
      await tokenizer.ignore(6);
      const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
      if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      await tokenizer.ignore(id3HeaderLength);
      return this.fromTokenizer(tokenizer);
    }
    if (this.checkString("MP+")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) {
      return {
        ext: "swf",
        mime: "application/x-shockwave-flash"
      };
    }
    if (this.check([255, 216, 255])) {
      if (this.check([247], { offset: 3 })) {
        return {
          ext: "jls",
          mime: "image/jls"
        };
      }
      return {
        ext: "jpg",
        mime: "image/jpeg"
      };
    }
    if (this.check([79, 98, 106, 1])) {
      return {
        ext: "avro",
        mime: "application/avro"
      };
    }
    if (this.checkString("FLIF")) {
      return {
        ext: "flif",
        mime: "image/flif"
      };
    }
    if (this.checkString("8BPS")) {
      return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop"
      };
    }
    if (this.checkString("MPCK")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if (this.checkString("FORM")) {
      return {
        ext: "aif",
        mime: "audio/aiff"
      };
    }
    if (this.checkString("icns", { offset: 0 })) {
      return {
        ext: "icns",
        mime: "image/icns"
      };
    }
    if (this.check([80, 75, 3, 4])) {
      let fileType;
      await new ZipHandler(tokenizer).unzip((zipHeader) => {
        switch (zipHeader.filename) {
          case "META-INF/mozilla.rsa":
            fileType = {
              ext: "xpi",
              mime: "application/x-xpinstall"
            };
            return {
              stop: true
            };
          case "META-INF/MANIFEST.MF":
            fileType = {
              ext: "jar",
              mime: "application/java-archive"
            };
            return {
              stop: true
            };
          case "mimetype":
            return {
              async handler(fileData) {
                const mimeType = new TextDecoder("utf-8").decode(fileData).trim();
                fileType = getFileTypeFromMimeType(mimeType);
              },
              stop: true
            };
          case "[Content_Types].xml":
            return {
              async handler(fileData) {
                let xmlContent = new TextDecoder("utf-8").decode(fileData);
                const endPos = xmlContent.indexOf('.main+xml"');
                if (endPos === -1) {
                  const mimeType = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                  if (xmlContent.includes(`ContentType="${mimeType}"`)) {
                    fileType = getFileTypeFromMimeType(mimeType);
                  }
                } else {
                  xmlContent = xmlContent.slice(0, Math.max(0, endPos));
                  const firstPos = xmlContent.lastIndexOf('"');
                  const mimeType = xmlContent.slice(Math.max(0, firstPos + 1));
                  fileType = getFileTypeFromMimeType(mimeType);
                }
              },
              stop: true
            };
          default:
            if (/classes\d*\.dex/.test(zipHeader.filename)) {
              fileType = {
                ext: "apk",
                mime: "application/vnd.android.package-archive"
              };
              return { stop: true };
            }
            return {};
        }
      });
      return fileType ?? {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (this.checkString("OggS")) {
      await tokenizer.ignore(28);
      const type = new Uint8Array(8);
      await tokenizer.readBuffer(type);
      if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
        return {
          ext: "opus",
          mime: "audio/ogg; codecs=opus"
        };
      }
      if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
        return {
          ext: "ogv",
          mime: "video/ogg"
        };
      }
      if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
        return {
          ext: "ogm",
          mime: "video/ogg"
        };
      }
      if (_check(type, [127, 70, 76, 65, 67])) {
        return {
          ext: "oga",
          mime: "audio/ogg"
        };
      }
      if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
        return {
          ext: "spx",
          mime: "audio/ogg"
        };
      }
      if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      return {
        ext: "ogx",
        mime: "application/ogg"
      };
    }
    if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) {
      return {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (this.checkString("MThd")) {
      return {
        ext: "mid",
        mime: "audio/midi"
      };
    }
    if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff",
        mime: "font/woff"
      };
    }
    if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff2",
        mime: "font/woff2"
      };
    }
    if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) {
      return {
        ext: "pcap",
        mime: "application/vnd.tcpdump.pcap"
      };
    }
    if (this.checkString("DSD ")) {
      return {
        ext: "dsf",
        mime: "audio/x-dsf"
      };
    }
    if (this.checkString("LZIP")) {
      return {
        ext: "lz",
        mime: "application/x-lzip"
      };
    }
    if (this.checkString("fLaC")) {
      return {
        ext: "flac",
        mime: "audio/flac"
      };
    }
    if (this.check([66, 80, 71, 251])) {
      return {
        ext: "bpg",
        mime: "image/bpg"
      };
    }
    if (this.checkString("wvpk")) {
      return {
        ext: "wv",
        mime: "audio/wavpack"
      };
    }
    if (this.checkString("%PDF")) {
      return {
        ext: "pdf",
        mime: "application/pdf"
      };
    }
    if (this.check([0, 97, 115, 109])) {
      return {
        ext: "wasm",
        mime: "application/wasm"
      };
    }
    if (this.check([73, 73])) {
      const fileType = await this.readTiffHeader(false);
      if (fileType) {
        return fileType;
      }
    }
    if (this.check([77, 77])) {
      const fileType = await this.readTiffHeader(true);
      if (fileType) {
        return fileType;
      }
    }
    if (this.checkString("MAC ")) {
      return {
        ext: "ape",
        mime: "audio/ape"
      };
    }
    if (this.check([26, 69, 223, 163])) {
      async function readField() {
        const msb = await tokenizer.peekNumber(UINT8);
        let mask = 128;
        let ic = 0;
        while ((msb & mask) === 0 && mask !== 0) {
          ++ic;
          mask >>= 1;
        }
        const id = new Uint8Array(ic + 1);
        await tokenizer.readBuffer(id);
        return id;
      }
      async function readElement() {
        const idField = await readField();
        const lengthField = await readField();
        lengthField[0] ^= 128 >> lengthField.length - 1;
        const nrLength = Math.min(6, lengthField.length);
        const idView = new DataView(idField.buffer);
        const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);
        return {
          id: getUintBE(idView),
          len: getUintBE(lengthView)
        };
      }
      async function readChildren(children) {
        while (children > 0) {
          const element = await readElement();
          if (element.id === 17026) {
            const rawValue = await tokenizer.readToken(new StringType2(element.len));
            return rawValue.replaceAll(/\00.*$/g, "");
          }
          await tokenizer.ignore(element.len);
          --children;
        }
      }
      const re = await readElement();
      const documentType = await readChildren(re.len);
      switch (documentType) {
        case "webm":
          return {
            ext: "webm",
            mime: "video/webm"
          };
        case "matroska":
          return {
            ext: "mkv",
            mime: "video/matroska"
          };
        default:
          return;
      }
    }
    if (this.checkString("SQLi")) {
      return {
        ext: "sqlite",
        mime: "application/x-sqlite3"
      };
    }
    if (this.check([78, 69, 83, 26])) {
      return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom"
      };
    }
    if (this.checkString("Cr24")) {
      return {
        ext: "crx",
        mime: "application/x-google-chrome-extension"
      };
    }
    if (this.checkString("MSCF") || this.checkString("ISc(")) {
      return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed"
      };
    }
    if (this.check([237, 171, 238, 219])) {
      return {
        ext: "rpm",
        mime: "application/x-rpm"
      };
    }
    if (this.check([197, 208, 211, 198])) {
      return {
        ext: "eps",
        mime: "application/eps"
      };
    }
    if (this.check([40, 181, 47, 253])) {
      return {
        ext: "zst",
        mime: "application/zstd"
      };
    }
    if (this.check([127, 69, 76, 70])) {
      return {
        ext: "elf",
        mime: "application/x-elf"
      };
    }
    if (this.check([33, 66, 68, 78])) {
      return {
        ext: "pst",
        mime: "application/vnd.ms-outlook"
      };
    }
    if (this.checkString("PAR1") || this.checkString("PARE")) {
      return {
        ext: "parquet",
        mime: "application/vnd.apache.parquet"
      };
    }
    if (this.checkString("ttcf")) {
      return {
        ext: "ttc",
        mime: "font/collection"
      };
    }
    if (this.check([207, 250, 237, 254])) {
      return {
        ext: "macho",
        mime: "application/x-mach-binary"
      };
    }
    if (this.check([4, 34, 77, 24])) {
      return {
        ext: "lz4",
        mime: "application/x-lz4"
      };
    }
    if (this.check([79, 84, 84, 79, 0])) {
      return {
        ext: "otf",
        mime: "font/otf"
      };
    }
    if (this.checkString("#!AMR")) {
      return {
        ext: "amr",
        mime: "audio/amr"
      };
    }
    if (this.checkString("{\\rtf")) {
      return {
        ext: "rtf",
        mime: "application/rtf"
      };
    }
    if (this.check([70, 76, 86, 1])) {
      return {
        ext: "flv",
        mime: "video/x-flv"
      };
    }
    if (this.checkString("IMPM")) {
      return {
        ext: "it",
        mime: "audio/x-it"
      };
    }
    if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) {
      return {
        ext: "lzh",
        mime: "application/x-lzh-compressed"
      };
    }
    if (this.check([0, 0, 1, 186])) {
      if (this.check([33], { offset: 4, mask: [241] })) {
        return {
          ext: "mpg",
          mime: "video/MP1S"
        };
      }
      if (this.check([68], { offset: 4, mask: [196] })) {
        return {
          ext: "mpg",
          mime: "video/MP2P"
        };
      }
    }
    if (this.checkString("ITSF")) {
      return {
        ext: "chm",
        mime: "application/vnd.ms-htmlhelp"
      };
    }
    if (this.check([202, 254, 186, 190])) {
      return {
        ext: "class",
        mime: "application/java-vm"
      };
    }
    if (this.checkString(".RMF")) {
      return {
        ext: "rm",
        mime: "application/vnd.rn-realmedia"
      };
    }
    if (this.checkString("DRACO")) {
      return {
        ext: "drc",
        mime: "application/vnd.google.draco"
      };
    }
    if (this.check([253, 55, 122, 88, 90, 0])) {
      return {
        ext: "xz",
        mime: "application/x-xz"
      };
    }
    if (this.checkString("<?xml ")) {
      return {
        ext: "xml",
        mime: "application/xml"
      };
    }
    if (this.check([55, 122, 188, 175, 39, 28])) {
      return {
        ext: "7z",
        mime: "application/x-7z-compressed"
      };
    }
    if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) {
      return {
        ext: "rar",
        mime: "application/x-rar-compressed"
      };
    }
    if (this.checkString("solid ")) {
      return {
        ext: "stl",
        mime: "model/stl"
      };
    }
    if (this.checkString("AC")) {
      const version = new StringType2(4, "latin1").get(this.buffer, 2);
      if (version.match("^d*") && version >= 1000 && version <= 1050) {
        return {
          ext: "dwg",
          mime: "image/vnd.dwg"
        };
      }
    }
    if (this.checkString("070707")) {
      return {
        ext: "cpio",
        mime: "application/x-cpio"
      };
    }
    if (this.checkString("BLENDER")) {
      return {
        ext: "blend",
        mime: "application/x-blender"
      };
    }
    if (this.checkString("!<arch>")) {
      await tokenizer.ignore(8);
      const string = await tokenizer.readToken(new StringType2(13, "ascii"));
      if (string === "debian-binary") {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      return {
        ext: "ar",
        mime: "application/x-unix-archive"
      };
    }
    if (this.checkString("WEBVTT") && [`
`, "\r", "\t", " ", "\x00"].some((char7) => this.checkString(char7, { offset: 6 }))) {
      return {
        ext: "vtt",
        mime: "text/vtt"
      };
    }
    if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
      await tokenizer.ignore(8);
      async function readChunkHeader() {
        return {
          length: await tokenizer.readToken(INT32_BE),
          type: await tokenizer.readToken(new StringType2(4, "latin1"))
        };
      }
      do {
        const chunk = await readChunkHeader();
        if (chunk.length < 0) {
          return;
        }
        switch (chunk.type) {
          case "IDAT":
            return {
              ext: "png",
              mime: "image/png"
            };
          case "acTL":
            return {
              ext: "apng",
              mime: "image/apng"
            };
          default:
            await tokenizer.ignore(chunk.length + 4);
        }
      } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
      return {
        ext: "png",
        mime: "image/png"
      };
    }
    if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) {
      return {
        ext: "arrow",
        mime: "application/vnd.apache.arrow.file"
      };
    }
    if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) {
      return {
        ext: "glb",
        mime: "model/gltf-binary"
      };
    }
    if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) {
      return {
        ext: "mov",
        mime: "video/quicktime"
      };
    }
    if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
      return {
        ext: "orf",
        mime: "image/x-olympus-orf"
      };
    }
    if (this.checkString("gimp xcf ")) {
      return {
        ext: "xcf",
        mime: "image/x-xcf"
      };
    }
    if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
      const brandMajor = new StringType2(4, "latin1").get(this.buffer, 8).replace("\x00", " ").trim();
      switch (brandMajor) {
        case "avif":
        case "avis":
          return { ext: "avif", mime: "image/avif" };
        case "mif1":
          return { ext: "heic", mime: "image/heif" };
        case "msf1":
          return { ext: "heic", mime: "image/heif-sequence" };
        case "heic":
        case "heix":
          return { ext: "heic", mime: "image/heic" };
        case "hevc":
        case "hevx":
          return { ext: "heic", mime: "image/heic-sequence" };
        case "qt":
          return { ext: "mov", mime: "video/quicktime" };
        case "M4V":
        case "M4VH":
        case "M4VP":
          return { ext: "m4v", mime: "video/x-m4v" };
        case "M4P":
          return { ext: "m4p", mime: "video/mp4" };
        case "M4B":
          return { ext: "m4b", mime: "audio/mp4" };
        case "M4A":
          return { ext: "m4a", mime: "audio/x-m4a" };
        case "F4V":
          return { ext: "f4v", mime: "video/mp4" };
        case "F4P":
          return { ext: "f4p", mime: "video/mp4" };
        case "F4A":
          return { ext: "f4a", mime: "audio/mp4" };
        case "F4B":
          return { ext: "f4b", mime: "audio/mp4" };
        case "crx":
          return { ext: "cr3", mime: "image/x-canon-cr3" };
        default:
          if (brandMajor.startsWith("3g")) {
            if (brandMajor.startsWith("3g2")) {
              return { ext: "3g2", mime: "video/3gpp2" };
            }
            return { ext: "3gp", mime: "video/3gpp" };
          }
          return { ext: "mp4", mime: "video/mp4" };
      }
    }
    if (this.check([82, 73, 70, 70])) {
      if (this.checkString("WEBP", { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (this.check([65, 86, 73], { offset: 8 })) {
        return {
          ext: "avi",
          mime: "video/vnd.avi"
        };
      }
      if (this.check([87, 65, 86, 69], { offset: 8 })) {
        return {
          ext: "wav",
          mime: "audio/wav"
        };
      }
      if (this.check([81, 76, 67, 77], { offset: 8 })) {
        return {
          ext: "qcp",
          mime: "audio/qcelp"
        };
      }
    }
    if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
      return {
        ext: "rw2",
        mime: "image/x-panasonic-rw2"
      };
    }
    if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
      async function readHeader() {
        const guid = new Uint8Array(16);
        await tokenizer.readBuffer(guid);
        return {
          id: guid,
          size: Number(await tokenizer.readToken(UINT64_LE))
        };
      }
      await tokenizer.ignore(30);
      while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
        const header = await readHeader();
        let payload = header.size - 24;
        if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
          const typeId = new Uint8Array(16);
          payload -= await tokenizer.readBuffer(typeId);
          if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "audio/x-ms-asf"
            };
          }
          if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "video/x-ms-asf"
            };
          }
          break;
        }
        await tokenizer.ignore(payload);
      }
      return {
        ext: "asf",
        mime: "application/vnd.ms-asf"
      };
    }
    if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
      return {
        ext: "ktx",
        mime: "image/ktx"
      };
    }
    if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) {
      return {
        ext: "mie",
        mime: "application/x-mie"
      };
    }
    if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
      return {
        ext: "shp",
        mime: "application/x-esri-shape"
      };
    }
    if (this.check([255, 79, 255, 81])) {
      return {
        ext: "j2c",
        mime: "image/j2c"
      };
    }
    if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
      await tokenizer.ignore(20);
      const type = await tokenizer.readToken(new StringType2(4, "ascii"));
      switch (type) {
        case "jp2 ":
          return {
            ext: "jp2",
            mime: "image/jp2"
          };
        case "jpx ":
          return {
            ext: "jpx",
            mime: "image/jpx"
          };
        case "jpm ":
          return {
            ext: "jpm",
            mime: "image/jpm"
          };
        case "mjp2":
          return {
            ext: "mj2",
            mime: "image/mj2"
          };
        default:
          return;
      }
    }
    if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
      return {
        ext: "jxl",
        mime: "image/jxl"
      };
    }
    if (this.check([254, 255])) {
      if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], { offset: 2 })) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      return;
    }
    if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) {
      return {
        ext: "cfb",
        mime: "application/x-cfb"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.check([97, 99, 115, 112], { offset: 36 })) {
      return {
        ext: "icc",
        mime: "application/vnd.iccprofile"
      };
    }
    if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 })) {
      return {
        ext: "ace",
        mime: "application/x-ace-compressed"
      };
    }
    if (this.checkString("BEGIN:")) {
      if (this.checkString("VCARD", { offset: 6 })) {
        return {
          ext: "vcf",
          mime: "text/vcard"
        };
      }
      if (this.checkString("VCALENDAR", { offset: 6 })) {
        return {
          ext: "ics",
          mime: "text/calendar"
        };
      }
    }
    if (this.checkString("FUJIFILMCCD-RAW")) {
      return {
        ext: "raf",
        mime: "image/x-fujifilm-raf"
      };
    }
    if (this.checkString("Extended Module:")) {
      return {
        ext: "xm",
        mime: "audio/x-xm"
      };
    }
    if (this.checkString("Creative Voice File")) {
      return {
        ext: "voc",
        mime: "audio/x-voc"
      };
    }
    if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
      const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);
      if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
        try {
          const header = new TextDecoder().decode(this.buffer.subarray(16, jsonSize + 16));
          const json = JSON.parse(header);
          if (json.files) {
            return {
              ext: "asar",
              mime: "application/x-asar"
            };
          }
        } catch {}
      }
    }
    if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
      return {
        ext: "mxf",
        mime: "application/mxf"
      };
    }
    if (this.checkString("SCRM", { offset: 44 })) {
      return {
        ext: "s3m",
        mime: "audio/x-s3m"
      };
    }
    if (this.check([71]) && this.check([71], { offset: 188 })) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
      return {
        ext: "mobi",
        mime: "application/x-mobipocket-ebook"
      };
    }
    if (this.check([68, 73, 67, 77], { offset: 128 })) {
      return {
        ext: "dcm",
        mime: "application/dicom"
      };
    }
    if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
      return {
        ext: "lnk",
        mime: "application/x.ms.shortcut"
      };
    }
    if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
      return {
        ext: "alias",
        mime: "application/x.apple.alias"
      };
    }
    if (this.checkString("Kaydara FBX Binary  \x00")) {
      return {
        ext: "fbx",
        mime: "application/x.autodesk.fbx"
      };
    }
    if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) {
      return {
        ext: "eot",
        mime: "application/vnd.ms-fontobject"
      };
    }
    if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
      return {
        ext: "indd",
        mime: "application/x-indesign"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.checkString("ustar", { offset: 257 }) && (this.checkString("\x00", { offset: 262 }) || this.checkString(" ", { offset: 262 })) || this.check([0, 0, 0, 0, 0, 0], { offset: 257 }) && tarHeaderChecksumMatches(this.buffer)) {
      return {
        ext: "tar",
        mime: "application/x-tar"
      };
    }
    if (this.check([255, 254])) {
      if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], { offset: 2 })) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (this.check([255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0], { offset: 2 })) {
        return {
          ext: "skp",
          mime: "application/vnd.sketchup.skp"
        };
      }
      return;
    }
    if (this.checkString("-----BEGIN PGP MESSAGE-----")) {
      return {
        ext: "pgp",
        mime: "application/pgp-encrypted"
      };
    }
  };
  detectImprecise = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(8, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) {
      return {
        ext: "mpg",
        mime: "video/mpeg"
      };
    }
    if (this.check([0, 1, 0, 0, 0])) {
      return {
        ext: "ttf",
        mime: "font/ttf"
      };
    }
    if (this.check([0, 0, 1, 0])) {
      return {
        ext: "ico",
        mime: "image/x-icon"
      };
    }
    if (this.check([0, 0, 2, 0])) {
      return {
        ext: "cur",
        mime: "image/x-icon"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(2 + this.options.mpegOffsetTolerance, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.buffer.length >= 2 + this.options.mpegOffsetTolerance) {
      for (let depth = 0;depth <= this.options.mpegOffsetTolerance; ++depth) {
        const type = this.scanMpeg(depth);
        if (type) {
          return type;
        }
      }
    }
  };
  async readTiffTag(bigEndian) {
    const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
    this.tokenizer.ignore(10);
    switch (tagId) {
      case 50341:
        return {
          ext: "arw",
          mime: "image/x-sony-arw"
        };
      case 50706:
        return {
          ext: "dng",
          mime: "image/x-adobe-dng"
        };
      default:
    }
  }
  async readTiffIFD(bigEndian) {
    const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
    for (let n = 0;n < numberOfTags; ++n) {
      const fileType = await this.readTiffTag(bigEndian);
      if (fileType) {
        return fileType;
      }
    }
  }
  async readTiffHeader(bigEndian) {
    const version = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
    const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
    if (version === 42) {
      if (ifdOffset >= 6) {
        if (this.checkString("CR", { offset: 8 })) {
          return {
            ext: "cr2",
            mime: "image/x-canon-cr2"
          };
        }
        if (ifdOffset >= 8) {
          const someId1 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 8);
          const someId2 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 10);
          if (someId1 === 28 && someId2 === 254 || someId1 === 31 && someId2 === 11) {
            return {
              ext: "nef",
              mime: "image/x-nikon-nef"
            };
          }
        }
      }
      await this.tokenizer.ignore(ifdOffset);
      const fileType = await this.readTiffIFD(bigEndian);
      return fileType ?? {
        ext: "tif",
        mime: "image/tiff"
      };
    }
    if (version === 43) {
      return {
        ext: "tif",
        mime: "image/tiff"
      };
    }
  }
  scanMpeg(offset) {
    if (this.check([255, 224], { offset, mask: [255, 224] })) {
      if (this.check([16], { offset: offset + 1, mask: [22] })) {
        if (this.check([8], { offset: offset + 1, mask: [8] })) {
          return {
            ext: "aac",
            mime: "audio/aac"
          };
        }
        return {
          ext: "aac",
          mime: "audio/aac"
        };
      }
      if (this.check([2], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (this.check([4], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp2",
          mime: "audio/mpeg"
        };
      }
      if (this.check([6], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp1",
          mime: "audio/mpeg"
        };
      }
    }
  }
}
var reasonableDetectionSizeInBytes = 4100, supportedExtensions, supportedMimeTypes;
var init_core2 = __esm(() => {
  init_lib3();
  init_core();
  init_lib4();
  init_uint8array_extras();
  init_util();
  init_supported();
  supportedExtensions = new Set(extensions);
  supportedMimeTypes = new Set(mimeTypes);
});

// node_modules/file-type/index.js
var exports_file_type = {};
__export(exports_file_type, {
  supportedMimeTypes: () => supportedMimeTypes,
  supportedExtensions: () => supportedExtensions,
  fileTypeStream: () => fileTypeStream,
  fileTypeFromTokenizer: () => fileTypeFromTokenizer,
  fileTypeFromStream: () => fileTypeFromStream,
  fileTypeFromFile: () => fileTypeFromFile,
  fileTypeFromBuffer: () => fileTypeFromBuffer,
  fileTypeFromBlob: () => fileTypeFromBlob,
  FileTypeParser: () => FileTypeParser2
});
import { ReadableStream as WebReadableStream } from "stream/web";
import { pipeline, PassThrough, Readable } from "stream";
async function fileTypeFromFile(path, options) {
  return new FileTypeParser2(options).fromFile(path, options);
}
async function fileTypeFromStream(stream, options) {
  return new FileTypeParser2(options).fromStream(stream);
}
async function fileTypeStream(readableStream, options = {}) {
  return new FileTypeParser2(options).toDetectionStream(readableStream, options);
}
var FileTypeParser2;
var init_file_type = __esm(() => {
  init_lib();
  init_core2();
  init_core2();
  FileTypeParser2 = class FileTypeParser2 extends FileTypeParser {
    async fromStream(stream) {
      const tokenizer = await (stream instanceof WebReadableStream ? fromWebStream(stream, this.tokenizerOptions) : fromStream2(stream, this.tokenizerOptions));
      try {
        return await super.fromTokenizer(tokenizer);
      } finally {
        await tokenizer.close();
      }
    }
    async fromFile(path) {
      const tokenizer = await fromFile(path);
      try {
        return await super.fromTokenizer(tokenizer);
      } finally {
        await tokenizer.close();
      }
    }
    async toDetectionStream(readableStream, options = {}) {
      if (!(readableStream instanceof Readable)) {
        return super.toDetectionStream(readableStream, options);
      }
      const { sampleSize = reasonableDetectionSizeInBytes } = options;
      return new Promise((resolve, reject) => {
        readableStream.on("error", reject);
        readableStream.once("readable", () => {
          (async () => {
            try {
              const pass = new PassThrough;
              const outputStream = pipeline ? pipeline(readableStream, pass, () => {}) : readableStream.pipe(pass);
              const chunk = readableStream.read(sampleSize) ?? readableStream.read() ?? new Uint8Array(0);
              try {
                pass.fileType = await this.fromBuffer(chunk);
              } catch (error) {
                if (error instanceof EndOfStreamError) {
                  pass.fileType = undefined;
                } else {
                  reject(error);
                }
              }
              resolve(outputStream);
            } catch (error) {
              reject(error);
            }
          })();
        });
      });
    }
  };
});

// node_modules/@smithy/types/dist-cjs/index.js
var require_dist_cjs = __commonJS((exports) => {
  exports.HttpAuthLocation = undefined;
  (function(HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
  })(exports.HttpAuthLocation || (exports.HttpAuthLocation = {}));
  exports.HttpApiKeyAuthLocation = undefined;
  (function(HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
  })(exports.HttpApiKeyAuthLocation || (exports.HttpApiKeyAuthLocation = {}));
  exports.EndpointURLScheme = undefined;
  (function(EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
  })(exports.EndpointURLScheme || (exports.EndpointURLScheme = {}));
  exports.AlgorithmId = undefined;
  (function(AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
  })(exports.AlgorithmId || (exports.AlgorithmId = {}));
  var getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
      checksumAlgorithms.push({
        algorithmId: () => exports.AlgorithmId.SHA256,
        checksumConstructor: () => runtimeConfig.sha256
      });
    }
    if (runtimeConfig.md5 != null) {
      checksumAlgorithms.push({
        algorithmId: () => exports.AlgorithmId.MD5,
        checksumConstructor: () => runtimeConfig.md5
      });
    }
    return {
      addChecksumAlgorithm(algo) {
        checksumAlgorithms.push(algo);
      },
      checksumAlgorithms() {
        return checksumAlgorithms;
      }
    };
  };
  var resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
      runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
  };
  var getDefaultClientConfiguration = (runtimeConfig) => {
    return getChecksumConfiguration(runtimeConfig);
  };
  var resolveDefaultRuntimeConfig = (config) => {
    return resolveChecksumRuntimeConfig(config);
  };
  exports.FieldPosition = undefined;
  (function(FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
  })(exports.FieldPosition || (exports.FieldPosition = {}));
  var SMITHY_CONTEXT_KEY = "__smithy_context";
  exports.IniSectionType = undefined;
  (function(IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
  })(exports.IniSectionType || (exports.IniSectionType = {}));
  exports.RequestHandlerProtocol = undefined;
  (function(RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
  })(exports.RequestHandlerProtocol || (exports.RequestHandlerProtocol = {}));
  exports.SMITHY_CONTEXT_KEY = SMITHY_CONTEXT_KEY;
  exports.getDefaultClientConfiguration = getDefaultClientConfiguration;
  exports.resolveDefaultRuntimeConfig = resolveDefaultRuntimeConfig;
});

// node_modules/@smithy/util-middleware/dist-cjs/index.js
var require_dist_cjs2 = __commonJS((exports) => {
  var types = require_dist_cjs();
  var getSmithyContext = (context) => context[types.SMITHY_CONTEXT_KEY] || (context[types.SMITHY_CONTEXT_KEY] = {});
  var normalizeProvider = (input) => {
    if (typeof input === "function")
      return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
  };
  exports.getSmithyContext = getSmithyContext;
  exports.normalizeProvider = normalizeProvider;
});

// node_modules/@aws-sdk/core/dist-cjs/submodules/account-id-endpoint/index.js
function validateAccountIdEndpointMode(value) {
  return ACCOUNT_ID_ENDPOINT_MODE_VALUES.includes(value);
}
var utilMiddleware, DEFAULT_ACCOUNT_ID_ENDPOINT_MODE = "preferred", ACCOUNT_ID_ENDPOINT_MODE_VALUES, resolveAccountIdEndpointModeConfig = (input) => {
  const { accountIdEndpointMode } = input;
  const accountIdEndpointModeProvider = utilMiddleware.normalizeProvider(accountIdEndpointMode ?? DEFAULT_ACCOUNT_ID_ENDPOINT_MODE);
  return Object.assign(input, {
    accountIdEndpointMode: async () => {
      const accIdMode = await accountIdEndpointModeProvider();
      if (!validateAccountIdEndpointMode(accIdMode)) {
        throw new Error(`Invalid value for accountIdEndpointMode: ${accIdMode}. Valid values are: "required", "preferred", "disabled".`);
      }
      return accIdMode;
    }
  });
}, err2 = "Invalid AccountIdEndpointMode value", _throw = (message) => {
  throw new Error(message);
}, ENV_ACCOUNT_ID_ENDPOINT_MODE = "AWS_ACCOUNT_ID_ENDPOINT_MODE", CONFIG_ACCOUNT_ID_ENDPOINT_MODE = "account_id_endpoint_mode", NODE_ACCOUNT_ID_ENDPOINT_MODE_CONFIG_OPTIONS, $NODE_ACCOUNT_ID_ENDPOINT_MODE_CONFIG_OPTIONS, $resolveAccountIdEndpointModeConfig;
var init_account_id_endpoint = __esm(() => {
  utilMiddleware = require_dist_cjs2();
  ACCOUNT_ID_ENDPOINT_MODE_VALUES = ["disabled", "preferred", "required"];
  NODE_ACCOUNT_ID_ENDPOINT_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env3) => {
      const value = env3[ENV_ACCOUNT_ID_ENDPOINT_MODE];
      if (value && !validateAccountIdEndpointMode(value)) {
        _throw(err2);
      }
      return value;
    },
    configFileSelector: (profile) => {
      const value = profile[CONFIG_ACCOUNT_ID_ENDPOINT_MODE];
      if (value && !validateAccountIdEndpointMode(value)) {
        _throw(err2);
      }
      return value;
    },
    default: DEFAULT_ACCOUNT_ID_ENDPOINT_MODE
  };
  $NODE_ACCOUNT_ID_ENDPOINT_MODE_CONFIG_OPTIONS = NODE_ACCOUNT_ID_ENDPOINT_MODE_CONFIG_OPTIONS;
  $resolveAccountIdEndpointModeConfig = resolveAccountIdEndpointModeConfig;
});

// node_modules/@aws-sdk/middleware-endpoint-discovery/dist-es/configurations.js
var ENV_ENDPOINT_DISCOVERY, CONFIG_ENDPOINT_DISCOVERY = "endpoint_discovery_enabled", isFalsy = (value) => ["false", "0"].indexOf(value) >= 0, NODE_ENDPOINT_DISCOVERY_CONFIG_OPTIONS;
var init_configurations = __esm(() => {
  ENV_ENDPOINT_DISCOVERY = ["AWS_ENABLE_ENDPOINT_DISCOVERY", "AWS_ENDPOINT_DISCOVERY_ENABLED"];
  NODE_ENDPOINT_DISCOVERY_CONFIG_OPTIONS = {
    environmentVariableSelector: (env3) => {
      for (let i2 = 0;i2 < ENV_ENDPOINT_DISCOVERY.length; i2++) {
        const envKey = ENV_ENDPOINT_DISCOVERY[i2];
        if (envKey in env3) {
          const value = env3[envKey];
          if (value === "") {
            throw Error(`Environment variable ${envKey} can't be empty of undefined, got "${value}"`);
          }
          return !isFalsy(value);
        }
      }
    },
    configFileSelector: (profile) => {
      if (CONFIG_ENDPOINT_DISCOVERY in profile) {
        const value = profile[CONFIG_ENDPOINT_DISCOVERY];
        if (value === undefined) {
          throw Error(`Shared config entry ${CONFIG_ENDPOINT_DISCOVERY} can't be undefined, got "${value}"`);
        }
        return !isFalsy(value);
      }
    },
    default: undefined
  };
});

// node_modules/@smithy/protocol-http/dist-cjs/index.js
var require_dist_cjs3 = __commonJS((exports) => {
  var types = require_dist_cjs();
  var getHttpHandlerExtensionConfiguration = (runtimeConfig) => {
    return {
      setHttpHandler(handler) {
        runtimeConfig.httpHandler = handler;
      },
      httpHandler() {
        return runtimeConfig.httpHandler;
      },
      updateHttpClientConfig(key, value) {
        runtimeConfig.httpHandler?.updateHttpClientConfig(key, value);
      },
      httpHandlerConfigs() {
        return runtimeConfig.httpHandler.httpHandlerConfigs();
      }
    };
  };
  var resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {
    return {
      httpHandler: httpHandlerExtensionConfiguration.httpHandler()
    };
  };

  class Field {
    name;
    kind;
    values;
    constructor({ name, kind = types.FieldPosition.HEADER, values = [] }) {
      this.name = name;
      this.kind = kind;
      this.values = values;
    }
    add(value) {
      this.values.push(value);
    }
    set(values) {
      this.values = values;
    }
    remove(value) {
      this.values = this.values.filter((v) => v !== value);
    }
    toString() {
      return this.values.map((v) => v.includes(",") || v.includes(" ") ? `"${v}"` : v).join(", ");
    }
    get() {
      return this.values;
    }
  }

  class Fields {
    entries = {};
    encoding;
    constructor({ fields = [], encoding = "utf-8" }) {
      fields.forEach(this.setField.bind(this));
      this.encoding = encoding;
    }
    setField(field) {
      this.entries[field.name.toLowerCase()] = field;
    }
    getField(name) {
      return this.entries[name.toLowerCase()];
    }
    removeField(name) {
      delete this.entries[name.toLowerCase()];
    }
    getByType(kind) {
      return Object.values(this.entries).filter((field) => field.kind === kind);
    }
  }

  class HttpRequest {
    method;
    protocol;
    hostname;
    port;
    path;
    query;
    headers;
    username;
    password;
    fragment;
    body;
    constructor(options) {
      this.method = options.method || "GET";
      this.hostname = options.hostname || "localhost";
      this.port = options.port;
      this.query = options.query || {};
      this.headers = options.headers || {};
      this.body = options.body;
      this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
      this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
      this.username = options.username;
      this.password = options.password;
      this.fragment = options.fragment;
    }
    static clone(request) {
      const cloned = new HttpRequest({
        ...request,
        headers: { ...request.headers }
      });
      if (cloned.query) {
        cloned.query = cloneQuery(cloned.query);
      }
      return cloned;
    }
    static isInstance(request) {
      if (!request) {
        return false;
      }
      const req = request;
      return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
    }
    clone() {
      return HttpRequest.clone(this);
    }
  }
  function cloneQuery(query) {
    return Object.keys(query).reduce((carry, paramName) => {
      const param = query[paramName];
      return {
        ...carry,
        [paramName]: Array.isArray(param) ? [...param] : param
      };
    }, {});
  }

  class HttpResponse {
    statusCode;
    reason;
    headers;
    body;
    constructor(options) {
      this.statusCode = options.statusCode;
      this.reason = options.reason;
      this.headers = options.headers || {};
      this.body = options.body;
    }
    static isInstance(response) {
      if (!response)
        return false;
      const resp = response;
      return typeof resp.statusCode === "number" && typeof resp.headers === "object";
    }
  }
  function isValidHostname(hostname) {
    const hostPattern = /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/;
    return hostPattern.test(hostname);
  }
  exports.Field = Field;
  exports.Fields = Fields;
  exports.HttpRequest = HttpRequest;
  exports.HttpResponse = HttpResponse;
  exports.getHttpHandlerExtensionConfiguration = getHttpHandlerExtensionConfiguration;
  exports.isValidHostname = isValidHostname;
  exports.resolveHttpHandlerRuntimeConfig = resolveHttpHandlerRuntimeConfig;
});

// node_modules/@aws-sdk/middleware-endpoint-discovery/dist-es/getEndpointDiscoveryPlugin.js
var init_getEndpointDiscoveryPlugin = () => {};

// node_modules/@aws-sdk/endpoint-cache/dist-es/Endpoint.js
var init_Endpoint = () => {};

// node_modules/obliterator/iterator.js
var require_iterator = __commonJS((exports, module) => {
  function Iterator3(next) {
    Object.defineProperty(this, "_next", {
      writable: false,
      enumerable: false,
      value: next
    });
    this.done = false;
  }
  Iterator3.prototype.next = function() {
    if (this.done)
      return { done: true };
    var step = this._next();
    if (step.done)
      this.done = true;
    return step;
  };
  if (typeof Symbol !== "undefined")
    Iterator3.prototype[Symbol.iterator] = function() {
      return this;
    };
  Iterator3.of = function() {
    var args = arguments, l = args.length, i2 = 0;
    return new Iterator3(function() {
      if (i2 >= l)
        return { done: true };
      return { done: false, value: args[i2++] };
    });
  };
  Iterator3.empty = function() {
    var iterator = new Iterator3(null);
    iterator.done = true;
    return iterator;
  };
  Iterator3.is = function(value) {
    if (value instanceof Iterator3)
      return true;
    return typeof value === "object" && value !== null && typeof value.next === "function";
  };
  module.exports = Iterator3;
});

// node_modules/obliterator/foreach.js
var require_foreach = __commonJS((exports, module) => {
  var ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== "undefined";
  var SYMBOL_SUPPORT = typeof Symbol !== "undefined";
  function forEach(iterable, callback) {
    var iterator, k2, i2, l, s;
    if (!iterable)
      throw new Error("obliterator/forEach: invalid iterable.");
    if (typeof callback !== "function")
      throw new Error("obliterator/forEach: expecting a callback.");
    if (Array.isArray(iterable) || ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable) || typeof iterable === "string" || iterable.toString() === "[object Arguments]") {
      for (i2 = 0, l = iterable.length;i2 < l; i2++)
        callback(iterable[i2], i2);
      return;
    }
    if (typeof iterable.forEach === "function") {
      iterable.forEach(callback);
      return;
    }
    if (SYMBOL_SUPPORT && Symbol.iterator in iterable && typeof iterable.next !== "function") {
      iterable = iterable[Symbol.iterator]();
    }
    if (typeof iterable.next === "function") {
      iterator = iterable;
      i2 = 0;
      while (s = iterator.next(), s.done !== true) {
        callback(s.value, i2);
        i2++;
      }
      return;
    }
    for (k2 in iterable) {
      if (iterable.hasOwnProperty(k2)) {
        callback(iterable[k2], k2);
      }
    }
    return;
  }
  forEach.forEachWithNullKeys = function(iterable, callback) {
    var iterator, k2, i2, l, s;
    if (!iterable)
      throw new Error("obliterator/forEachWithNullKeys: invalid iterable.");
    if (typeof callback !== "function")
      throw new Error("obliterator/forEachWithNullKeys: expecting a callback.");
    if (Array.isArray(iterable) || ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable) || typeof iterable === "string" || iterable.toString() === "[object Arguments]") {
      for (i2 = 0, l = iterable.length;i2 < l; i2++)
        callback(iterable[i2], null);
      return;
    }
    if (iterable instanceof Set) {
      iterable.forEach(function(value) {
        callback(value, null);
      });
      return;
    }
    if (typeof iterable.forEach === "function") {
      iterable.forEach(callback);
      return;
    }
    if (SYMBOL_SUPPORT && Symbol.iterator in iterable && typeof iterable.next !== "function") {
      iterable = iterable[Symbol.iterator]();
    }
    if (typeof iterable.next === "function") {
      iterator = iterable;
      i2 = 0;
      while (s = iterator.next(), s.done !== true) {
        callback(s.value, null);
        i2++;
      }
      return;
    }
    for (k2 in iterable) {
      if (iterable.hasOwnProperty(k2)) {
        callback(iterable[k2], k2);
      }
    }
    return;
  };
  module.exports = forEach;
});

// node_modules/mnemonist/utils/typed-arrays.js
var require_typed_arrays = __commonJS((exports) => {
  var MAX_8BIT_INTEGER = Math.pow(2, 8) - 1;
  var MAX_16BIT_INTEGER = Math.pow(2, 16) - 1;
  var MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;
  var MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1;
  var MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1;
  var MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;
  exports.getPointerArray = function(size) {
    var maxIndex = size - 1;
    if (maxIndex <= MAX_8BIT_INTEGER)
      return Uint8Array;
    if (maxIndex <= MAX_16BIT_INTEGER)
      return Uint16Array;
    if (maxIndex <= MAX_32BIT_INTEGER)
      return Uint32Array;
    return Float64Array;
  };
  exports.getSignedPointerArray = function(size) {
    var maxIndex = size - 1;
    if (maxIndex <= MAX_SIGNED_8BIT_INTEGER)
      return Int8Array;
    if (maxIndex <= MAX_SIGNED_16BIT_INTEGER)
      return Int16Array;
    if (maxIndex <= MAX_SIGNED_32BIT_INTEGER)
      return Int32Array;
    return Float64Array;
  };
  exports.getNumberType = function(value) {
    if (value === (value | 0)) {
      if (Math.sign(value) === -1) {
        if (value <= 127 && value >= -128)
          return Int8Array;
        if (value <= 32767 && value >= -32768)
          return Int16Array;
        return Int32Array;
      } else {
        if (value <= 255)
          return Uint8Array;
        if (value <= 65535)
          return Uint16Array;
        return Uint32Array;
      }
    }
    return Float64Array;
  };
  var TYPE_PRIORITY = {
    Uint8Array: 1,
    Int8Array: 2,
    Uint16Array: 3,
    Int16Array: 4,
    Uint32Array: 5,
    Int32Array: 6,
    Float32Array: 7,
    Float64Array: 8
  };
  exports.getMinimalRepresentation = function(array, getter) {
    var maxType = null, maxPriority = 0, p, t2, v, i2, l;
    for (i2 = 0, l = array.length;i2 < l; i2++) {
      v = getter ? getter(array[i2]) : array[i2];
      t2 = exports.getNumberType(v);
      p = TYPE_PRIORITY[t2.name];
      if (p > maxPriority) {
        maxPriority = p;
        maxType = t2;
      }
    }
    return maxType;
  };
  exports.isTypedArray = function(value) {
    return typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView(value);
  };
  exports.concat = function() {
    var length = 0, i2, o, l;
    for (i2 = 0, l = arguments.length;i2 < l; i2++)
      length += arguments[i2].length;
    var array = new arguments[0].constructor(length);
    for (i2 = 0, o = 0;i2 < l; i2++) {
      array.set(arguments[i2], o);
      o += arguments[i2].length;
    }
    return array;
  };
  exports.indices = function(length) {
    var PointerArray = exports.getPointerArray(length);
    var array = new PointerArray(length);
    for (var i2 = 0;i2 < length; i2++)
      array[i2] = i2;
    return array;
  };
});

// node_modules/mnemonist/utils/iterables.js
var require_iterables = __commonJS((exports) => {
  var forEach = require_foreach();
  var typed = require_typed_arrays();
  function isArrayLike(target) {
    return Array.isArray(target) || typed.isTypedArray(target);
  }
  function guessLength(target) {
    if (typeof target.length === "number")
      return target.length;
    if (typeof target.size === "number")
      return target.size;
    return;
  }
  function toArray(target) {
    var l = guessLength(target);
    var array = typeof l === "number" ? new Array(l) : [];
    var i2 = 0;
    forEach(target, function(value) {
      array[i2++] = value;
    });
    return array;
  }
  function toArrayWithIndices(target) {
    var l = guessLength(target);
    var IndexArray = typeof l === "number" ? typed.getPointerArray(l) : Array;
    var array = typeof l === "number" ? new Array(l) : [];
    var indices = typeof l === "number" ? new IndexArray(l) : [];
    var i2 = 0;
    forEach(target, function(value) {
      array[i2] = value;
      indices[i2] = i2++;
    });
    return [array, indices];
  }
  exports.isArrayLike = isArrayLike;
  exports.guessLength = guessLength;
  exports.toArray = toArray;
  exports.toArrayWithIndices = toArrayWithIndices;
});

// node_modules/mnemonist/lru-cache.js
var require_lru_cache = __commonJS((exports, module) => {
  var Iterator3 = require_iterator();
  var forEach = require_foreach();
  var typed = require_typed_arrays();
  var iterables = require_iterables();
  function LRUCache(Keys, Values, capacity) {
    if (arguments.length < 2) {
      capacity = Keys;
      Keys = null;
      Values = null;
    }
    this.capacity = capacity;
    if (typeof this.capacity !== "number" || this.capacity <= 0)
      throw new Error("mnemonist/lru-cache: capacity should be positive number.");
    var PointerArray = typed.getPointerArray(capacity);
    this.forward = new PointerArray(capacity);
    this.backward = new PointerArray(capacity);
    this.K = typeof Keys === "function" ? new Keys(capacity) : new Array(capacity);
    this.V = typeof Values === "function" ? new Values(capacity) : new Array(capacity);
    this.size = 0;
    this.head = 0;
    this.tail = 0;
    this.items = {};
  }
  LRUCache.prototype.clear = function() {
    this.size = 0;
    this.head = 0;
    this.tail = 0;
    this.items = {};
  };
  LRUCache.prototype.splayOnTop = function(pointer2) {
    var oldHead = this.head;
    if (this.head === pointer2)
      return this;
    var previous = this.backward[pointer2], next = this.forward[pointer2];
    if (this.tail === pointer2) {
      this.tail = previous;
    } else {
      this.backward[next] = previous;
    }
    this.forward[previous] = next;
    this.backward[oldHead] = pointer2;
    this.head = pointer2;
    this.forward[pointer2] = oldHead;
    return this;
  };
  LRUCache.prototype.set = function(key, value) {
    var pointer2 = this.items[key];
    if (typeof pointer2 !== "undefined") {
      this.splayOnTop(pointer2);
      this.V[pointer2] = value;
      return;
    }
    if (this.size < this.capacity) {
      pointer2 = this.size++;
    } else {
      pointer2 = this.tail;
      this.tail = this.backward[pointer2];
      delete this.items[this.K[pointer2]];
    }
    this.items[key] = pointer2;
    this.K[pointer2] = key;
    this.V[pointer2] = value;
    this.forward[pointer2] = this.head;
    this.backward[this.head] = pointer2;
    this.head = pointer2;
  };
  LRUCache.prototype.setpop = function(key, value) {
    var oldValue = null;
    var oldKey = null;
    var pointer2 = this.items[key];
    if (typeof pointer2 !== "undefined") {
      this.splayOnTop(pointer2);
      oldValue = this.V[pointer2];
      this.V[pointer2] = value;
      return { evicted: false, key, value: oldValue };
    }
    if (this.size < this.capacity) {
      pointer2 = this.size++;
    } else {
      pointer2 = this.tail;
      this.tail = this.backward[pointer2];
      oldValue = this.V[pointer2];
      oldKey = this.K[pointer2];
      delete this.items[this.K[pointer2]];
    }
    this.items[key] = pointer2;
    this.K[pointer2] = key;
    this.V[pointer2] = value;
    this.forward[pointer2] = this.head;
    this.backward[this.head] = pointer2;
    this.head = pointer2;
    if (oldKey) {
      return { evicted: true, key: oldKey, value: oldValue };
    } else {
      return null;
    }
  };
  LRUCache.prototype.has = function(key) {
    return key in this.items;
  };
  LRUCache.prototype.get = function(key) {
    var pointer2 = this.items[key];
    if (typeof pointer2 === "undefined")
      return;
    this.splayOnTop(pointer2);
    return this.V[pointer2];
  };
  LRUCache.prototype.peek = function(key) {
    var pointer2 = this.items[key];
    if (typeof pointer2 === "undefined")
      return;
    return this.V[pointer2];
  };
  LRUCache.prototype.forEach = function(callback, scope) {
    scope = arguments.length > 1 ? scope : this;
    var i2 = 0, l = this.size;
    var pointer2 = this.head, keys = this.K, values = this.V, forward = this.forward;
    while (i2 < l) {
      callback.call(scope, values[pointer2], keys[pointer2], this);
      pointer2 = forward[pointer2];
      i2++;
    }
  };
  LRUCache.prototype.keys = function() {
    var i2 = 0, l = this.size;
    var pointer2 = this.head, keys = this.K, forward = this.forward;
    return new Iterator3(function() {
      if (i2 >= l)
        return { done: true };
      var key = keys[pointer2];
      i2++;
      if (i2 < l)
        pointer2 = forward[pointer2];
      return {
        done: false,
        value: key
      };
    });
  };
  LRUCache.prototype.values = function() {
    var i2 = 0, l = this.size;
    var pointer2 = this.head, values = this.V, forward = this.forward;
    return new Iterator3(function() {
      if (i2 >= l)
        return { done: true };
      var value = values[pointer2];
      i2++;
      if (i2 < l)
        pointer2 = forward[pointer2];
      return {
        done: false,
        value
      };
    });
  };
  LRUCache.prototype.entries = function() {
    var i2 = 0, l = this.size;
    var pointer2 = this.head, keys = this.K, values = this.V, forward = this.forward;
    return new Iterator3(function() {
      if (i2 >= l)
        return { done: true };
      var key = keys[pointer2], value = values[pointer2];
      i2++;
      if (i2 < l)
        pointer2 = forward[pointer2];
      return {
        done: false,
        value: [key, value]
      };
    });
  };
  if (typeof Symbol !== "undefined")
    LRUCache.prototype[Symbol.iterator] = LRUCache.prototype.entries;
  LRUCache.prototype.inspect = function() {
    var proxy = new Map;
    var iterator = this.entries(), step;
    while (step = iterator.next(), !step.done)
      proxy.set(step.value[0], step.value[1]);
    Object.defineProperty(proxy, "constructor", {
      value: LRUCache,
      enumerable: false
    });
    return proxy;
  };
  if (typeof Symbol !== "undefined")
    LRUCache.prototype[Symbol.for("nodejs.util.inspect.custom")] = LRUCache.prototype.inspect;
  LRUCache.from = function(iterable, Keys, Values, capacity) {
    if (arguments.length < 2) {
      capacity = iterables.guessLength(iterable);
      if (typeof capacity !== "number")
        throw new Error("mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.");
    } else if (arguments.length === 2) {
      capacity = Keys;
      Keys = null;
      Values = null;
    }
    var cache = new LRUCache(Keys, Values, capacity);
    forEach(iterable, function(value, key) {
      cache.set(key, value);
    });
    return cache;
  };
  module.exports = LRUCache;
});

// node_modules/@aws-sdk/endpoint-cache/dist-es/EndpointCache.js
class EndpointCache {
  cache;
  constructor(capacity) {
    this.cache = new import_lru_cache.default(capacity);
  }
  getEndpoint(key) {
    const endpointsWithExpiry = this.get(key);
    if (!endpointsWithExpiry || endpointsWithExpiry.length === 0) {
      return;
    }
    const endpoints = endpointsWithExpiry.map((endpoint) => endpoint.Address);
    return endpoints[Math.floor(Math.random() * endpoints.length)];
  }
  get(key) {
    if (!this.has(key)) {
      return;
    }
    const value = this.cache.get(key);
    if (!value) {
      return;
    }
    const now = Date.now();
    const endpointsWithExpiry = value.filter((endpoint) => now < endpoint.Expires);
    if (endpointsWithExpiry.length === 0) {
      this.delete(key);
      return;
    }
    return endpointsWithExpiry;
  }
  set(key, endpoints) {
    const now = Date.now();
    this.cache.set(key, endpoints.map(({ Address, CachePeriodInMinutes }) => ({
      Address,
      Expires: now + CachePeriodInMinutes * 60 * 1000
    })));
  }
  delete(key) {
    this.cache.set(key, []);
  }
  has(key) {
    if (!this.cache.has(key)) {
      return false;
    }
    const endpoints = this.cache.peek(key);
    if (!endpoints) {
      return false;
    }
    return endpoints.length > 0;
  }
  clear() {
    this.cache.clear();
  }
}
var import_lru_cache;
var init_EndpointCache = __esm(() => {
  import_lru_cache = __toESM(require_lru_cache(), 1);
});

// node_modules/@aws-sdk/endpoint-cache/dist-es/index.js
var init_dist_es = __esm(() => {
  init_Endpoint();
  init_EndpointCache();
});

// node_modules/@aws-sdk/middleware-endpoint-discovery/dist-es/resolveEndpointDiscoveryConfig.js
var resolveEndpointDiscoveryConfig = (input, { endpointDiscoveryCommandCtor }) => {
  const { endpointCacheSize, endpointDiscoveryEnabled, endpointDiscoveryEnabledProvider } = input;
  return Object.assign(input, {
    endpointDiscoveryCommandCtor,
    endpointCache: new EndpointCache(endpointCacheSize ?? 1000),
    endpointDiscoveryEnabled: endpointDiscoveryEnabled !== undefined ? () => Promise.resolve(endpointDiscoveryEnabled) : endpointDiscoveryEnabledProvider,
    isClientEndpointDiscoveryEnabled: endpointDiscoveryEnabled !== undefined
  });
};
var init_resolveEndpointDiscoveryConfig = __esm(() => {
  init_dist_es();
});

// node_modules/@aws-sdk/middleware-endpoint-discovery/dist-es/index.js
var init_dist_es2 = __esm(() => {
  init_configurations();
  init_getEndpointDiscoveryPlugin();
  init_resolveEndpointDiscoveryConfig();
});

// node_modules/@aws-sdk/middleware-host-header/dist-cjs/index.js
var require_dist_cjs4 = __commonJS((exports) => {
  var protocolHttp = require_dist_cjs3();
  function resolveHostHeaderConfig(input) {
    return input;
  }
  var hostHeaderMiddleware = (options) => (next) => async (args) => {
    if (!protocolHttp.HttpRequest.isInstance(args.request))
      return next(args);
    const { request } = args;
    const { handlerProtocol = "" } = options.requestHandler.metadata || {};
    if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
      delete request.headers["host"];
      request.headers[":authority"] = request.hostname + (request.port ? ":" + request.port : "");
    } else if (!request.headers["host"]) {
      let host = request.hostname;
      if (request.port != null)
        host += `:${request.port}`;
      request.headers["host"] = host;
    }
    return next(args);
  };
  var hostHeaderMiddlewareOptions = {
    name: "hostHeaderMiddleware",
    step: "build",
    priority: "low",
    tags: ["HOST"],
    override: true
  };
  var getHostHeaderPlugin = (options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
    }
  });
  exports.getHostHeaderPlugin = getHostHeaderPlugin;
  exports.hostHeaderMiddleware = hostHeaderMiddleware;
  exports.hostHeaderMiddlewareOptions = hostHeaderMiddlewareOptions;
  exports.resolveHostHeaderConfig = resolveHostHeaderConfig;
});

// node_modules/@aws-sdk/middleware-logger/dist-cjs/index.js
var require_dist_cjs5 = __commonJS((exports) => {
  var loggerMiddleware = () => (next, context) => async (args) => {
    try {
      const response = await next(args);
      const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
      const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
      const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
      const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;
      const { $metadata, ...outputWithoutMetadata } = response.output;
      logger?.info?.({
        clientName,
        commandName,
        input: inputFilterSensitiveLog(args.input),
        output: outputFilterSensitiveLog(outputWithoutMetadata),
        metadata: $metadata
      });
      return response;
    } catch (error) {
      const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
      const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
      const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
      logger?.error?.({
        clientName,
        commandName,
        input: inputFilterSensitiveLog(args.input),
        error,
        metadata: error.$metadata
      });
      throw error;
    }
  };
  var loggerMiddlewareOptions = {
    name: "loggerMiddleware",
    tags: ["LOGGER"],
    step: "initialize",
    override: true
  };
  var getLoggerPlugin = (options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
    }
  });
  exports.getLoggerPlugin = getLoggerPlugin;
  exports.loggerMiddleware = loggerMiddleware;
  exports.loggerMiddlewareOptions = loggerMiddlewareOptions;
});

// node_modules/@aws/lambda-invoke-store/dist/invoke-store.js
var require_invoke_store = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InvokeStore = undefined;
  var async_hooks_1 = __require("async_hooks");
  var noGlobalAwsLambda = process.env["AWS_LAMBDA_NODEJS_NO_GLOBAL_AWSLAMBDA"] === "1" || process.env["AWS_LAMBDA_NODEJS_NO_GLOBAL_AWSLAMBDA"] === "true";
  if (!noGlobalAwsLambda) {
    globalThis.awslambda = globalThis.awslambda || {};
  }
  var PROTECTED_KEYS = {
    REQUEST_ID: Symbol("_AWS_LAMBDA_REQUEST_ID"),
    X_RAY_TRACE_ID: Symbol("_AWS_LAMBDA_X_RAY_TRACE_ID")
  };

  class InvokeStoreImpl {
    static storage = new async_hooks_1.AsyncLocalStorage;
    static PROTECTED_KEYS = PROTECTED_KEYS;
    static run(context, fn) {
      return this.storage.run({ ...context }, fn);
    }
    static getContext() {
      return this.storage.getStore();
    }
    static get(key) {
      const context = this.storage.getStore();
      return context?.[key];
    }
    static set(key, value) {
      if (this.isProtectedKey(key)) {
        throw new Error(`Cannot modify protected Lambda context field`);
      }
      const context = this.storage.getStore();
      if (context) {
        context[key] = value;
      }
    }
    static getRequestId() {
      return this.get(this.PROTECTED_KEYS.REQUEST_ID) ?? "-";
    }
    static getXRayTraceId() {
      return this.get(this.PROTECTED_KEYS.X_RAY_TRACE_ID);
    }
    static hasContext() {
      return this.storage.getStore() !== undefined;
    }
    static isProtectedKey(key) {
      return key === this.PROTECTED_KEYS.REQUEST_ID || key === this.PROTECTED_KEYS.X_RAY_TRACE_ID;
    }
  }
  var instance;
  if (!noGlobalAwsLambda && globalThis.awslambda?.InvokeStore) {
    instance = globalThis.awslambda.InvokeStore;
  } else {
    instance = InvokeStoreImpl;
    if (!noGlobalAwsLambda && globalThis.awslambda) {
      globalThis.awslambda.InvokeStore = instance;
    }
  }
  exports.InvokeStore = instance;
});

// node_modules/@aws-sdk/middleware-recursion-detection/dist-cjs/recursionDetectionMiddleware.js
var require_recursionDetectionMiddleware = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.recursionDetectionMiddleware = undefined;
  var lambda_invoke_store_1 = require_invoke_store();
  var protocol_http_1 = require_dist_cjs3();
  var TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
  var ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
  var ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
  var recursionDetectionMiddleware = () => (next) => async (args) => {
    const { request } = args;
    if (!protocol_http_1.HttpRequest.isInstance(request)) {
      return next(args);
    }
    const traceIdHeader = Object.keys(request.headers ?? {}).find((h) => h.toLowerCase() === TRACE_ID_HEADER_NAME.toLowerCase()) ?? TRACE_ID_HEADER_NAME;
    if (request.headers.hasOwnProperty(traceIdHeader)) {
      return next(args);
    }
    const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
    const traceIdFromEnv = process.env[ENV_TRACE_ID];
    const traceIdFromInvokeStore = lambda_invoke_store_1.InvokeStore.getXRayTraceId();
    const traceId = traceIdFromInvokeStore ?? traceIdFromEnv;
    const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
    if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
      request.headers[TRACE_ID_HEADER_NAME] = traceId;
    }
    return next({
      ...args,
      request
    });
  };
  exports.recursionDetectionMiddleware = recursionDetectionMiddleware;
});

// node_modules/@aws-sdk/middleware-recursion-detection/dist-cjs/index.js
var require_dist_cjs6 = __commonJS((exports) => {
  var recursionDetectionMiddleware = require_recursionDetectionMiddleware();
  var recursionDetectionMiddlewareOptions = {
    step: "build",
    tags: ["RECURSION_DETECTION"],
    name: "recursionDetectionMiddleware",
    override: true,
    priority: "low"
  };
  var getRecursionDetectionPlugin = (options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(recursionDetectionMiddleware.recursionDetectionMiddleware(), recursionDetectionMiddlewareOptions);
    }
  });
  exports.getRecursionDetectionPlugin = getRecursionDetectionPlugin;
  Object.keys(recursionDetectionMiddleware).forEach(function(k2) {
    if (k2 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k2))
      Object.defineProperty(exports, k2, {
        enumerable: true,
        get: function() {
          return recursionDetectionMiddleware[k2];
        }
      });
  });
});

// node_modules/@smithy/middleware-serde/dist-cjs/index.js
var require_dist_cjs7 = __commonJS((exports) => {
  var protocolHttp = require_dist_cjs3();
  var deserializerMiddleware = (options, deserializer) => (next, context) => async (args) => {
    const { response } = await next(args);
    try {
      const parsed = await deserializer(response, options);
      return {
        response,
        output: parsed
      };
    } catch (error) {
      Object.defineProperty(error, "$response", {
        value: response
      });
      if (!("$metadata" in error)) {
        const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
        try {
          error.message += `
  ` + hint;
        } catch (e) {
          if (!context.logger || context.logger?.constructor?.name === "NoOpLogger") {
            console.warn(hint);
          } else {
            context.logger?.warn?.(hint);
          }
        }
        if (typeof error.$responseBodyText !== "undefined") {
          if (error.$response) {
            error.$response.body = error.$responseBodyText;
          }
        }
        try {
          if (protocolHttp.HttpResponse.isInstance(response)) {
            const { headers = {} } = response;
            const headerEntries = Object.entries(headers);
            error.$metadata = {
              httpStatusCode: response.statusCode,
              requestId: findHeader(/^x-[\w-]+-request-?id$/, headerEntries),
              extendedRequestId: findHeader(/^x-[\w-]+-id-2$/, headerEntries),
              cfId: findHeader(/^x-[\w-]+-cf-id$/, headerEntries)
            };
          }
        } catch (e) {}
      }
      throw error;
    }
  };
  var findHeader = (pattern, headers) => {
    return (headers.find(([k2]) => {
      return k2.match(pattern);
    }) || [undefined, undefined])[1];
  };
  var serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
    const endpointConfig = options;
    const endpoint = context.endpointV2?.url && endpointConfig.urlParser ? async () => endpointConfig.urlParser(context.endpointV2.url) : endpointConfig.endpoint;
    if (!endpoint) {
      throw new Error("No valid endpoint provider available.");
    }
    const request = await serializer(args.input, { ...options, endpoint });
    return next({
      ...args,
      request
    });
  };
  var deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true
  };
  var serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true
  };
  function getSerdePlugin(config, serializer, deserializer) {
    return {
      applyToStack: (commandStack) => {
        commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);
        commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption);
      }
    };
  }
  exports.deserializerMiddleware = deserializerMiddleware;
  exports.deserializerMiddlewareOption = deserializerMiddlewareOption;
  exports.getSerdePlugin = getSerdePlugin;
  exports.serializerMiddleware = serializerMiddleware;
  exports.serializerMiddlewareOption = serializerMiddlewareOption;
});

// node_modules/@smithy/is-array-buffer/dist-cjs/index.js
var require_dist_cjs8 = __commonJS((exports) => {
  var isArrayBuffer = (arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";
  exports.isArrayBuffer = isArrayBuffer;
});

// node_modules/@smithy/util-buffer-from/dist-cjs/index.js
var require_dist_cjs9 = __commonJS((exports) => {
  var isArrayBuffer = require_dist_cjs8();
  var buffer = __require("buffer");
  var fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
    if (!isArrayBuffer.isArrayBuffer(input)) {
      throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return buffer.Buffer.from(input, offset, length);
  };
  var fromString = (input, encoding) => {
    if (typeof input !== "string") {
      throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? buffer.Buffer.from(input, encoding) : buffer.Buffer.from(input);
  };
  exports.fromArrayBuffer = fromArrayBuffer;
  exports.fromString = fromString;
});

// node_modules/@smithy/util-base64/dist-cjs/fromBase64.js
var require_fromBase64 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromBase64 = undefined;
  var util_buffer_from_1 = require_dist_cjs9();
  var BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
  var fromBase64 = (input) => {
    if (input.length * 3 % 4 !== 0) {
      throw new TypeError(`Incorrect padding on base64 string.`);
    }
    if (!BASE64_REGEX.exec(input)) {
      throw new TypeError(`Invalid base64 string.`);
    }
    const buffer = (0, util_buffer_from_1.fromString)(input, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  };
  exports.fromBase64 = fromBase64;
});

// node_modules/@smithy/util-utf8/dist-cjs/index.js
var require_dist_cjs10 = __commonJS((exports) => {
  var utilBufferFrom = require_dist_cjs9();
  var fromUtf8 = (input) => {
    const buf = utilBufferFrom.fromString(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  };
  var toUint8Array = (data) => {
    if (typeof data === "string") {
      return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
  };
  var toUtf8 = (input) => {
    if (typeof input === "string") {
      return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
      throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return utilBufferFrom.fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
  };
  exports.fromUtf8 = fromUtf8;
  exports.toUint8Array = toUint8Array;
  exports.toUtf8 = toUtf8;
});

// node_modules/@smithy/util-base64/dist-cjs/toBase64.js
var require_toBase64 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toBase64 = undefined;
  var util_buffer_from_1 = require_dist_cjs9();
  var util_utf8_1 = require_dist_cjs10();
  var toBase64 = (_input) => {
    let input;
    if (typeof _input === "string") {
      input = (0, util_utf8_1.fromUtf8)(_input);
    } else {
      input = _input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
      throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
    }
    return (0, util_buffer_from_1.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("base64");
  };
  exports.toBase64 = toBase64;
});

// node_modules/@smithy/util-base64/dist-cjs/index.js
var require_dist_cjs11 = __commonJS((exports) => {
  var fromBase64 = require_fromBase64();
  var toBase64 = require_toBase64();
  Object.keys(fromBase64).forEach(function(k2) {
    if (k2 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k2))
      Object.defineProperty(exports, k2, {
        enumerable: true,
        get: function() {
          return fromBase64[k2];
        }
      });
  });
  Object.keys(toBase64).forEach(function(k2) {
    if (k2 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k2))
      Object.defineProperty(exports, k2, {
        enumerable: true,
        get: function() {
          return toBase64[k2];
        }
      });
  });
});

// node_modules/@smithy/util-stream/dist-cjs/checksum/ChecksumStream.js
var require_ChecksumStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChecksumStream = undefined;
  var util_base64_1 = require_dist_cjs11();
  var stream_1 = __require("stream");

  class ChecksumStream extends stream_1.Duplex {
    expectedChecksum;
    checksumSourceLocation;
    checksum;
    source;
    base64Encoder;
    constructor({ expectedChecksum, checksum: checksum2, source, checksumSourceLocation, base64Encoder }) {
      super();
      if (typeof source.pipe === "function") {
        this.source = source;
      } else {
        throw new Error(`@smithy/util-stream: unsupported source type ${source?.constructor?.name ?? source} in ChecksumStream.`);
      }
      this.base64Encoder = base64Encoder ?? util_base64_1.toBase64;
      this.expectedChecksum = expectedChecksum;
      this.checksum = checksum2;
      this.checksumSourceLocation = checksumSourceLocation;
      this.source.pipe(this);
    }
    _read(size) {}
    _write(chunk, encoding, callback) {
      try {
        this.checksum.update(chunk);
        this.push(chunk);
      } catch (e) {
        return callback(e);
      }
      return callback();
    }
    async _final(callback) {
      try {
        const digest = await this.checksum.digest();
        const received = this.base64Encoder(digest);
        if (this.expectedChecksum !== received) {
          return callback(new Error(`Checksum mismatch: expected "${this.expectedChecksum}" but received "${received}"` + ` in response header "${this.checksumSourceLocation}".`));
        }
      } catch (e) {
        return callback(e);
      }
      this.push(null);
      return callback();
    }
  }
  exports.ChecksumStream = ChecksumStream;
});

// node_modules/@smithy/util-stream/dist-cjs/stream-type-check.js
var require_stream_type_check = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isBlob = exports.isReadableStream = undefined;
  var isReadableStream = (stream) => typeof ReadableStream === "function" && (stream?.constructor?.name === ReadableStream.name || stream instanceof ReadableStream);
  exports.isReadableStream = isReadableStream;
  var isBlob = (blob) => {
    return typeof Blob === "function" && (blob?.constructor?.name === Blob.name || blob instanceof Blob);
  };
  exports.isBlob = isBlob;
});

// node_modules/@smithy/util-stream/dist-cjs/checksum/ChecksumStream.browser.js
var require_ChecksumStream_browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChecksumStream = undefined;
  var ReadableStreamRef = typeof ReadableStream === "function" ? ReadableStream : function() {};

  class ChecksumStream extends ReadableStreamRef {
  }
  exports.ChecksumStream = ChecksumStream;
});

// node_modules/@smithy/util-stream/dist-cjs/checksum/createChecksumStream.browser.js
var require_createChecksumStream_browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createChecksumStream = undefined;
  var util_base64_1 = require_dist_cjs11();
  var stream_type_check_1 = require_stream_type_check();
  var ChecksumStream_browser_1 = require_ChecksumStream_browser();
  var createChecksumStream = ({ expectedChecksum, checksum: checksum2, source, checksumSourceLocation, base64Encoder }) => {
    if (!(0, stream_type_check_1.isReadableStream)(source)) {
      throw new Error(`@smithy/util-stream: unsupported source type ${source?.constructor?.name ?? source} in ChecksumStream.`);
    }
    const encoder2 = base64Encoder ?? util_base64_1.toBase64;
    if (typeof TransformStream !== "function") {
      throw new Error("@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.");
    }
    const transform2 = new TransformStream({
      start() {},
      async transform(chunk, controller) {
        checksum2.update(chunk);
        controller.enqueue(chunk);
      },
      async flush(controller) {
        const digest = await checksum2.digest();
        const received = encoder2(digest);
        if (expectedChecksum !== received) {
          const error = new Error(`Checksum mismatch: expected "${expectedChecksum}" but received "${received}"` + ` in response header "${checksumSourceLocation}".`);
          controller.error(error);
        } else {
          controller.terminate();
        }
      }
    });
    source.pipeThrough(transform2);
    const readable = transform2.readable;
    Object.setPrototypeOf(readable, ChecksumStream_browser_1.ChecksumStream.prototype);
    return readable;
  };
  exports.createChecksumStream = createChecksumStream;
});

// node_modules/@smithy/util-stream/dist-cjs/checksum/createChecksumStream.js
var require_createChecksumStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createChecksumStream = createChecksumStream;
  var stream_type_check_1 = require_stream_type_check();
  var ChecksumStream_1 = require_ChecksumStream();
  var createChecksumStream_browser_1 = require_createChecksumStream_browser();
  function createChecksumStream(init) {
    if (typeof ReadableStream === "function" && (0, stream_type_check_1.isReadableStream)(init.source)) {
      return (0, createChecksumStream_browser_1.createChecksumStream)(init);
    }
    return new ChecksumStream_1.ChecksumStream(init);
  }
});

// node_modules/@smithy/util-stream/dist-cjs/ByteArrayCollector.js
var require_ByteArrayCollector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ByteArrayCollector = undefined;

  class ByteArrayCollector {
    allocByteArray;
    byteLength = 0;
    byteArrays = [];
    constructor(allocByteArray) {
      this.allocByteArray = allocByteArray;
    }
    push(byteArray) {
      this.byteArrays.push(byteArray);
      this.byteLength += byteArray.byteLength;
    }
    flush() {
      if (this.byteArrays.length === 1) {
        const bytes = this.byteArrays[0];
        this.reset();
        return bytes;
      }
      const aggregation = this.allocByteArray(this.byteLength);
      let cursor = 0;
      for (let i2 = 0;i2 < this.byteArrays.length; ++i2) {
        const bytes = this.byteArrays[i2];
        aggregation.set(bytes, cursor);
        cursor += bytes.byteLength;
      }
      this.reset();
      return aggregation;
    }
    reset() {
      this.byteArrays = [];
      this.byteLength = 0;
    }
  }
  exports.ByteArrayCollector = ByteArrayCollector;
});

// node_modules/@smithy/util-stream/dist-cjs/createBufferedReadableStream.js
var require_createBufferedReadableStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createBufferedReadable = undefined;
  exports.createBufferedReadableStream = createBufferedReadableStream;
  exports.merge = merge;
  exports.flush = flush;
  exports.sizeOf = sizeOf;
  exports.modeOf = modeOf;
  var ByteArrayCollector_1 = require_ByteArrayCollector();
  function createBufferedReadableStream(upstream, size, logger) {
    const reader = upstream.getReader();
    let streamBufferingLoggedWarning = false;
    let bytesSeen = 0;
    const buffers = ["", new ByteArrayCollector_1.ByteArrayCollector((size2) => new Uint8Array(size2))];
    let mode = -1;
    const pull = async (controller) => {
      const { value, done } = await reader.read();
      const chunk = value;
      if (done) {
        if (mode !== -1) {
          const remainder = flush(buffers, mode);
          if (sizeOf(remainder) > 0) {
            controller.enqueue(remainder);
          }
        }
        controller.close();
      } else {
        const chunkMode = modeOf(chunk, false);
        if (mode !== chunkMode) {
          if (mode >= 0) {
            controller.enqueue(flush(buffers, mode));
          }
          mode = chunkMode;
        }
        if (mode === -1) {
          controller.enqueue(chunk);
          return;
        }
        const chunkSize = sizeOf(chunk);
        bytesSeen += chunkSize;
        const bufferSize = sizeOf(buffers[mode]);
        if (chunkSize >= size && bufferSize === 0) {
          controller.enqueue(chunk);
        } else {
          const newSize = merge(buffers, mode, chunk);
          if (!streamBufferingLoggedWarning && bytesSeen > size * 2) {
            streamBufferingLoggedWarning = true;
            logger?.warn(`@smithy/util-stream - stream chunk size ${chunkSize} is below threshold of ${size}, automatically buffering.`);
          }
          if (newSize >= size) {
            controller.enqueue(flush(buffers, mode));
          } else {
            await pull(controller);
          }
        }
      }
    };
    return new ReadableStream({
      pull
    });
  }
  exports.createBufferedReadable = createBufferedReadableStream;
  function merge(buffers, mode, chunk) {
    switch (mode) {
      case 0:
        buffers[0] += chunk;
        return sizeOf(buffers[0]);
      case 1:
      case 2:
        buffers[mode].push(chunk);
        return sizeOf(buffers[mode]);
    }
  }
  function flush(buffers, mode) {
    switch (mode) {
      case 0:
        const s = buffers[0];
        buffers[0] = "";
        return s;
      case 1:
      case 2:
        return buffers[mode].flush();
    }
    throw new Error(`@smithy/util-stream - invalid index ${mode} given to flush()`);
  }
  function sizeOf(chunk) {
    return chunk?.byteLength ?? chunk?.length ?? 0;
  }
  function modeOf(chunk, allowBuffer = true) {
    if (allowBuffer && typeof Buffer !== "undefined" && chunk instanceof Buffer) {
      return 2;
    }
    if (chunk instanceof Uint8Array) {
      return 1;
    }
    if (typeof chunk === "string") {
      return 0;
    }
    return -1;
  }
});

// node_modules/@smithy/util-stream/dist-cjs/createBufferedReadable.js
var require_createBufferedReadable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createBufferedReadable = createBufferedReadable;
  var node_stream_1 = __require("stream");
  var ByteArrayCollector_1 = require_ByteArrayCollector();
  var createBufferedReadableStream_1 = require_createBufferedReadableStream();
  var stream_type_check_1 = require_stream_type_check();
  function createBufferedReadable(upstream, size, logger) {
    if ((0, stream_type_check_1.isReadableStream)(upstream)) {
      return (0, createBufferedReadableStream_1.createBufferedReadableStream)(upstream, size, logger);
    }
    const downstream = new node_stream_1.Readable({ read() {} });
    let streamBufferingLoggedWarning = false;
    let bytesSeen = 0;
    const buffers = [
      "",
      new ByteArrayCollector_1.ByteArrayCollector((size2) => new Uint8Array(size2)),
      new ByteArrayCollector_1.ByteArrayCollector((size2) => Buffer.from(new Uint8Array(size2)))
    ];
    let mode = -1;
    upstream.on("data", (chunk) => {
      const chunkMode = (0, createBufferedReadableStream_1.modeOf)(chunk, true);
      if (mode !== chunkMode) {
        if (mode >= 0) {
          downstream.push((0, createBufferedReadableStream_1.flush)(buffers, mode));
        }
        mode = chunkMode;
      }
      if (mode === -1) {
        downstream.push(chunk);
        return;
      }
      const chunkSize = (0, createBufferedReadableStream_1.sizeOf)(chunk);
      bytesSeen += chunkSize;
      const bufferSize = (0, createBufferedReadableStream_1.sizeOf)(buffers[mode]);
      if (chunkSize >= size && bufferSize === 0) {
        downstream.push(chunk);
      } else {
        const newSize = (0, createBufferedReadableStream_1.merge)(buffers, mode, chunk);
        if (!streamBufferingLoggedWarning && bytesSeen > size * 2) {
          streamBufferingLoggedWarning = true;
          logger?.warn(`@smithy/util-stream - stream chunk size ${chunkSize} is below threshold of ${size}, automatically buffering.`);
        }
        if (newSize >= size) {
          downstream.push((0, createBufferedReadableStream_1.flush)(buffers, mode));
        }
      }
    });
    upstream.on("end", () => {
      if (mode !== -1) {
        const remainder = (0, createBufferedReadableStream_1.flush)(buffers, mode);
        if ((0, createBufferedReadableStream_1.sizeOf)(remainder) > 0) {
          downstream.push(remainder);
        }
      }
      downstream.push(null);
    });
    return downstream;
  }
});

// node_modules/@smithy/util-stream/dist-cjs/getAwsChunkedEncodingStream.js
var require_getAwsChunkedEncodingStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getAwsChunkedEncodingStream = undefined;
  var stream_1 = __require("stream");
  var getAwsChunkedEncodingStream = (readableStream, options) => {
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== undefined && checksumAlgorithmFn !== undefined && checksumLocationName !== undefined && streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;
    const awsChunkedEncodingStream = new stream_1.Readable({ read: () => {} });
    readableStream.on("data", (data) => {
      const length = bodyLengthChecker(data) || 0;
      awsChunkedEncodingStream.push(`${length.toString(16)}\r
`);
      awsChunkedEncodingStream.push(data);
      awsChunkedEncodingStream.push(`\r
`);
    });
    readableStream.on("end", async () => {
      awsChunkedEncodingStream.push(`0\r
`);
      if (checksumRequired) {
        const checksum2 = base64Encoder(await digest);
        awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum2}\r
`);
        awsChunkedEncodingStream.push(`\r
`);
      }
      awsChunkedEncodingStream.push(null);
    });
    return awsChunkedEncodingStream;
  };
  exports.getAwsChunkedEncodingStream = getAwsChunkedEncodingStream;
});

// node_modules/@smithy/util-stream/dist-cjs/headStream.browser.js
var require_headStream_browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.headStream = headStream;
  async function headStream(stream, bytes) {
    let byteLengthCounter = 0;
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    while (!isDone) {
      const { done, value } = await reader.read();
      if (value) {
        chunks.push(value);
        byteLengthCounter += value?.byteLength ?? 0;
      }
      if (byteLengthCounter >= bytes) {
        break;
      }
      isDone = done;
    }
    reader.releaseLock();
    const collected = new Uint8Array(Math.min(bytes, byteLengthCounter));
    let offset = 0;
    for (const chunk of chunks) {
      if (chunk.byteLength > collected.byteLength - offset) {
        collected.set(chunk.subarray(0, collected.byteLength - offset), offset);
        break;
      } else {
        collected.set(chunk, offset);
      }
      offset += chunk.length;
    }
    return collected;
  }
});

// node_modules/@smithy/util-stream/dist-cjs/headStream.js
var require_headStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.headStream = undefined;
  var stream_1 = __require("stream");
  var headStream_browser_1 = require_headStream_browser();
  var stream_type_check_1 = require_stream_type_check();
  var headStream = (stream, bytes) => {
    if ((0, stream_type_check_1.isReadableStream)(stream)) {
      return (0, headStream_browser_1.headStream)(stream, bytes);
    }
    return new Promise((resolve, reject) => {
      const collector = new Collector;
      collector.limit = bytes;
      stream.pipe(collector);
      stream.on("error", (err3) => {
        collector.end();
        reject(err3);
      });
      collector.on("error", reject);
      collector.on("finish", function() {
        const bytes2 = new Uint8Array(Buffer.concat(this.buffers));
        resolve(bytes2);
      });
    });
  };
  exports.headStream = headStream;

  class Collector extends stream_1.Writable {
    buffers = [];
    limit = Infinity;
    bytesBuffered = 0;
    _write(chunk, encoding, callback) {
      this.buffers.push(chunk);
      this.bytesBuffered += chunk.byteLength ?? 0;
      if (this.bytesBuffered >= this.limit) {
        const excess = this.bytesBuffered - this.limit;
        const tailBuffer = this.buffers[this.buffers.length - 1];
        this.buffers[this.buffers.length - 1] = tailBuffer.subarray(0, tailBuffer.byteLength - excess);
        this.emit("finish");
      }
      callback();
    }
  }
});

// node_modules/@smithy/util-uri-escape/dist-cjs/index.js
var require_dist_cjs12 = __commonJS((exports) => {
  var escapeUri = (uri2) => encodeURIComponent(uri2).replace(/[!'()*]/g, hexEncode);
  var hexEncode = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;
  var escapeUriPath = (uri2) => uri2.split("/").map(escapeUri).join("/");
  exports.escapeUri = escapeUri;
  exports.escapeUriPath = escapeUriPath;
});

// node_modules/@smithy/querystring-builder/dist-cjs/index.js
var require_dist_cjs13 = __commonJS((exports) => {
  var utilUriEscape = require_dist_cjs12();
  function buildQueryString(query) {
    const parts = [];
    for (let key of Object.keys(query).sort()) {
      const value = query[key];
      key = utilUriEscape.escapeUri(key);
      if (Array.isArray(value)) {
        for (let i2 = 0, iLen = value.length;i2 < iLen; i2++) {
          parts.push(`${key}=${utilUriEscape.escapeUri(value[i2])}`);
        }
      } else {
        let qsEntry = key;
        if (value || typeof value === "string") {
          qsEntry += `=${utilUriEscape.escapeUri(value)}`;
        }
        parts.push(qsEntry);
      }
    }
    return parts.join("&");
  }
  exports.buildQueryString = buildQueryString;
});

// node_modules/@smithy/node-http-handler/dist-cjs/index.js
var require_dist_cjs14 = __commonJS((exports) => {
  var protocolHttp = require_dist_cjs3();
  var querystringBuilder = require_dist_cjs13();
  var http = __require("http");
  var https = __require("https");
  var stream = __require("stream");
  var http2 = __require("http2");
  var NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];
  var getTransformedHeaders = (headers) => {
    const transformedHeaders = {};
    for (const name of Object.keys(headers)) {
      const headerValues = headers[name];
      transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
    }
    return transformedHeaders;
  };
  var timing = {
    setTimeout: (cb, ms) => setTimeout(cb, ms),
    clearTimeout: (timeoutId) => clearTimeout(timeoutId)
  };
  var DEFER_EVENT_LISTENER_TIME$2 = 1000;
  var setConnectionTimeout = (request, reject, timeoutInMs = 0) => {
    if (!timeoutInMs) {
      return -1;
    }
    const registerTimeout = (offset) => {
      const timeoutId = timing.setTimeout(() => {
        request.destroy();
        reject(Object.assign(new Error(`@smithy/node-http-handler - the request socket did not establish a connection with the server within the configured timeout of ${timeoutInMs} ms.`), {
          name: "TimeoutError"
        }));
      }, timeoutInMs - offset);
      const doWithSocket = (socket) => {
        if (socket?.connecting) {
          socket.on("connect", () => {
            timing.clearTimeout(timeoutId);
          });
        } else {
          timing.clearTimeout(timeoutId);
        }
      };
      if (request.socket) {
        doWithSocket(request.socket);
      } else {
        request.on("socket", doWithSocket);
      }
    };
    if (timeoutInMs < 2000) {
      registerTimeout(0);
      return 0;
    }
    return timing.setTimeout(registerTimeout.bind(null, DEFER_EVENT_LISTENER_TIME$2), DEFER_EVENT_LISTENER_TIME$2);
  };
  var setRequestTimeout = (req, reject, timeoutInMs = 0, throwOnRequestTimeout, logger) => {
    if (timeoutInMs) {
      return timing.setTimeout(() => {
        let msg = `@smithy/node-http-handler - [${throwOnRequestTimeout ? "ERROR" : "WARN"}] a request has exceeded the configured ${timeoutInMs} ms requestTimeout.`;
        if (throwOnRequestTimeout) {
          const error = Object.assign(new Error(msg), {
            name: "TimeoutError",
            code: "ETIMEDOUT"
          });
          req.destroy(error);
          reject(error);
        } else {
          msg += ` Init client requestHandler with throwOnRequestTimeout=true to turn this into an error.`;
          logger?.warn?.(msg);
        }
      }, timeoutInMs);
    }
    return -1;
  };
  var DEFER_EVENT_LISTENER_TIME$1 = 3000;
  var setSocketKeepAlive = (request, { keepAlive, keepAliveMsecs }, deferTimeMs = DEFER_EVENT_LISTENER_TIME$1) => {
    if (keepAlive !== true) {
      return -1;
    }
    const registerListener = () => {
      if (request.socket) {
        request.socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
      } else {
        request.on("socket", (socket) => {
          socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
        });
      }
    };
    if (deferTimeMs === 0) {
      registerListener();
      return 0;
    }
    return timing.setTimeout(registerListener, deferTimeMs);
  };
  var DEFER_EVENT_LISTENER_TIME = 3000;
  var setSocketTimeout = (request, reject, timeoutInMs = 0) => {
    const registerTimeout = (offset) => {
      const timeout = timeoutInMs - offset;
      const onTimeout = () => {
        request.destroy();
        reject(Object.assign(new Error(`@smithy/node-http-handler - the request socket timed out after ${timeoutInMs} ms of inactivity (configured by client requestHandler).`), { name: "TimeoutError" }));
      };
      if (request.socket) {
        request.socket.setTimeout(timeout, onTimeout);
        request.on("close", () => request.socket?.removeListener("timeout", onTimeout));
      } else {
        request.setTimeout(timeout, onTimeout);
      }
    };
    if (0 < timeoutInMs && timeoutInMs < 6000) {
      registerTimeout(0);
      return 0;
    }
    return timing.setTimeout(registerTimeout.bind(null, timeoutInMs === 0 ? 0 : DEFER_EVENT_LISTENER_TIME), DEFER_EVENT_LISTENER_TIME);
  };
  var MIN_WAIT_TIME = 6000;
  async function writeRequestBody(httpRequest, request, maxContinueTimeoutMs = MIN_WAIT_TIME) {
    const headers = request.headers ?? {};
    const expect = headers.Expect || headers.expect;
    let timeoutId = -1;
    let sendBody = true;
    if (expect === "100-continue") {
      sendBody = await Promise.race([
        new Promise((resolve) => {
          timeoutId = Number(timing.setTimeout(() => resolve(true), Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
        }),
        new Promise((resolve) => {
          httpRequest.on("continue", () => {
            timing.clearTimeout(timeoutId);
            resolve(true);
          });
          httpRequest.on("response", () => {
            timing.clearTimeout(timeoutId);
            resolve(false);
          });
          httpRequest.on("error", () => {
            timing.clearTimeout(timeoutId);
            resolve(false);
          });
        })
      ]);
    }
    if (sendBody) {
      writeBody(httpRequest, request.body);
    }
  }
  function writeBody(httpRequest, body) {
    if (body instanceof stream.Readable) {
      body.pipe(httpRequest);
      return;
    }
    if (body) {
      if (Buffer.isBuffer(body) || typeof body === "string") {
        httpRequest.end(body);
        return;
      }
      const uint8 = body;
      if (typeof uint8 === "object" && uint8.buffer && typeof uint8.byteOffset === "number" && typeof uint8.byteLength === "number") {
        httpRequest.end(Buffer.from(uint8.buffer, uint8.byteOffset, uint8.byteLength));
        return;
      }
      httpRequest.end(Buffer.from(body));
      return;
    }
    httpRequest.end();
  }
  var DEFAULT_REQUEST_TIMEOUT = 0;

  class NodeHttpHandler {
    config;
    configProvider;
    socketWarningTimestamp = 0;
    metadata = { handlerProtocol: "http/1.1" };
    static create(instanceOrOptions) {
      if (typeof instanceOrOptions?.handle === "function") {
        return instanceOrOptions;
      }
      return new NodeHttpHandler(instanceOrOptions);
    }
    static checkSocketUsage(agent, socketWarningTimestamp, logger = console) {
      const { sockets, requests, maxSockets } = agent;
      if (typeof maxSockets !== "number" || maxSockets === Infinity) {
        return socketWarningTimestamp;
      }
      const interval = 15000;
      if (Date.now() - interval < socketWarningTimestamp) {
        return socketWarningTimestamp;
      }
      if (sockets && requests) {
        for (const origin in sockets) {
          const socketsInUse = sockets[origin]?.length ?? 0;
          const requestsEnqueued = requests[origin]?.length ?? 0;
          if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {
            logger?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`);
            return Date.now();
          }
        }
      }
      return socketWarningTimestamp;
    }
    constructor(options) {
      this.configProvider = new Promise((resolve, reject) => {
        if (typeof options === "function") {
          options().then((_options) => {
            resolve(this.resolveDefaultConfig(_options));
          }).catch(reject);
        } else {
          resolve(this.resolveDefaultConfig(options));
        }
      });
    }
    resolveDefaultConfig(options) {
      const { requestTimeout, connectionTimeout, socketTimeout, socketAcquisitionWarningTimeout, httpAgent, httpsAgent, throwOnRequestTimeout } = options || {};
      const keepAlive = true;
      const maxSockets = 50;
      return {
        connectionTimeout,
        requestTimeout,
        socketTimeout,
        socketAcquisitionWarningTimeout,
        throwOnRequestTimeout,
        httpAgent: (() => {
          if (httpAgent instanceof http.Agent || typeof httpAgent?.destroy === "function") {
            return httpAgent;
          }
          return new http.Agent({ keepAlive, maxSockets, ...httpAgent });
        })(),
        httpsAgent: (() => {
          if (httpsAgent instanceof https.Agent || typeof httpsAgent?.destroy === "function") {
            return httpsAgent;
          }
          return new https.Agent({ keepAlive, maxSockets, ...httpsAgent });
        })(),
        logger: console
      };
    }
    destroy() {
      this.config?.httpAgent?.destroy();
      this.config?.httpsAgent?.destroy();
    }
    async handle(request, { abortSignal, requestTimeout } = {}) {
      if (!this.config) {
        this.config = await this.configProvider;
      }
      return new Promise((_resolve, _reject) => {
        const config = this.config;
        let writeRequestBodyPromise = undefined;
        const timeouts = [];
        const resolve = async (arg) => {
          await writeRequestBodyPromise;
          timeouts.forEach(timing.clearTimeout);
          _resolve(arg);
        };
        const reject = async (arg) => {
          await writeRequestBodyPromise;
          timeouts.forEach(timing.clearTimeout);
          _reject(arg);
        };
        if (abortSignal?.aborted) {
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
          return;
        }
        const isSSL = request.protocol === "https:";
        const headers = request.headers ?? {};
        const expectContinue = (headers.Expect ?? headers.expect) === "100-continue";
        let agent = isSSL ? config.httpsAgent : config.httpAgent;
        if (expectContinue) {
          agent = new (isSSL ? https.Agent : http.Agent)({
            keepAlive: false,
            maxSockets: Infinity
          });
        }
        timeouts.push(timing.setTimeout(() => {
          this.socketWarningTimestamp = NodeHttpHandler.checkSocketUsage(agent, this.socketWarningTimestamp, config.logger);
        }, config.socketAcquisitionWarningTimeout ?? (config.requestTimeout ?? 2000) + (config.connectionTimeout ?? 1000)));
        const queryString = querystringBuilder.buildQueryString(request.query || {});
        let auth = undefined;
        if (request.username != null || request.password != null) {
          const username = request.username ?? "";
          const password = request.password ?? "";
          auth = `${username}:${password}`;
        }
        let path = request.path;
        if (queryString) {
          path += `?${queryString}`;
        }
        if (request.fragment) {
          path += `#${request.fragment}`;
        }
        let hostname = request.hostname ?? "";
        if (hostname[0] === "[" && hostname.endsWith("]")) {
          hostname = request.hostname.slice(1, -1);
        } else {
          hostname = request.hostname;
        }
        const nodeHttpsOptions = {
          headers: request.headers,
          host: hostname,
          method: request.method,
          path,
          port: request.port,
          agent,
          auth
        };
        const requestFunc = isSSL ? https.request : http.request;
        const req = requestFunc(nodeHttpsOptions, (res) => {
          const httpResponse = new protocolHttp.HttpResponse({
            statusCode: res.statusCode || -1,
            reason: res.statusMessage,
            headers: getTransformedHeaders(res.headers),
            body: res
          });
          resolve({ response: httpResponse });
        });
        req.on("error", (err3) => {
          if (NODEJS_TIMEOUT_ERROR_CODES.includes(err3.code)) {
            reject(Object.assign(err3, { name: "TimeoutError" }));
          } else {
            reject(err3);
          }
        });
        if (abortSignal) {
          const onAbort = () => {
            req.destroy();
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            reject(abortError);
          };
          if (typeof abortSignal.addEventListener === "function") {
            const signal = abortSignal;
            signal.addEventListener("abort", onAbort, { once: true });
            req.once("close", () => signal.removeEventListener("abort", onAbort));
          } else {
            abortSignal.onabort = onAbort;
          }
        }
        const effectiveRequestTimeout = requestTimeout ?? config.requestTimeout;
        timeouts.push(setConnectionTimeout(req, reject, config.connectionTimeout));
        timeouts.push(setRequestTimeout(req, reject, effectiveRequestTimeout, config.throwOnRequestTimeout, config.logger ?? console));
        timeouts.push(setSocketTimeout(req, reject, config.socketTimeout));
        const httpAgent = nodeHttpsOptions.agent;
        if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
          timeouts.push(setSocketKeepAlive(req, {
            keepAlive: httpAgent.keepAlive,
            keepAliveMsecs: httpAgent.keepAliveMsecs
          }));
        }
        writeRequestBodyPromise = writeRequestBody(req, request, effectiveRequestTimeout).catch((e) => {
          timeouts.forEach(timing.clearTimeout);
          return _reject(e);
        });
      });
    }
    updateHttpClientConfig(key, value) {
      this.config = undefined;
      this.configProvider = this.configProvider.then((config) => {
        return {
          ...config,
          [key]: value
        };
      });
    }
    httpHandlerConfigs() {
      return this.config ?? {};
    }
  }

  class NodeHttp2ConnectionPool {
    sessions = [];
    constructor(sessions) {
      this.sessions = sessions ?? [];
    }
    poll() {
      if (this.sessions.length > 0) {
        return this.sessions.shift();
      }
    }
    offerLast(session) {
      this.sessions.push(session);
    }
    contains(session) {
      return this.sessions.includes(session);
    }
    remove(session) {
      this.sessions = this.sessions.filter((s) => s !== session);
    }
    [Symbol.iterator]() {
      return this.sessions[Symbol.iterator]();
    }
    destroy(connection) {
      for (const session of this.sessions) {
        if (session === connection) {
          if (!session.destroyed) {
            session.destroy();
          }
        }
      }
    }
  }

  class NodeHttp2ConnectionManager {
    constructor(config) {
      this.config = config;
      if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
        throw new RangeError("maxConcurrency must be greater than zero.");
      }
    }
    config;
    sessionCache = new Map;
    lease(requestContext, connectionConfiguration) {
      const url = this.getUrlString(requestContext);
      const existingPool = this.sessionCache.get(url);
      if (existingPool) {
        const existingSession = existingPool.poll();
        if (existingSession && !this.config.disableConcurrency) {
          return existingSession;
        }
      }
      const session = http2.connect(url);
      if (this.config.maxConcurrency) {
        session.settings({ maxConcurrentStreams: this.config.maxConcurrency }, (err3) => {
          if (err3) {
            throw new Error("Fail to set maxConcurrentStreams to " + this.config.maxConcurrency + "when creating new session for " + requestContext.destination.toString());
          }
        });
      }
      session.unref();
      const destroySessionCb = () => {
        session.destroy();
        this.deleteSession(url, session);
      };
      session.on("goaway", destroySessionCb);
      session.on("error", destroySessionCb);
      session.on("frameError", destroySessionCb);
      session.on("close", () => this.deleteSession(url, session));
      if (connectionConfiguration.requestTimeout) {
        session.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
      }
      const connectionPool = this.sessionCache.get(url) || new NodeHttp2ConnectionPool;
      connectionPool.offerLast(session);
      this.sessionCache.set(url, connectionPool);
      return session;
    }
    deleteSession(authority, session) {
      const existingConnectionPool = this.sessionCache.get(authority);
      if (!existingConnectionPool) {
        return;
      }
      if (!existingConnectionPool.contains(session)) {
        return;
      }
      existingConnectionPool.remove(session);
      this.sessionCache.set(authority, existingConnectionPool);
    }
    release(requestContext, session) {
      const cacheKey = this.getUrlString(requestContext);
      this.sessionCache.get(cacheKey)?.offerLast(session);
    }
    destroy() {
      for (const [key, connectionPool] of this.sessionCache) {
        for (const session of connectionPool) {
          if (!session.destroyed) {
            session.destroy();
          }
          connectionPool.remove(session);
        }
        this.sessionCache.delete(key);
      }
    }
    setMaxConcurrentStreams(maxConcurrentStreams) {
      if (maxConcurrentStreams && maxConcurrentStreams <= 0) {
        throw new RangeError("maxConcurrentStreams must be greater than zero.");
      }
      this.config.maxConcurrency = maxConcurrentStreams;
    }
    setDisableConcurrentStreams(disableConcurrentStreams) {
      this.config.disableConcurrency = disableConcurrentStreams;
    }
    getUrlString(request) {
      return request.destination.toString();
    }
  }

  class NodeHttp2Handler {
    config;
    configProvider;
    metadata = { handlerProtocol: "h2" };
    connectionManager = new NodeHttp2ConnectionManager({});
    static create(instanceOrOptions) {
      if (typeof instanceOrOptions?.handle === "function") {
        return instanceOrOptions;
      }
      return new NodeHttp2Handler(instanceOrOptions);
    }
    constructor(options) {
      this.configProvider = new Promise((resolve, reject) => {
        if (typeof options === "function") {
          options().then((opts) => {
            resolve(opts || {});
          }).catch(reject);
        } else {
          resolve(options || {});
        }
      });
    }
    destroy() {
      this.connectionManager.destroy();
    }
    async handle(request, { abortSignal, requestTimeout } = {}) {
      if (!this.config) {
        this.config = await this.configProvider;
        this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
        if (this.config.maxConcurrentStreams) {
          this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
        }
      }
      const { requestTimeout: configRequestTimeout, disableConcurrentStreams } = this.config;
      const effectiveRequestTimeout = requestTimeout ?? configRequestTimeout;
      return new Promise((_resolve, _reject) => {
        let fulfilled = false;
        let writeRequestBodyPromise = undefined;
        const resolve = async (arg) => {
          await writeRequestBodyPromise;
          _resolve(arg);
        };
        const reject = async (arg) => {
          await writeRequestBodyPromise;
          _reject(arg);
        };
        if (abortSignal?.aborted) {
          fulfilled = true;
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          reject(abortError);
          return;
        }
        const { hostname, method, port, protocol, query } = request;
        let auth = "";
        if (request.username != null || request.password != null) {
          const username = request.username ?? "";
          const password = request.password ?? "";
          auth = `${username}:${password}@`;
        }
        const authority = `${protocol}//${auth}${hostname}${port ? `:${port}` : ""}`;
        const requestContext = { destination: new URL(authority) };
        const session = this.connectionManager.lease(requestContext, {
          requestTimeout: this.config?.sessionTimeout,
          disableConcurrentStreams: disableConcurrentStreams || false
        });
        const rejectWithDestroy = (err3) => {
          if (disableConcurrentStreams) {
            this.destroySession(session);
          }
          fulfilled = true;
          reject(err3);
        };
        const queryString = querystringBuilder.buildQueryString(query || {});
        let path = request.path;
        if (queryString) {
          path += `?${queryString}`;
        }
        if (request.fragment) {
          path += `#${request.fragment}`;
        }
        const req = session.request({
          ...request.headers,
          [http2.constants.HTTP2_HEADER_PATH]: path,
          [http2.constants.HTTP2_HEADER_METHOD]: method
        });
        session.ref();
        req.on("response", (headers) => {
          const httpResponse = new protocolHttp.HttpResponse({
            statusCode: headers[":status"] || -1,
            headers: getTransformedHeaders(headers),
            body: req
          });
          fulfilled = true;
          resolve({ response: httpResponse });
          if (disableConcurrentStreams) {
            session.close();
            this.connectionManager.deleteSession(authority, session);
          }
        });
        if (effectiveRequestTimeout) {
          req.setTimeout(effectiveRequestTimeout, () => {
            req.close();
            const timeoutError = new Error(`Stream timed out because of no activity for ${effectiveRequestTimeout} ms`);
            timeoutError.name = "TimeoutError";
            rejectWithDestroy(timeoutError);
          });
        }
        if (abortSignal) {
          const onAbort = () => {
            req.close();
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            rejectWithDestroy(abortError);
          };
          if (typeof abortSignal.addEventListener === "function") {
            const signal = abortSignal;
            signal.addEventListener("abort", onAbort, { once: true });
            req.once("close", () => signal.removeEventListener("abort", onAbort));
          } else {
            abortSignal.onabort = onAbort;
          }
        }
        req.on("frameError", (type, code, id) => {
          rejectWithDestroy(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
        });
        req.on("error", rejectWithDestroy);
        req.on("aborted", () => {
          rejectWithDestroy(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
        });
        req.on("close", () => {
          session.unref();
          if (disableConcurrentStreams) {
            session.destroy();
          }
          if (!fulfilled) {
            rejectWithDestroy(new Error("Unexpected error: http2 request did not get a response"));
          }
        });
        writeRequestBodyPromise = writeRequestBody(req, request, effectiveRequestTimeout);
      });
    }
    updateHttpClientConfig(key, value) {
      this.config = undefined;
      this.configProvider = this.configProvider.then((config) => {
        return {
          ...config,
          [key]: value
        };
      });
    }
    httpHandlerConfigs() {
      return this.config ?? {};
    }
    destroySession(session) {
      if (!session.destroyed) {
        session.destroy();
      }
    }
  }

  class Collector extends stream.Writable {
    bufferedBytes = [];
    _write(chunk, encoding, callback) {
      this.bufferedBytes.push(chunk);
      callback();
    }
  }
  var streamCollector = (stream2) => {
    if (isReadableStreamInstance(stream2)) {
      return collectReadableStream(stream2);
    }
    return new Promise((resolve, reject) => {
      const collector = new Collector;
      stream2.pipe(collector);
      stream2.on("error", (err3) => {
        collector.end();
        reject(err3);
      });
      collector.on("error", reject);
      collector.on("finish", function() {
        const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
        resolve(bytes);
      });
    });
  };
  var isReadableStreamInstance = (stream2) => typeof ReadableStream === "function" && stream2 instanceof ReadableStream;
  async function collectReadableStream(stream2) {
    const chunks = [];
    const reader = stream2.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
      const { done, value } = await reader.read();
      if (value) {
        chunks.push(value);
        length += value.length;
      }
      isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
      collected.set(chunk, offset);
      offset += chunk.length;
    }
    return collected;
  }
  exports.DEFAULT_REQUEST_TIMEOUT = DEFAULT_REQUEST_TIMEOUT;
  exports.NodeHttp2Handler = NodeHttp2Handler;
  exports.NodeHttpHandler = NodeHttpHandler;
  exports.streamCollector = streamCollector;
});

// node_modules/@smithy/fetch-http-handler/dist-cjs/index.js
var require_dist_cjs15 = __commonJS((exports) => {
  var protocolHttp = require_dist_cjs3();
  var querystringBuilder = require_dist_cjs13();
  var utilBase64 = require_dist_cjs11();
  function createRequest(url, requestOptions) {
    return new Request(url, requestOptions);
  }
  function requestTimeout(timeoutInMs = 0) {
    return new Promise((resolve, reject) => {
      if (timeoutInMs) {
        setTimeout(() => {
          const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);
          timeoutError.name = "TimeoutError";
          reject(timeoutError);
        }, timeoutInMs);
      }
    });
  }
  var keepAliveSupport = {
    supported: undefined
  };

  class FetchHttpHandler {
    config;
    configProvider;
    static create(instanceOrOptions) {
      if (typeof instanceOrOptions?.handle === "function") {
        return instanceOrOptions;
      }
      return new FetchHttpHandler(instanceOrOptions);
    }
    constructor(options) {
      if (typeof options === "function") {
        this.configProvider = options().then((opts) => opts || {});
      } else {
        this.config = options ?? {};
        this.configProvider = Promise.resolve(this.config);
      }
      if (keepAliveSupport.supported === undefined) {
        keepAliveSupport.supported = Boolean(typeof Request !== "undefined" && "keepalive" in createRequest("https://[::1]"));
      }
    }
    destroy() {}
    async handle(request, { abortSignal, requestTimeout: requestTimeout$1 } = {}) {
      if (!this.config) {
        this.config = await this.configProvider;
      }
      const requestTimeoutInMs = requestTimeout$1 ?? this.config.requestTimeout;
      const keepAlive = this.config.keepAlive === true;
      const credentials = this.config.credentials;
      if (abortSignal?.aborted) {
        const abortError = new Error("Request aborted");
        abortError.name = "AbortError";
        return Promise.reject(abortError);
      }
      let path = request.path;
      const queryString = querystringBuilder.buildQueryString(request.query || {});
      if (queryString) {
        path += `?${queryString}`;
      }
      if (request.fragment) {
        path += `#${request.fragment}`;
      }
      let auth = "";
      if (request.username != null || request.password != null) {
        const username = request.username ?? "";
        const password = request.password ?? "";
        auth = `${username}:${password}@`;
      }
      const { port, method } = request;
      const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
      const body = method === "GET" || method === "HEAD" ? undefined : request.body;
      const requestOptions = {
        body,
        headers: new Headers(request.headers),
        method,
        credentials
      };
      if (this.config?.cache) {
        requestOptions.cache = this.config.cache;
      }
      if (body) {
        requestOptions.duplex = "half";
      }
      if (typeof AbortController !== "undefined") {
        requestOptions.signal = abortSignal;
      }
      if (keepAliveSupport.supported) {
        requestOptions.keepalive = keepAlive;
      }
      if (typeof this.config.requestInit === "function") {
        Object.assign(requestOptions, this.config.requestInit(request));
      }
      let removeSignalEventListener = () => {};
      const fetchRequest = createRequest(url, requestOptions);
      const raceOfPromises = [
        fetch(fetchRequest).then((response) => {
          const fetchHeaders = response.headers;
          const transformedHeaders = {};
          for (const pair of fetchHeaders.entries()) {
            transformedHeaders[pair[0]] = pair[1];
          }
          const hasReadableStream = response.body != null;
          if (!hasReadableStream) {
            return response.blob().then((body2) => ({
              response: new protocolHttp.HttpResponse({
                headers: transformedHeaders,
                reason: response.statusText,
                statusCode: response.status,
                body: body2
              })
            }));
          }
          return {
            response: new protocolHttp.HttpResponse({
              headers: transformedHeaders,
              reason: response.statusText,
              statusCode: response.status,
              body: response.body
            })
          };
        }),
        requestTimeout(requestTimeoutInMs)
      ];
      if (abortSignal) {
        raceOfPromises.push(new Promise((resolve, reject) => {
          const onAbort = () => {
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            reject(abortError);
          };
          if (typeof abortSignal.addEventListener === "function") {
            const signal = abortSignal;
            signal.addEventListener("abort", onAbort, { once: true });
            removeSignalEventListener = () => signal.removeEventListener("abort", onAbort);
          } else {
            abortSignal.onabort = onAbort;
          }
        }));
      }
      return Promise.race(raceOfPromises).finally(removeSignalEventListener);
    }
    updateHttpClientConfig(key, value) {
      this.config = undefined;
      this.configProvider = this.configProvider.then((config) => {
        config[key] = value;
        return config;
      });
    }
    httpHandlerConfigs() {
      return this.config ?? {};
    }
  }
  var streamCollector = async (stream) => {
    if (typeof Blob === "function" && stream instanceof Blob || stream.constructor?.name === "Blob") {
      if (Blob.prototype.arrayBuffer !== undefined) {
        return new Uint8Array(await stream.arrayBuffer());
      }
      return collectBlob(stream);
    }
    return collectStream(stream);
  };
  async function collectBlob(blob) {
    const base64 = await readToBase64(blob);
    const arrayBuffer = utilBase64.fromBase64(base64);
    return new Uint8Array(arrayBuffer);
  }
  async function collectStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
      const { done, value } = await reader.read();
      if (value) {
        chunks.push(value);
        length += value.length;
      }
      isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
      collected.set(chunk, offset);
      offset += chunk.length;
    }
    return collected;
  }
  function readToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader;
      reader.onloadend = () => {
        if (reader.readyState !== 2) {
          return reject(new Error("Reader aborted too early"));
        }
        const result = reader.result ?? "";
        const commaIndex = result.indexOf(",");
        const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
        resolve(result.substring(dataOffset));
      };
      reader.onabort = () => reject(new Error("Read aborted"));
      reader.onerror = () => reject(reader.error);
      reader.readAsDataURL(blob);
    });
  }
  exports.FetchHttpHandler = FetchHttpHandler;
  exports.keepAliveSupport = keepAliveSupport;
  exports.streamCollector = streamCollector;
});

// node_modules/@smithy/util-hex-encoding/dist-cjs/index.js
var require_dist_cjs16 = __commonJS((exports) => {
  var SHORT_TO_HEX = {};
  var HEX_TO_SHORT = {};
  for (let i2 = 0;i2 < 256; i2++) {
    let encodedByte = i2.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
      encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i2] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i2;
  }
  function fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
      throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i2 = 0;i2 < encoded.length; i2 += 2) {
      const encodedByte = encoded.slice(i2, i2 + 2).toLowerCase();
      if (encodedByte in HEX_TO_SHORT) {
        out[i2 / 2] = HEX_TO_SHORT[encodedByte];
      } else {
        throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
      }
    }
    return out;
  }
  function toHex(bytes) {
    let out = "";
    for (let i2 = 0;i2 < bytes.byteLength; i2++) {
      out += SHORT_TO_HEX[bytes[i2]];
    }
    return out;
  }
  exports.fromHex = fromHex;
  exports.toHex = toHex;
});

// node_modules/@smithy/util-stream/dist-cjs/sdk-stream-mixin.browser.js
var require_sdk_stream_mixin_browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sdkStreamMixin = undefined;
  var fetch_http_handler_1 = require_dist_cjs15();
  var util_base64_1 = require_dist_cjs11();
  var util_hex_encoding_1 = require_dist_cjs16();
  var util_utf8_1 = require_dist_cjs10();
  var stream_type_check_1 = require_stream_type_check();
  var ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
  var sdkStreamMixin = (stream) => {
    if (!isBlobInstance(stream) && !(0, stream_type_check_1.isReadableStream)(stream)) {
      const name = stream?.__proto__?.constructor?.name || stream;
      throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
    }
    let transformed = false;
    const transformToByteArray = async () => {
      if (transformed) {
        throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
      }
      transformed = true;
      return await (0, fetch_http_handler_1.streamCollector)(stream);
    };
    const blobToWebStream = (blob) => {
      if (typeof blob.stream !== "function") {
        throw new Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.
` + "If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
      }
      return blob.stream();
    };
    return Object.assign(stream, {
      transformToByteArray,
      transformToString: async (encoding) => {
        const buf = await transformToByteArray();
        if (encoding === "base64") {
          return (0, util_base64_1.toBase64)(buf);
        } else if (encoding === "hex") {
          return (0, util_hex_encoding_1.toHex)(buf);
        } else if (encoding === undefined || encoding === "utf8" || encoding === "utf-8") {
          return (0, util_utf8_1.toUtf8)(buf);
        } else if (typeof TextDecoder === "function") {
          return new TextDecoder(encoding).decode(buf);
        } else {
          throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
        }
      },
      transformToWebStream: () => {
        if (transformed) {
          throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        if (isBlobInstance(stream)) {
          return blobToWebStream(stream);
        } else if ((0, stream_type_check_1.isReadableStream)(stream)) {
          return stream;
        } else {
          throw new Error(`Cannot transform payload to web stream, got ${stream}`);
        }
      }
    });
  };
  exports.sdkStreamMixin = sdkStreamMixin;
  var isBlobInstance = (stream) => typeof Blob === "function" && stream instanceof Blob;
});

// node_modules/@smithy/util-stream/dist-cjs/sdk-stream-mixin.js
var require_sdk_stream_mixin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sdkStreamMixin = undefined;
  var node_http_handler_1 = require_dist_cjs14();
  var util_buffer_from_1 = require_dist_cjs9();
  var stream_1 = __require("stream");
  var sdk_stream_mixin_browser_1 = require_sdk_stream_mixin_browser();
  var ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
  var sdkStreamMixin = (stream) => {
    if (!(stream instanceof stream_1.Readable)) {
      try {
        return (0, sdk_stream_mixin_browser_1.sdkStreamMixin)(stream);
      } catch (e) {
        const name = stream?.__proto__?.constructor?.name || stream;
        throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
      }
    }
    let transformed = false;
    const transformToByteArray = async () => {
      if (transformed) {
        throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
      }
      transformed = true;
      return await (0, node_http_handler_1.streamCollector)(stream);
    };
    return Object.assign(stream, {
      transformToByteArray,
      transformToString: async (encoding) => {
        const buf = await transformToByteArray();
        if (encoding === undefined || Buffer.isEncoding(encoding)) {
          return (0, util_buffer_from_1.fromArrayBuffer)(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
        } else {
          const decoder = new TextDecoder(encoding);
          return decoder.decode(buf);
        }
      },
      transformToWebStream: () => {
        if (transformed) {
          throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        if (stream.readableFlowing !== null) {
          throw new Error("The stream has been consumed by other callbacks.");
        }
        if (typeof stream_1.Readable.toWeb !== "function") {
          throw new Error("Readable.toWeb() is not supported. Please ensure a polyfill is available.");
        }
        transformed = true;
        return stream_1.Readable.toWeb(stream);
      }
    });
  };
  exports.sdkStreamMixin = sdkStreamMixin;
});

// node_modules/@smithy/util-stream/dist-cjs/splitStream.browser.js
var require_splitStream_browser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.splitStream = splitStream;
  async function splitStream(stream) {
    if (typeof stream.stream === "function") {
      stream = stream.stream();
    }
    const readableStream = stream;
    return readableStream.tee();
  }
});

// node_modules/@smithy/util-stream/dist-cjs/splitStream.js
var require_splitStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.splitStream = splitStream;
  var stream_1 = __require("stream");
  var splitStream_browser_1 = require_splitStream_browser();
  var stream_type_check_1 = require_stream_type_check();
  async function splitStream(stream) {
    if ((0, stream_type_check_1.isReadableStream)(stream) || (0, stream_type_check_1.isBlob)(stream)) {
      return (0, splitStream_browser_1.splitStream)(stream);
    }
    const stream1 = new stream_1.PassThrough;
    const stream2 = new stream_1.PassThrough;
    stream.pipe(stream1);
    stream.pipe(stream2);
    return [stream1, stream2];
  }
});

// node_modules/@smithy/util-stream/dist-cjs/index.js
var require_dist_cjs17 = __commonJS((exports) => {
  var utilBase64 = require_dist_cjs11();
  var utilUtf8 = require_dist_cjs10();
  var ChecksumStream = require_ChecksumStream();
  var createChecksumStream = require_createChecksumStream();
  var createBufferedReadable = require_createBufferedReadable();
  var getAwsChunkedEncodingStream = require_getAwsChunkedEncodingStream();
  var headStream = require_headStream();
  var sdkStreamMixin = require_sdk_stream_mixin();
  var splitStream = require_splitStream();
  var streamTypeCheck = require_stream_type_check();

  class Uint8ArrayBlobAdapter extends Uint8Array {
    static fromString(source, encoding = "utf-8") {
      if (typeof source === "string") {
        if (encoding === "base64") {
          return Uint8ArrayBlobAdapter.mutate(utilBase64.fromBase64(source));
        }
        return Uint8ArrayBlobAdapter.mutate(utilUtf8.fromUtf8(source));
      }
      throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
    }
    static mutate(source) {
      Object.setPrototypeOf(source, Uint8ArrayBlobAdapter.prototype);
      return source;
    }
    transformToString(encoding = "utf-8") {
      if (encoding === "base64") {
        return utilBase64.toBase64(this);
      }
      return utilUtf8.toUtf8(this);
    }
  }
  exports.Uint8ArrayBlobAdapter = Uint8ArrayBlobAdapter;
  Object.keys(ChecksumStream).forEach(function(k2) {
    if (k2 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k2))
      Object.defineProperty(exports, k2, {
        enumerable: true,
        get: function() {
          return ChecksumStream[k2];
        }
      });
  });
  Object.keys(createChecksumStream).forEach(function(k2) {
    if (k2 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k2))
      Object.defineProperty(exports, k2, {
        enumerable: true,
        get: function() {
          return createChecksumStream[k2];
        }
      });
  });
  Object.keys(createBufferedReadable).forEach(function(k2) {
    if (k2 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k2))
      Object.defineProperty(exports, k2, {
        enumerable: true,
        get: function() {
          return createBufferedReadable[k2];
        }
      });
  });
  Object.keys(getAwsChunkedEncodingStream).forEach(function(k2) {
    if (k2 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k2))
      Object.defineProperty(exports, k2, {
        enumerable: true,
        get: function() {
          return getAwsChunkedEncodingStream[k2];
        }
      });
  });
  Object.keys(headStream).forEach(function(k2) {
    if (k2 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k2))
      Object.defineProperty(exports, k2, {
        enumerable: true,
        get: function() {
          return headStream[k2];
        }
      });
  });
  Object.keys(sdkStreamMixin).forEach(function(k2) {
    if (k2 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k2))
      Object.defineProperty(exports, k2, {
        enumerable: true,
        get: function() {
          return sdkStreamMixin[k2];
        }
      });
  });
  Object.keys(splitStream).forEach(function(k2) {
    if (k2 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k2))
      Object.defineProperty(exports, k2, {
        enumerable: true,
        get: function() {
          return splitStream[k2];
        }
      });
  });
  Object.keys(streamTypeCheck).forEach(function(k2) {
    if (k2 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k2))
      Object.defineProperty(exports, k2, {
        enumerable: true,
        get: function() {
          return streamTypeCheck[k2];
        }
      });
  });
});

// node_modules/@smithy/core/dist-cjs/submodules/schema/index.js
var require_schema = __commonJS((exports) => {
  var protocolHttp = require_dist_cjs3();
  var utilMiddleware2 = require_dist_cjs2();
  var deref = (schemaRef) => {
    if (typeof schemaRef === "function") {
      return schemaRef();
    }
    return schemaRef;
  };
  var operation = (namespace, name, traits, input, output) => ({
    name,
    namespace,
    traits,
    input,
    output
  });
  var schemaDeserializationMiddleware = (config) => (next, context) => async (args) => {
    const { response } = await next(args);
    const { operationSchema } = utilMiddleware2.getSmithyContext(context);
    const [, ns, n, t2, i2, o] = operationSchema ?? [];
    try {
      const parsed = await config.protocol.deserializeResponse(operation(ns, n, t2, i2, o), {
        ...config,
        ...context
      }, response);
      return {
        response,
        output: parsed
      };
    } catch (error2) {
      Object.defineProperty(error2, "$response", {
        value: response
      });
      if (!("$metadata" in error2)) {
        const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
        try {
          error2.message += `
  ` + hint;
        } catch (e) {
          if (!context.logger || context.logger?.constructor?.name === "NoOpLogger") {
            console.warn(hint);
          } else {
            context.logger?.warn?.(hint);
          }
        }
        if (typeof error2.$responseBodyText !== "undefined") {
          if (error2.$response) {
            error2.$response.body = error2.$responseBodyText;
          }
        }
        try {
          if (protocolHttp.HttpResponse.isInstance(response)) {
            const { headers = {} } = response;
            const headerEntries = Object.entries(headers);
            error2.$metadata = {
              httpStatusCode: response.statusCode,
              requestId: findHeader(/^x-[\w-]+-request-?id$/, headerEntries),
              extendedRequestId: findHeader(/^x-[\w-]+-id-2$/, headerEntries),
              cfId: findHeader(/^x-[\w-]+-cf-id$/, headerEntries)
            };
          }
        } catch (e) {}
      }
      throw error2;
    }
  };
  var findHeader = (pattern, headers) => {
    return (headers.find(([k2]) => {
      return k2.match(pattern);
    }) || [undefined, undefined])[1];
  };
  var schemaSerializationMiddleware = (config) => (next, context) => async (args) => {
    const { operationSchema } = utilMiddleware2.getSmithyContext(context);
    const [, ns, n, t2, i2, o] = operationSchema ?? [];
    const endpoint = context.endpointV2?.url && config.urlParser ? async () => config.urlParser(context.endpointV2.url) : config.endpoint;
    const request = await config.protocol.serializeRequest(operation(ns, n, t2, i2, o), args.input, {
      ...config,
      ...context,
      endpoint
    });
    return next({
      ...args,
      request
    });
  };
  var deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true
  };
  var serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true
  };
  function getSchemaSerdePlugin(config) {
    return {
      applyToStack: (commandStack) => {
        commandStack.add(schemaSerializationMiddleware(config), serializerMiddlewareOption);
        commandStack.add(schemaDeserializationMiddleware(config), deserializerMiddlewareOption);
        config.protocol.setSerdeContext(config);
      }
    };
  }

  class Schema {
    name;
    namespace;
    traits;
    static assign(instance, values) {
      const schema = Object.assign(instance, values);
      return schema;
    }
    static [Symbol.hasInstance](lhs) {
      const isPrototype = this.prototype.isPrototypeOf(lhs);
      if (!isPrototype && typeof lhs === "object" && lhs !== null) {
        const list2 = lhs;
        return list2.symbol === this.symbol;
      }
      return isPrototype;
    }
    getName() {
      return this.namespace + "#" + this.name;
    }
  }

  class ListSchema extends Schema {
    static symbol = Symbol.for("@smithy/lis");
    name;
    traits;
    valueSchema;
    symbol = ListSchema.symbol;
  }
  var list = (namespace, name, traits, valueSchema) => Schema.assign(new ListSchema, {
    name,
    namespace,
    traits,
    valueSchema
  });

  class MapSchema extends Schema {
    static symbol = Symbol.for("@smithy/map");
    name;
    traits;
    keySchema;
    valueSchema;
    symbol = MapSchema.symbol;
  }
  var map3 = (namespace, name, traits, keySchema, valueSchema) => Schema.assign(new MapSchema, {
    name,
    namespace,
    traits,
    keySchema,
    valueSchema
  });

  class OperationSchema extends Schema {
    static symbol = Symbol.for("@smithy/ope");
    name;
    traits;
    input;
    output;
    symbol = OperationSchema.symbol;
  }
  var op = (namespace, name, traits, input, output) => Schema.assign(new OperationSchema, {
    name,
    namespace,
    traits,
    input,
    output
  });

  class StructureSchema extends Schema {
    static symbol = Symbol.for("@smithy/str");
    name;
    traits;
    memberNames;
    memberList;
    symbol = StructureSchema.symbol;
  }
  var struct = (namespace, name, traits, memberNames, memberList) => Schema.assign(new StructureSchema, {
    name,
    namespace,
    traits,
    memberNames,
    memberList
  });

  class ErrorSchema extends StructureSchema {
    static symbol = Symbol.for("@smithy/err");
    ctor;
    symbol = ErrorSchema.symbol;
  }
  var error = (namespace, name, traits, memberNames, memberList, ctor) => Schema.assign(new ErrorSchema, {
    name,
    namespace,
    traits,
    memberNames,
    memberList,
    ctor: null
  });
  function translateTraits(indicator) {
    if (typeof indicator === "object") {
      return indicator;
    }
    indicator = indicator | 0;
    const traits = {};
    let i2 = 0;
    for (const trait of [
      "httpLabel",
      "idempotent",
      "idempotencyToken",
      "sensitive",
      "httpPayload",
      "httpResponseCode",
      "httpQueryParams"
    ]) {
      if ((indicator >> i2++ & 1) === 1) {
        traits[trait] = 1;
      }
    }
    return traits;
  }

  class NormalizedSchema {
    ref;
    memberName;
    static symbol = Symbol.for("@smithy/nor");
    symbol = NormalizedSchema.symbol;
    name;
    schema;
    _isMemberSchema;
    traits;
    memberTraits;
    normalizedTraits;
    constructor(ref, memberName) {
      this.ref = ref;
      this.memberName = memberName;
      const traitStack = [];
      let _ref = ref;
      let schema = ref;
      this._isMemberSchema = false;
      while (isMemberSchema(_ref)) {
        traitStack.push(_ref[1]);
        _ref = _ref[0];
        schema = deref(_ref);
        this._isMemberSchema = true;
      }
      if (traitStack.length > 0) {
        this.memberTraits = {};
        for (let i2 = traitStack.length - 1;i2 >= 0; --i2) {
          const traitSet = traitStack[i2];
          Object.assign(this.memberTraits, translateTraits(traitSet));
        }
      } else {
        this.memberTraits = 0;
      }
      if (schema instanceof NormalizedSchema) {
        const computedMemberTraits = this.memberTraits;
        Object.assign(this, schema);
        this.memberTraits = Object.assign({}, computedMemberTraits, schema.getMemberTraits(), this.getMemberTraits());
        this.normalizedTraits = undefined;
        this.memberName = memberName ?? schema.memberName;
        return;
      }
      this.schema = deref(schema);
      if (isStaticSchema(this.schema)) {
        this.name = `${this.schema[1]}#${this.schema[2]}`;
        this.traits = this.schema[3];
      } else {
        this.name = this.memberName ?? String(schema);
        this.traits = 0;
      }
      if (this._isMemberSchema && !memberName) {
        throw new Error(`@smithy/core/schema - NormalizedSchema member init ${this.getName(true)} missing member name.`);
      }
    }
    static [Symbol.hasInstance](lhs) {
      const isPrototype = this.prototype.isPrototypeOf(lhs);
      if (!isPrototype && typeof lhs === "object" && lhs !== null) {
        const ns = lhs;
        return ns.symbol === this.symbol;
      }
      return isPrototype;
    }
    static of(ref) {
      const sc = deref(ref);
      if (sc instanceof NormalizedSchema) {
        return sc;
      }
      if (isMemberSchema(sc)) {
        const [ns, traits] = sc;
        if (ns instanceof NormalizedSchema) {
          Object.assign(ns.getMergedTraits(), translateTraits(traits));
          return ns;
        }
        throw new Error(`@smithy/core/schema - may not init unwrapped member schema=${JSON.stringify(ref, null, 2)}.`);
      }
      return new NormalizedSchema(sc);
    }
    getSchema() {
      const sc = this.schema;
      if (sc[0] === 0) {
        return sc[4];
      }
      return sc;
    }
    getName(withNamespace = false) {
      const { name } = this;
      const short = !withNamespace && name && name.includes("#");
      return short ? name.split("#")[1] : name || undefined;
    }
    getMemberName() {
      return this.memberName;
    }
    isMemberSchema() {
      return this._isMemberSchema;
    }
    isListSchema() {
      const sc = this.getSchema();
      return typeof sc === "number" ? sc >= 64 && sc < 128 : sc[0] === 1;
    }
    isMapSchema() {
      const sc = this.getSchema();
      return typeof sc === "number" ? sc >= 128 && sc <= 255 : sc[0] === 2;
    }
    isStructSchema() {
      const sc = this.getSchema();
      return sc[0] === 3 || sc[0] === -3;
    }
    isBlobSchema() {
      const sc = this.getSchema();
      return sc === 21 || sc === 42;
    }
    isTimestampSchema() {
      const sc = this.getSchema();
      return typeof sc === "number" && sc >= 4 && sc <= 7;
    }
    isUnitSchema() {
      return this.getSchema() === "unit";
    }
    isDocumentSchema() {
      return this.getSchema() === 15;
    }
    isStringSchema() {
      return this.getSchema() === 0;
    }
    isBooleanSchema() {
      return this.getSchema() === 2;
    }
    isNumericSchema() {
      return this.getSchema() === 1;
    }
    isBigIntegerSchema() {
      return this.getSchema() === 17;
    }
    isBigDecimalSchema() {
      return this.getSchema() === 19;
    }
    isStreaming() {
      const { streaming } = this.getMergedTraits();
      return !!streaming || this.getSchema() === 42;
    }
    isIdempotencyToken() {
      const match = (traits2) => (traits2 & 4) === 4 || !!traits2?.idempotencyToken;
      const { normalizedTraits, traits, memberTraits } = this;
      return match(normalizedTraits) || match(traits) || match(memberTraits);
    }
    getMergedTraits() {
      return this.normalizedTraits ?? (this.normalizedTraits = {
        ...this.getOwnTraits(),
        ...this.getMemberTraits()
      });
    }
    getMemberTraits() {
      return translateTraits(this.memberTraits);
    }
    getOwnTraits() {
      return translateTraits(this.traits);
    }
    getKeySchema() {
      const [isDoc, isMap] = [this.isDocumentSchema(), this.isMapSchema()];
      if (!isDoc && !isMap) {
        throw new Error(`@smithy/core/schema - cannot get key for non-map: ${this.getName(true)}`);
      }
      const schema = this.getSchema();
      const memberSchema = isDoc ? 15 : schema[4] ?? 0;
      return member([memberSchema, 0], "key");
    }
    getValueSchema() {
      const sc = this.getSchema();
      const [isDoc, isMap, isList] = [this.isDocumentSchema(), this.isMapSchema(), this.isListSchema()];
      const memberSchema = typeof sc === "number" ? 63 & sc : sc && typeof sc === "object" && (isMap || isList) ? sc[3 + sc[0]] : isDoc ? 15 : undefined;
      if (memberSchema != null) {
        return member([memberSchema, 0], isMap ? "value" : "member");
      }
      throw new Error(`@smithy/core/schema - ${this.getName(true)} has no value member.`);
    }
    getMemberSchema(memberName) {
      const struct2 = this.getSchema();
      if (this.isStructSchema() && struct2[4].includes(memberName)) {
        const i2 = struct2[4].indexOf(memberName);
        const memberSchema = struct2[5][i2];
        return member(isMemberSchema(memberSchema) ? memberSchema : [memberSchema, 0], memberName);
      }
      if (this.isDocumentSchema()) {
        return member([15, 0], memberName);
      }
      throw new Error(`@smithy/core/schema - ${this.getName(true)} has no no member=${memberName}.`);
    }
    getMemberSchemas() {
      const buffer = {};
      try {
        for (const [k2, v] of this.structIterator()) {
          buffer[k2] = v;
        }
      } catch (ignored) {}
      return buffer;
    }
    getEventStreamMember() {
      if (this.isStructSchema()) {
        for (const [memberName, memberSchema] of this.structIterator()) {
          if (memberSchema.isStreaming() && memberSchema.isStructSchema()) {
            return memberName;
          }
        }
      }
      return "";
    }
    *structIterator() {
      if (this.isUnitSchema()) {
        return;
      }
      if (!this.isStructSchema()) {
        throw new Error("@smithy/core/schema - cannot iterate non-struct schema.");
      }
      const struct2 = this.getSchema();
      for (let i2 = 0;i2 < struct2[4].length; ++i2) {
        yield [struct2[4][i2], member([struct2[5][i2], 0], struct2[4][i2])];
      }
    }
  }
  function member(memberSchema, memberName) {
    if (memberSchema instanceof NormalizedSchema) {
      return Object.assign(memberSchema, {
        memberName,
        _isMemberSchema: true
      });
    }
    const internalCtorAccess = NormalizedSchema;
    return new internalCtorAccess(memberSchema, memberName);
  }
  var isMemberSchema = (sc) => Array.isArray(sc) && sc.length === 2;
  var isStaticSchema = (sc) => Array.isArray(sc) && sc.length >= 5;

  class SimpleSchema extends Schema {
    static symbol = Symbol.for("@smithy/sim");
    name;
    schemaRef;
    traits;
    symbol = SimpleSchema.symbol;
  }
  var sim = (namespace, name, schemaRef, traits) => Schema.assign(new SimpleSchema, {
    name,
    namespace,
    traits,
    schemaRef
  });
  var simAdapter = (namespace, name, traits, schemaRef) => Schema.assign(new SimpleSchema, {
    name,
    namespace,
    traits,
    schemaRef
  });
  var SCHEMA = {
    BLOB: 21,
    STREAMING_BLOB: 42,
    BOOLEAN: 2,
    STRING: 0,
    NUMERIC: 1,
    BIG_INTEGER: 17,
    BIG_DECIMAL: 19,
    DOCUMENT: 15,
    TIMESTAMP_DEFAULT: 4,
    TIMESTAMP_DATE_TIME: 5,
    TIMESTAMP_HTTP_DATE: 6,
    TIMESTAMP_EPOCH_SECONDS: 7,
    LIST_MODIFIER: 64,
    MAP_MODIFIER: 128
  };

  class TypeRegistry {
    namespace;
    schemas;
    exceptions;
    static registries = new Map;
    constructor(namespace, schemas = new Map, exceptions = new Map) {
      this.namespace = namespace;
      this.schemas = schemas;
      this.exceptions = exceptions;
    }
    static for(namespace) {
      if (!TypeRegistry.registries.has(namespace)) {
        TypeRegistry.registries.set(namespace, new TypeRegistry(namespace));
      }
      return TypeRegistry.registries.get(namespace);
    }
    register(shapeId, schema) {
      const qualifiedName = this.normalizeShapeId(shapeId);
      const registry = TypeRegistry.for(qualifiedName.split("#")[0]);
      registry.schemas.set(qualifiedName, schema);
    }
    getSchema(shapeId) {
      const id = this.normalizeShapeId(shapeId);
      if (!this.schemas.has(id)) {
        throw new Error(`@smithy/core/schema - schema not found for ${id}`);
      }
      return this.schemas.get(id);
    }
    registerError(es, ctor) {
      const $error2 = es;
      const registry = TypeRegistry.for($error2[1]);
      registry.schemas.set($error2[1] + "#" + $error2[2], $error2);
      registry.exceptions.set($error2, ctor);
    }
    getErrorCtor(es) {
      const $error2 = es;
      const registry = TypeRegistry.for($error2[1]);
      return registry.exceptions.get($error2);
    }
    getBaseException() {
      for (const exceptionKey of this.exceptions.keys()) {
        if (Array.isArray(exceptionKey)) {
          const [, ns, name] = exceptionKey;
          const id = ns + "#" + name;
          if (id.startsWith("smithy.ts.sdk.synthetic.") && id.endsWith("ServiceException")) {
            return exceptionKey;
          }
        }
      }
      return;
    }
    find(predicate) {
      return [...this.schemas.values()].find(predicate);
    }
    clear() {
      this.schemas.clear();
      this.exceptions.clear();
    }
    normalizeShapeId(shapeId) {
      if (shapeId.includes("#")) {
        return shapeId;
      }
      return this.namespace + "#" + shapeId;
    }
  }
  exports.ErrorSchema = ErrorSchema;
  exports.ListSchema = ListSchema;
  exports.MapSchema = MapSchema;
  exports.NormalizedSchema = NormalizedSchema;
  exports.OperationSchema = OperationSchema;
  exports.SCHEMA = SCHEMA;
  exports.Schema = Schema;
  exports.SimpleSchema = SimpleSchema;
  exports.StructureSchema = StructureSchema;
  exports.TypeRegistry = TypeRegistry;
  exports.deref = deref;
  exports.deserializerMiddlewareOption = deserializerMiddlewareOption;
  exports.error = error;
  exports.getSchemaSerdePlugin = getSchemaSerdePlugin;
  exports.isStaticSchema = isStaticSchema;
  exports.list = list;
  exports.map = map3;
  exports.op = op;
  exports.operation = operation;
  exports.serializerMiddlewareOption = serializerMiddlewareOption;
  exports.sim = sim;
  exports.simAdapter = simAdapter;
  exports.struct = struct;
  exports.translateTraits = translateTraits;
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet2;
  var __classPrivateFieldSet2;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  var __rewriteRelativeImportExtension;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t2) {
      for (var s, i2 = 1, n = arguments.length;i2 < n; i2++) {
        s = arguments[i2];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t2[p] = s[p];
      }
      return t2;
    };
    __rest = function(s, e) {
      var t2 = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t2[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s);i2 < p.length; i2++) {
          if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
            t2[p[i2]] = s[p[i2]];
        }
      return t2;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i2 = decorators.length - 1;i2 >= 0; i2--)
          if (d = decorators[i2])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _2, done = false;
      for (var i2 = decorators.length - 1;i2 >= 0; i2--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_2 = accept(result.get))
            descriptor.get = _2;
          if (_2 = accept(result.set))
            descriptor.set = _2;
          if (_2 = accept(result.init))
            initializers.unshift(_2);
        } else if (_2 = accept(result)) {
          if (kind === "field")
            initializers.unshift(_2);
          else
            descriptor[key] = _2;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i2 = 0;i2 < initializers.length; i2++) {
        value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x2) {
      return typeof x2 === "symbol" ? x2 : "".concat(x2);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t2[0] & 1)
          throw t2[1];
        return t2[1];
      }, trys: [], ops: [] }, f, y, t2, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_2 = 0)), _2)
          try {
            if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
              return t2;
            if (y = 0, t2)
              op = [op[0] & 2, t2.value];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _2.label++;
                return { value: op[1], done: false };
              case 5:
                _2.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t2[1]) {
                  _2.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _2.label < t2[2]) {
                  _2.label = t2[2];
                  _2.ops.push(op);
                  break;
                }
                if (t2[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t2 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k2, k22) {
      if (k22 === undefined)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k2, k22) {
      if (k22 === undefined)
        k22 = k2;
      o[k22] = m[k2];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i2 >= o.length)
              o = undefined;
            return { value: o && o[i2++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i2 = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i2["return"]))
            m.call(i2);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i2 = 0;i2 < arguments.length; i2++)
        ar = ar.concat(__read(arguments[i2]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i2 = 0, il = arguments.length;i2 < il; i2++)
        s += arguments[i2].length;
      for (var r = Array(s), k2 = 0, i2 = 0;i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length;j < jl; j++, k2++)
          r[k2] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l = from.length, ar;i2 < l; i2++) {
          if (ar || !(i2 in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i2);
            ar[i2] = from[i2];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i2, q = [];
      return i2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i2[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i2[n] = f(i2[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i2, p;
      return i2 = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i2[Symbol.iterator] = function() {
        return this;
      }, i2;
      function verb(n, f) {
        i2[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i2;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2);
      function verb(n) {
        i2[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    var ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k2 in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k2))
            ar[ar.length] = k2;
        return ar;
      };
      return ownKeys(o);
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 = ownKeys(mod), i2 = 0;i2 < k2.length; i2++)
          if (k2[i2] !== "default")
            __createBinding(result, mod, k2[i2]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet2 = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env3, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env3.stack.push({ value, dispose, async });
      } else if (async) {
        env3.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env3) {
      function fail(e) {
        env3.error = env3.hasError ? new _SuppressedError(e, env3.error, "An error was suppressed during disposal.") : e;
        env3.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env3.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env3.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env3.hasError ? Promise.reject(env3.error) : Promise.resolve();
        if (env3.hasError)
          throw env3.error;
      }
      return next();
    };
    __rewriteRelativeImportExtension = function(path, preserveJsx) {
      if (typeof path === "string" && /^\.\.?\//.test(path)) {
        return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
        });
      }
      return path;
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
    exporter("__rewriteRelativeImportExtension", __rewriteRelativeImportExtension);
  });
});

// node_modules/@smithy/uuid/dist-cjs/randomUUID.js
var require_randomUUID = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomUUID = undefined;
  var tslib_1 = require_tslib();
  var crypto_1 = tslib_1.__importDefault(__require("crypto"));
  exports.randomUUID = crypto_1.default.randomUUID.bind(crypto_1.default);
});

// node_modules/@smithy/uuid/dist-cjs/index.js
var require_dist_cjs18 = __commonJS((exports) => {
  var randomUUID = require_randomUUID();
  var decimalToHex = Array.from({ length: 256 }, (_2, i2) => i2.toString(16).padStart(2, "0"));
  var v4 = () => {
    if (randomUUID.randomUUID) {
      return randomUUID.randomUUID();
    }
    const rnds = new Uint8Array(16);
    crypto.getRandomValues(rnds);
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    return decimalToHex[rnds[0]] + decimalToHex[rnds[1]] + decimalToHex[rnds[2]] + decimalToHex[rnds[3]] + "-" + decimalToHex[rnds[4]] + decimalToHex[rnds[5]] + "-" + decimalToHex[rnds[6]] + decimalToHex[rnds[7]] + "-" + decimalToHex[rnds[8]] + decimalToHex[rnds[9]] + "-" + decimalToHex[rnds[10]] + decimalToHex[rnds[11]] + decimalToHex[rnds[12]] + decimalToHex[rnds[13]] + decimalToHex[rnds[14]] + decimalToHex[rnds[15]];
  };
  exports.v4 = v4;
});

// node_modules/@smithy/core/dist-cjs/submodules/serde/index.js
var require_serde = __commonJS((exports) => {
  var uuid = require_dist_cjs18();
  var copyDocumentWithTransform = (source, schemaRef, transform2 = (_2) => _2) => source;
  var parseBoolean = (value) => {
    switch (value) {
      case "true":
        return true;
      case "false":
        return false;
      default:
        throw new Error(`Unable to parse boolean value "${value}"`);
    }
  };
  var expectBoolean = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value === "number") {
      if (value === 0 || value === 1) {
        logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
      }
      if (value === 0) {
        return false;
      }
      if (value === 1) {
        return true;
      }
    }
    if (typeof value === "string") {
      const lower = value.toLowerCase();
      if (lower === "false" || lower === "true") {
        logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
      }
      if (lower === "false") {
        return false;
      }
      if (lower === "true") {
        return true;
      }
    }
    if (typeof value === "boolean") {
      return value;
    }
    throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
  };
  var expectNumber = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value === "string") {
      const parsed = parseFloat(value);
      if (!Number.isNaN(parsed)) {
        if (String(parsed) !== String(value)) {
          logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
        }
        return parsed;
      }
    }
    if (typeof value === "number") {
      return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
  };
  var MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
  var expectFloat32 = (value) => {
    const expected = expectNumber(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
      if (Math.abs(expected) > MAX_FLOAT) {
        throw new TypeError(`Expected 32-bit float, got ${value}`);
      }
    }
    return expected;
  };
  var expectLong = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
      return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
  };
  var expectInt = expectLong;
  var expectInt32 = (value) => expectSizedInt(value, 32);
  var expectShort = (value) => expectSizedInt(value, 16);
  var expectByte = (value) => expectSizedInt(value, 8);
  var expectSizedInt = (value, size) => {
    const expected = expectLong(value);
    if (expected !== undefined && castInt(expected, size) !== expected) {
      throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
  };
  var castInt = (value, size) => {
    switch (size) {
      case 32:
        return Int32Array.of(value)[0];
      case 16:
        return Int16Array.of(value)[0];
      case 8:
        return Int8Array.of(value)[0];
    }
  };
  var expectNonNull = (value, location) => {
    if (value === null || value === undefined) {
      if (location) {
        throw new TypeError(`Expected a non-null value for ${location}`);
      }
      throw new TypeError("Expected a non-null value");
    }
    return value;
  };
  var expectObject = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
      return value;
    }
    const receivedType = Array.isArray(value) ? "array" : typeof value;
    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
  };
  var expectString = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value === "string") {
      return value;
    }
    if (["boolean", "number", "bigint"].includes(typeof value)) {
      logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
      return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
  };
  var expectUnion = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    const asObject = expectObject(value);
    const setKeys = Object.entries(asObject).filter(([, v]) => v != null).map(([k2]) => k2);
    if (setKeys.length === 0) {
      throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
    }
    if (setKeys.length > 1) {
      throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
    }
    return asObject;
  };
  var strictParseDouble = (value) => {
    if (typeof value == "string") {
      return expectNumber(parseNumber(value));
    }
    return expectNumber(value);
  };
  var strictParseFloat = strictParseDouble;
  var strictParseFloat32 = (value) => {
    if (typeof value == "string") {
      return expectFloat32(parseNumber(value));
    }
    return expectFloat32(value);
  };
  var NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
  var parseNumber = (value) => {
    const matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
      throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
  };
  var limitedParseDouble = (value) => {
    if (typeof value == "string") {
      return parseFloatString(value);
    }
    return expectNumber(value);
  };
  var handleFloat = limitedParseDouble;
  var limitedParseFloat = limitedParseDouble;
  var limitedParseFloat32 = (value) => {
    if (typeof value == "string") {
      return parseFloatString(value);
    }
    return expectFloat32(value);
  };
  var parseFloatString = (value) => {
    switch (value) {
      case "NaN":
        return NaN;
      case "Infinity":
        return Infinity;
      case "-Infinity":
        return -Infinity;
      default:
        throw new Error(`Unable to parse float value: ${value}`);
    }
  };
  var strictParseLong = (value) => {
    if (typeof value === "string") {
      return expectLong(parseNumber(value));
    }
    return expectLong(value);
  };
  var strictParseInt = strictParseLong;
  var strictParseInt32 = (value) => {
    if (typeof value === "string") {
      return expectInt32(parseNumber(value));
    }
    return expectInt32(value);
  };
  var strictParseShort = (value) => {
    if (typeof value === "string") {
      return expectShort(parseNumber(value));
    }
    return expectShort(value);
  };
  var strictParseByte = (value) => {
    if (typeof value === "string") {
      return expectByte(parseNumber(value));
    }
    return expectByte(value);
  };
  var stackTraceWarning = (message) => {
    return String(new TypeError(message).stack || message).split(`
`).slice(0, 5).filter((s) => !s.includes("stackTraceWarning")).join(`
`);
  };
  var logger = {
    warn: console.warn
  };
  var DAYS2 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  var MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  function dateToUtcString(date3) {
    const year2 = date3.getUTCFullYear();
    const month = date3.getUTCMonth();
    const dayOfWeek = date3.getUTCDay();
    const dayOfMonthInt = date3.getUTCDate();
    const hoursInt = date3.getUTCHours();
    const minutesInt = date3.getUTCMinutes();
    const secondsInt = date3.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${DAYS2[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year2} ${hoursString}:${minutesString}:${secondsString} GMT`;
  }
  var RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
  var parseRfc3339DateTime = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value !== "string") {
      throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339.exec(value);
    if (!match) {
      throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_2, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    const year2 = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    return buildDate(year2, month, day, { hours, minutes, seconds, fractionalMilliseconds });
  };
  var RFC3339_WITH_OFFSET$1 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
  var parseRfc3339DateTimeWithOffset = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value !== "string") {
      throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339_WITH_OFFSET$1.exec(value);
    if (!match) {
      throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_2, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
    const year2 = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    const date3 = buildDate(year2, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    if (offsetStr.toUpperCase() != "Z") {
      date3.setTime(date3.getTime() - parseOffsetToMilliseconds(offsetStr));
    }
    return date3;
  };
  var IMF_FIXDATE$1 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
  var RFC_850_DATE$1 = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
  var ASC_TIME$1 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
  var parseRfc7231DateTime = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    if (typeof value !== "string") {
      throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    let match = IMF_FIXDATE$1.exec(value);
    if (match) {
      const [_2, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
      return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    match = RFC_850_DATE$1.exec(value);
    if (match) {
      const [_2, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
      return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
        hours,
        minutes,
        seconds,
        fractionalMilliseconds
      }));
    }
    match = ASC_TIME$1.exec(value);
    if (match) {
      const [_2, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
      return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    throw new TypeError("Invalid RFC-7231 date-time value");
  };
  var parseEpochTimestamp = (value) => {
    if (value === null || value === undefined) {
      return;
    }
    let valueAsDouble;
    if (typeof value === "number") {
      valueAsDouble = value;
    } else if (typeof value === "string") {
      valueAsDouble = strictParseDouble(value);
    } else if (typeof value === "object" && value.tag === 1) {
      valueAsDouble = value.value;
    } else {
      throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
      throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
  };
  var buildDate = (year2, month, day, time2) => {
    const adjustedMonth = month - 1;
    validateDayOfMonth(year2, adjustedMonth, day);
    return new Date(Date.UTC(year2, adjustedMonth, day, parseDateValue(time2.hours, "hour", 0, 23), parseDateValue(time2.minutes, "minute", 0, 59), parseDateValue(time2.seconds, "seconds", 0, 60), parseMilliseconds(time2.fractionalMilliseconds)));
  };
  var parseTwoDigitYear = (value) => {
    const thisYear = new Date().getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
      return valueInThisCentury + 100;
    }
    return valueInThisCentury;
  };
  var FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1000;
  var adjustRfc850Year = (input) => {
    if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {
      return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
  };
  var parseMonthByShortName = (value) => {
    const monthIdx = MONTHS.indexOf(value);
    if (monthIdx < 0) {
      throw new TypeError(`Invalid month: ${value}`);
    }
    return monthIdx + 1;
  };
  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var validateDayOfMonth = (year2, month, day) => {
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear2(year2)) {
      maxDays = 29;
    }
    if (day > maxDays) {
      throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year2}: ${day}`);
    }
  };
  var isLeapYear2 = (year2) => {
    return year2 % 4 === 0 && (year2 % 100 !== 0 || year2 % 400 === 0);
  };
  var parseDateValue = (value, type, lower, upper) => {
    const dateVal = strictParseByte(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
      throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
  };
  var parseMilliseconds = (value) => {
    if (value === null || value === undefined) {
      return 0;
    }
    return strictParseFloat32("0." + value) * 1000;
  };
  var parseOffsetToMilliseconds = (value) => {
    const directionStr = value[0];
    let direction = 1;
    if (directionStr == "+") {
      direction = 1;
    } else if (directionStr == "-") {
      direction = -1;
    } else {
      throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour = Number(value.substring(1, 3));
    const minute = Number(value.substring(4, 6));
    return direction * (hour * 60 + minute) * 60 * 1000;
  };
  var stripLeadingZeroes = (value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
      idx++;
    }
    if (idx === 0) {
      return value;
    }
    return value.slice(idx);
  };
  var LazyJsonString = function LazyJsonString(val) {
    const str = Object.assign(new String(val), {
      deserializeJSON() {
        return JSON.parse(String(val));
      },
      toString() {
        return String(val);
      },
      toJSON() {
        return String(val);
      }
    });
    return str;
  };
  LazyJsonString.from = (object) => {
    if (object && typeof object === "object" && (object instanceof LazyJsonString || ("deserializeJSON" in object))) {
      return object;
    } else if (typeof object === "string" || Object.getPrototypeOf(object) === String.prototype) {
      return LazyJsonString(String(object));
    }
    return LazyJsonString(JSON.stringify(object));
  };
  LazyJsonString.fromObject = LazyJsonString.from;
  function quoteHeader(part) {
    if (part.includes(",") || part.includes('"')) {
      part = `"${part.replace(/"/g, "\\\"")}"`;
    }
    return part;
  }
  var ddd = `(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)(?:[ne|u?r]?s?day)?`;
  var mmm = `(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)`;
  var time = `(\\d?\\d):(\\d{2}):(\\d{2})(?:\\.(\\d+))?`;
  var date2 = `(\\d?\\d)`;
  var year = `(\\d{4})`;
  var RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d\d)-(\d\d)[tT](\d\d):(\d\d):(\d\d)(\.(\d+))?(([-+]\d\d:\d\d)|[zZ])$/);
  var IMF_FIXDATE = new RegExp(`^${ddd}, ${date2} ${mmm} ${year} ${time} GMT$`);
  var RFC_850_DATE = new RegExp(`^${ddd}, ${date2}-${mmm}-(\\d\\d) ${time} GMT$`);
  var ASC_TIME = new RegExp(`^${ddd} ${mmm} ( [1-9]|\\d\\d) ${time} ${year}$`);
  var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  var _parseEpochTimestamp = (value) => {
    if (value == null) {
      return;
    }
    let num = NaN;
    if (typeof value === "number") {
      num = value;
    } else if (typeof value === "string") {
      if (!/^-?\d*\.?\d+$/.test(value)) {
        throw new TypeError(`parseEpochTimestamp - numeric string invalid.`);
      }
      num = Number.parseFloat(value);
    } else if (typeof value === "object" && value.tag === 1) {
      num = value.value;
    }
    if (isNaN(num) || Math.abs(num) === Infinity) {
      throw new TypeError("Epoch timestamps must be valid finite numbers.");
    }
    return new Date(Math.round(num * 1000));
  };
  var _parseRfc3339DateTimeWithOffset = (value) => {
    if (value == null) {
      return;
    }
    if (typeof value !== "string") {
      throw new TypeError("RFC3339 timestamps must be strings");
    }
    const matches = RFC3339_WITH_OFFSET.exec(value);
    if (!matches) {
      throw new TypeError(`Invalid RFC3339 timestamp format ${value}`);
    }
    const [, yearStr, monthStr, dayStr, hours, minutes, seconds, , ms, offsetStr] = matches;
    range(monthStr, 1, 12);
    range(dayStr, 1, 31);
    range(hours, 0, 23);
    range(minutes, 0, 59);
    range(seconds, 0, 60);
    const date3 = new Date;
    date3.setUTCFullYear(Number(yearStr), Number(monthStr) - 1, Number(dayStr));
    date3.setUTCHours(Number(hours));
    date3.setUTCMinutes(Number(minutes));
    date3.setUTCSeconds(Number(seconds));
    date3.setUTCMilliseconds(Number(ms) ? Math.round(parseFloat(`0.${ms}`) * 1000) : 0);
    if (offsetStr.toUpperCase() != "Z") {
      const [, sign, offsetH, offsetM] = /([+-])(\d\d):(\d\d)/.exec(offsetStr) || [undefined, "+", 0, 0];
      const scalar = sign === "-" ? 1 : -1;
      date3.setTime(date3.getTime() + scalar * (Number(offsetH) * 60 * 60 * 1000 + Number(offsetM) * 60 * 1000));
    }
    return date3;
  };
  var _parseRfc7231DateTime = (value) => {
    if (value == null) {
      return;
    }
    if (typeof value !== "string") {
      throw new TypeError("RFC7231 timestamps must be strings.");
    }
    let day;
    let month;
    let year2;
    let hour;
    let minute;
    let second;
    let fraction;
    let matches;
    if (matches = IMF_FIXDATE.exec(value)) {
      [, day, month, year2, hour, minute, second, fraction] = matches;
    } else if (matches = RFC_850_DATE.exec(value)) {
      [, day, month, year2, hour, minute, second, fraction] = matches;
      year2 = (Number(year2) + 1900).toString();
    } else if (matches = ASC_TIME.exec(value)) {
      [, month, day, hour, minute, second, fraction, year2] = matches;
    }
    if (year2 && second) {
      const date3 = new Date;
      date3.setUTCFullYear(Number(year2));
      date3.setUTCMonth(months.indexOf(month));
      range(day, 1, 31);
      date3.setUTCDate(Number(day));
      range(hour, 0, 23);
      date3.setUTCHours(Number(hour));
      range(minute, 0, 59);
      date3.setUTCMinutes(Number(minute));
      range(second, 0, 60);
      date3.setUTCSeconds(Number(second));
      date3.setUTCMilliseconds(fraction ? Math.round(parseFloat(`0.${fraction}`) * 1000) : 0);
      return date3;
    }
    throw new TypeError(`Invalid RFC7231 date-time value ${value}.`);
  };
  function range(v, min, max2) {
    const _v = Number(v);
    if (_v < min || _v > max2) {
      throw new Error(`Value ${_v} out of range [${min}, ${max2}]`);
    }
  }
  function splitEvery(value, delimiter, numDelimiters) {
    if (numDelimiters <= 0 || !Number.isInteger(numDelimiters)) {
      throw new Error("Invalid number of delimiters (" + numDelimiters + ") for splitEvery.");
    }
    const segments = value.split(delimiter);
    if (numDelimiters === 1) {
      return segments;
    }
    const compoundSegments = [];
    let currentSegment = "";
    for (let i2 = 0;i2 < segments.length; i2++) {
      if (currentSegment === "") {
        currentSegment = segments[i2];
      } else {
        currentSegment += delimiter + segments[i2];
      }
      if ((i2 + 1) % numDelimiters === 0) {
        compoundSegments.push(currentSegment);
        currentSegment = "";
      }
    }
    if (currentSegment !== "") {
      compoundSegments.push(currentSegment);
    }
    return compoundSegments;
  }
  var splitHeader = (value) => {
    const z = value.length;
    const values = [];
    let withinQuotes = false;
    let prevChar = undefined;
    let anchor = 0;
    for (let i2 = 0;i2 < z; ++i2) {
      const char = value[i2];
      switch (char) {
        case `"`:
          if (prevChar !== "\\") {
            withinQuotes = !withinQuotes;
          }
          break;
        case ",":
          if (!withinQuotes) {
            values.push(value.slice(anchor, i2));
            anchor = i2 + 1;
          }
          break;
      }
      prevChar = char;
    }
    values.push(value.slice(anchor));
    return values.map((v) => {
      v = v.trim();
      const z2 = v.length;
      if (z2 < 2) {
        return v;
      }
      if (v[0] === `"` && v[z2 - 1] === `"`) {
        v = v.slice(1, z2 - 1);
      }
      return v.replace(/\\"/g, '"');
    });
  };
  var format = /^-?\d*(\.\d+)?$/;

  class NumericValue {
    string;
    type;
    constructor(string, type) {
      this.string = string;
      this.type = type;
      if (!format.test(string)) {
        throw new Error(`@smithy/core/serde - NumericValue must only contain [0-9], at most one decimal point ".", and an optional negation prefix "-".`);
      }
    }
    toString() {
      return this.string;
    }
    static [Symbol.hasInstance](object) {
      if (!object || typeof object !== "object") {
        return false;
      }
      const _nv = object;
      return NumericValue.prototype.isPrototypeOf(object) || _nv.type === "bigDecimal" && format.test(_nv.string);
    }
  }
  function nv(input) {
    return new NumericValue(String(input), "bigDecimal");
  }
  Object.defineProperty(exports, "generateIdempotencyToken", {
    enumerable: true,
    get: function() {
      return uuid.v4;
    }
  });
  exports.LazyJsonString = LazyJsonString;
  exports.NumericValue = NumericValue;
  exports._parseEpochTimestamp = _parseEpochTimestamp;
  exports._parseRfc3339DateTimeWithOffset = _parseRfc3339DateTimeWithOffset;
  exports._parseRfc7231DateTime = _parseRfc7231DateTime;
  exports.copyDocumentWithTransform = copyDocumentWithTransform;
  exports.dateToUtcString = dateToUtcString;
  exports.expectBoolean = expectBoolean;
  exports.expectByte = expectByte;
  exports.expectFloat32 = expectFloat32;
  exports.expectInt = expectInt;
  exports.expectInt32 = expectInt32;
  exports.expectLong = expectLong;
  exports.expectNonNull = expectNonNull;
  exports.expectNumber = expectNumber;
  exports.expectObject = expectObject;
  exports.expectShort = expectShort;
  exports.expectString = expectString;
  exports.expectUnion = expectUnion;
  exports.handleFloat = handleFloat;
  exports.limitedParseDouble = limitedParseDouble;
  exports.limitedParseFloat = limitedParseFloat;
  exports.limitedParseFloat32 = limitedParseFloat32;
  exports.logger = logger;
  exports.nv = nv;
  exports.parseBoolean = parseBoolean;
  exports.parseEpochTimestamp = parseEpochTimestamp;
  exports.parseRfc3339DateTime = parseRfc3339DateTime;
  exports.parseRfc3339DateTimeWithOffset = parseRfc3339DateTimeWithOffset;
  exports.parseRfc7231DateTime = parseRfc7231DateTime;
  exports.quoteHeader = quoteHeader;
  exports.splitEvery = splitEvery;
  exports.splitHeader = splitHeader;
  exports.strictParseByte = strictParseByte;
  exports.strictParseDouble = strictParseDouble;
  exports.strictParseFloat = strictParseFloat;
  exports.strictParseFloat32 = strictParseFloat32;
  exports.strictParseInt = strictParseInt;
  exports.strictParseInt32 = strictParseInt32;
  exports.strictParseLong = strictParseLong;
  exports.strictParseShort = strictParseShort;
});

// node_modules/@smithy/core/dist-cjs/submodules/event-streams/index.js
var require_event_streams = __commonJS((exports) => {
  var utilUtf8 = require_dist_cjs10();

  class EventStreamSerde {
    marshaller;
    serializer;
    deserializer;
    serdeContext;
    defaultContentType;
    constructor({ marshaller, serializer, deserializer, serdeContext, defaultContentType }) {
      this.marshaller = marshaller;
      this.serializer = serializer;
      this.deserializer = deserializer;
      this.serdeContext = serdeContext;
      this.defaultContentType = defaultContentType;
    }
    async serializeEventStream({ eventStream, requestSchema, initialRequest }) {
      const marshaller = this.marshaller;
      const eventStreamMember = requestSchema.getEventStreamMember();
      const unionSchema = requestSchema.getMemberSchema(eventStreamMember);
      const serializer = this.serializer;
      const defaultContentType = this.defaultContentType;
      const initialRequestMarker = Symbol("initialRequestMarker");
      const eventStreamIterable = {
        async* [Symbol.asyncIterator]() {
          if (initialRequest) {
            const headers = {
              ":event-type": { type: "string", value: "initial-request" },
              ":message-type": { type: "string", value: "event" },
              ":content-type": { type: "string", value: defaultContentType }
            };
            serializer.write(requestSchema, initialRequest);
            const body = serializer.flush();
            yield {
              [initialRequestMarker]: true,
              headers,
              body
            };
          }
          for await (const page of eventStream) {
            yield page;
          }
        }
      };
      return marshaller.serialize(eventStreamIterable, (event) => {
        if (event[initialRequestMarker]) {
          return {
            headers: event.headers,
            body: event.body
          };
        }
        const unionMember = Object.keys(event).find((key) => {
          return key !== "__type";
        }) ?? "";
        const { additionalHeaders, body, eventType, explicitPayloadContentType } = this.writeEventBody(unionMember, unionSchema, event);
        const headers = {
          ":event-type": { type: "string", value: eventType },
          ":message-type": { type: "string", value: "event" },
          ":content-type": { type: "string", value: explicitPayloadContentType ?? defaultContentType },
          ...additionalHeaders
        };
        return {
          headers,
          body
        };
      });
    }
    async deserializeEventStream({ response, responseSchema, initialResponseContainer }) {
      const marshaller = this.marshaller;
      const eventStreamMember = responseSchema.getEventStreamMember();
      const unionSchema = responseSchema.getMemberSchema(eventStreamMember);
      const memberSchemas = unionSchema.getMemberSchemas();
      const initialResponseMarker = Symbol("initialResponseMarker");
      const asyncIterable = marshaller.deserialize(response.body, async (event) => {
        const unionMember = Object.keys(event).find((key) => {
          return key !== "__type";
        }) ?? "";
        if (unionMember === "initial-response") {
          const dataObject = await this.deserializer.read(responseSchema, event[unionMember].body);
          delete dataObject[eventStreamMember];
          return {
            [initialResponseMarker]: true,
            ...dataObject
          };
        } else if (unionMember in memberSchemas) {
          const eventStreamSchema = memberSchemas[unionMember];
          return {
            [unionMember]: await this.deserializer.read(eventStreamSchema, event[unionMember].body)
          };
        } else {
          return {
            $unknown: event
          };
        }
      });
      const asyncIterator = asyncIterable[Symbol.asyncIterator]();
      const firstEvent = await asyncIterator.next();
      if (firstEvent.done) {
        return asyncIterable;
      }
      if (firstEvent.value?.[initialResponseMarker]) {
        if (!responseSchema) {
          throw new Error("@smithy::core/protocols - initial-response event encountered in event stream but no response schema given.");
        }
        for (const [key, value] of Object.entries(firstEvent.value)) {
          initialResponseContainer[key] = value;
        }
      }
      return {
        async* [Symbol.asyncIterator]() {
          if (!firstEvent?.value?.[initialResponseMarker]) {
            yield firstEvent.value;
          }
          while (true) {
            const { done, value } = await asyncIterator.next();
            if (done) {
              break;
            }
            yield value;
          }
        }
      };
    }
    writeEventBody(unionMember, unionSchema, event) {
      const serializer = this.serializer;
      let eventType = unionMember;
      let explicitPayloadMember = null;
      let explicitPayloadContentType;
      const isKnownSchema = (() => {
        const struct = unionSchema.getSchema();
        return struct[4].includes(unionMember);
      })();
      const additionalHeaders = {};
      if (!isKnownSchema) {
        const [type, value] = event[unionMember];
        eventType = type;
        serializer.write(15, value);
      } else {
        const eventSchema = unionSchema.getMemberSchema(unionMember);
        if (eventSchema.isStructSchema()) {
          for (const [memberName, memberSchema] of eventSchema.structIterator()) {
            const { eventHeader, eventPayload } = memberSchema.getMergedTraits();
            if (eventPayload) {
              explicitPayloadMember = memberName;
              break;
            } else if (eventHeader) {
              const value = event[unionMember][memberName];
              let type = "binary";
              if (memberSchema.isNumericSchema()) {
                if ((-2) ** 31 <= value && value <= 2 ** 31 - 1) {
                  type = "integer";
                } else {
                  type = "long";
                }
              } else if (memberSchema.isTimestampSchema()) {
                type = "timestamp";
              } else if (memberSchema.isStringSchema()) {
                type = "string";
              } else if (memberSchema.isBooleanSchema()) {
                type = "boolean";
              }
              if (value != null) {
                additionalHeaders[memberName] = {
                  type,
                  value
                };
                delete event[unionMember][memberName];
              }
            }
          }
          if (explicitPayloadMember !== null) {
            const payloadSchema = eventSchema.getMemberSchema(explicitPayloadMember);
            if (payloadSchema.isBlobSchema()) {
              explicitPayloadContentType = "application/octet-stream";
            } else if (payloadSchema.isStringSchema()) {
              explicitPayloadContentType = "text/plain";
            }
            serializer.write(payloadSchema, event[unionMember][explicitPayloadMember]);
          } else {
            serializer.write(eventSchema, event[unionMember]);
          }
        } else {
          throw new Error("@smithy/core/event-streams - non-struct member not supported in event stream union.");
        }
      }
      const messageSerialization = serializer.flush();
      const body = typeof messageSerialization === "string" ? (this.serdeContext?.utf8Decoder ?? utilUtf8.fromUtf8)(messageSerialization) : messageSerialization;
      return {
        body,
        eventType,
        explicitPayloadContentType,
        additionalHeaders
      };
    }
  }
  exports.EventStreamSerde = EventStreamSerde;
});

// node_modules/@smithy/core/dist-cjs/submodules/protocols/index.js
var require_protocols = __commonJS((exports) => {
  var utilStream = require_dist_cjs17();
  var schema = require_schema();
  var serde = require_serde();
  var protocolHttp = require_dist_cjs3();
  var utilBase64 = require_dist_cjs11();
  var utilUtf8 = require_dist_cjs10();
  var collectBody = async (streamBody = new Uint8Array, context) => {
    if (streamBody instanceof Uint8Array) {
      return utilStream.Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
      return utilStream.Uint8ArrayBlobAdapter.mutate(new Uint8Array);
    }
    const fromContext = context.streamCollector(streamBody);
    return utilStream.Uint8ArrayBlobAdapter.mutate(await fromContext);
  };
  function extendedEncodeURIComponent(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }

  class SerdeContext {
    serdeContext;
    setSerdeContext(serdeContext) {
      this.serdeContext = serdeContext;
    }
  }

  class HttpProtocol extends SerdeContext {
    options;
    constructor(options) {
      super();
      this.options = options;
    }
    getRequestType() {
      return protocolHttp.HttpRequest;
    }
    getResponseType() {
      return protocolHttp.HttpResponse;
    }
    setSerdeContext(serdeContext) {
      this.serdeContext = serdeContext;
      this.serializer.setSerdeContext(serdeContext);
      this.deserializer.setSerdeContext(serdeContext);
      if (this.getPayloadCodec()) {
        this.getPayloadCodec().setSerdeContext(serdeContext);
      }
    }
    updateServiceEndpoint(request, endpoint) {
      if ("url" in endpoint) {
        request.protocol = endpoint.url.protocol;
        request.hostname = endpoint.url.hostname;
        request.port = endpoint.url.port ? Number(endpoint.url.port) : undefined;
        request.path = endpoint.url.pathname;
        request.fragment = endpoint.url.hash || undefined;
        request.username = endpoint.url.username || undefined;
        request.password = endpoint.url.password || undefined;
        if (!request.query) {
          request.query = {};
        }
        for (const [k2, v] of endpoint.url.searchParams.entries()) {
          request.query[k2] = v;
        }
        return request;
      } else {
        request.protocol = endpoint.protocol;
        request.hostname = endpoint.hostname;
        request.port = endpoint.port ? Number(endpoint.port) : undefined;
        request.path = endpoint.path;
        request.query = {
          ...endpoint.query
        };
        return request;
      }
    }
    setHostPrefix(request, operationSchema, input) {
      const inputNs = schema.NormalizedSchema.of(operationSchema.input);
      const opTraits = schema.translateTraits(operationSchema.traits ?? {});
      if (opTraits.endpoint) {
        let hostPrefix = opTraits.endpoint?.[0];
        if (typeof hostPrefix === "string") {
          const hostLabelInputs = [...inputNs.structIterator()].filter(([, member]) => member.getMergedTraits().hostLabel);
          for (const [name] of hostLabelInputs) {
            const replacement = input[name];
            if (typeof replacement !== "string") {
              throw new Error(`@smithy/core/schema - ${name} in input must be a string as hostLabel.`);
            }
            hostPrefix = hostPrefix.replace(`{${name}}`, replacement);
          }
          request.hostname = hostPrefix + request.hostname;
        }
      }
    }
    deserializeMetadata(output) {
      return {
        httpStatusCode: output.statusCode,
        requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"]
      };
    }
    async serializeEventStream({ eventStream, requestSchema, initialRequest }) {
      const eventStreamSerde = await this.loadEventStreamCapability();
      return eventStreamSerde.serializeEventStream({
        eventStream,
        requestSchema,
        initialRequest
      });
    }
    async deserializeEventStream({ response, responseSchema, initialResponseContainer }) {
      const eventStreamSerde = await this.loadEventStreamCapability();
      return eventStreamSerde.deserializeEventStream({
        response,
        responseSchema,
        initialResponseContainer
      });
    }
    async loadEventStreamCapability() {
      const { EventStreamSerde } = await Promise.resolve().then(() => __toESM(require_event_streams(), 1));
      return new EventStreamSerde({
        marshaller: this.getEventStreamMarshaller(),
        serializer: this.serializer,
        deserializer: this.deserializer,
        serdeContext: this.serdeContext,
        defaultContentType: this.getDefaultContentType()
      });
    }
    getDefaultContentType() {
      throw new Error(`@smithy/core/protocols - ${this.constructor.name} getDefaultContentType() implementation missing.`);
    }
    async deserializeHttpMessage(schema2, context, response, arg4, arg5) {
      return [];
    }
    getEventStreamMarshaller() {
      const context = this.serdeContext;
      if (!context.eventStreamMarshaller) {
        throw new Error("@smithy/core - HttpProtocol: eventStreamMarshaller missing in serdeContext.");
      }
      return context.eventStreamMarshaller;
    }
  }

  class HttpBindingProtocol extends HttpProtocol {
    async serializeRequest(operationSchema, _input, context) {
      const input = {
        ..._input ?? {}
      };
      const serializer = this.serializer;
      const query = {};
      const headers = {};
      const endpoint = await context.endpoint();
      const ns = schema.NormalizedSchema.of(operationSchema?.input);
      const schema$1 = ns.getSchema();
      let hasNonHttpBindingMember = false;
      let payload;
      const request = new protocolHttp.HttpRequest({
        protocol: "",
        hostname: "",
        port: undefined,
        path: "",
        fragment: undefined,
        query,
        headers,
        body: undefined
      });
      if (endpoint) {
        this.updateServiceEndpoint(request, endpoint);
        this.setHostPrefix(request, operationSchema, input);
        const opTraits = schema.translateTraits(operationSchema.traits);
        if (opTraits.http) {
          request.method = opTraits.http[0];
          const [path, search] = opTraits.http[1].split("?");
          if (request.path == "/") {
            request.path = path;
          } else {
            request.path += path;
          }
          const traitSearchParams = new URLSearchParams(search ?? "");
          Object.assign(query, Object.fromEntries(traitSearchParams));
        }
      }
      for (const [memberName, memberNs] of ns.structIterator()) {
        const memberTraits = memberNs.getMergedTraits() ?? {};
        const inputMemberValue = input[memberName];
        if (inputMemberValue == null) {
          continue;
        }
        if (memberTraits.httpPayload) {
          const isStreaming = memberNs.isStreaming();
          if (isStreaming) {
            const isEventStream = memberNs.isStructSchema();
            if (isEventStream) {
              if (input[memberName]) {
                payload = await this.serializeEventStream({
                  eventStream: input[memberName],
                  requestSchema: ns
                });
              }
            } else {
              payload = inputMemberValue;
            }
          } else {
            serializer.write(memberNs, inputMemberValue);
            payload = serializer.flush();
          }
          delete input[memberName];
        } else if (memberTraits.httpLabel) {
          serializer.write(memberNs, inputMemberValue);
          const replacement = serializer.flush();
          if (request.path.includes(`{${memberName}+}`)) {
            request.path = request.path.replace(`{${memberName}+}`, replacement.split("/").map(extendedEncodeURIComponent).join("/"));
          } else if (request.path.includes(`{${memberName}}`)) {
            request.path = request.path.replace(`{${memberName}}`, extendedEncodeURIComponent(replacement));
          }
          delete input[memberName];
        } else if (memberTraits.httpHeader) {
          serializer.write(memberNs, inputMemberValue);
          headers[memberTraits.httpHeader.toLowerCase()] = String(serializer.flush());
          delete input[memberName];
        } else if (typeof memberTraits.httpPrefixHeaders === "string") {
          for (const [key, val] of Object.entries(inputMemberValue)) {
            const amalgam = memberTraits.httpPrefixHeaders + key;
            serializer.write([memberNs.getValueSchema(), { httpHeader: amalgam }], val);
            headers[amalgam.toLowerCase()] = serializer.flush();
          }
          delete input[memberName];
        } else if (memberTraits.httpQuery || memberTraits.httpQueryParams) {
          this.serializeQuery(memberNs, inputMemberValue, query);
          delete input[memberName];
        } else {
          hasNonHttpBindingMember = true;
        }
      }
      if (hasNonHttpBindingMember && input) {
        serializer.write(schema$1, input);
        payload = serializer.flush();
      }
      request.headers = headers;
      request.query = query;
      request.body = payload;
      return request;
    }
    serializeQuery(ns, data, query) {
      const serializer = this.serializer;
      const traits = ns.getMergedTraits();
      if (traits.httpQueryParams) {
        for (const [key, val] of Object.entries(data)) {
          if (!(key in query)) {
            const valueSchema = ns.getValueSchema();
            Object.assign(valueSchema.getMergedTraits(), {
              ...traits,
              httpQuery: key,
              httpQueryParams: undefined
            });
            this.serializeQuery(valueSchema, val, query);
          }
        }
        return;
      }
      if (ns.isListSchema()) {
        const sparse = !!ns.getMergedTraits().sparse;
        const buffer = [];
        for (const item of data) {
          serializer.write([ns.getValueSchema(), traits], item);
          const serializable = serializer.flush();
          if (sparse || serializable !== undefined) {
            buffer.push(serializable);
          }
        }
        query[traits.httpQuery] = buffer;
      } else {
        serializer.write([ns, traits], data);
        query[traits.httpQuery] = serializer.flush();
      }
    }
    async deserializeResponse(operationSchema, context, response) {
      const deserializer = this.deserializer;
      const ns = schema.NormalizedSchema.of(operationSchema.output);
      const dataObject = {};
      if (response.statusCode >= 300) {
        const bytes = await collectBody(response.body, context);
        if (bytes.byteLength > 0) {
          Object.assign(dataObject, await deserializer.read(15, bytes));
        }
        await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));
        throw new Error("@smithy/core/protocols - HTTP Protocol error handler failed to throw.");
      }
      for (const header in response.headers) {
        const value = response.headers[header];
        delete response.headers[header];
        response.headers[header.toLowerCase()] = value;
      }
      const nonHttpBindingMembers = await this.deserializeHttpMessage(ns, context, response, dataObject);
      if (nonHttpBindingMembers.length) {
        const bytes = await collectBody(response.body, context);
        if (bytes.byteLength > 0) {
          const dataFromBody = await deserializer.read(ns, bytes);
          for (const member of nonHttpBindingMembers) {
            dataObject[member] = dataFromBody[member];
          }
        }
      }
      dataObject.$metadata = this.deserializeMetadata(response);
      return dataObject;
    }
    async deserializeHttpMessage(schema$1, context, response, arg4, arg5) {
      let dataObject;
      if (arg4 instanceof Set) {
        dataObject = arg5;
      } else {
        dataObject = arg4;
      }
      const deserializer = this.deserializer;
      const ns = schema.NormalizedSchema.of(schema$1);
      const nonHttpBindingMembers = [];
      for (const [memberName, memberSchema] of ns.structIterator()) {
        const memberTraits = memberSchema.getMemberTraits();
        if (memberTraits.httpPayload) {
          const isStreaming = memberSchema.isStreaming();
          if (isStreaming) {
            const isEventStream = memberSchema.isStructSchema();
            if (isEventStream) {
              dataObject[memberName] = await this.deserializeEventStream({
                response,
                responseSchema: ns
              });
            } else {
              dataObject[memberName] = utilStream.sdkStreamMixin(response.body);
            }
          } else if (response.body) {
            const bytes = await collectBody(response.body, context);
            if (bytes.byteLength > 0) {
              dataObject[memberName] = await deserializer.read(memberSchema, bytes);
            }
          }
        } else if (memberTraits.httpHeader) {
          const key = String(memberTraits.httpHeader).toLowerCase();
          const value = response.headers[key];
          if (value != null) {
            if (memberSchema.isListSchema()) {
              const headerListValueSchema = memberSchema.getValueSchema();
              headerListValueSchema.getMergedTraits().httpHeader = key;
              let sections;
              if (headerListValueSchema.isTimestampSchema() && headerListValueSchema.getSchema() === 4) {
                sections = serde.splitEvery(value, ",", 2);
              } else {
                sections = serde.splitHeader(value);
              }
              const list = [];
              for (const section of sections) {
                list.push(await deserializer.read(headerListValueSchema, section.trim()));
              }
              dataObject[memberName] = list;
            } else {
              dataObject[memberName] = await deserializer.read(memberSchema, value);
            }
          }
        } else if (memberTraits.httpPrefixHeaders !== undefined) {
          dataObject[memberName] = {};
          for (const [header, value] of Object.entries(response.headers)) {
            if (header.startsWith(memberTraits.httpPrefixHeaders)) {
              const valueSchema = memberSchema.getValueSchema();
              valueSchema.getMergedTraits().httpHeader = header;
              dataObject[memberName][header.slice(memberTraits.httpPrefixHeaders.length)] = await deserializer.read(valueSchema, value);
            }
          }
        } else if (memberTraits.httpResponseCode) {
          dataObject[memberName] = response.statusCode;
        } else {
          nonHttpBindingMembers.push(memberName);
        }
      }
      return nonHttpBindingMembers;
    }
  }

  class RpcProtocol extends HttpProtocol {
    async serializeRequest(operationSchema, input, context) {
      const serializer = this.serializer;
      const query = {};
      const headers = {};
      const endpoint = await context.endpoint();
      const ns = schema.NormalizedSchema.of(operationSchema?.input);
      const schema$1 = ns.getSchema();
      let payload;
      const request = new protocolHttp.HttpRequest({
        protocol: "",
        hostname: "",
        port: undefined,
        path: "/",
        fragment: undefined,
        query,
        headers,
        body: undefined
      });
      if (endpoint) {
        this.updateServiceEndpoint(request, endpoint);
        this.setHostPrefix(request, operationSchema, input);
      }
      const _input = {
        ...input
      };
      if (input) {
        const eventStreamMember = ns.getEventStreamMember();
        if (eventStreamMember) {
          if (_input[eventStreamMember]) {
            const initialRequest = {};
            for (const [memberName, memberSchema] of ns.structIterator()) {
              if (memberName !== eventStreamMember && _input[memberName]) {
                serializer.write(memberSchema, _input[memberName]);
                initialRequest[memberName] = serializer.flush();
              }
            }
            payload = await this.serializeEventStream({
              eventStream: _input[eventStreamMember],
              requestSchema: ns,
              initialRequest
            });
          }
        } else {
          serializer.write(schema$1, _input);
          payload = serializer.flush();
        }
      }
      request.headers = headers;
      request.query = query;
      request.body = payload;
      request.method = "POST";
      return request;
    }
    async deserializeResponse(operationSchema, context, response) {
      const deserializer = this.deserializer;
      const ns = schema.NormalizedSchema.of(operationSchema.output);
      const dataObject = {};
      if (response.statusCode >= 300) {
        const bytes = await collectBody(response.body, context);
        if (bytes.byteLength > 0) {
          Object.assign(dataObject, await deserializer.read(15, bytes));
        }
        await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));
        throw new Error("@smithy/core/protocols - RPC Protocol error handler failed to throw.");
      }
      for (const header in response.headers) {
        const value = response.headers[header];
        delete response.headers[header];
        response.headers[header.toLowerCase()] = value;
      }
      const eventStreamMember = ns.getEventStreamMember();
      if (eventStreamMember) {
        dataObject[eventStreamMember] = await this.deserializeEventStream({
          response,
          responseSchema: ns,
          initialResponseContainer: dataObject
        });
      } else {
        const bytes = await collectBody(response.body, context);
        if (bytes.byteLength > 0) {
          Object.assign(dataObject, await deserializer.read(ns, bytes));
        }
      }
      dataObject.$metadata = this.deserializeMetadata(response);
      return dataObject;
    }
  }
  var resolvedPath = (resolvedPath2, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
    if (input != null && input[memberName] !== undefined) {
      const labelValue = labelValueProvider();
      if (labelValue.length <= 0) {
        throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
      }
      resolvedPath2 = resolvedPath2.replace(uriLabel, isGreedyLabel ? labelValue.split("/").map((segment) => extendedEncodeURIComponent(segment)).join("/") : extendedEncodeURIComponent(labelValue));
    } else {
      throw new Error("No value provided for input HTTP label: " + memberName + ".");
    }
    return resolvedPath2;
  };
  function requestBuilder(input, context) {
    return new RequestBuilder(input, context);
  }

  class RequestBuilder {
    input;
    context;
    query = {};
    method = "";
    headers = {};
    path = "";
    body = null;
    hostname = "";
    resolvePathStack = [];
    constructor(input, context) {
      this.input = input;
      this.context = context;
    }
    async build() {
      const { hostname, protocol = "https", port, path: basePath } = await this.context.endpoint();
      this.path = basePath;
      for (const resolvePath of this.resolvePathStack) {
        resolvePath(this.path);
      }
      return new protocolHttp.HttpRequest({
        protocol,
        hostname: this.hostname || hostname,
        port,
        method: this.method,
        path: this.path,
        query: this.query,
        body: this.body,
        headers: this.headers
      });
    }
    hn(hostname) {
      this.hostname = hostname;
      return this;
    }
    bp(uriLabel) {
      this.resolvePathStack.push((basePath) => {
        this.path = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + uriLabel;
      });
      return this;
    }
    p(memberName, labelValueProvider, uriLabel, isGreedyLabel) {
      this.resolvePathStack.push((path) => {
        this.path = resolvedPath(path, this.input, memberName, labelValueProvider, uriLabel, isGreedyLabel);
      });
      return this;
    }
    h(headers) {
      this.headers = headers;
      return this;
    }
    q(query) {
      this.query = query;
      return this;
    }
    b(body) {
      this.body = body;
      return this;
    }
    m(method) {
      this.method = method;
      return this;
    }
  }
  function determineTimestampFormat(ns, settings) {
    if (settings.timestampFormat.useTrait) {
      if (ns.isTimestampSchema() && (ns.getSchema() === 5 || ns.getSchema() === 6 || ns.getSchema() === 7)) {
        return ns.getSchema();
      }
    }
    const { httpLabel, httpPrefixHeaders, httpHeader, httpQuery } = ns.getMergedTraits();
    const bindingFormat = settings.httpBindings ? typeof httpPrefixHeaders === "string" || Boolean(httpHeader) ? 6 : Boolean(httpQuery) || Boolean(httpLabel) ? 5 : undefined : undefined;
    return bindingFormat ?? settings.timestampFormat.default;
  }

  class FromStringShapeDeserializer extends SerdeContext {
    settings;
    constructor(settings) {
      super();
      this.settings = settings;
    }
    read(_schema, data) {
      const ns = schema.NormalizedSchema.of(_schema);
      if (ns.isListSchema()) {
        return serde.splitHeader(data).map((item) => this.read(ns.getValueSchema(), item));
      }
      if (ns.isBlobSchema()) {
        return (this.serdeContext?.base64Decoder ?? utilBase64.fromBase64)(data);
      }
      if (ns.isTimestampSchema()) {
        const format = determineTimestampFormat(ns, this.settings);
        switch (format) {
          case 5:
            return serde._parseRfc3339DateTimeWithOffset(data);
          case 6:
            return serde._parseRfc7231DateTime(data);
          case 7:
            return serde._parseEpochTimestamp(data);
          default:
            console.warn("Missing timestamp format, parsing value with Date constructor:", data);
            return new Date(data);
        }
      }
      if (ns.isStringSchema()) {
        const mediaType = ns.getMergedTraits().mediaType;
        let intermediateValue = data;
        if (mediaType) {
          if (ns.getMergedTraits().httpHeader) {
            intermediateValue = this.base64ToUtf8(intermediateValue);
          }
          const isJson = mediaType === "application/json" || mediaType.endsWith("+json");
          if (isJson) {
            intermediateValue = serde.LazyJsonString.from(intermediateValue);
          }
          return intermediateValue;
        }
      }
      if (ns.isNumericSchema()) {
        return Number(data);
      }
      if (ns.isBigIntegerSchema()) {
        return BigInt(data);
      }
      if (ns.isBigDecimalSchema()) {
        return new serde.NumericValue(data, "bigDecimal");
      }
      if (ns.isBooleanSchema()) {
        return String(data).toLowerCase() === "true";
      }
      return data;
    }
    base64ToUtf8(base64String) {
      return (this.serdeContext?.utf8Encoder ?? utilUtf8.toUtf8)((this.serdeContext?.base64Decoder ?? utilBase64.fromBase64)(base64String));
    }
  }

  class HttpInterceptingShapeDeserializer extends SerdeContext {
    codecDeserializer;
    stringDeserializer;
    constructor(codecDeserializer, codecSettings) {
      super();
      this.codecDeserializer = codecDeserializer;
      this.stringDeserializer = new FromStringShapeDeserializer(codecSettings);
    }
    setSerdeContext(serdeContext) {
      this.stringDeserializer.setSerdeContext(serdeContext);
      this.codecDeserializer.setSerdeContext(serdeContext);
      this.serdeContext = serdeContext;
    }
    read(schema$1, data) {
      const ns = schema.NormalizedSchema.of(schema$1);
      const traits = ns.getMergedTraits();
      const toString = this.serdeContext?.utf8Encoder ?? utilUtf8.toUtf8;
      if (traits.httpHeader || traits.httpResponseCode) {
        return this.stringDeserializer.read(ns, toString(data));
      }
      if (traits.httpPayload) {
        if (ns.isBlobSchema()) {
          const toBytes = this.serdeContext?.utf8Decoder ?? utilUtf8.fromUtf8;
          if (typeof data === "string") {
            return toBytes(data);
          }
          return data;
        } else if (ns.isStringSchema()) {
          if ("byteLength" in data) {
            return toString(data);
          }
          return data;
        }
      }
      return this.codecDeserializer.read(ns, data);
    }
  }

  class ToStringShapeSerializer extends SerdeContext {
    settings;
    stringBuffer = "";
    constructor(settings) {
      super();
      this.settings = settings;
    }
    write(schema$1, value) {
      const ns = schema.NormalizedSchema.of(schema$1);
      switch (typeof value) {
        case "object":
          if (value === null) {
            this.stringBuffer = "null";
            return;
          }
          if (ns.isTimestampSchema()) {
            if (!(value instanceof Date)) {
              throw new Error(`@smithy/core/protocols - received non-Date value ${value} when schema expected Date in ${ns.getName(true)}`);
            }
            const format = determineTimestampFormat(ns, this.settings);
            switch (format) {
              case 5:
                this.stringBuffer = value.toISOString().replace(".000Z", "Z");
                break;
              case 6:
                this.stringBuffer = serde.dateToUtcString(value);
                break;
              case 7:
                this.stringBuffer = String(value.getTime() / 1000);
                break;
              default:
                console.warn("Missing timestamp format, using epoch seconds", value);
                this.stringBuffer = String(value.getTime() / 1000);
            }
            return;
          }
          if (ns.isBlobSchema() && "byteLength" in value) {
            this.stringBuffer = (this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(value);
            return;
          }
          if (ns.isListSchema() && Array.isArray(value)) {
            let buffer = "";
            for (const item of value) {
              this.write([ns.getValueSchema(), ns.getMergedTraits()], item);
              const headerItem = this.flush();
              const serialized = ns.getValueSchema().isTimestampSchema() ? headerItem : serde.quoteHeader(headerItem);
              if (buffer !== "") {
                buffer += ", ";
              }
              buffer += serialized;
            }
            this.stringBuffer = buffer;
            return;
          }
          this.stringBuffer = JSON.stringify(value, null, 2);
          break;
        case "string":
          const mediaType = ns.getMergedTraits().mediaType;
          let intermediateValue = value;
          if (mediaType) {
            const isJson = mediaType === "application/json" || mediaType.endsWith("+json");
            if (isJson) {
              intermediateValue = serde.LazyJsonString.from(intermediateValue);
            }
            if (ns.getMergedTraits().httpHeader) {
              this.stringBuffer = (this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(intermediateValue.toString());
              return;
            }
          }
          this.stringBuffer = value;
          break;
        default:
          this.stringBuffer = String(value);
      }
    }
    flush() {
      const buffer = this.stringBuffer;
      this.stringBuffer = "";
      return buffer;
    }
  }

  class HttpInterceptingShapeSerializer {
    codecSerializer;
    stringSerializer;
    buffer;
    constructor(codecSerializer, codecSettings, stringSerializer = new ToStringShapeSerializer(codecSettings)) {
      this.codecSerializer = codecSerializer;
      this.stringSerializer = stringSerializer;
    }
    setSerdeContext(serdeContext) {
      this.codecSerializer.setSerdeContext(serdeContext);
      this.stringSerializer.setSerdeContext(serdeContext);
    }
    write(schema$1, value) {
      const ns = schema.NormalizedSchema.of(schema$1);
      const traits = ns.getMergedTraits();
      if (traits.httpHeader || traits.httpLabel || traits.httpQuery) {
        this.stringSerializer.write(ns, value);
        this.buffer = this.stringSerializer.flush();
        return;
      }
      return this.codecSerializer.write(ns, value);
    }
    flush() {
      if (this.buffer !== undefined) {
        const buffer = this.buffer;
        this.buffer = undefined;
        return buffer;
      }
      return this.codecSerializer.flush();
    }
  }
  exports.FromStringShapeDeserializer = FromStringShapeDeserializer;
  exports.HttpBindingProtocol = HttpBindingProtocol;
  exports.HttpInterceptingShapeDeserializer = HttpInterceptingShapeDeserializer;
  exports.HttpInterceptingShapeSerializer = HttpInterceptingShapeSerializer;
  exports.HttpProtocol = HttpProtocol;
  exports.RequestBuilder = RequestBuilder;
  exports.RpcProtocol = RpcProtocol;
  exports.SerdeContext = SerdeContext;
  exports.ToStringShapeSerializer = ToStringShapeSerializer;
  exports.collectBody = collectBody;
  exports.determineTimestampFormat = determineTimestampFormat;
  exports.extendedEncodeURIComponent = extendedEncodeURIComponent;
  exports.requestBuilder = requestBuilder;
  exports.resolvedPath = resolvedPath;
});

// node_modules/@smithy/core/dist-cjs/index.js
var require_dist_cjs19 = __commonJS((exports) => {
  var types = require_dist_cjs();
  var utilMiddleware2 = require_dist_cjs2();
  var middlewareSerde = require_dist_cjs7();
  var protocolHttp = require_dist_cjs3();
  var protocols = require_protocols();
  var getSmithyContext = (context) => context[types.SMITHY_CONTEXT_KEY] || (context[types.SMITHY_CONTEXT_KEY] = {});
  var resolveAuthOptions = (candidateAuthOptions, authSchemePreference) => {
    if (!authSchemePreference || authSchemePreference.length === 0) {
      return candidateAuthOptions;
    }
    const preferredAuthOptions = [];
    for (const preferredSchemeName of authSchemePreference) {
      for (const candidateAuthOption of candidateAuthOptions) {
        const candidateAuthSchemeName = candidateAuthOption.schemeId.split("#")[1];
        if (candidateAuthSchemeName === preferredSchemeName) {
          preferredAuthOptions.push(candidateAuthOption);
        }
      }
    }
    for (const candidateAuthOption of candidateAuthOptions) {
      if (!preferredAuthOptions.find(({ schemeId }) => schemeId === candidateAuthOption.schemeId)) {
        preferredAuthOptions.push(candidateAuthOption);
      }
    }
    return preferredAuthOptions;
  };
  function convertHttpAuthSchemesToMap(httpAuthSchemes) {
    const map3 = new Map;
    for (const scheme of httpAuthSchemes) {
      map3.set(scheme.schemeId, scheme);
    }
    return map3;
  }
  var httpAuthSchemeMiddleware = (config, mwOptions) => (next, context) => async (args) => {
    const options = config.httpAuthSchemeProvider(await mwOptions.httpAuthSchemeParametersProvider(config, context, args.input));
    const authSchemePreference = config.authSchemePreference ? await config.authSchemePreference() : [];
    const resolvedOptions = resolveAuthOptions(options, authSchemePreference);
    const authSchemes = convertHttpAuthSchemesToMap(config.httpAuthSchemes);
    const smithyContext = utilMiddleware2.getSmithyContext(context);
    const failureReasons = [];
    for (const option of resolvedOptions) {
      const scheme = authSchemes.get(option.schemeId);
      if (!scheme) {
        failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` was not enabled for this service.`);
        continue;
      }
      const identityProvider = scheme.identityProvider(await mwOptions.identityProviderConfigProvider(config));
      if (!identityProvider) {
        failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` did not have an IdentityProvider configured.`);
        continue;
      }
      const { identityProperties = {}, signingProperties = {} } = option.propertiesExtractor?.(config, context) || {};
      option.identityProperties = Object.assign(option.identityProperties || {}, identityProperties);
      option.signingProperties = Object.assign(option.signingProperties || {}, signingProperties);
      smithyContext.selectedHttpAuthScheme = {
        httpAuthOption: option,
        identity: await identityProvider(option.identityProperties),
        signer: scheme.signer
      };
      break;
    }
    if (!smithyContext.selectedHttpAuthScheme) {
      throw new Error(failureReasons.join(`
`));
    }
    return next(args);
  };
  var httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
    step: "serialize",
    tags: ["HTTP_AUTH_SCHEME"],
    name: "httpAuthSchemeMiddleware",
    override: true,
    relation: "before",
    toMiddleware: "endpointV2Middleware"
  };
  var getHttpAuthSchemeEndpointRuleSetPlugin = (config, { httpAuthSchemeParametersProvider, identityProviderConfigProvider }) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(httpAuthSchemeMiddleware(config, {
        httpAuthSchemeParametersProvider,
        identityProviderConfigProvider
      }), httpAuthSchemeEndpointRuleSetMiddlewareOptions);
    }
  });
  var httpAuthSchemeMiddlewareOptions = {
    step: "serialize",
    tags: ["HTTP_AUTH_SCHEME"],
    name: "httpAuthSchemeMiddleware",
    override: true,
    relation: "before",
    toMiddleware: middlewareSerde.serializerMiddlewareOption.name
  };
  var getHttpAuthSchemePlugin = (config, { httpAuthSchemeParametersProvider, identityProviderConfigProvider }) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(httpAuthSchemeMiddleware(config, {
        httpAuthSchemeParametersProvider,
        identityProviderConfigProvider
      }), httpAuthSchemeMiddlewareOptions);
    }
  });
  var defaultErrorHandler = (signingProperties) => (error) => {
    throw error;
  };
  var defaultSuccessHandler = (httpResponse, signingProperties) => {};
  var httpSigningMiddleware = (config) => (next, context) => async (args) => {
    if (!protocolHttp.HttpRequest.isInstance(args.request)) {
      return next(args);
    }
    const smithyContext = utilMiddleware2.getSmithyContext(context);
    const scheme = smithyContext.selectedHttpAuthScheme;
    if (!scheme) {
      throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
    }
    const { httpAuthOption: { signingProperties = {} }, identity, signer } = scheme;
    const output = await next({
      ...args,
      request: await signer.sign(args.request, identity, signingProperties)
    }).catch((signer.errorHandler || defaultErrorHandler)(signingProperties));
    (signer.successHandler || defaultSuccessHandler)(output.response, signingProperties);
    return output;
  };
  var httpSigningMiddlewareOptions = {
    step: "finalizeRequest",
    tags: ["HTTP_SIGNING"],
    name: "httpSigningMiddleware",
    aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
    override: true,
    relation: "after",
    toMiddleware: "retryMiddleware"
  };
  var getHttpSigningPlugin = (config) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(httpSigningMiddleware(), httpSigningMiddlewareOptions);
    }
  });
  var normalizeProvider = (input) => {
    if (typeof input === "function")
      return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
  };
  var makePagedClientRequest = async (CommandCtor, client, input, withCommand = (_2) => _2, ...args) => {
    let command = new CommandCtor(input);
    command = withCommand(command) ?? command;
    return await client.send(command, ...args);
  };
  function createPaginator(ClientCtor, CommandCtor, inputTokenName, outputTokenName, pageSizeTokenName) {
    return async function* paginateOperation(config, input, ...additionalArguments) {
      const _input = input;
      let token = config.startingToken ?? _input[inputTokenName];
      let hasNext = true;
      let page;
      while (hasNext) {
        _input[inputTokenName] = token;
        if (pageSizeTokenName) {
          _input[pageSizeTokenName] = _input[pageSizeTokenName] ?? config.pageSize;
        }
        if (config.client instanceof ClientCtor) {
          page = await makePagedClientRequest(CommandCtor, config.client, input, config.withCommand, ...additionalArguments);
        } else {
          throw new Error(`Invalid client, expected instance of ${ClientCtor.name}`);
        }
        yield page;
        const prevToken = token;
        token = get(page, outputTokenName);
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
      }
      return;
    };
  }
  var get = (fromObject, path) => {
    let cursor = fromObject;
    const pathComponents = path.split(".");
    for (const step of pathComponents) {
      if (!cursor || typeof cursor !== "object") {
        return;
      }
      cursor = cursor[step];
    }
    return cursor;
  };
  function setFeature(context, feature, value) {
    if (!context.__smithy_context) {
      context.__smithy_context = {
        features: {}
      };
    } else if (!context.__smithy_context.features) {
      context.__smithy_context.features = {};
    }
    context.__smithy_context.features[feature] = value;
  }

  class DefaultIdentityProviderConfig {
    authSchemes = new Map;
    constructor(config) {
      for (const [key, value] of Object.entries(config)) {
        if (value !== undefined) {
          this.authSchemes.set(key, value);
        }
      }
    }
    getIdentityProvider(schemeId) {
      return this.authSchemes.get(schemeId);
    }
  }

  class HttpApiKeyAuthSigner {
    async sign(httpRequest, identity, signingProperties) {
      if (!signingProperties) {
        throw new Error("request could not be signed with `apiKey` since the `name` and `in` signer properties are missing");
      }
      if (!signingProperties.name) {
        throw new Error("request could not be signed with `apiKey` since the `name` signer property is missing");
      }
      if (!signingProperties.in) {
        throw new Error("request could not be signed with `apiKey` since the `in` signer property is missing");
      }
      if (!identity.apiKey) {
        throw new Error("request could not be signed with `apiKey` since the `apiKey` is not defined");
      }
      const clonedRequest = protocolHttp.HttpRequest.clone(httpRequest);
      if (signingProperties.in === types.HttpApiKeyAuthLocation.QUERY) {
        clonedRequest.query[signingProperties.name] = identity.apiKey;
      } else if (signingProperties.in === types.HttpApiKeyAuthLocation.HEADER) {
        clonedRequest.headers[signingProperties.name] = signingProperties.scheme ? `${signingProperties.scheme} ${identity.apiKey}` : identity.apiKey;
      } else {
        throw new Error("request can only be signed with `apiKey` locations `query` or `header`, " + "but found: `" + signingProperties.in + "`");
      }
      return clonedRequest;
    }
  }

  class HttpBearerAuthSigner {
    async sign(httpRequest, identity, signingProperties) {
      const clonedRequest = protocolHttp.HttpRequest.clone(httpRequest);
      if (!identity.token) {
        throw new Error("request could not be signed with `token` since the `token` is not defined");
      }
      clonedRequest.headers["Authorization"] = `Bearer ${identity.token}`;
      return clonedRequest;
    }
  }

  class NoAuthSigner {
    async sign(httpRequest, identity, signingProperties) {
      return httpRequest;
    }
  }
  var createIsIdentityExpiredFunction = (expirationMs) => function isIdentityExpired(identity) {
    return doesIdentityRequireRefresh(identity) && identity.expiration.getTime() - Date.now() < expirationMs;
  };
  var EXPIRATION_MS = 300000;
  var isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);
  var doesIdentityRequireRefresh = (identity) => identity.expiration !== undefined;
  var memoizeIdentityProvider = (provider, isExpired, requiresRefresh) => {
    if (provider === undefined) {
      return;
    }
    const normalizedProvider = typeof provider !== "function" ? async () => Promise.resolve(provider) : provider;
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async (options) => {
      if (!pending) {
        pending = normalizedProvider(options);
      }
      try {
        resolved = await pending;
        hasResult = true;
        isConstant = false;
      } finally {
        pending = undefined;
      }
      return resolved;
    };
    if (isExpired === undefined) {
      return async (options) => {
        if (!hasResult || options?.forceRefresh) {
          resolved = await coalesceProvider(options);
        }
        return resolved;
      };
    }
    return async (options) => {
      if (!hasResult || options?.forceRefresh) {
        resolved = await coalesceProvider(options);
      }
      if (isConstant) {
        return resolved;
      }
      if (!requiresRefresh(resolved)) {
        isConstant = true;
        return resolved;
      }
      if (isExpired(resolved)) {
        await coalesceProvider(options);
        return resolved;
      }
      return resolved;
    };
  };
  Object.defineProperty(exports, "requestBuilder", {
    enumerable: true,
    get: function() {
      return protocols.requestBuilder;
    }
  });
  exports.DefaultIdentityProviderConfig = DefaultIdentityProviderConfig;
  exports.EXPIRATION_MS = EXPIRATION_MS;
  exports.HttpApiKeyAuthSigner = HttpApiKeyAuthSigner;
  exports.HttpBearerAuthSigner = HttpBearerAuthSigner;
  exports.NoAuthSigner = NoAuthSigner;
  exports.createIsIdentityExpiredFunction = createIsIdentityExpiredFunction;
  exports.createPaginator = createPaginator;
  exports.doesIdentityRequireRefresh = doesIdentityRequireRefresh;
  exports.getHttpAuthSchemeEndpointRuleSetPlugin = getHttpAuthSchemeEndpointRuleSetPlugin;
  exports.getHttpAuthSchemePlugin = getHttpAuthSchemePlugin;
  exports.getHttpSigningPlugin = getHttpSigningPlugin;
  exports.getSmithyContext = getSmithyContext;
  exports.httpAuthSchemeEndpointRuleSetMiddlewareOptions = httpAuthSchemeEndpointRuleSetMiddlewareOptions;
  exports.httpAuthSchemeMiddleware = httpAuthSchemeMiddleware;
  exports.httpAuthSchemeMiddlewareOptions = httpAuthSchemeMiddlewareOptions;
  exports.httpSigningMiddleware = httpSigningMiddleware;
  exports.httpSigningMiddlewareOptions = httpSigningMiddlewareOptions;
  exports.isIdentityExpired = isIdentityExpired;
  exports.memoizeIdentityProvider = memoizeIdentityProvider;
  exports.normalizeProvider = normalizeProvider;
  exports.setFeature = setFeature;
});

// node_modules/@smithy/util-endpoints/dist-cjs/index.js
var require_dist_cjs20 = __commonJS((exports) => {
  var types = require_dist_cjs();

  class EndpointCache3 {
    capacity;
    data = new Map;
    parameters = [];
    constructor({ size, params }) {
      this.capacity = size ?? 50;
      if (params) {
        this.parameters = params;
      }
    }
    get(endpointParams, resolver) {
      const key = this.hash(endpointParams);
      if (key === false) {
        return resolver();
      }
      if (!this.data.has(key)) {
        if (this.data.size > this.capacity + 10) {
          const keys = this.data.keys();
          let i2 = 0;
          while (true) {
            const { value, done } = keys.next();
            this.data.delete(value);
            if (done || ++i2 > 10) {
              break;
            }
          }
        }
        this.data.set(key, resolver());
      }
      return this.data.get(key);
    }
    size() {
      return this.data.size;
    }
    hash(endpointParams) {
      let buffer = "";
      const { parameters } = this;
      if (parameters.length === 0) {
        return false;
      }
      for (const param of parameters) {
        const val = String(endpointParams[param] ?? "");
        if (val.includes("|;")) {
          return false;
        }
        buffer += val + "|;";
      }
      return buffer;
    }
  }
  var IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
  var isIpAddress = (value) => IP_V4_REGEX.test(value) || value.startsWith("[") && value.endsWith("]");
  var VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
  var isValidHostLabel = (value, allowSubDomains = false) => {
    if (!allowSubDomains) {
      return VALID_HOST_LABEL_REGEX.test(value);
    }
    const labels = value.split(".");
    for (const label of labels) {
      if (!isValidHostLabel(label)) {
        return false;
      }
    }
    return true;
  };
  var customEndpointFunctions = {};
  var debugId = "endpoints";
  function toDebugString(input) {
    if (typeof input !== "object" || input == null) {
      return input;
    }
    if ("ref" in input) {
      return `$${toDebugString(input.ref)}`;
    }
    if ("fn" in input) {
      return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
    }
    return JSON.stringify(input, null, 2);
  }

  class EndpointError extends Error {
    constructor(message) {
      super(message);
      this.name = "EndpointError";
    }
  }
  var booleanEquals = (value1, value2) => value1 === value2;
  var getAttrPathList = (path) => {
    const parts = path.split(".");
    const pathList = [];
    for (const part of parts) {
      const squareBracketIndex = part.indexOf("[");
      if (squareBracketIndex !== -1) {
        if (part.indexOf("]") !== part.length - 1) {
          throw new EndpointError(`Path: '${path}' does not end with ']'`);
        }
        const arrayIndex = part.slice(squareBracketIndex + 1, -1);
        if (Number.isNaN(parseInt(arrayIndex))) {
          throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
        }
        if (squareBracketIndex !== 0) {
          pathList.push(part.slice(0, squareBracketIndex));
        }
        pathList.push(arrayIndex);
      } else {
        pathList.push(part);
      }
    }
    return pathList;
  };
  var getAttr = (value, path) => getAttrPathList(path).reduce((acc, index) => {
    if (typeof acc !== "object") {
      throw new EndpointError(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);
    } else if (Array.isArray(acc)) {
      return acc[parseInt(index)];
    }
    return acc[index];
  }, value);
  var isSet = (value) => value != null;
  var not = (value) => !value;
  var DEFAULT_PORTS = {
    [types.EndpointURLScheme.HTTP]: 80,
    [types.EndpointURLScheme.HTTPS]: 443
  };
  var parseURL = (value) => {
    const whatwgURL = (() => {
      try {
        if (value instanceof URL) {
          return value;
        }
        if (typeof value === "object" && "hostname" in value) {
          const { hostname: hostname2, port, protocol: protocol2 = "", path = "", query = {} } = value;
          const url = new URL(`${protocol2}//${hostname2}${port ? `:${port}` : ""}${path}`);
          url.search = Object.entries(query).map(([k2, v]) => `${k2}=${v}`).join("&");
          return url;
        }
        return new URL(value);
      } catch (error) {
        return null;
      }
    })();
    if (!whatwgURL) {
      console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
      return null;
    }
    const urlString = whatwgURL.href;
    const { host, hostname, pathname, protocol, search } = whatwgURL;
    if (search) {
      return null;
    }
    const scheme = protocol.slice(0, -1);
    if (!Object.values(types.EndpointURLScheme).includes(scheme)) {
      return null;
    }
    const isIp = isIpAddress(hostname);
    const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`);
    const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
    return {
      scheme,
      authority,
      path: pathname,
      normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
      isIp
    };
  };
  var stringEquals = (value1, value2) => value1 === value2;
  var substring = (input, start, stop, reverse) => {
    if (start >= stop || input.length < stop) {
      return null;
    }
    if (!reverse) {
      return input.substring(start, stop);
    }
    return input.substring(input.length - stop, input.length - start);
  };
  var uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);
  var endpointFunctions = {
    booleanEquals,
    getAttr,
    isSet,
    isValidHostLabel,
    not,
    parseURL,
    stringEquals,
    substring,
    uriEncode
  };
  var evaluateTemplate = (template, options) => {
    const evaluatedTemplateArr = [];
    const templateContext = {
      ...options.endpointParams,
      ...options.referenceRecord
    };
    let currentIndex = 0;
    while (currentIndex < template.length) {
      const openingBraceIndex = template.indexOf("{", currentIndex);
      if (openingBraceIndex === -1) {
        evaluatedTemplateArr.push(template.slice(currentIndex));
        break;
      }
      evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
      const closingBraceIndex = template.indexOf("}", openingBraceIndex);
      if (closingBraceIndex === -1) {
        evaluatedTemplateArr.push(template.slice(openingBraceIndex));
        break;
      }
      if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
        evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
        currentIndex = closingBraceIndex + 2;
      }
      const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
      if (parameterName.includes("#")) {
        const [refName, attrName] = parameterName.split("#");
        evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
      } else {
        evaluatedTemplateArr.push(templateContext[parameterName]);
      }
      currentIndex = closingBraceIndex + 1;
    }
    return evaluatedTemplateArr.join("");
  };
  var getReferenceValue = ({ ref }, options) => {
    const referenceRecord = {
      ...options.endpointParams,
      ...options.referenceRecord
    };
    return referenceRecord[ref];
  };
  var evaluateExpression = (obj, keyName, options) => {
    if (typeof obj === "string") {
      return evaluateTemplate(obj, options);
    } else if (obj["fn"]) {
      return group$2.callFunction(obj, options);
    } else if (obj["ref"]) {
      return getReferenceValue(obj, options);
    }
    throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
  };
  var callFunction = ({ fn, argv }, options) => {
    const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : group$2.evaluateExpression(arg, "arg", options));
    const fnSegments = fn.split(".");
    if (fnSegments[0] in customEndpointFunctions && fnSegments[1] != null) {
      return customEndpointFunctions[fnSegments[0]][fnSegments[1]](...evaluatedArgs);
    }
    return endpointFunctions[fn](...evaluatedArgs);
  };
  var group$2 = {
    evaluateExpression,
    callFunction
  };
  var evaluateCondition = ({ assign, ...fnArgs }, options) => {
    if (assign && assign in options.referenceRecord) {
      throw new EndpointError(`'${assign}' is already defined in Reference Record.`);
    }
    const value = callFunction(fnArgs, options);
    options.logger?.debug?.(`${debugId} evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
    return {
      result: value === "" ? true : !!value,
      ...assign != null && { toAssign: { name: assign, value } }
    };
  };
  var evaluateConditions = (conditions = [], options) => {
    const conditionsReferenceRecord = {};
    for (const condition of conditions) {
      const { result, toAssign } = evaluateCondition(condition, {
        ...options,
        referenceRecord: {
          ...options.referenceRecord,
          ...conditionsReferenceRecord
        }
      });
      if (!result) {
        return { result };
      }
      if (toAssign) {
        conditionsReferenceRecord[toAssign.name] = toAssign.value;
        options.logger?.debug?.(`${debugId} assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
      }
    }
    return { result: true, referenceRecord: conditionsReferenceRecord };
  };
  var getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
    ...acc,
    [headerKey]: headerVal.map((headerValEntry) => {
      const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
      if (typeof processedExpr !== "string") {
        throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
      }
      return processedExpr;
    })
  }), {});
  var getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
    ...acc,
    [propertyKey]: group$1.getEndpointProperty(propertyVal, options)
  }), {});
  var getEndpointProperty = (property, options) => {
    if (Array.isArray(property)) {
      return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
    }
    switch (typeof property) {
      case "string":
        return evaluateTemplate(property, options);
      case "object":
        if (property === null) {
          throw new EndpointError(`Unexpected endpoint property: ${property}`);
        }
        return group$1.getEndpointProperties(property, options);
      case "boolean":
        return property;
      default:
        throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);
    }
  };
  var group$1 = {
    getEndpointProperty,
    getEndpointProperties
  };
  var getEndpointUrl = (endpointUrl, options) => {
    const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
    if (typeof expression === "string") {
      try {
        return new URL(expression);
      } catch (error) {
        console.error(`Failed to construct URL with ${expression}`, error);
        throw error;
      }
    }
    throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
  };
  var evaluateEndpointRule = (endpointRule, options) => {
    const { conditions, endpoint } = endpointRule;
    const { result, referenceRecord } = evaluateConditions(conditions, options);
    if (!result) {
      return;
    }
    const endpointRuleOptions = {
      ...options,
      referenceRecord: { ...options.referenceRecord, ...referenceRecord }
    };
    const { url, properties, headers } = endpoint;
    options.logger?.debug?.(`${debugId} Resolving endpoint from template: ${toDebugString(endpoint)}`);
    return {
      ...headers != null && {
        headers: getEndpointHeaders(headers, endpointRuleOptions)
      },
      ...properties != null && {
        properties: getEndpointProperties(properties, endpointRuleOptions)
      },
      url: getEndpointUrl(url, endpointRuleOptions)
    };
  };
  var evaluateErrorRule = (errorRule, options) => {
    const { conditions, error } = errorRule;
    const { result, referenceRecord } = evaluateConditions(conditions, options);
    if (!result) {
      return;
    }
    throw new EndpointError(evaluateExpression(error, "Error", {
      ...options,
      referenceRecord: { ...options.referenceRecord, ...referenceRecord }
    }));
  };
  var evaluateRules = (rules, options) => {
    for (const rule of rules) {
      if (rule.type === "endpoint") {
        const endpointOrUndefined = evaluateEndpointRule(rule, options);
        if (endpointOrUndefined) {
          return endpointOrUndefined;
        }
      } else if (rule.type === "error") {
        evaluateErrorRule(rule, options);
      } else if (rule.type === "tree") {
        const endpointOrUndefined = group.evaluateTreeRule(rule, options);
        if (endpointOrUndefined) {
          return endpointOrUndefined;
        }
      } else {
        throw new EndpointError(`Unknown endpoint rule: ${rule}`);
      }
    }
    throw new EndpointError(`Rules evaluation failed`);
  };
  var evaluateTreeRule = (treeRule, options) => {
    const { conditions, rules } = treeRule;
    const { result, referenceRecord } = evaluateConditions(conditions, options);
    if (!result) {
      return;
    }
    return group.evaluateRules(rules, {
      ...options,
      referenceRecord: { ...options.referenceRecord, ...referenceRecord }
    });
  };
  var group = {
    evaluateRules,
    evaluateTreeRule
  };
  var resolveEndpoint = (ruleSetObject, options) => {
    const { endpointParams, logger } = options;
    const { parameters, rules } = ruleSetObject;
    options.logger?.debug?.(`${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);
    const paramsWithDefault = Object.entries(parameters).filter(([, v]) => v.default != null).map(([k2, v]) => [k2, v.default]);
    if (paramsWithDefault.length > 0) {
      for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
        endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
      }
    }
    const requiredParams = Object.entries(parameters).filter(([, v]) => v.required).map(([k2]) => k2);
    for (const requiredParam of requiredParams) {
      if (endpointParams[requiredParam] == null) {
        throw new EndpointError(`Missing required parameter: '${requiredParam}'`);
      }
    }
    const endpoint = evaluateRules(rules, { endpointParams, logger, referenceRecord: {} });
    options.logger?.debug?.(`${debugId} Resolved endpoint: ${toDebugString(endpoint)}`);
    return endpoint;
  };
  exports.EndpointCache = EndpointCache3;
  exports.EndpointError = EndpointError;
  exports.customEndpointFunctions = customEndpointFunctions;
  exports.isIpAddress = isIpAddress;
  exports.isValidHostLabel = isValidHostLabel;
  exports.resolveEndpoint = resolveEndpoint;
});

// node_modules/@smithy/querystring-parser/dist-cjs/index.js
var require_dist_cjs21 = __commonJS((exports) => {
  function parseQueryString(querystring) {
    const query = {};
    querystring = querystring.replace(/^\?/, "");
    if (querystring) {
      for (const pair of querystring.split("&")) {
        let [key, value = null] = pair.split("=");
        key = decodeURIComponent(key);
        if (value) {
          value = decodeURIComponent(value);
        }
        if (!(key in query)) {
          query[key] = value;
        } else if (Array.isArray(query[key])) {
          query[key].push(value);
        } else {
          query[key] = [query[key], value];
        }
      }
    }
    return query;
  }
  exports.parseQueryString = parseQueryString;
});

// node_modules/@smithy/url-parser/dist-cjs/index.js
var require_dist_cjs22 = __commonJS((exports) => {
  var querystringParser = require_dist_cjs21();
  var parseUrl = (url) => {
    if (typeof url === "string") {
      return parseUrl(new URL(url));
    }
    const { hostname, pathname, port, protocol, search } = url;
    let query;
    if (search) {
      query = querystringParser.parseQueryString(search);
    }
    return {
      hostname,
      port: port ? parseInt(port) : undefined,
      protocol,
      path: pathname,
      query
    };
  };
  exports.parseUrl = parseUrl;
});

// node_modules/@aws-sdk/util-endpoints/dist-cjs/index.js
var require_dist_cjs23 = __commonJS((exports) => {
  var utilEndpoints = require_dist_cjs20();
  var urlParser = require_dist_cjs22();
  var isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
    if (allowSubDomains) {
      for (const label of value.split(".")) {
        if (!isVirtualHostableS3Bucket(label)) {
          return false;
        }
      }
      return true;
    }
    if (!utilEndpoints.isValidHostLabel(value)) {
      return false;
    }
    if (value.length < 3 || value.length > 63) {
      return false;
    }
    if (value !== value.toLowerCase()) {
      return false;
    }
    if (utilEndpoints.isIpAddress(value)) {
      return false;
    }
    return true;
  };
  var ARN_DELIMITER = ":";
  var RESOURCE_DELIMITER = "/";
  var parseArn = (value) => {
    const segments = value.split(ARN_DELIMITER);
    if (segments.length < 6)
      return null;
    const [arn, partition2, service, region, accountId, ...resourcePath] = segments;
    if (arn !== "arn" || partition2 === "" || service === "" || resourcePath.join(ARN_DELIMITER) === "")
      return null;
    const resourceId = resourcePath.map((resource) => resource.split(RESOURCE_DELIMITER)).flat();
    return {
      partition: partition2,
      service,
      region,
      accountId,
      resourceId
    };
  };
  var partitions = [
    {
      id: "aws",
      outputs: {
        dnsSuffix: "amazonaws.com",
        dualStackDnsSuffix: "api.aws",
        implicitGlobalRegion: "us-east-1",
        name: "aws",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
      regions: {
        "af-south-1": {
          description: "Africa (Cape Town)"
        },
        "ap-east-1": {
          description: "Asia Pacific (Hong Kong)"
        },
        "ap-east-2": {
          description: "Asia Pacific (Taipei)"
        },
        "ap-northeast-1": {
          description: "Asia Pacific (Tokyo)"
        },
        "ap-northeast-2": {
          description: "Asia Pacific (Seoul)"
        },
        "ap-northeast-3": {
          description: "Asia Pacific (Osaka)"
        },
        "ap-south-1": {
          description: "Asia Pacific (Mumbai)"
        },
        "ap-south-2": {
          description: "Asia Pacific (Hyderabad)"
        },
        "ap-southeast-1": {
          description: "Asia Pacific (Singapore)"
        },
        "ap-southeast-2": {
          description: "Asia Pacific (Sydney)"
        },
        "ap-southeast-3": {
          description: "Asia Pacific (Jakarta)"
        },
        "ap-southeast-4": {
          description: "Asia Pacific (Melbourne)"
        },
        "ap-southeast-5": {
          description: "Asia Pacific (Malaysia)"
        },
        "ap-southeast-6": {
          description: "Asia Pacific (New Zealand)"
        },
        "ap-southeast-7": {
          description: "Asia Pacific (Thailand)"
        },
        "aws-global": {
          description: "aws global region"
        },
        "ca-central-1": {
          description: "Canada (Central)"
        },
        "ca-west-1": {
          description: "Canada West (Calgary)"
        },
        "eu-central-1": {
          description: "Europe (Frankfurt)"
        },
        "eu-central-2": {
          description: "Europe (Zurich)"
        },
        "eu-north-1": {
          description: "Europe (Stockholm)"
        },
        "eu-south-1": {
          description: "Europe (Milan)"
        },
        "eu-south-2": {
          description: "Europe (Spain)"
        },
        "eu-west-1": {
          description: "Europe (Ireland)"
        },
        "eu-west-2": {
          description: "Europe (London)"
        },
        "eu-west-3": {
          description: "Europe (Paris)"
        },
        "il-central-1": {
          description: "Israel (Tel Aviv)"
        },
        "me-central-1": {
          description: "Middle East (UAE)"
        },
        "me-south-1": {
          description: "Middle East (Bahrain)"
        },
        "mx-central-1": {
          description: "Mexico (Central)"
        },
        "sa-east-1": {
          description: "South America (Sao Paulo)"
        },
        "us-east-1": {
          description: "US East (N. Virginia)"
        },
        "us-east-2": {
          description: "US East (Ohio)"
        },
        "us-west-1": {
          description: "US West (N. California)"
        },
        "us-west-2": {
          description: "US West (Oregon)"
        }
      }
    },
    {
      id: "aws-cn",
      outputs: {
        dnsSuffix: "amazonaws.com.cn",
        dualStackDnsSuffix: "api.amazonwebservices.com.cn",
        implicitGlobalRegion: "cn-northwest-1",
        name: "aws-cn",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^cn\\-\\w+\\-\\d+$",
      regions: {
        "aws-cn-global": {
          description: "aws-cn global region"
        },
        "cn-north-1": {
          description: "China (Beijing)"
        },
        "cn-northwest-1": {
          description: "China (Ningxia)"
        }
      }
    },
    {
      id: "aws-eusc",
      outputs: {
        dnsSuffix: "amazonaws.eu",
        dualStackDnsSuffix: "api.amazonwebservices.eu",
        implicitGlobalRegion: "eusc-de-east-1",
        name: "aws-eusc",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$",
      regions: {
        "eusc-de-east-1": {
          description: "EU (Germany)"
        }
      }
    },
    {
      id: "aws-iso",
      outputs: {
        dnsSuffix: "c2s.ic.gov",
        dualStackDnsSuffix: "api.aws.ic.gov",
        implicitGlobalRegion: "us-iso-east-1",
        name: "aws-iso",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
      regions: {
        "aws-iso-global": {
          description: "aws-iso global region"
        },
        "us-iso-east-1": {
          description: "US ISO East"
        },
        "us-iso-west-1": {
          description: "US ISO WEST"
        }
      }
    },
    {
      id: "aws-iso-b",
      outputs: {
        dnsSuffix: "sc2s.sgov.gov",
        dualStackDnsSuffix: "api.aws.scloud",
        implicitGlobalRegion: "us-isob-east-1",
        name: "aws-iso-b",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
      regions: {
        "aws-iso-b-global": {
          description: "aws-iso-b global region"
        },
        "us-isob-east-1": {
          description: "US ISOB East (Ohio)"
        }
      }
    },
    {
      id: "aws-iso-e",
      outputs: {
        dnsSuffix: "cloud.adc-e.uk",
        dualStackDnsSuffix: "api.cloud-aws.adc-e.uk",
        implicitGlobalRegion: "eu-isoe-west-1",
        name: "aws-iso-e",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
      regions: {
        "aws-iso-e-global": {
          description: "aws-iso-e global region"
        },
        "eu-isoe-west-1": {
          description: "EU ISOE West"
        }
      }
    },
    {
      id: "aws-iso-f",
      outputs: {
        dnsSuffix: "csp.hci.ic.gov",
        dualStackDnsSuffix: "api.aws.hci.ic.gov",
        implicitGlobalRegion: "us-isof-south-1",
        name: "aws-iso-f",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
      regions: {
        "aws-iso-f-global": {
          description: "aws-iso-f global region"
        },
        "us-isof-east-1": {
          description: "US ISOF EAST"
        },
        "us-isof-south-1": {
          description: "US ISOF SOUTH"
        }
      }
    },
    {
      id: "aws-us-gov",
      outputs: {
        dnsSuffix: "amazonaws.com",
        dualStackDnsSuffix: "api.aws",
        implicitGlobalRegion: "us-gov-west-1",
        name: "aws-us-gov",
        supportsDualStack: true,
        supportsFIPS: true
      },
      regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
      regions: {
        "aws-us-gov-global": {
          description: "aws-us-gov global region"
        },
        "us-gov-east-1": {
          description: "AWS GovCloud (US-East)"
        },
        "us-gov-west-1": {
          description: "AWS GovCloud (US-West)"
        }
      }
    }
  ];
  var version = "1.1";
  var partitionsInfo = {
    partitions,
    version
  };
  var selectedPartitionsInfo = partitionsInfo;
  var selectedUserAgentPrefix = "";
  var partition = (value) => {
    const { partitions: partitions2 } = selectedPartitionsInfo;
    for (const partition2 of partitions2) {
      const { regions, outputs } = partition2;
      for (const [region, regionData] of Object.entries(regions)) {
        if (region === value) {
          return {
            ...outputs,
            ...regionData
          };
        }
      }
    }
    for (const partition2 of partitions2) {
      const { regionRegex, outputs } = partition2;
      if (new RegExp(regionRegex).test(value)) {
        return {
          ...outputs
        };
      }
    }
    const DEFAULT_PARTITION = partitions2.find((partition2) => partition2.id === "aws");
    if (!DEFAULT_PARTITION) {
      throw new Error("Provided region was not found in the partition array or regex," + " and default partition with id 'aws' doesn't exist.");
    }
    return {
      ...DEFAULT_PARTITION.outputs
    };
  };
  var setPartitionInfo = (partitionsInfo2, userAgentPrefix = "") => {
    selectedPartitionsInfo = partitionsInfo2;
    selectedUserAgentPrefix = userAgentPrefix;
  };
  var useDefaultPartitionInfo = () => {
    setPartitionInfo(partitionsInfo, "");
  };
  var getUserAgentPrefix = () => selectedUserAgentPrefix;
  var awsEndpointFunctions = {
    isVirtualHostableS3Bucket,
    parseArn,
    partition
  };
  utilEndpoints.customEndpointFunctions.aws = awsEndpointFunctions;
  var resolveDefaultAwsRegionalEndpointsConfig = (input) => {
    if (typeof input.endpointProvider !== "function") {
      throw new Error("@aws-sdk/util-endpoint - endpointProvider and endpoint missing in config for this client.");
    }
    const { endpoint } = input;
    if (endpoint === undefined) {
      input.endpoint = async () => {
        return toEndpointV1(input.endpointProvider({
          Region: typeof input.region === "function" ? await input.region() : input.region,
          UseDualStack: typeof input.useDualstackEndpoint === "function" ? await input.useDualstackEndpoint() : input.useDualstackEndpoint,
          UseFIPS: typeof input.useFipsEndpoint === "function" ? await input.useFipsEndpoint() : input.useFipsEndpoint,
          Endpoint: undefined
        }, { logger: input.logger }));
      };
    }
    return input;
  };
  var toEndpointV1 = (endpoint) => urlParser.parseUrl(endpoint.url);
  Object.defineProperty(exports, "EndpointError", {
    enumerable: true,
    get: function() {
      return utilEndpoints.EndpointError;
    }
  });
  Object.defineProperty(exports, "isIpAddress", {
    enumerable: true,
    get: function() {
      return utilEndpoints.isIpAddress;
    }
  });
  Object.defineProperty(exports, "resolveEndpoint", {
    enumerable: true,
    get: function() {
      return utilEndpoints.resolveEndpoint;
    }
  });
  exports.awsEndpointFunctions = awsEndpointFunctions;
  exports.getUserAgentPrefix = getUserAgentPrefix;
  exports.partition = partition;
  exports.resolveDefaultAwsRegionalEndpointsConfig = resolveDefaultAwsRegionalEndpointsConfig;
  exports.setPartitionInfo = setPartitionInfo;
  exports.toEndpointV1 = toEndpointV1;
  exports.useDefaultPartitionInfo = useDefaultPartitionInfo;
});

// node_modules/@smithy/property-provider/dist-cjs/index.js
var require_dist_cjs24 = __commonJS((exports) => {
  class ProviderError extends Error {
    name = "ProviderError";
    tryNextLink;
    constructor(message, options = true) {
      let logger;
      let tryNextLink = true;
      if (typeof options === "boolean") {
        logger = undefined;
        tryNextLink = options;
      } else if (options != null && typeof options === "object") {
        logger = options.logger;
        tryNextLink = options.tryNextLink ?? true;
      }
      super(message);
      this.tryNextLink = tryNextLink;
      Object.setPrototypeOf(this, ProviderError.prototype);
      logger?.debug?.(`@smithy/property-provider ${tryNextLink ? "->" : "(!)"} ${message}`);
    }
    static from(error, options = true) {
      return Object.assign(new this(error.message, options), error);
    }
  }

  class CredentialsProviderError extends ProviderError {
    name = "CredentialsProviderError";
    constructor(message, options = true) {
      super(message, options);
      Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
  }

  class TokenProviderError extends ProviderError {
    name = "TokenProviderError";
    constructor(message, options = true) {
      super(message, options);
      Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
  }
  var chain = (...providers) => async () => {
    if (providers.length === 0) {
      throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
      try {
        const credentials = await provider();
        return credentials;
      } catch (err3) {
        lastProviderError = err3;
        if (err3?.tryNextLink) {
          continue;
        }
        throw err3;
      }
    }
    throw lastProviderError;
  };
  var fromStatic = (staticValue) => () => Promise.resolve(staticValue);
  var memoize = (provider, isExpired, requiresRefresh) => {
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async () => {
      if (!pending) {
        pending = provider();
      }
      try {
        resolved = await pending;
        hasResult = true;
        isConstant = false;
      } finally {
        pending = undefined;
      }
      return resolved;
    };
    if (isExpired === undefined) {
      return async (options) => {
        if (!hasResult || options?.forceRefresh) {
          resolved = await coalesceProvider();
        }
        return resolved;
      };
    }
    return async (options) => {
      if (!hasResult || options?.forceRefresh) {
        resolved = await coalesceProvider();
      }
      if (isConstant) {
        return resolved;
      }
      if (requiresRefresh && !requiresRefresh(resolved)) {
        isConstant = true;
        return resolved;
      }
      if (isExpired(resolved)) {
        await coalesceProvider();
        return resolved;
      }
      return resolved;
    };
  };
  exports.CredentialsProviderError = CredentialsProviderError;
  exports.ProviderError = ProviderError;
  exports.TokenProviderError = TokenProviderError;
  exports.chain = chain;
  exports.fromStatic = fromStatic;
  exports.memoize = memoize;
});

// node_modules/@aws-sdk/core/dist-cjs/submodules/client/index.js
var require_client = __commonJS((exports) => {
  var state = {
    warningEmitted: false
  };
  var emitWarningIfUnsupportedVersion = (version) => {
    if (version && !state.warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 18) {
      state.warningEmitted = true;
      process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js 16.x on January 6, 2025.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/74kJMmI`);
    }
  };
  function setCredentialFeature(credentials, feature, value) {
    if (!credentials.$source) {
      credentials.$source = {};
    }
    credentials.$source[feature] = value;
    return credentials;
  }
  function setFeature(context, feature, value) {
    if (!context.__aws_sdk_context) {
      context.__aws_sdk_context = {
        features: {}
      };
    } else if (!context.__aws_sdk_context.features) {
      context.__aws_sdk_context.features = {};
    }
    context.__aws_sdk_context.features[feature] = value;
  }
  function setTokenFeature(token, feature, value) {
    if (!token.$source) {
      token.$source = {};
    }
    token.$source[feature] = value;
    return token;
  }
  exports.emitWarningIfUnsupportedVersion = emitWarningIfUnsupportedVersion;
  exports.setCredentialFeature = setCredentialFeature;
  exports.setFeature = setFeature;
  exports.setTokenFeature = setTokenFeature;
  exports.state = state;
});

// node_modules/@smithy/signature-v4/dist-cjs/index.js
var require_dist_cjs25 = __commonJS((exports) => {
  var utilHexEncoding = require_dist_cjs16();
  var utilUtf8 = require_dist_cjs10();
  var isArrayBuffer = require_dist_cjs8();
  var protocolHttp = require_dist_cjs3();
  var utilMiddleware2 = require_dist_cjs2();
  var utilUriEscape = require_dist_cjs12();
  var ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
  var CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
  var AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
  var SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
  var EXPIRES_QUERY_PARAM = "X-Amz-Expires";
  var SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
  var TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
  var REGION_SET_PARAM = "X-Amz-Region-Set";
  var AUTH_HEADER = "authorization";
  var AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
  var DATE_HEADER = "date";
  var GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
  var SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
  var SHA256_HEADER = "x-amz-content-sha256";
  var TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
  var HOST_HEADER = "host";
  var ALWAYS_UNSIGNABLE_HEADERS = {
    authorization: true,
    "cache-control": true,
    connection: true,
    expect: true,
    from: true,
    "keep-alive": true,
    "max-forwards": true,
    pragma: true,
    referer: true,
    te: true,
    trailer: true,
    "transfer-encoding": true,
    upgrade: true,
    "user-agent": true,
    "x-amzn-trace-id": true
  };
  var PROXY_HEADER_PATTERN = /^proxy-/;
  var SEC_HEADER_PATTERN = /^sec-/;
  var UNSIGNABLE_PATTERNS = [/^proxy-/i, /^sec-/i];
  var ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
  var ALGORITHM_IDENTIFIER_V4A = "AWS4-ECDSA-P256-SHA256";
  var EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
  var UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
  var MAX_CACHE_SIZE = 50;
  var KEY_TYPE_IDENTIFIER = "aws4_request";
  var MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;
  var signingKeyCache = {};
  var cacheQueue = [];
  var createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;
  var getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
    const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
    const cacheKey = `${shortDate}:${region}:${service}:${utilHexEncoding.toHex(credsHash)}:${credentials.sessionToken}`;
    if (cacheKey in signingKeyCache) {
      return signingKeyCache[cacheKey];
    }
    cacheQueue.push(cacheKey);
    while (cacheQueue.length > MAX_CACHE_SIZE) {
      delete signingKeyCache[cacheQueue.shift()];
    }
    let key = `AWS4${credentials.secretAccessKey}`;
    for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
      key = await hmac(sha256Constructor, key, signable);
    }
    return signingKeyCache[cacheKey] = key;
  };
  var clearCredentialCache = () => {
    cacheQueue.length = 0;
    Object.keys(signingKeyCache).forEach((cacheKey) => {
      delete signingKeyCache[cacheKey];
    });
  };
  var hmac = (ctor, secret, data) => {
    const hash2 = new ctor(secret);
    hash2.update(utilUtf8.toUint8Array(data));
    return hash2.digest();
  };
  var getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {
    const canonical = {};
    for (const headerName of Object.keys(headers).sort()) {
      if (headers[headerName] == undefined) {
        continue;
      }
      const canonicalHeaderName = headerName.toLowerCase();
      if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || unsignableHeaders?.has(canonicalHeaderName) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
        if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
          continue;
        }
      }
      canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
    }
    return canonical;
  };
  var getPayloadHash = async ({ headers, body }, hashConstructor) => {
    for (const headerName of Object.keys(headers)) {
      if (headerName.toLowerCase() === SHA256_HEADER) {
        return headers[headerName];
      }
    }
    if (body == undefined) {
      return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
    } else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer.isArrayBuffer(body)) {
      const hashCtor = new hashConstructor;
      hashCtor.update(utilUtf8.toUint8Array(body));
      return utilHexEncoding.toHex(await hashCtor.digest());
    }
    return UNSIGNED_PAYLOAD;
  };

  class HeaderFormatter {
    format(headers) {
      const chunks = [];
      for (const headerName of Object.keys(headers)) {
        const bytes = utilUtf8.fromUtf8(headerName);
        chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
      }
      const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
      let position = 0;
      for (const chunk of chunks) {
        out.set(chunk, position);
        position += chunk.byteLength;
      }
      return out;
    }
    formatHeaderValue(header) {
      switch (header.type) {
        case "boolean":
          return Uint8Array.from([header.value ? 0 : 1]);
        case "byte":
          return Uint8Array.from([2, header.value]);
        case "short":
          const shortView = new DataView(new ArrayBuffer(3));
          shortView.setUint8(0, 3);
          shortView.setInt16(1, header.value, false);
          return new Uint8Array(shortView.buffer);
        case "integer":
          const intView = new DataView(new ArrayBuffer(5));
          intView.setUint8(0, 4);
          intView.setInt32(1, header.value, false);
          return new Uint8Array(intView.buffer);
        case "long":
          const longBytes = new Uint8Array(9);
          longBytes[0] = 5;
          longBytes.set(header.value.bytes, 1);
          return longBytes;
        case "binary":
          const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
          binView.setUint8(0, 6);
          binView.setUint16(1, header.value.byteLength, false);
          const binBytes = new Uint8Array(binView.buffer);
          binBytes.set(header.value, 3);
          return binBytes;
        case "string":
          const utf8Bytes = utilUtf8.fromUtf8(header.value);
          const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
          strView.setUint8(0, 7);
          strView.setUint16(1, utf8Bytes.byteLength, false);
          const strBytes = new Uint8Array(strView.buffer);
          strBytes.set(utf8Bytes, 3);
          return strBytes;
        case "timestamp":
          const tsBytes = new Uint8Array(9);
          tsBytes[0] = 8;
          tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
          return tsBytes;
        case "uuid":
          if (!UUID_PATTERN.test(header.value)) {
            throw new Error(`Invalid UUID received: ${header.value}`);
          }
          const uuidBytes = new Uint8Array(17);
          uuidBytes[0] = 9;
          uuidBytes.set(utilHexEncoding.fromHex(header.value.replace(/\-/g, "")), 1);
          return uuidBytes;
      }
    }
  }
  var UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;

  class Int64 {
    bytes;
    constructor(bytes) {
      this.bytes = bytes;
      if (bytes.byteLength !== 8) {
        throw new Error("Int64 buffers must be exactly 8 bytes");
      }
    }
    static fromNumber(number) {
      if (number > 9223372036854776000 || number < -9223372036854776000) {
        throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
      }
      const bytes = new Uint8Array(8);
      for (let i2 = 7, remaining = Math.abs(Math.round(number));i2 > -1 && remaining > 0; i2--, remaining /= 256) {
        bytes[i2] = remaining;
      }
      if (number < 0) {
        negate(bytes);
      }
      return new Int64(bytes);
    }
    valueOf() {
      const bytes = this.bytes.slice(0);
      const negative = bytes[0] & 128;
      if (negative) {
        negate(bytes);
      }
      return parseInt(utilHexEncoding.toHex(bytes), 16) * (negative ? -1 : 1);
    }
    toString() {
      return String(this.valueOf());
    }
  }
  function negate(bytes) {
    for (let i2 = 0;i2 < 8; i2++) {
      bytes[i2] ^= 255;
    }
    for (let i2 = 7;i2 > -1; i2--) {
      bytes[i2]++;
      if (bytes[i2] !== 0)
        break;
    }
  }
  var hasHeader = (soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
      if (soughtHeader === headerName.toLowerCase()) {
        return true;
      }
    }
    return false;
  };
  var moveHeadersToQuery = (request, options = {}) => {
    const { headers, query = {} } = protocolHttp.HttpRequest.clone(request);
    for (const name of Object.keys(headers)) {
      const lname = name.toLowerCase();
      if (lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname) || options.hoistableHeaders?.has(lname)) {
        query[name] = headers[name];
        delete headers[name];
      }
    }
    return {
      ...request,
      headers,
      query
    };
  };
  var prepareRequest = (request) => {
    request = protocolHttp.HttpRequest.clone(request);
    for (const headerName of Object.keys(request.headers)) {
      if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
        delete request.headers[headerName];
      }
    }
    return request;
  };
  var getCanonicalQuery = ({ query = {} }) => {
    const keys = [];
    const serialized = {};
    for (const key of Object.keys(query)) {
      if (key.toLowerCase() === SIGNATURE_HEADER) {
        continue;
      }
      const encodedKey = utilUriEscape.escapeUri(key);
      keys.push(encodedKey);
      const value = query[key];
      if (typeof value === "string") {
        serialized[encodedKey] = `${encodedKey}=${utilUriEscape.escapeUri(value)}`;
      } else if (Array.isArray(value)) {
        serialized[encodedKey] = value.slice(0).reduce((encoded, value2) => encoded.concat([`${encodedKey}=${utilUriEscape.escapeUri(value2)}`]), []).sort().join("&");
      }
    }
    return keys.sort().map((key) => serialized[key]).filter((serialized2) => serialized2).join("&");
  };
  var iso8601 = (time) => toDate(time).toISOString().replace(/\.\d{3}Z$/, "Z");
  var toDate = (time) => {
    if (typeof time === "number") {
      return new Date(time * 1000);
    }
    if (typeof time === "string") {
      if (Number(time)) {
        return new Date(Number(time) * 1000);
      }
      return new Date(time);
    }
    return time;
  };

  class SignatureV4Base {
    service;
    regionProvider;
    credentialProvider;
    sha256;
    uriEscapePath;
    applyChecksum;
    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true }) {
      this.service = service;
      this.sha256 = sha256;
      this.uriEscapePath = uriEscapePath;
      this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
      this.regionProvider = utilMiddleware2.normalizeProvider(region);
      this.credentialProvider = utilMiddleware2.normalizeProvider(credentials);
    }
    createCanonicalRequest(request, canonicalHeaders, payloadHash) {
      const sortedHeaders = Object.keys(canonicalHeaders).sort();
      return `${request.method}
${this.getCanonicalPath(request)}
${getCanonicalQuery(request)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join(`
`)}

${sortedHeaders.join(";")}
${payloadHash}`;
    }
    async createStringToSign(longDate, credentialScope, canonicalRequest, algorithmIdentifier) {
      const hash2 = new this.sha256;
      hash2.update(utilUtf8.toUint8Array(canonicalRequest));
      const hashedRequest = await hash2.digest();
      return `${algorithmIdentifier}
${longDate}
${credentialScope}
${utilHexEncoding.toHex(hashedRequest)}`;
    }
    getCanonicalPath({ path }) {
      if (this.uriEscapePath) {
        const normalizedPathSegments = [];
        for (const pathSegment of path.split("/")) {
          if (pathSegment?.length === 0)
            continue;
          if (pathSegment === ".")
            continue;
          if (pathSegment === "..") {
            normalizedPathSegments.pop();
          } else {
            normalizedPathSegments.push(pathSegment);
          }
        }
        const normalizedPath = `${path?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path?.endsWith("/") ? "/" : ""}`;
        const doubleEncoded = utilUriEscape.escapeUri(normalizedPath);
        return doubleEncoded.replace(/%2F/g, "/");
      }
      return path;
    }
    validateResolvedCredentials(credentials) {
      if (typeof credentials !== "object" || typeof credentials.accessKeyId !== "string" || typeof credentials.secretAccessKey !== "string") {
        throw new Error("Resolved credential object is not valid");
      }
    }
    formatDate(now) {
      const longDate = iso8601(now).replace(/[\-:]/g, "");
      return {
        longDate,
        shortDate: longDate.slice(0, 8)
      };
    }
    getCanonicalHeaderList(headers) {
      return Object.keys(headers).sort().join(";");
    }
  }

  class SignatureV4 extends SignatureV4Base {
    headerFormatter = new HeaderFormatter;
    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true }) {
      super({
        applyChecksum,
        credentials,
        region,
        service,
        sha256,
        uriEscapePath
      });
    }
    async presign(originalRequest, options = {}) {
      const { signingDate = new Date, expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, hoistableHeaders, signingRegion, signingService } = options;
      const credentials = await this.credentialProvider();
      this.validateResolvedCredentials(credentials);
      const region = signingRegion ?? await this.regionProvider();
      const { longDate, shortDate } = this.formatDate(signingDate);
      if (expiresIn > MAX_PRESIGNED_TTL) {
        return Promise.reject("Signature version 4 presigned URLs" + " must have an expiration date less than one week in" + " the future");
      }
      const scope = createScope(shortDate, region, signingService ?? this.service);
      const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders, hoistableHeaders });
      if (credentials.sessionToken) {
        request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
      }
      request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
      request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
      request.query[AMZ_DATE_QUERY_PARAM] = longDate;
      request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
      const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
      request.query[SIGNED_HEADERS_QUERY_PARAM] = this.getCanonicalHeaderList(canonicalHeaders);
      request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
      return request;
    }
    async sign(toSign, options) {
      if (typeof toSign === "string") {
        return this.signString(toSign, options);
      } else if (toSign.headers && toSign.payload) {
        return this.signEvent(toSign, options);
      } else if (toSign.message) {
        return this.signMessage(toSign, options);
      } else {
        return this.signRequest(toSign, options);
      }
    }
    async signEvent({ headers, payload }, { signingDate = new Date, priorSignature, signingRegion, signingService }) {
      const region = signingRegion ?? await this.regionProvider();
      const { shortDate, longDate } = this.formatDate(signingDate);
      const scope = createScope(shortDate, region, signingService ?? this.service);
      const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);
      const hash2 = new this.sha256;
      hash2.update(headers);
      const hashedHeaders = utilHexEncoding.toHex(await hash2.digest());
      const stringToSign = [
        EVENT_ALGORITHM_IDENTIFIER,
        longDate,
        scope,
        priorSignature,
        hashedHeaders,
        hashedPayload
      ].join(`
`);
      return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
    }
    async signMessage(signableMessage, { signingDate = new Date, signingRegion, signingService }) {
      const promise = this.signEvent({
        headers: this.headerFormatter.format(signableMessage.message.headers),
        payload: signableMessage.message.body
      }, {
        signingDate,
        signingRegion,
        signingService,
        priorSignature: signableMessage.priorSignature
      });
      return promise.then((signature) => {
        return { message: signableMessage.message, signature };
      });
    }
    async signString(stringToSign, { signingDate = new Date, signingRegion, signingService } = {}) {
      const credentials = await this.credentialProvider();
      this.validateResolvedCredentials(credentials);
      const region = signingRegion ?? await this.regionProvider();
      const { shortDate } = this.formatDate(signingDate);
      const hash2 = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
      hash2.update(utilUtf8.toUint8Array(stringToSign));
      return utilHexEncoding.toHex(await hash2.digest());
    }
    async signRequest(requestToSign, { signingDate = new Date, signableHeaders, unsignableHeaders, signingRegion, signingService } = {}) {
      const credentials = await this.credentialProvider();
      this.validateResolvedCredentials(credentials);
      const region = signingRegion ?? await this.regionProvider();
      const request = prepareRequest(requestToSign);
      const { longDate, shortDate } = this.formatDate(signingDate);
      const scope = createScope(shortDate, region, signingService ?? this.service);
      request.headers[AMZ_DATE_HEADER] = longDate;
      if (credentials.sessionToken) {
        request.headers[TOKEN_HEADER] = credentials.sessionToken;
      }
      const payloadHash = await getPayloadHash(request, this.sha256);
      if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {
        request.headers[SHA256_HEADER] = payloadHash;
      }
      const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
      const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
      request.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} ` + `Credential=${credentials.accessKeyId}/${scope}, ` + `SignedHeaders=${this.getCanonicalHeaderList(canonicalHeaders)}, ` + `Signature=${signature}`;
      return request;
    }
    async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
      const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest, ALGORITHM_IDENTIFIER);
      const hash2 = new this.sha256(await keyPromise);
      hash2.update(utilUtf8.toUint8Array(stringToSign));
      return utilHexEncoding.toHex(await hash2.digest());
    }
    getSigningKey(credentials, region, shortDate, service) {
      return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
    }
  }
  var signatureV4aContainer = {
    SignatureV4a: null
  };
  exports.ALGORITHM_IDENTIFIER = ALGORITHM_IDENTIFIER;
  exports.ALGORITHM_IDENTIFIER_V4A = ALGORITHM_IDENTIFIER_V4A;
  exports.ALGORITHM_QUERY_PARAM = ALGORITHM_QUERY_PARAM;
  exports.ALWAYS_UNSIGNABLE_HEADERS = ALWAYS_UNSIGNABLE_HEADERS;
  exports.AMZ_DATE_HEADER = AMZ_DATE_HEADER;
  exports.AMZ_DATE_QUERY_PARAM = AMZ_DATE_QUERY_PARAM;
  exports.AUTH_HEADER = AUTH_HEADER;
  exports.CREDENTIAL_QUERY_PARAM = CREDENTIAL_QUERY_PARAM;
  exports.DATE_HEADER = DATE_HEADER;
  exports.EVENT_ALGORITHM_IDENTIFIER = EVENT_ALGORITHM_IDENTIFIER;
  exports.EXPIRES_QUERY_PARAM = EXPIRES_QUERY_PARAM;
  exports.GENERATED_HEADERS = GENERATED_HEADERS;
  exports.HOST_HEADER = HOST_HEADER;
  exports.KEY_TYPE_IDENTIFIER = KEY_TYPE_IDENTIFIER;
  exports.MAX_CACHE_SIZE = MAX_CACHE_SIZE;
  exports.MAX_PRESIGNED_TTL = MAX_PRESIGNED_TTL;
  exports.PROXY_HEADER_PATTERN = PROXY_HEADER_PATTERN;
  exports.REGION_SET_PARAM = REGION_SET_PARAM;
  exports.SEC_HEADER_PATTERN = SEC_HEADER_PATTERN;
  exports.SHA256_HEADER = SHA256_HEADER;
  exports.SIGNATURE_HEADER = SIGNATURE_HEADER;
  exports.SIGNATURE_QUERY_PARAM = SIGNATURE_QUERY_PARAM;
  exports.SIGNED_HEADERS_QUERY_PARAM = SIGNED_HEADERS_QUERY_PARAM;
  exports.SignatureV4 = SignatureV4;
  exports.SignatureV4Base = SignatureV4Base;
  exports.TOKEN_HEADER = TOKEN_HEADER;
  exports.TOKEN_QUERY_PARAM = TOKEN_QUERY_PARAM;
  exports.UNSIGNABLE_PATTERNS = UNSIGNABLE_PATTERNS;
  exports.UNSIGNED_PAYLOAD = UNSIGNED_PAYLOAD;
  exports.clearCredentialCache = clearCredentialCache;
  exports.createScope = createScope;
  exports.getCanonicalHeaders = getCanonicalHeaders;
  exports.getCanonicalQuery = getCanonicalQuery;
  exports.getPayloadHash = getPayloadHash;
  exports.getSigningKey = getSigningKey;
  exports.hasHeader = hasHeader;
  exports.moveHeadersToQuery = moveHeadersToQuery;
  exports.prepareRequest = prepareRequest;
  exports.signatureV4aContainer = signatureV4aContainer;
});

// node_modules/@smithy/util-body-length-browser/dist-cjs/index.js
var require_dist_cjs26 = __commonJS((exports) => {
  var TEXT_ENCODER = typeof TextEncoder == "function" ? new TextEncoder : null;
  var calculateBodyLength = (body) => {
    if (typeof body === "string") {
      if (TEXT_ENCODER) {
        return TEXT_ENCODER.encode(body).byteLength;
      }
      let len = body.length;
      for (let i2 = len - 1;i2 >= 0; i2--) {
        const code = body.charCodeAt(i2);
        if (code > 127 && code <= 2047)
          len++;
        else if (code > 2047 && code <= 65535)
          len += 2;
        if (code >= 56320 && code <= 57343)
          i2--;
      }
      return len;
    } else if (typeof body.byteLength === "number") {
      return body.byteLength;
    } else if (typeof body.size === "number") {
      return body.size;
    }
    throw new Error(`Body Length computation failed for ${body}`);
  };
  exports.calculateBodyLength = calculateBodyLength;
});

// node_modules/@smithy/core/dist-cjs/submodules/cbor/index.js
var require_cbor = __commonJS((exports) => {
  var serde = require_serde();
  var utilUtf8 = require_dist_cjs10();
  var protocols = require_protocols();
  var protocolHttp = require_dist_cjs3();
  var utilBodyLengthBrowser = require_dist_cjs26();
  var schema = require_schema();
  var utilMiddleware2 = require_dist_cjs2();
  var utilBase64 = require_dist_cjs11();
  var majorUint64 = 0;
  var majorNegativeInt64 = 1;
  var majorUnstructuredByteString = 2;
  var majorUtf8String = 3;
  var majorList = 4;
  var majorMap = 5;
  var majorTag = 6;
  var majorSpecial = 7;
  var specialFalse = 20;
  var specialTrue = 21;
  var specialNull = 22;
  var specialUndefined = 23;
  var extendedOneByte = 24;
  var extendedFloat16 = 25;
  var extendedFloat32 = 26;
  var extendedFloat64 = 27;
  var minorIndefinite = 31;
  function alloc(size) {
    return typeof Buffer !== "undefined" ? Buffer.alloc(size) : new Uint8Array(size);
  }
  var tagSymbol = Symbol("@smithy/core/cbor::tagSymbol");
  function tag(data2) {
    data2[tagSymbol] = true;
    return data2;
  }
  var USE_TEXT_DECODER = typeof TextDecoder !== "undefined";
  var USE_BUFFER$1 = typeof Buffer !== "undefined";
  var payload = alloc(0);
  var dataView$1 = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
  var textDecoder = USE_TEXT_DECODER ? new TextDecoder : null;
  var _offset = 0;
  function setPayload(bytes) {
    payload = bytes;
    dataView$1 = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
  }
  function decode2(at, to) {
    if (at >= to) {
      throw new Error("unexpected end of (decode) payload.");
    }
    const major = (payload[at] & 224) >> 5;
    const minor = payload[at] & 31;
    switch (major) {
      case majorUint64:
      case majorNegativeInt64:
      case majorTag:
        let unsignedInt;
        let offset;
        if (minor < 24) {
          unsignedInt = minor;
          offset = 1;
        } else {
          switch (minor) {
            case extendedOneByte:
            case extendedFloat16:
            case extendedFloat32:
            case extendedFloat64:
              const countLength = minorValueToArgumentLength[minor];
              const countOffset = countLength + 1;
              offset = countOffset;
              if (to - at < countOffset) {
                throw new Error(`countLength ${countLength} greater than remaining buf len.`);
              }
              const countIndex = at + 1;
              if (countLength === 1) {
                unsignedInt = payload[countIndex];
              } else if (countLength === 2) {
                unsignedInt = dataView$1.getUint16(countIndex);
              } else if (countLength === 4) {
                unsignedInt = dataView$1.getUint32(countIndex);
              } else {
                unsignedInt = dataView$1.getBigUint64(countIndex);
              }
              break;
            default:
              throw new Error(`unexpected minor value ${minor}.`);
          }
        }
        if (major === majorUint64) {
          _offset = offset;
          return castBigInt(unsignedInt);
        } else if (major === majorNegativeInt64) {
          let negativeInt;
          if (typeof unsignedInt === "bigint") {
            negativeInt = BigInt(-1) - unsignedInt;
          } else {
            negativeInt = -1 - unsignedInt;
          }
          _offset = offset;
          return castBigInt(negativeInt);
        } else {
          if (minor === 2 || minor === 3) {
            const length = decodeCount(at + offset, to);
            let b = BigInt(0);
            const start = at + offset + _offset;
            for (let i2 = start;i2 < start + length; ++i2) {
              b = b << BigInt(8) | BigInt(payload[i2]);
            }
            _offset = offset + _offset + length;
            return minor === 3 ? -b - BigInt(1) : b;
          } else if (minor === 4) {
            const decimalFraction = decode2(at + offset, to);
            const [exponent, mantissa] = decimalFraction;
            const normalizer = mantissa < 0 ? -1 : 1;
            const mantissaStr = "0".repeat(Math.abs(exponent) + 1) + String(BigInt(normalizer) * BigInt(mantissa));
            let numericString;
            const sign = mantissa < 0 ? "-" : "";
            numericString = exponent === 0 ? mantissaStr : mantissaStr.slice(0, mantissaStr.length + exponent) + "." + mantissaStr.slice(exponent);
            numericString = numericString.replace(/^0+/g, "");
            if (numericString === "") {
              numericString = "0";
            }
            if (numericString[0] === ".") {
              numericString = "0" + numericString;
            }
            numericString = sign + numericString;
            _offset = offset + _offset;
            return serde.nv(numericString);
          } else {
            const value = decode2(at + offset, to);
            const valueOffset = _offset;
            _offset = offset + valueOffset;
            return tag({ tag: castBigInt(unsignedInt), value });
          }
        }
      case majorUtf8String:
      case majorMap:
      case majorList:
      case majorUnstructuredByteString:
        if (minor === minorIndefinite) {
          switch (major) {
            case majorUtf8String:
              return decodeUtf8StringIndefinite(at, to);
            case majorMap:
              return decodeMapIndefinite(at, to);
            case majorList:
              return decodeListIndefinite(at, to);
            case majorUnstructuredByteString:
              return decodeUnstructuredByteStringIndefinite(at, to);
          }
        } else {
          switch (major) {
            case majorUtf8String:
              return decodeUtf8String(at, to);
            case majorMap:
              return decodeMap(at, to);
            case majorList:
              return decodeList(at, to);
            case majorUnstructuredByteString:
              return decodeUnstructuredByteString(at, to);
          }
        }
      default:
        return decodeSpecial(at, to);
    }
  }
  function bytesToUtf8(bytes, at, to) {
    if (USE_BUFFER$1 && bytes.constructor?.name === "Buffer") {
      return bytes.toString("utf-8", at, to);
    }
    if (textDecoder) {
      return textDecoder.decode(bytes.subarray(at, to));
    }
    return utilUtf8.toUtf8(bytes.subarray(at, to));
  }
  function demote(bigInteger) {
    const num = Number(bigInteger);
    if (num < Number.MIN_SAFE_INTEGER || Number.MAX_SAFE_INTEGER < num) {
      console.warn(new Error(`@smithy/core/cbor - truncating BigInt(${bigInteger}) to ${num} with loss of precision.`));
    }
    return num;
  }
  var minorValueToArgumentLength = {
    [extendedOneByte]: 1,
    [extendedFloat16]: 2,
    [extendedFloat32]: 4,
    [extendedFloat64]: 8
  };
  function bytesToFloat16(a, b) {
    const sign = a >> 7;
    const exponent = (a & 124) >> 2;
    const fraction = (a & 3) << 8 | b;
    const scalar = sign === 0 ? 1 : -1;
    let exponentComponent;
    let summation;
    if (exponent === 0) {
      if (fraction === 0) {
        return 0;
      } else {
        exponentComponent = Math.pow(2, 1 - 15);
        summation = 0;
      }
    } else if (exponent === 31) {
      if (fraction === 0) {
        return scalar * Infinity;
      } else {
        return NaN;
      }
    } else {
      exponentComponent = Math.pow(2, exponent - 15);
      summation = 1;
    }
    summation += fraction / 1024;
    return scalar * (exponentComponent * summation);
  }
  function decodeCount(at, to) {
    const minor = payload[at] & 31;
    if (minor < 24) {
      _offset = 1;
      return minor;
    }
    if (minor === extendedOneByte || minor === extendedFloat16 || minor === extendedFloat32 || minor === extendedFloat64) {
      const countLength = minorValueToArgumentLength[minor];
      _offset = countLength + 1;
      if (to - at < _offset) {
        throw new Error(`countLength ${countLength} greater than remaining buf len.`);
      }
      const countIndex = at + 1;
      if (countLength === 1) {
        return payload[countIndex];
      } else if (countLength === 2) {
        return dataView$1.getUint16(countIndex);
      } else if (countLength === 4) {
        return dataView$1.getUint32(countIndex);
      }
      return demote(dataView$1.getBigUint64(countIndex));
    }
    throw new Error(`unexpected minor value ${minor}.`);
  }
  function decodeUtf8String(at, to) {
    const length = decodeCount(at, to);
    const offset = _offset;
    at += offset;
    if (to - at < length) {
      throw new Error(`string len ${length} greater than remaining buf len.`);
    }
    const value = bytesToUtf8(payload, at, at + length);
    _offset = offset + length;
    return value;
  }
  function decodeUtf8StringIndefinite(at, to) {
    at += 1;
    const vector = [];
    for (const base = at;at < to; ) {
      if (payload[at] === 255) {
        const data2 = alloc(vector.length);
        data2.set(vector, 0);
        _offset = at - base + 2;
        return bytesToUtf8(data2, 0, data2.length);
      }
      const major = (payload[at] & 224) >> 5;
      const minor = payload[at] & 31;
      if (major !== majorUtf8String) {
        throw new Error(`unexpected major type ${major} in indefinite string.`);
      }
      if (minor === minorIndefinite) {
        throw new Error("nested indefinite string.");
      }
      const bytes = decodeUnstructuredByteString(at, to);
      const length = _offset;
      at += length;
      for (let i2 = 0;i2 < bytes.length; ++i2) {
        vector.push(bytes[i2]);
      }
    }
    throw new Error("expected break marker.");
  }
  function decodeUnstructuredByteString(at, to) {
    const length = decodeCount(at, to);
    const offset = _offset;
    at += offset;
    if (to - at < length) {
      throw new Error(`unstructured byte string len ${length} greater than remaining buf len.`);
    }
    const value = payload.subarray(at, at + length);
    _offset = offset + length;
    return value;
  }
  function decodeUnstructuredByteStringIndefinite(at, to) {
    at += 1;
    const vector = [];
    for (const base = at;at < to; ) {
      if (payload[at] === 255) {
        const data2 = alloc(vector.length);
        data2.set(vector, 0);
        _offset = at - base + 2;
        return data2;
      }
      const major = (payload[at] & 224) >> 5;
      const minor = payload[at] & 31;
      if (major !== majorUnstructuredByteString) {
        throw new Error(`unexpected major type ${major} in indefinite string.`);
      }
      if (minor === minorIndefinite) {
        throw new Error("nested indefinite string.");
      }
      const bytes = decodeUnstructuredByteString(at, to);
      const length = _offset;
      at += length;
      for (let i2 = 0;i2 < bytes.length; ++i2) {
        vector.push(bytes[i2]);
      }
    }
    throw new Error("expected break marker.");
  }
  function decodeList(at, to) {
    const listDataLength = decodeCount(at, to);
    const offset = _offset;
    at += offset;
    const base = at;
    const list = Array(listDataLength);
    for (let i2 = 0;i2 < listDataLength; ++i2) {
      const item = decode2(at, to);
      const itemOffset = _offset;
      list[i2] = item;
      at += itemOffset;
    }
    _offset = offset + (at - base);
    return list;
  }
  function decodeListIndefinite(at, to) {
    at += 1;
    const list = [];
    for (const base = at;at < to; ) {
      if (payload[at] === 255) {
        _offset = at - base + 2;
        return list;
      }
      const item = decode2(at, to);
      const n = _offset;
      at += n;
      list.push(item);
    }
    throw new Error("expected break marker.");
  }
  function decodeMap(at, to) {
    const mapDataLength = decodeCount(at, to);
    const offset = _offset;
    at += offset;
    const base = at;
    const map3 = {};
    for (let i2 = 0;i2 < mapDataLength; ++i2) {
      if (at >= to) {
        throw new Error("unexpected end of map payload.");
      }
      const major = (payload[at] & 224) >> 5;
      if (major !== majorUtf8String) {
        throw new Error(`unexpected major type ${major} for map key at index ${at}.`);
      }
      const key = decode2(at, to);
      at += _offset;
      const value = decode2(at, to);
      at += _offset;
      map3[key] = value;
    }
    _offset = offset + (at - base);
    return map3;
  }
  function decodeMapIndefinite(at, to) {
    at += 1;
    const base = at;
    const map3 = {};
    for (;at < to; ) {
      if (at >= to) {
        throw new Error("unexpected end of map payload.");
      }
      if (payload[at] === 255) {
        _offset = at - base + 2;
        return map3;
      }
      const major = (payload[at] & 224) >> 5;
      if (major !== majorUtf8String) {
        throw new Error(`unexpected major type ${major} for map key.`);
      }
      const key = decode2(at, to);
      at += _offset;
      const value = decode2(at, to);
      at += _offset;
      map3[key] = value;
    }
    throw new Error("expected break marker.");
  }
  function decodeSpecial(at, to) {
    const minor = payload[at] & 31;
    switch (minor) {
      case specialTrue:
      case specialFalse:
        _offset = 1;
        return minor === specialTrue;
      case specialNull:
        _offset = 1;
        return null;
      case specialUndefined:
        _offset = 1;
        return null;
      case extendedFloat16:
        if (to - at < 3) {
          throw new Error("incomplete float16 at end of buf.");
        }
        _offset = 3;
        return bytesToFloat16(payload[at + 1], payload[at + 2]);
      case extendedFloat32:
        if (to - at < 5) {
          throw new Error("incomplete float32 at end of buf.");
        }
        _offset = 5;
        return dataView$1.getFloat32(at + 1);
      case extendedFloat64:
        if (to - at < 9) {
          throw new Error("incomplete float64 at end of buf.");
        }
        _offset = 9;
        return dataView$1.getFloat64(at + 1);
      default:
        throw new Error(`unexpected minor value ${minor}.`);
    }
  }
  function castBigInt(bigInt) {
    if (typeof bigInt === "number") {
      return bigInt;
    }
    const num = Number(bigInt);
    if (Number.MIN_SAFE_INTEGER <= num && num <= Number.MAX_SAFE_INTEGER) {
      return num;
    }
    return bigInt;
  }
  var USE_BUFFER = typeof Buffer !== "undefined";
  var initialSize = 2048;
  var data = alloc(initialSize);
  var dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
  var cursor = 0;
  function ensureSpace(bytes) {
    const remaining = data.byteLength - cursor;
    if (remaining < bytes) {
      if (cursor < 16000000) {
        resize(Math.max(data.byteLength * 4, data.byteLength + bytes));
      } else {
        resize(data.byteLength + bytes + 16000000);
      }
    }
  }
  function toUint8Array() {
    const out = alloc(cursor);
    out.set(data.subarray(0, cursor), 0);
    cursor = 0;
    return out;
  }
  function resize(size) {
    const old = data;
    data = alloc(size);
    if (old) {
      if (old.copy) {
        old.copy(data, 0, 0, old.byteLength);
      } else {
        data.set(old, 0);
      }
    }
    dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
  }
  function encodeHeader(major, value) {
    if (value < 24) {
      data[cursor++] = major << 5 | value;
    } else if (value < 1 << 8) {
      data[cursor++] = major << 5 | 24;
      data[cursor++] = value;
    } else if (value < 1 << 16) {
      data[cursor++] = major << 5 | extendedFloat16;
      dataView.setUint16(cursor, value);
      cursor += 2;
    } else if (value < 2 ** 32) {
      data[cursor++] = major << 5 | extendedFloat32;
      dataView.setUint32(cursor, value);
      cursor += 4;
    } else {
      data[cursor++] = major << 5 | extendedFloat64;
      dataView.setBigUint64(cursor, typeof value === "bigint" ? value : BigInt(value));
      cursor += 8;
    }
  }
  function encode2(_input) {
    const encodeStack = [_input];
    while (encodeStack.length) {
      const input = encodeStack.pop();
      ensureSpace(typeof input === "string" ? input.length * 4 : 64);
      if (typeof input === "string") {
        if (USE_BUFFER) {
          encodeHeader(majorUtf8String, Buffer.byteLength(input));
          cursor += data.write(input, cursor);
        } else {
          const bytes = utilUtf8.fromUtf8(input);
          encodeHeader(majorUtf8String, bytes.byteLength);
          data.set(bytes, cursor);
          cursor += bytes.byteLength;
        }
        continue;
      } else if (typeof input === "number") {
        if (Number.isInteger(input)) {
          const nonNegative = input >= 0;
          const major = nonNegative ? majorUint64 : majorNegativeInt64;
          const value = nonNegative ? input : -input - 1;
          if (value < 24) {
            data[cursor++] = major << 5 | value;
          } else if (value < 256) {
            data[cursor++] = major << 5 | 24;
            data[cursor++] = value;
          } else if (value < 65536) {
            data[cursor++] = major << 5 | extendedFloat16;
            data[cursor++] = value >> 8;
            data[cursor++] = value;
          } else if (value < 4294967296) {
            data[cursor++] = major << 5 | extendedFloat32;
            dataView.setUint32(cursor, value);
            cursor += 4;
          } else {
            data[cursor++] = major << 5 | extendedFloat64;
            dataView.setBigUint64(cursor, BigInt(value));
            cursor += 8;
          }
          continue;
        }
        data[cursor++] = majorSpecial << 5 | extendedFloat64;
        dataView.setFloat64(cursor, input);
        cursor += 8;
        continue;
      } else if (typeof input === "bigint") {
        const nonNegative = input >= 0;
        const major = nonNegative ? majorUint64 : majorNegativeInt64;
        const value = nonNegative ? input : -input - BigInt(1);
        const n = Number(value);
        if (n < 24) {
          data[cursor++] = major << 5 | n;
        } else if (n < 256) {
          data[cursor++] = major << 5 | 24;
          data[cursor++] = n;
        } else if (n < 65536) {
          data[cursor++] = major << 5 | extendedFloat16;
          data[cursor++] = n >> 8;
          data[cursor++] = n & 255;
        } else if (n < 4294967296) {
          data[cursor++] = major << 5 | extendedFloat32;
          dataView.setUint32(cursor, n);
          cursor += 4;
        } else if (value < BigInt("18446744073709551616")) {
          data[cursor++] = major << 5 | extendedFloat64;
          dataView.setBigUint64(cursor, value);
          cursor += 8;
        } else {
          const binaryBigInt = value.toString(2);
          const bigIntBytes = new Uint8Array(Math.ceil(binaryBigInt.length / 8));
          let b = value;
          let i2 = 0;
          while (bigIntBytes.byteLength - ++i2 >= 0) {
            bigIntBytes[bigIntBytes.byteLength - i2] = Number(b & BigInt(255));
            b >>= BigInt(8);
          }
          ensureSpace(bigIntBytes.byteLength * 2);
          data[cursor++] = nonNegative ? 194 : 195;
          if (USE_BUFFER) {
            encodeHeader(majorUnstructuredByteString, Buffer.byteLength(bigIntBytes));
          } else {
            encodeHeader(majorUnstructuredByteString, bigIntBytes.byteLength);
          }
          data.set(bigIntBytes, cursor);
          cursor += bigIntBytes.byteLength;
        }
        continue;
      } else if (input === null) {
        data[cursor++] = majorSpecial << 5 | specialNull;
        continue;
      } else if (typeof input === "boolean") {
        data[cursor++] = majorSpecial << 5 | (input ? specialTrue : specialFalse);
        continue;
      } else if (typeof input === "undefined") {
        throw new Error("@smithy/core/cbor: client may not serialize undefined value.");
      } else if (Array.isArray(input)) {
        for (let i2 = input.length - 1;i2 >= 0; --i2) {
          encodeStack.push(input[i2]);
        }
        encodeHeader(majorList, input.length);
        continue;
      } else if (typeof input.byteLength === "number") {
        ensureSpace(input.length * 2);
        encodeHeader(majorUnstructuredByteString, input.length);
        data.set(input, cursor);
        cursor += input.byteLength;
        continue;
      } else if (typeof input === "object") {
        if (input instanceof serde.NumericValue) {
          const decimalIndex = input.string.indexOf(".");
          const exponent = decimalIndex === -1 ? 0 : decimalIndex - input.string.length + 1;
          const mantissa = BigInt(input.string.replace(".", ""));
          data[cursor++] = 196;
          encodeStack.push(mantissa);
          encodeStack.push(exponent);
          encodeHeader(majorList, 2);
          continue;
        }
        if (input[tagSymbol]) {
          if ("tag" in input && "value" in input) {
            encodeStack.push(input.value);
            encodeHeader(majorTag, input.tag);
            continue;
          } else {
            throw new Error("tag encountered with missing fields, need 'tag' and 'value', found: " + JSON.stringify(input));
          }
        }
        const keys = Object.keys(input);
        for (let i2 = keys.length - 1;i2 >= 0; --i2) {
          const key = keys[i2];
          encodeStack.push(input[key]);
          encodeStack.push(key);
        }
        encodeHeader(majorMap, keys.length);
        continue;
      }
      throw new Error(`data type ${input?.constructor?.name ?? typeof input} not compatible for encoding.`);
    }
  }
  var cbor = {
    deserialize(payload2) {
      setPayload(payload2);
      return decode2(0, payload2.length);
    },
    serialize(input) {
      try {
        encode2(input);
        return toUint8Array();
      } catch (e) {
        toUint8Array();
        throw e;
      }
    },
    resizeEncodingBuffer(size) {
      resize(size);
    }
  };
  var parseCborBody = (streamBody, context) => {
    return protocols.collectBody(streamBody, context).then(async (bytes) => {
      if (bytes.length) {
        try {
          return cbor.deserialize(bytes);
        } catch (e) {
          Object.defineProperty(e, "$responseBodyText", {
            value: context.utf8Encoder(bytes)
          });
          throw e;
        }
      }
      return {};
    });
  };
  var dateToTag = (date2) => {
    return tag({
      tag: 1,
      value: date2.getTime() / 1000
    });
  };
  var parseCborErrorBody = async (errorBody, context) => {
    const value = await parseCborBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
  };
  var loadSmithyRpcV2CborErrorCode = (output, data2) => {
    const sanitizeErrorCode = (rawValue) => {
      let cleanValue = rawValue;
      if (typeof cleanValue === "number") {
        cleanValue = cleanValue.toString();
      }
      if (cleanValue.indexOf(",") >= 0) {
        cleanValue = cleanValue.split(",")[0];
      }
      if (cleanValue.indexOf(":") >= 0) {
        cleanValue = cleanValue.split(":")[0];
      }
      if (cleanValue.indexOf("#") >= 0) {
        cleanValue = cleanValue.split("#")[1];
      }
      return cleanValue;
    };
    if (data2["__type"] !== undefined) {
      return sanitizeErrorCode(data2["__type"]);
    }
    const codeKey = Object.keys(data2).find((key) => key.toLowerCase() === "code");
    if (codeKey && data2[codeKey] !== undefined) {
      return sanitizeErrorCode(data2[codeKey]);
    }
  };
  var checkCborResponse = (response) => {
    if (String(response.headers["smithy-protocol"]).toLowerCase() !== "rpc-v2-cbor") {
      throw new Error("Malformed RPCv2 CBOR response, status: " + response.statusCode);
    }
  };
  var buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
      protocol,
      hostname,
      port,
      method: "POST",
      path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
      headers: {
        ...headers
      }
    };
    if (resolvedHostname !== undefined) {
      contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
      contents.body = body;
      try {
        contents.headers["content-length"] = String(utilBodyLengthBrowser.calculateBodyLength(body));
      } catch (e) {}
    }
    return new protocolHttp.HttpRequest(contents);
  };

  class CborCodec extends protocols.SerdeContext {
    createSerializer() {
      const serializer = new CborShapeSerializer;
      serializer.setSerdeContext(this.serdeContext);
      return serializer;
    }
    createDeserializer() {
      const deserializer = new CborShapeDeserializer;
      deserializer.setSerdeContext(this.serdeContext);
      return deserializer;
    }
  }

  class CborShapeSerializer extends protocols.SerdeContext {
    value;
    write(schema2, value) {
      this.value = this.serialize(schema2, value);
    }
    serialize(schema$1, source) {
      const ns = schema.NormalizedSchema.of(schema$1);
      if (source == null) {
        if (ns.isIdempotencyToken()) {
          return serde.generateIdempotencyToken();
        }
        return source;
      }
      if (ns.isBlobSchema()) {
        if (typeof source === "string") {
          return (this.serdeContext?.base64Decoder ?? utilBase64.fromBase64)(source);
        }
        return source;
      }
      if (ns.isTimestampSchema()) {
        if (typeof source === "number" || typeof source === "bigint") {
          return dateToTag(new Date(Number(source) / 1000 | 0));
        }
        return dateToTag(source);
      }
      if (typeof source === "function" || typeof source === "object") {
        const sourceObject = source;
        if (ns.isListSchema() && Array.isArray(sourceObject)) {
          const sparse = !!ns.getMergedTraits().sparse;
          const newArray = [];
          let i2 = 0;
          for (const item of sourceObject) {
            const value = this.serialize(ns.getValueSchema(), item);
            if (value != null || sparse) {
              newArray[i2++] = value;
            }
          }
          return newArray;
        }
        if (sourceObject instanceof Date) {
          return dateToTag(sourceObject);
        }
        const newObject = {};
        if (ns.isMapSchema()) {
          const sparse = !!ns.getMergedTraits().sparse;
          for (const key of Object.keys(sourceObject)) {
            const value = this.serialize(ns.getValueSchema(), sourceObject[key]);
            if (value != null || sparse) {
              newObject[key] = value;
            }
          }
        } else if (ns.isStructSchema()) {
          for (const [key, memberSchema] of ns.structIterator()) {
            const value = this.serialize(memberSchema, sourceObject[key]);
            if (value != null) {
              newObject[key] = value;
            }
          }
        } else if (ns.isDocumentSchema()) {
          for (const key of Object.keys(sourceObject)) {
            newObject[key] = this.serialize(ns.getValueSchema(), sourceObject[key]);
          }
        }
        return newObject;
      }
      return source;
    }
    flush() {
      const buffer = cbor.serialize(this.value);
      this.value = undefined;
      return buffer;
    }
  }

  class CborShapeDeserializer extends protocols.SerdeContext {
    read(schema2, bytes) {
      const data2 = cbor.deserialize(bytes);
      return this.readValue(schema2, data2);
    }
    readValue(_schema, value) {
      const ns = schema.NormalizedSchema.of(_schema);
      if (ns.isTimestampSchema() && typeof value === "number") {
        return serde._parseEpochTimestamp(value);
      }
      if (ns.isBlobSchema()) {
        if (typeof value === "string") {
          return (this.serdeContext?.base64Decoder ?? utilBase64.fromBase64)(value);
        }
        return value;
      }
      if (typeof value === "undefined" || typeof value === "boolean" || typeof value === "number" || typeof value === "string" || typeof value === "bigint" || typeof value === "symbol") {
        return value;
      } else if (typeof value === "function" || typeof value === "object") {
        if (value === null) {
          return null;
        }
        if ("byteLength" in value) {
          return value;
        }
        if (value instanceof Date) {
          return value;
        }
        if (ns.isDocumentSchema()) {
          return value;
        }
        if (ns.isListSchema()) {
          const newArray = [];
          const memberSchema = ns.getValueSchema();
          const sparse = !!ns.getMergedTraits().sparse;
          for (const item of value) {
            const itemValue = this.readValue(memberSchema, item);
            if (itemValue != null || sparse) {
              newArray.push(itemValue);
            }
          }
          return newArray;
        }
        const newObject = {};
        if (ns.isMapSchema()) {
          const sparse = !!ns.getMergedTraits().sparse;
          const targetSchema = ns.getValueSchema();
          for (const key of Object.keys(value)) {
            const itemValue = this.readValue(targetSchema, value[key]);
            if (itemValue != null || sparse) {
              newObject[key] = itemValue;
            }
          }
        } else if (ns.isStructSchema()) {
          for (const [key, memberSchema] of ns.structIterator()) {
            newObject[key] = this.readValue(memberSchema, value[key]);
          }
        }
        return newObject;
      } else {
        return value;
      }
    }
  }

  class SmithyRpcV2CborProtocol extends protocols.RpcProtocol {
    codec = new CborCodec;
    serializer = this.codec.createSerializer();
    deserializer = this.codec.createDeserializer();
    constructor({ defaultNamespace }) {
      super({ defaultNamespace });
    }
    getShapeId() {
      return "smithy.protocols#rpcv2Cbor";
    }
    getPayloadCodec() {
      return this.codec;
    }
    async serializeRequest(operationSchema, input, context) {
      const request = await super.serializeRequest(operationSchema, input, context);
      Object.assign(request.headers, {
        "content-type": this.getDefaultContentType(),
        "smithy-protocol": "rpc-v2-cbor",
        accept: this.getDefaultContentType()
      });
      if (schema.deref(operationSchema.input) === "unit") {
        delete request.body;
        delete request.headers["content-type"];
      } else {
        if (!request.body) {
          this.serializer.write(15, {});
          request.body = this.serializer.flush();
        }
        try {
          request.headers["content-length"] = String(request.body.byteLength);
        } catch (e) {}
      }
      const { service, operation } = utilMiddleware2.getSmithyContext(context);
      const path = `/service/${service}/operation/${operation}`;
      if (request.path.endsWith("/")) {
        request.path += path.slice(1);
      } else {
        request.path += path;
      }
      return request;
    }
    async deserializeResponse(operationSchema, context, response) {
      return super.deserializeResponse(operationSchema, context, response);
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
      const errorName = loadSmithyRpcV2CborErrorCode(response, dataObject) ?? "Unknown";
      let namespace = this.options.defaultNamespace;
      if (errorName.includes("#")) {
        [namespace] = errorName.split("#");
      }
      const errorMetadata = {
        $metadata: metadata,
        $response: response,
        $fault: response.statusCode <= 500 ? "client" : "server"
      };
      const registry = schema.TypeRegistry.for(namespace);
      let errorSchema;
      try {
        errorSchema = registry.getSchema(errorName);
      } catch (e) {
        if (dataObject.Message) {
          dataObject.message = dataObject.Message;
        }
        const synthetic = schema.TypeRegistry.for("smithy.ts.sdk.synthetic." + namespace);
        const baseExceptionSchema = synthetic.getBaseException();
        if (baseExceptionSchema) {
          const ErrorCtor2 = synthetic.getErrorCtor(baseExceptionSchema);
          throw Object.assign(new ErrorCtor2({ name: errorName }), errorMetadata, dataObject);
        }
        throw Object.assign(new Error(errorName), errorMetadata, dataObject);
      }
      const ns = schema.NormalizedSchema.of(errorSchema);
      const ErrorCtor = registry.getErrorCtor(errorSchema);
      const message = dataObject.message ?? dataObject.Message ?? "Unknown";
      const exception = new ErrorCtor(message);
      const output = {};
      for (const [name, member] of ns.structIterator()) {
        output[name] = this.deserializer.readValue(member, dataObject[name]);
      }
      throw Object.assign(exception, errorMetadata, {
        $fault: ns.getMergedTraits().error,
        message
      }, output);
    }
    getDefaultContentType() {
      return "application/cbor";
    }
  }
  exports.CborCodec = CborCodec;
  exports.CborShapeDeserializer = CborShapeDeserializer;
  exports.CborShapeSerializer = CborShapeSerializer;
  exports.SmithyRpcV2CborProtocol = SmithyRpcV2CborProtocol;
  exports.buildHttpRpcRequest = buildHttpRpcRequest;
  exports.cbor = cbor;
  exports.checkCborResponse = checkCborResponse;
  exports.dateToTag = dateToTag;
  exports.loadSmithyRpcV2CborErrorCode = loadSmithyRpcV2CborErrorCode;
  exports.parseCborBody = parseCborBody;
  exports.parseCborErrorBody = parseCborErrorBody;
  exports.tag = tag;
  exports.tagSymbol = tagSymbol;
});

// node_modules/@smithy/middleware-stack/dist-cjs/index.js
var require_dist_cjs27 = __commonJS((exports) => {
  var getAllAliases = (name, aliases) => {
    const _aliases = [];
    if (name) {
      _aliases.push(name);
    }
    if (aliases) {
      for (const alias of aliases) {
        _aliases.push(alias);
      }
    }
    return _aliases;
  };
  var getMiddlewareNameWithAliases = (name, aliases) => {
    return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
  };
  var constructStack = () => {
    let absoluteEntries = [];
    let relativeEntries = [];
    let identifyOnResolve = false;
    const entriesNameSet = new Set;
    const sort = (entries) => entries.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] || priorityWeights[b.priority || "normal"] - priorityWeights[a.priority || "normal"]);
    const removeByName = (toRemove) => {
      let isRemoved = false;
      const filterCb = (entry) => {
        const aliases = getAllAliases(entry.name, entry.aliases);
        if (aliases.includes(toRemove)) {
          isRemoved = true;
          for (const alias of aliases) {
            entriesNameSet.delete(alias);
          }
          return false;
        }
        return true;
      };
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    };
    const removeByReference = (toRemove) => {
      let isRemoved = false;
      const filterCb = (entry) => {
        if (entry.middleware === toRemove) {
          isRemoved = true;
          for (const alias of getAllAliases(entry.name, entry.aliases)) {
            entriesNameSet.delete(alias);
          }
          return false;
        }
        return true;
      };
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    };
    const cloneTo = (toStack) => {
      absoluteEntries.forEach((entry) => {
        toStack.add(entry.middleware, { ...entry });
      });
      relativeEntries.forEach((entry) => {
        toStack.addRelativeTo(entry.middleware, { ...entry });
      });
      toStack.identifyOnResolve?.(stack.identifyOnResolve());
      return toStack;
    };
    const expandRelativeMiddlewareList = (from) => {
      const expandedMiddlewareList = [];
      from.before.forEach((entry) => {
        if (entry.before.length === 0 && entry.after.length === 0) {
          expandedMiddlewareList.push(entry);
        } else {
          expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
        }
      });
      expandedMiddlewareList.push(from);
      from.after.reverse().forEach((entry) => {
        if (entry.before.length === 0 && entry.after.length === 0) {
          expandedMiddlewareList.push(entry);
        } else {
          expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
        }
      });
      return expandedMiddlewareList;
    };
    const getMiddlewareList = (debug2 = false) => {
      const normalizedAbsoluteEntries = [];
      const normalizedRelativeEntries = [];
      const normalizedEntriesNameMap = {};
      absoluteEntries.forEach((entry) => {
        const normalizedEntry = {
          ...entry,
          before: [],
          after: []
        };
        for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
          normalizedEntriesNameMap[alias] = normalizedEntry;
        }
        normalizedAbsoluteEntries.push(normalizedEntry);
      });
      relativeEntries.forEach((entry) => {
        const normalizedEntry = {
          ...entry,
          before: [],
          after: []
        };
        for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
          normalizedEntriesNameMap[alias] = normalizedEntry;
        }
        normalizedRelativeEntries.push(normalizedEntry);
      });
      normalizedRelativeEntries.forEach((entry) => {
        if (entry.toMiddleware) {
          const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
          if (toMiddleware === undefined) {
            if (debug2) {
              return;
            }
            throw new Error(`${entry.toMiddleware} is not found when adding ` + `${getMiddlewareNameWithAliases(entry.name, entry.aliases)} ` + `middleware ${entry.relation} ${entry.toMiddleware}`);
          }
          if (entry.relation === "after") {
            toMiddleware.after.push(entry);
          }
          if (entry.relation === "before") {
            toMiddleware.before.push(entry);
          }
        }
      });
      const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expandedMiddlewareList) => {
        wholeList.push(...expandedMiddlewareList);
        return wholeList;
      }, []);
      return mainChain;
    };
    const stack = {
      add: (middleware, options = {}) => {
        const { name, override, aliases: _aliases } = options;
        const entry = {
          step: "initialize",
          priority: "normal",
          middleware,
          ...options
        };
        const aliases = getAllAliases(name, _aliases);
        if (aliases.length > 0) {
          if (aliases.some((alias) => entriesNameSet.has(alias))) {
            if (!override)
              throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
            for (const alias of aliases) {
              const toOverrideIndex = absoluteEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a) => a === alias));
              if (toOverrideIndex === -1) {
                continue;
              }
              const toOverride = absoluteEntries[toOverrideIndex];
              if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ` + `${toOverride.priority} priority in ${toOverride.step} step cannot ` + `be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ` + `${entry.priority} priority in ${entry.step} step.`);
              }
              absoluteEntries.splice(toOverrideIndex, 1);
            }
          }
          for (const alias of aliases) {
            entriesNameSet.add(alias);
          }
        }
        absoluteEntries.push(entry);
      },
      addRelativeTo: (middleware, options) => {
        const { name, override, aliases: _aliases } = options;
        const entry = {
          middleware,
          ...options
        };
        const aliases = getAllAliases(name, _aliases);
        if (aliases.length > 0) {
          if (aliases.some((alias) => entriesNameSet.has(alias))) {
            if (!override)
              throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
            for (const alias of aliases) {
              const toOverrideIndex = relativeEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a) => a === alias));
              if (toOverrideIndex === -1) {
                continue;
              }
              const toOverride = relativeEntries[toOverrideIndex];
              if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ` + `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` + `by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} ` + `"${entry.toMiddleware}" middleware.`);
              }
              relativeEntries.splice(toOverrideIndex, 1);
            }
          }
          for (const alias of aliases) {
            entriesNameSet.add(alias);
          }
        }
        relativeEntries.push(entry);
      },
      clone: () => cloneTo(constructStack()),
      use: (plugin) => {
        plugin.applyToStack(stack);
      },
      remove: (toRemove) => {
        if (typeof toRemove === "string")
          return removeByName(toRemove);
        else
          return removeByReference(toRemove);
      },
      removeByTag: (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
          const { tags, name, aliases: _aliases } = entry;
          if (tags && tags.includes(toRemove)) {
            const aliases = getAllAliases(name, _aliases);
            for (const alias of aliases) {
              entriesNameSet.delete(alias);
            }
            isRemoved = true;
            return false;
          }
          return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
      },
      concat: (from) => {
        const cloned = cloneTo(constructStack());
        cloned.use(from);
        cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
        return cloned;
      },
      applyToStack: cloneTo,
      identify: () => {
        return getMiddlewareList(true).map((mw) => {
          const step = mw.step ?? mw.relation + " " + mw.toMiddleware;
          return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
        });
      },
      identifyOnResolve(toggle) {
        if (typeof toggle === "boolean")
          identifyOnResolve = toggle;
        return identifyOnResolve;
      },
      resolve: (handler, context) => {
        for (const middleware of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
          handler = middleware(handler, context);
        }
        if (identifyOnResolve) {
          console.log(stack.identify());
        }
        return handler;
      }
    };
    return stack;
  };
  var stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1
  };
  var priorityWeights = {
    high: 3,
    normal: 2,
    low: 1
  };
  exports.constructStack = constructStack;
});

// node_modules/@smithy/smithy-client/dist-cjs/index.js
var require_dist_cjs28 = __commonJS((exports) => {
  var middlewareStack = require_dist_cjs27();
  var protocols = require_protocols();
  var types = require_dist_cjs();
  var schema = require_schema();
  var serde = require_serde();

  class Client {
    config;
    middlewareStack = middlewareStack.constructStack();
    initConfig;
    handlers;
    constructor(config) {
      this.config = config;
    }
    send(command, optionsOrCb, cb) {
      const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
      const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
      const useHandlerCache = options === undefined && this.config.cacheMiddleware === true;
      let handler;
      if (useHandlerCache) {
        if (!this.handlers) {
          this.handlers = new WeakMap;
        }
        const handlers = this.handlers;
        if (handlers.has(command.constructor)) {
          handler = handlers.get(command.constructor);
        } else {
          handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
          handlers.set(command.constructor, handler);
        }
      } else {
        delete this.handlers;
        handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
      }
      if (callback) {
        handler(command).then((result) => callback(null, result.output), (err3) => callback(err3)).catch(() => {});
      } else {
        return handler(command).then((result) => result.output);
      }
    }
    destroy() {
      this.config?.requestHandler?.destroy?.();
      delete this.handlers;
    }
  }
  var SENSITIVE_STRING$1 = "***SensitiveInformation***";
  function schemaLogFilter(schema$1, data) {
    if (data == null) {
      return data;
    }
    const ns = schema.NormalizedSchema.of(schema$1);
    if (ns.getMergedTraits().sensitive) {
      return SENSITIVE_STRING$1;
    }
    if (ns.isListSchema()) {
      const isSensitive = !!ns.getValueSchema().getMergedTraits().sensitive;
      if (isSensitive) {
        return SENSITIVE_STRING$1;
      }
    } else if (ns.isMapSchema()) {
      const isSensitive = !!ns.getKeySchema().getMergedTraits().sensitive || !!ns.getValueSchema().getMergedTraits().sensitive;
      if (isSensitive) {
        return SENSITIVE_STRING$1;
      }
    } else if (ns.isStructSchema() && typeof data === "object") {
      const object = data;
      const newObject = {};
      for (const [member, memberNs] of ns.structIterator()) {
        if (object[member] != null) {
          newObject[member] = schemaLogFilter(memberNs, object[member]);
        }
      }
      return newObject;
    }
    return data;
  }

  class Command {
    middlewareStack = middlewareStack.constructStack();
    schema;
    static classBuilder() {
      return new ClassBuilder;
    }
    resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor }) {
      for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
        this.middlewareStack.use(mw);
      }
      const stack = clientStack.concat(this.middlewareStack);
      const { logger } = configuration;
      const handlerExecutionContext = {
        logger,
        clientName,
        commandName,
        inputFilterSensitiveLog,
        outputFilterSensitiveLog,
        [types.SMITHY_CONTEXT_KEY]: {
          commandInstance: this,
          ...smithyContext
        },
        ...additionalContext
      };
      const { requestHandler } = configuration;
      return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
  }

  class ClassBuilder {
    _init = () => {};
    _ep = {};
    _middlewareFn = () => [];
    _commandName = "";
    _clientName = "";
    _additionalContext = {};
    _smithyContext = {};
    _inputFilterSensitiveLog = undefined;
    _outputFilterSensitiveLog = undefined;
    _serializer = null;
    _deserializer = null;
    _operationSchema;
    init(cb) {
      this._init = cb;
    }
    ep(endpointParameterInstructions) {
      this._ep = endpointParameterInstructions;
      return this;
    }
    m(middlewareSupplier) {
      this._middlewareFn = middlewareSupplier;
      return this;
    }
    s(service, operation, smithyContext = {}) {
      this._smithyContext = {
        service,
        operation,
        ...smithyContext
      };
      return this;
    }
    c(additionalContext = {}) {
      this._additionalContext = additionalContext;
      return this;
    }
    n(clientName, commandName) {
      this._clientName = clientName;
      this._commandName = commandName;
      return this;
    }
    f(inputFilter = (_2) => _2, outputFilter = (_2) => _2) {
      this._inputFilterSensitiveLog = inputFilter;
      this._outputFilterSensitiveLog = outputFilter;
      return this;
    }
    ser(serializer) {
      this._serializer = serializer;
      return this;
    }
    de(deserializer) {
      this._deserializer = deserializer;
      return this;
    }
    sc(operation) {
      this._operationSchema = operation;
      this._smithyContext.operationSchema = operation;
      return this;
    }
    build() {
      const closure = this;
      let CommandRef;
      return CommandRef = class extends Command {
        input;
        static getEndpointParameterInstructions() {
          return closure._ep;
        }
        constructor(...[input]) {
          super();
          this.input = input ?? {};
          closure._init(this);
          this.schema = closure._operationSchema;
        }
        resolveMiddleware(stack, configuration, options) {
          const op = closure._operationSchema;
          const input = op?.[4] ?? op?.input;
          const output = op?.[5] ?? op?.output;
          return this.resolveMiddlewareWithContext(stack, configuration, options, {
            CommandCtor: CommandRef,
            middlewareFn: closure._middlewareFn,
            clientName: closure._clientName,
            commandName: closure._commandName,
            inputFilterSensitiveLog: closure._inputFilterSensitiveLog ?? (op ? schemaLogFilter.bind(null, input) : (_2) => _2),
            outputFilterSensitiveLog: closure._outputFilterSensitiveLog ?? (op ? schemaLogFilter.bind(null, output) : (_2) => _2),
            smithyContext: closure._smithyContext,
            additionalContext: closure._additionalContext
          });
        }
        serialize = closure._serializer;
        deserialize = closure._deserializer;
      };
    }
  }
  var SENSITIVE_STRING = "***SensitiveInformation***";
  var createAggregatedClient = (commands, Client2) => {
    for (const command of Object.keys(commands)) {
      const CommandCtor = commands[command];
      const methodImpl = async function(args, optionsOrCb, cb) {
        const command2 = new CommandCtor(args);
        if (typeof optionsOrCb === "function") {
          this.send(command2, optionsOrCb);
        } else if (typeof cb === "function") {
          if (typeof optionsOrCb !== "object")
            throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
          this.send(command2, optionsOrCb || {}, cb);
        } else {
          return this.send(command2, optionsOrCb);
        }
      };
      const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, "");
      Client2.prototype[methodName] = methodImpl;
    }
  };

  class ServiceException extends Error {
    $fault;
    $response;
    $retryable;
    $metadata;
    constructor(options) {
      super(options.message);
      Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype);
      this.name = options.name;
      this.$fault = options.$fault;
      this.$metadata = options.$metadata;
    }
    static isInstance(value) {
      if (!value)
        return false;
      const candidate = value;
      return ServiceException.prototype.isPrototypeOf(candidate) || Boolean(candidate.$fault) && Boolean(candidate.$metadata) && (candidate.$fault === "client" || candidate.$fault === "server");
    }
    static [Symbol.hasInstance](instance) {
      if (!instance)
        return false;
      const candidate = instance;
      if (this === ServiceException) {
        return ServiceException.isInstance(instance);
      }
      if (ServiceException.isInstance(instance)) {
        if (candidate.name && this.name) {
          return this.prototype.isPrototypeOf(instance) || candidate.name === this.name;
        }
        return this.prototype.isPrototypeOf(instance);
      }
      return false;
    }
  }
  var decorateServiceException = (exception, additions = {}) => {
    Object.entries(additions).filter(([, v]) => v !== undefined).forEach(([k2, v]) => {
      if (exception[k2] == undefined || exception[k2] === "") {
        exception[k2] = v;
      }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
  };
  var throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
    const response = new exceptionCtor({
      name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
      $fault: "client",
      $metadata
    });
    throw decorateServiceException(response, parsedBody);
  };
  var withBaseException = (ExceptionCtor) => {
    return ({ output, parsedBody, errorCode }) => {
      throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
    };
  };
  var deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"]
  });
  var loadConfigsForDefaultMode = (mode) => {
    switch (mode) {
      case "standard":
        return {
          retryMode: "standard",
          connectionTimeout: 3100
        };
      case "in-region":
        return {
          retryMode: "standard",
          connectionTimeout: 1100
        };
      case "cross-region":
        return {
          retryMode: "standard",
          connectionTimeout: 3100
        };
      case "mobile":
        return {
          retryMode: "standard",
          connectionTimeout: 30000
        };
      default:
        return {};
    }
  };
  var warningEmitted = false;
  var emitWarningIfUnsupportedVersion = (version) => {
    if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 16) {
      warningEmitted = true;
    }
  };
  var getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    for (const id in types.AlgorithmId) {
      const algorithmId = types.AlgorithmId[id];
      if (runtimeConfig[algorithmId] === undefined) {
        continue;
      }
      checksumAlgorithms.push({
        algorithmId: () => algorithmId,
        checksumConstructor: () => runtimeConfig[algorithmId]
      });
    }
    return {
      addChecksumAlgorithm(algo) {
        checksumAlgorithms.push(algo);
      },
      checksumAlgorithms() {
        return checksumAlgorithms;
      }
    };
  };
  var resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
      runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
  };
  var getRetryConfiguration = (runtimeConfig) => {
    return {
      setRetryStrategy(retryStrategy) {
        runtimeConfig.retryStrategy = retryStrategy;
      },
      retryStrategy() {
        return runtimeConfig.retryStrategy;
      }
    };
  };
  var resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
    const runtimeConfig = {};
    runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
    return runtimeConfig;
  };
  var getDefaultExtensionConfiguration = (runtimeConfig) => {
    return Object.assign(getChecksumConfiguration(runtimeConfig), getRetryConfiguration(runtimeConfig));
  };
  var getDefaultClientConfiguration = getDefaultExtensionConfiguration;
  var resolveDefaultRuntimeConfig = (config) => {
    return Object.assign(resolveChecksumRuntimeConfig(config), resolveRetryRuntimeConfig(config));
  };
  var getArrayIfSingleItem = (mayBeArray) => Array.isArray(mayBeArray) ? mayBeArray : [mayBeArray];
  var getValueFromTextNode = (obj) => {
    const textNodeName = "#text";
    for (const key in obj) {
      if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== undefined) {
        obj[key] = obj[key][textNodeName];
      } else if (typeof obj[key] === "object" && obj[key] !== null) {
        obj[key] = getValueFromTextNode(obj[key]);
      }
    }
    return obj;
  };
  var isSerializableHeaderValue = (value) => {
    return value != null;
  };

  class NoOpLogger {
    trace() {}
    debug() {}
    info() {}
    warn() {}
    error() {}
  }
  function map3(arg0, arg1, arg2) {
    let target;
    let filter;
    let instructions;
    if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
      target = {};
      instructions = arg0;
    } else {
      target = arg0;
      if (typeof arg1 === "function") {
        filter = arg1;
        instructions = arg2;
        return mapWithFilter(target, filter, instructions);
      } else {
        instructions = arg1;
      }
    }
    for (const key of Object.keys(instructions)) {
      if (!Array.isArray(instructions[key])) {
        target[key] = instructions[key];
        continue;
      }
      applyInstruction(target, null, instructions, key);
    }
    return target;
  }
  var convertMap = (target) => {
    const output = {};
    for (const [k2, v] of Object.entries(target || {})) {
      output[k2] = [, v];
    }
    return output;
  };
  var take = (source, instructions) => {
    const out = {};
    for (const key in instructions) {
      applyInstruction(out, source, instructions, key);
    }
    return out;
  };
  var mapWithFilter = (target, filter, instructions) => {
    return map3(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
      if (Array.isArray(value)) {
        _instructions[key] = value;
      } else {
        if (typeof value === "function") {
          _instructions[key] = [filter, value()];
        } else {
          _instructions[key] = [filter, value];
        }
      }
      return _instructions;
    }, {}));
  };
  var applyInstruction = (target, source, instructions, targetKey) => {
    if (source !== null) {
      let instruction = instructions[targetKey];
      if (typeof instruction === "function") {
        instruction = [, instruction];
      }
      const [filter2 = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
      if (typeof filter2 === "function" && filter2(source[sourceKey]) || typeof filter2 !== "function" && !!filter2) {
        target[targetKey] = valueFn(source[sourceKey]);
      }
      return;
    }
    let [filter, value] = instructions[targetKey];
    if (typeof value === "function") {
      let _value;
      const defaultFilterPassed = filter === undefined && (_value = value()) != null;
      const customFilterPassed = typeof filter === "function" && !!filter(undefined) || typeof filter !== "function" && !!filter;
      if (defaultFilterPassed) {
        target[targetKey] = _value;
      } else if (customFilterPassed) {
        target[targetKey] = value();
      }
    } else {
      const defaultFilterPassed = filter === undefined && value != null;
      const customFilterPassed = typeof filter === "function" && !!filter(value) || typeof filter !== "function" && !!filter;
      if (defaultFilterPassed || customFilterPassed) {
        target[targetKey] = value;
      }
    }
  };
  var nonNullish = (_2) => _2 != null;
  var pass = (_2) => _2;
  var serializeFloat = (value) => {
    if (value !== value) {
      return "NaN";
    }
    switch (value) {
      case Infinity:
        return "Infinity";
      case -Infinity:
        return "-Infinity";
      default:
        return value;
    }
  };
  var serializeDateTime = (date2) => date2.toISOString().replace(".000Z", "Z");
  var _json = (obj) => {
    if (obj == null) {
      return {};
    }
    if (Array.isArray(obj)) {
      return obj.filter((_2) => _2 != null).map(_json);
    }
    if (typeof obj === "object") {
      const target = {};
      for (const key of Object.keys(obj)) {
        if (obj[key] == null) {
          continue;
        }
        target[key] = _json(obj[key]);
      }
      return target;
    }
    return obj;
  };
  Object.defineProperty(exports, "collectBody", {
    enumerable: true,
    get: function() {
      return protocols.collectBody;
    }
  });
  Object.defineProperty(exports, "extendedEncodeURIComponent", {
    enumerable: true,
    get: function() {
      return protocols.extendedEncodeURIComponent;
    }
  });
  Object.defineProperty(exports, "resolvedPath", {
    enumerable: true,
    get: function() {
      return protocols.resolvedPath;
    }
  });
  exports.Client = Client;
  exports.Command = Command;
  exports.NoOpLogger = NoOpLogger;
  exports.SENSITIVE_STRING = SENSITIVE_STRING;
  exports.ServiceException = ServiceException;
  exports._json = _json;
  exports.convertMap = convertMap;
  exports.createAggregatedClient = createAggregatedClient;
  exports.decorateServiceException = decorateServiceException;
  exports.emitWarningIfUnsupportedVersion = emitWarningIfUnsupportedVersion;
  exports.getArrayIfSingleItem = getArrayIfSingleItem;
  exports.getDefaultClientConfiguration = getDefaultClientConfiguration;
  exports.getDefaultExtensionConfiguration = getDefaultExtensionConfiguration;
  exports.getValueFromTextNode = getValueFromTextNode;
  exports.isSerializableHeaderValue = isSerializableHeaderValue;
  exports.loadConfigsForDefaultMode = loadConfigsForDefaultMode;
  exports.map = map3;
  exports.resolveDefaultRuntimeConfig = resolveDefaultRuntimeConfig;
  exports.serializeDateTime = serializeDateTime;
  exports.serializeFloat = serializeFloat;
  exports.take = take;
  exports.throwDefaultError = throwDefaultError;
  exports.withBaseException = withBaseException;
  Object.keys(serde).forEach(function(k2) {
    if (k2 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k2))
      Object.defineProperty(exports, k2, {
        enumerable: true,
        get: function() {
          return serde[k2];
        }
      });
  });
});

// node_modules/fast-xml-parser/lib/fxp.cjs
var require_fxp = __commonJS((exports, module) => {
  (() => {
    var t2 = { d: (e2, n2) => {
      for (var i3 in n2)
        t2.o(n2, i3) && !t2.o(e2, i3) && Object.defineProperty(e2, i3, { enumerable: true, get: n2[i3] });
    }, o: (t3, e2) => Object.prototype.hasOwnProperty.call(t3, e2), r: (t3) => {
      typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t3, "__esModule", { value: true });
    } }, e = {};
    t2.r(e), t2.d(e, { XMLBuilder: () => ft, XMLParser: () => st, XMLValidator: () => mt });
    const n = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", i2 = new RegExp("^[" + n + "][" + n + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");
    function s(t3, e2) {
      const n2 = [];
      let i3 = e2.exec(t3);
      for (;i3; ) {
        const s2 = [];
        s2.startIndex = e2.lastIndex - i3[0].length;
        const r2 = i3.length;
        for (let t4 = 0;t4 < r2; t4++)
          s2.push(i3[t4]);
        n2.push(s2), i3 = e2.exec(t3);
      }
      return n2;
    }
    const r = function(t3) {
      return !(i2.exec(t3) == null);
    }, o = { allowBooleanAttributes: false, unpairedTags: [] };
    function a(t3, e2) {
      e2 = Object.assign({}, o, e2);
      const n2 = [];
      let i3 = false, s2 = false;
      t3[0] === "\uFEFF" && (t3 = t3.substr(1));
      for (let o2 = 0;o2 < t3.length; o2++)
        if (t3[o2] === "<" && t3[o2 + 1] === "?") {
          if (o2 += 2, o2 = u(t3, o2), o2.err)
            return o2;
        } else {
          if (t3[o2] !== "<") {
            if (l(t3[o2]))
              continue;
            return x2("InvalidChar", "char '" + t3[o2] + "' is not expected.", N(t3, o2));
          }
          {
            let a2 = o2;
            if (o2++, t3[o2] === "!") {
              o2 = h(t3, o2);
              continue;
            }
            {
              let d2 = false;
              t3[o2] === "/" && (d2 = true, o2++);
              let f2 = "";
              for (;o2 < t3.length && t3[o2] !== ">" && t3[o2] !== " " && t3[o2] !== "\t" && t3[o2] !== `
` && t3[o2] !== "\r"; o2++)
                f2 += t3[o2];
              if (f2 = f2.trim(), f2[f2.length - 1] === "/" && (f2 = f2.substring(0, f2.length - 1), o2--), !r(f2)) {
                let e3;
                return e3 = f2.trim().length === 0 ? "Invalid space after '<'." : "Tag '" + f2 + "' is an invalid name.", x2("InvalidTag", e3, N(t3, o2));
              }
              const p2 = c(t3, o2);
              if (p2 === false)
                return x2("InvalidAttr", "Attributes for '" + f2 + "' have open quote.", N(t3, o2));
              let b2 = p2.value;
              if (o2 = p2.index, b2[b2.length - 1] === "/") {
                const n3 = o2 - b2.length;
                b2 = b2.substring(0, b2.length - 1);
                const s3 = g(b2, e2);
                if (s3 !== true)
                  return x2(s3.err.code, s3.err.msg, N(t3, n3 + s3.err.line));
                i3 = true;
              } else if (d2) {
                if (!p2.tagClosed)
                  return x2("InvalidTag", "Closing tag '" + f2 + "' doesn't have proper closing.", N(t3, o2));
                if (b2.trim().length > 0)
                  return x2("InvalidTag", "Closing tag '" + f2 + "' can't have attributes or invalid starting.", N(t3, a2));
                if (n2.length === 0)
                  return x2("InvalidTag", "Closing tag '" + f2 + "' has not been opened.", N(t3, a2));
                {
                  const e3 = n2.pop();
                  if (f2 !== e3.tagName) {
                    let n3 = N(t3, e3.tagStartPos);
                    return x2("InvalidTag", "Expected closing tag '" + e3.tagName + "' (opened in line " + n3.line + ", col " + n3.col + ") instead of closing tag '" + f2 + "'.", N(t3, a2));
                  }
                  n2.length == 0 && (s2 = true);
                }
              } else {
                const r2 = g(b2, e2);
                if (r2 !== true)
                  return x2(r2.err.code, r2.err.msg, N(t3, o2 - b2.length + r2.err.line));
                if (s2 === true)
                  return x2("InvalidXml", "Multiple possible root nodes found.", N(t3, o2));
                e2.unpairedTags.indexOf(f2) !== -1 || n2.push({ tagName: f2, tagStartPos: a2 }), i3 = true;
              }
              for (o2++;o2 < t3.length; o2++)
                if (t3[o2] === "<") {
                  if (t3[o2 + 1] === "!") {
                    o2++, o2 = h(t3, o2);
                    continue;
                  }
                  if (t3[o2 + 1] !== "?")
                    break;
                  if (o2 = u(t3, ++o2), o2.err)
                    return o2;
                } else if (t3[o2] === "&") {
                  const e3 = m(t3, o2);
                  if (e3 == -1)
                    return x2("InvalidChar", "char '&' is not expected.", N(t3, o2));
                  o2 = e3;
                } else if (s2 === true && !l(t3[o2]))
                  return x2("InvalidXml", "Extra text at the end", N(t3, o2));
              t3[o2] === "<" && o2--;
            }
          }
        }
      return i3 ? n2.length == 1 ? x2("InvalidTag", "Unclosed tag '" + n2[0].tagName + "'.", N(t3, n2[0].tagStartPos)) : !(n2.length > 0) || x2("InvalidXml", "Invalid '" + JSON.stringify(n2.map((t4) => t4.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 }) : x2("InvalidXml", "Start tag expected.", 1);
    }
    function l(t3) {
      return t3 === " " || t3 === "\t" || t3 === `
` || t3 === "\r";
    }
    function u(t3, e2) {
      const n2 = e2;
      for (;e2 < t3.length; e2++)
        if (t3[e2] != "?" && t3[e2] != " ")
          ;
        else {
          const i3 = t3.substr(n2, e2 - n2);
          if (e2 > 5 && i3 === "xml")
            return x2("InvalidXml", "XML declaration allowed only at the start of the document.", N(t3, e2));
          if (t3[e2] == "?" && t3[e2 + 1] == ">") {
            e2++;
            break;
          }
        }
      return e2;
    }
    function h(t3, e2) {
      if (t3.length > e2 + 5 && t3[e2 + 1] === "-" && t3[e2 + 2] === "-") {
        for (e2 += 3;e2 < t3.length; e2++)
          if (t3[e2] === "-" && t3[e2 + 1] === "-" && t3[e2 + 2] === ">") {
            e2 += 2;
            break;
          }
      } else if (t3.length > e2 + 8 && t3[e2 + 1] === "D" && t3[e2 + 2] === "O" && t3[e2 + 3] === "C" && t3[e2 + 4] === "T" && t3[e2 + 5] === "Y" && t3[e2 + 6] === "P" && t3[e2 + 7] === "E") {
        let n2 = 1;
        for (e2 += 8;e2 < t3.length; e2++)
          if (t3[e2] === "<")
            n2++;
          else if (t3[e2] === ">" && (n2--, n2 === 0))
            break;
      } else if (t3.length > e2 + 9 && t3[e2 + 1] === "[" && t3[e2 + 2] === "C" && t3[e2 + 3] === "D" && t3[e2 + 4] === "A" && t3[e2 + 5] === "T" && t3[e2 + 6] === "A" && t3[e2 + 7] === "[") {
        for (e2 += 8;e2 < t3.length; e2++)
          if (t3[e2] === "]" && t3[e2 + 1] === "]" && t3[e2 + 2] === ">") {
            e2 += 2;
            break;
          }
      }
      return e2;
    }
    const d = '"', f = "'";
    function c(t3, e2) {
      let n2 = "", i3 = "", s2 = false;
      for (;e2 < t3.length; e2++) {
        if (t3[e2] === d || t3[e2] === f)
          i3 === "" ? i3 = t3[e2] : i3 !== t3[e2] || (i3 = "");
        else if (t3[e2] === ">" && i3 === "") {
          s2 = true;
          break;
        }
        n2 += t3[e2];
      }
      return i3 === "" && { value: n2, index: e2, tagClosed: s2 };
    }
    const p = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function g(t3, e2) {
      const n2 = s(t3, p), i3 = {};
      for (let t4 = 0;t4 < n2.length; t4++) {
        if (n2[t4][1].length === 0)
          return x2("InvalidAttr", "Attribute '" + n2[t4][2] + "' has no space in starting.", E(n2[t4]));
        if (n2[t4][3] !== undefined && n2[t4][4] === undefined)
          return x2("InvalidAttr", "Attribute '" + n2[t4][2] + "' is without value.", E(n2[t4]));
        if (n2[t4][3] === undefined && !e2.allowBooleanAttributes)
          return x2("InvalidAttr", "boolean attribute '" + n2[t4][2] + "' is not allowed.", E(n2[t4]));
        const s2 = n2[t4][2];
        if (!b(s2))
          return x2("InvalidAttr", "Attribute '" + s2 + "' is an invalid name.", E(n2[t4]));
        if (i3.hasOwnProperty(s2))
          return x2("InvalidAttr", "Attribute '" + s2 + "' is repeated.", E(n2[t4]));
        i3[s2] = 1;
      }
      return true;
    }
    function m(t3, e2) {
      if (t3[++e2] === ";")
        return -1;
      if (t3[e2] === "#")
        return function(t4, e3) {
          let n3 = /\d/;
          for (t4[e3] === "x" && (e3++, n3 = /[\da-fA-F]/);e3 < t4.length; e3++) {
            if (t4[e3] === ";")
              return e3;
            if (!t4[e3].match(n3))
              break;
          }
          return -1;
        }(t3, ++e2);
      let n2 = 0;
      for (;e2 < t3.length; e2++, n2++)
        if (!(t3[e2].match(/\w/) && n2 < 20)) {
          if (t3[e2] === ";")
            break;
          return -1;
        }
      return e2;
    }
    function x2(t3, e2, n2) {
      return { err: { code: t3, msg: e2, line: n2.line || n2, col: n2.col } };
    }
    function b(t3) {
      return r(t3);
    }
    function N(t3, e2) {
      const n2 = t3.substring(0, e2).split(/\r?\n/);
      return { line: n2.length, col: n2[n2.length - 1].length + 1 };
    }
    function E(t3) {
      return t3.startIndex + t3[1].length;
    }
    const v = { preserveOrder: false, attributeNamePrefix: "@_", attributesGroupName: false, textNodeName: "#text", ignoreAttributes: true, removeNSPrefix: false, allowBooleanAttributes: false, parseTagValue: true, parseAttributeValue: false, trimValues: true, cdataPropName: false, numberParseOptions: { hex: true, leadingZeros: true, eNotation: true }, tagValueProcessor: function(t3, e2) {
      return e2;
    }, attributeValueProcessor: function(t3, e2) {
      return e2;
    }, stopNodes: [], alwaysCreateTextNode: false, isArray: () => false, commentPropName: false, unpairedTags: [], processEntities: true, htmlEntities: false, ignoreDeclaration: false, ignorePiTags: false, transformTagName: false, transformAttributeName: false, updateTag: function(t3, e2, n2) {
      return t3;
    }, captureMetaData: false };
    let y;
    y = typeof Symbol != "function" ? "@@xmlMetadata" : Symbol("XML Node Metadata");

    class T2 {
      constructor(t3) {
        this.tagname = t3, this.child = [], this[":@"] = {};
      }
      add(t3, e2) {
        t3 === "__proto__" && (t3 = "#__proto__"), this.child.push({ [t3]: e2 });
      }
      addChild(t3, e2) {
        t3.tagname === "__proto__" && (t3.tagname = "#__proto__"), t3[":@"] && Object.keys(t3[":@"]).length > 0 ? this.child.push({ [t3.tagname]: t3.child, ":@": t3[":@"] }) : this.child.push({ [t3.tagname]: t3.child }), e2 !== undefined && (this.child[this.child.length - 1][y] = { startIndex: e2 });
      }
      static getMetaDataSymbol() {
        return y;
      }
    }
    function w(t3, e2) {
      const n2 = {};
      if (t3[e2 + 3] !== "O" || t3[e2 + 4] !== "C" || t3[e2 + 5] !== "T" || t3[e2 + 6] !== "Y" || t3[e2 + 7] !== "P" || t3[e2 + 8] !== "E")
        throw new Error("Invalid Tag instead of DOCTYPE");
      {
        e2 += 9;
        let i3 = 1, s2 = false, r2 = false, o2 = "";
        for (;e2 < t3.length; e2++)
          if (t3[e2] !== "<" || r2)
            if (t3[e2] === ">") {
              if (r2 ? t3[e2 - 1] === "-" && t3[e2 - 2] === "-" && (r2 = false, i3--) : i3--, i3 === 0)
                break;
            } else
              t3[e2] === "[" ? s2 = true : o2 += t3[e2];
          else {
            if (s2 && C(t3, "!ENTITY", e2)) {
              let i4, s3;
              e2 += 7, [i4, s3, e2] = O(t3, e2 + 1), s3.indexOf("&") === -1 && (n2[i4] = { regx: RegExp(`&${i4};`, "g"), val: s3 });
            } else if (s2 && C(t3, "!ELEMENT", e2)) {
              e2 += 8;
              const { index: n3 } = S(t3, e2 + 1);
              e2 = n3;
            } else if (s2 && C(t3, "!ATTLIST", e2))
              e2 += 8;
            else if (s2 && C(t3, "!NOTATION", e2)) {
              e2 += 9;
              const { index: n3 } = A(t3, e2 + 1);
              e2 = n3;
            } else {
              if (!C(t3, "!--", e2))
                throw new Error("Invalid DOCTYPE");
              r2 = true;
            }
            i3++, o2 = "";
          }
        if (i3 !== 0)
          throw new Error("Unclosed DOCTYPE");
      }
      return { entities: n2, i: e2 };
    }
    const P = (t3, e2) => {
      for (;e2 < t3.length && /\s/.test(t3[e2]); )
        e2++;
      return e2;
    };
    function O(t3, e2) {
      e2 = P(t3, e2);
      let n2 = "";
      for (;e2 < t3.length && !/\s/.test(t3[e2]) && t3[e2] !== '"' && t3[e2] !== "'"; )
        n2 += t3[e2], e2++;
      if ($2(n2), e2 = P(t3, e2), t3.substring(e2, e2 + 6).toUpperCase() === "SYSTEM")
        throw new Error("External entities are not supported");
      if (t3[e2] === "%")
        throw new Error("Parameter entities are not supported");
      let i3 = "";
      return [e2, i3] = I(t3, e2, "entity"), [n2, i3, --e2];
    }
    function A(t3, e2) {
      e2 = P(t3, e2);
      let n2 = "";
      for (;e2 < t3.length && !/\s/.test(t3[e2]); )
        n2 += t3[e2], e2++;
      $2(n2), e2 = P(t3, e2);
      const i3 = t3.substring(e2, e2 + 6).toUpperCase();
      if (i3 !== "SYSTEM" && i3 !== "PUBLIC")
        throw new Error(`Expected SYSTEM or PUBLIC, found "${i3}"`);
      e2 += i3.length, e2 = P(t3, e2);
      let s2 = null, r2 = null;
      if (i3 === "PUBLIC")
        [e2, s2] = I(t3, e2, "publicIdentifier"), t3[e2 = P(t3, e2)] !== '"' && t3[e2] !== "'" || ([e2, r2] = I(t3, e2, "systemIdentifier"));
      else if (i3 === "SYSTEM" && ([e2, r2] = I(t3, e2, "systemIdentifier"), !r2))
        throw new Error("Missing mandatory system identifier for SYSTEM notation");
      return { notationName: n2, publicIdentifier: s2, systemIdentifier: r2, index: --e2 };
    }
    function I(t3, e2, n2) {
      let i3 = "";
      const s2 = t3[e2];
      if (s2 !== '"' && s2 !== "'")
        throw new Error(`Expected quoted string, found "${s2}"`);
      for (e2++;e2 < t3.length && t3[e2] !== s2; )
        i3 += t3[e2], e2++;
      if (t3[e2] !== s2)
        throw new Error(`Unterminated ${n2} value`);
      return [++e2, i3];
    }
    function S(t3, e2) {
      e2 = P(t3, e2);
      let n2 = "";
      for (;e2 < t3.length && !/\s/.test(t3[e2]); )
        n2 += t3[e2], e2++;
      if (!$2(n2))
        throw new Error(`Invalid element name: "${n2}"`);
      let i3 = "";
      if (t3[e2 = P(t3, e2)] === "E" && C(t3, "MPTY", e2))
        e2 += 4;
      else if (t3[e2] === "A" && C(t3, "NY", e2))
        e2 += 2;
      else {
        if (t3[e2] !== "(")
          throw new Error(`Invalid Element Expression, found "${t3[e2]}"`);
        for (e2++;e2 < t3.length && t3[e2] !== ")"; )
          i3 += t3[e2], e2++;
        if (t3[e2] !== ")")
          throw new Error("Unterminated content model");
      }
      return { elementName: n2, contentModel: i3.trim(), index: e2 };
    }
    function C(t3, e2, n2) {
      for (let i3 = 0;i3 < e2.length; i3++)
        if (e2[i3] !== t3[n2 + i3 + 1])
          return false;
      return true;
    }
    function $2(t3) {
      if (r(t3))
        return t3;
      throw new Error(`Invalid entity name ${t3}`);
    }
    const j = /^[-+]?0x[a-fA-F0-9]+$/, D = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/, V = { hex: true, leadingZeros: true, decimalPoint: ".", eNotation: true };
    const M = /^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/;
    function _2(t3) {
      return typeof t3 == "function" ? t3 : Array.isArray(t3) ? (e2) => {
        for (const n2 of t3) {
          if (typeof n2 == "string" && e2 === n2)
            return true;
          if (n2 instanceof RegExp && n2.test(e2))
            return true;
        }
      } : () => false;
    }

    class k2 {
      constructor(t3) {
        this.options = t3, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = { apos: { regex: /&(apos|#39|#x27);/g, val: "'" }, gt: { regex: /&(gt|#62|#x3E);/g, val: ">" }, lt: { regex: /&(lt|#60|#x3C);/g, val: "<" }, quot: { regex: /&(quot|#34|#x22);/g, val: '"' } }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = { space: { regex: /&(nbsp|#160);/g, val: " " }, cent: { regex: /&(cent|#162);/g, val: "\xA2" }, pound: { regex: /&(pound|#163);/g, val: "\xA3" }, yen: { regex: /&(yen|#165);/g, val: "\xA5" }, euro: { regex: /&(euro|#8364);/g, val: "\u20AC" }, copyright: { regex: /&(copy|#169);/g, val: "\xA9" }, reg: { regex: /&(reg|#174);/g, val: "\xAE" }, inr: { regex: /&(inr|#8377);/g, val: "\u20B9" }, num_dec: { regex: /&#([0-9]{1,7});/g, val: (t4, e2) => String.fromCodePoint(Number.parseInt(e2, 10)) }, num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (t4, e2) => String.fromCodePoint(Number.parseInt(e2, 16)) } }, this.addExternalEntities = F, this.parseXml = X, this.parseTextData = L, this.resolveNameSpace = B, this.buildAttributesMap = G, this.isItStopNode = Z, this.replaceEntitiesValue = R, this.readStopNodeData = J, this.saveTextToParentTag = q, this.addChild = Y2, this.ignoreAttributesFn = _2(this.options.ignoreAttributes);
      }
    }
    function F(t3) {
      const e2 = Object.keys(t3);
      for (let n2 = 0;n2 < e2.length; n2++) {
        const i3 = e2[n2];
        this.lastEntities[i3] = { regex: new RegExp("&" + i3 + ";", "g"), val: t3[i3] };
      }
    }
    function L(t3, e2, n2, i3, s2, r2, o2) {
      if (t3 !== undefined && (this.options.trimValues && !i3 && (t3 = t3.trim()), t3.length > 0)) {
        o2 || (t3 = this.replaceEntitiesValue(t3));
        const i4 = this.options.tagValueProcessor(e2, t3, n2, s2, r2);
        return i4 == null ? t3 : typeof i4 != typeof t3 || i4 !== t3 ? i4 : this.options.trimValues || t3.trim() === t3 ? H(t3, this.options.parseTagValue, this.options.numberParseOptions) : t3;
      }
    }
    function B(t3) {
      if (this.options.removeNSPrefix) {
        const e2 = t3.split(":"), n2 = t3.charAt(0) === "/" ? "/" : "";
        if (e2[0] === "xmlns")
          return "";
        e2.length === 2 && (t3 = n2 + e2[1]);
      }
      return t3;
    }
    const U = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function G(t3, e2, n2) {
      if (this.options.ignoreAttributes !== true && typeof t3 == "string") {
        const n3 = s(t3, U), i3 = n3.length, r2 = {};
        for (let t4 = 0;t4 < i3; t4++) {
          const i4 = this.resolveNameSpace(n3[t4][1]);
          if (this.ignoreAttributesFn(i4, e2))
            continue;
          let s2 = n3[t4][4], o2 = this.options.attributeNamePrefix + i4;
          if (i4.length)
            if (this.options.transformAttributeName && (o2 = this.options.transformAttributeName(o2)), o2 === "__proto__" && (o2 = "#__proto__"), s2 !== undefined) {
              this.options.trimValues && (s2 = s2.trim()), s2 = this.replaceEntitiesValue(s2);
              const t5 = this.options.attributeValueProcessor(i4, s2, e2);
              r2[o2] = t5 == null ? s2 : typeof t5 != typeof s2 || t5 !== s2 ? t5 : H(s2, this.options.parseAttributeValue, this.options.numberParseOptions);
            } else
              this.options.allowBooleanAttributes && (r2[o2] = true);
        }
        if (!Object.keys(r2).length)
          return;
        if (this.options.attributesGroupName) {
          const t4 = {};
          return t4[this.options.attributesGroupName] = r2, t4;
        }
        return r2;
      }
    }
    const X = function(t3) {
      t3 = t3.replace(/\r\n?/g, `
`);
      const e2 = new T2("!xml");
      let n2 = e2, i3 = "", s2 = "";
      for (let r2 = 0;r2 < t3.length; r2++)
        if (t3[r2] === "<")
          if (t3[r2 + 1] === "/") {
            const e3 = W(t3, ">", r2, "Closing Tag is not closed.");
            let o2 = t3.substring(r2 + 2, e3).trim();
            if (this.options.removeNSPrefix) {
              const t4 = o2.indexOf(":");
              t4 !== -1 && (o2 = o2.substr(t4 + 1));
            }
            this.options.transformTagName && (o2 = this.options.transformTagName(o2)), n2 && (i3 = this.saveTextToParentTag(i3, n2, s2));
            const a2 = s2.substring(s2.lastIndexOf(".") + 1);
            if (o2 && this.options.unpairedTags.indexOf(o2) !== -1)
              throw new Error(`Unpaired tag can not be used as closing tag: </${o2}>`);
            let l2 = 0;
            a2 && this.options.unpairedTags.indexOf(a2) !== -1 ? (l2 = s2.lastIndexOf(".", s2.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : l2 = s2.lastIndexOf("."), s2 = s2.substring(0, l2), n2 = this.tagsNodeStack.pop(), i3 = "", r2 = e3;
          } else if (t3[r2 + 1] === "?") {
            let e3 = z(t3, r2, false, "?>");
            if (!e3)
              throw new Error("Pi Tag is not closed.");
            if (i3 = this.saveTextToParentTag(i3, n2, s2), this.options.ignoreDeclaration && e3.tagName === "?xml" || this.options.ignorePiTags)
              ;
            else {
              const t4 = new T2(e3.tagName);
              t4.add(this.options.textNodeName, ""), e3.tagName !== e3.tagExp && e3.attrExpPresent && (t4[":@"] = this.buildAttributesMap(e3.tagExp, s2, e3.tagName)), this.addChild(n2, t4, s2, r2);
            }
            r2 = e3.closeIndex + 1;
          } else if (t3.substr(r2 + 1, 3) === "!--") {
            const e3 = W(t3, "-->", r2 + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const o2 = t3.substring(r2 + 4, e3 - 2);
              i3 = this.saveTextToParentTag(i3, n2, s2), n2.add(this.options.commentPropName, [{ [this.options.textNodeName]: o2 }]);
            }
            r2 = e3;
          } else if (t3.substr(r2 + 1, 2) === "!D") {
            const e3 = w(t3, r2);
            this.docTypeEntities = e3.entities, r2 = e3.i;
          } else if (t3.substr(r2 + 1, 2) === "![") {
            const e3 = W(t3, "]]>", r2, "CDATA is not closed.") - 2, o2 = t3.substring(r2 + 9, e3);
            i3 = this.saveTextToParentTag(i3, n2, s2);
            let a2 = this.parseTextData(o2, n2.tagname, s2, true, false, true, true);
            a2 == null && (a2 = ""), this.options.cdataPropName ? n2.add(this.options.cdataPropName, [{ [this.options.textNodeName]: o2 }]) : n2.add(this.options.textNodeName, a2), r2 = e3 + 2;
          } else {
            let o2 = z(t3, r2, this.options.removeNSPrefix), a2 = o2.tagName;
            const l2 = o2.rawTagName;
            let { tagExp: u2, attrExpPresent: h2, closeIndex: d2 } = o2;
            this.options.transformTagName && (a2 = this.options.transformTagName(a2)), n2 && i3 && n2.tagname !== "!xml" && (i3 = this.saveTextToParentTag(i3, n2, s2, false));
            const f2 = n2;
            f2 && this.options.unpairedTags.indexOf(f2.tagname) !== -1 && (n2 = this.tagsNodeStack.pop(), s2 = s2.substring(0, s2.lastIndexOf("."))), a2 !== e2.tagname && (s2 += s2 ? "." + a2 : a2);
            const c2 = r2;
            if (this.isItStopNode(this.options.stopNodes, s2, a2)) {
              let e3 = "";
              if (u2.length > 0 && u2.lastIndexOf("/") === u2.length - 1)
                a2[a2.length - 1] === "/" ? (a2 = a2.substr(0, a2.length - 1), s2 = s2.substr(0, s2.length - 1), u2 = a2) : u2 = u2.substr(0, u2.length - 1), r2 = o2.closeIndex;
              else if (this.options.unpairedTags.indexOf(a2) !== -1)
                r2 = o2.closeIndex;
              else {
                const n3 = this.readStopNodeData(t3, l2, d2 + 1);
                if (!n3)
                  throw new Error(`Unexpected end of ${l2}`);
                r2 = n3.i, e3 = n3.tagContent;
              }
              const i4 = new T2(a2);
              a2 !== u2 && h2 && (i4[":@"] = this.buildAttributesMap(u2, s2, a2)), e3 && (e3 = this.parseTextData(e3, a2, s2, true, h2, true, true)), s2 = s2.substr(0, s2.lastIndexOf(".")), i4.add(this.options.textNodeName, e3), this.addChild(n2, i4, s2, c2);
            } else {
              if (u2.length > 0 && u2.lastIndexOf("/") === u2.length - 1) {
                a2[a2.length - 1] === "/" ? (a2 = a2.substr(0, a2.length - 1), s2 = s2.substr(0, s2.length - 1), u2 = a2) : u2 = u2.substr(0, u2.length - 1), this.options.transformTagName && (a2 = this.options.transformTagName(a2));
                const t4 = new T2(a2);
                a2 !== u2 && h2 && (t4[":@"] = this.buildAttributesMap(u2, s2, a2)), this.addChild(n2, t4, s2, c2), s2 = s2.substr(0, s2.lastIndexOf("."));
              } else {
                const t4 = new T2(a2);
                this.tagsNodeStack.push(n2), a2 !== u2 && h2 && (t4[":@"] = this.buildAttributesMap(u2, s2, a2)), this.addChild(n2, t4, s2, c2), n2 = t4;
              }
              i3 = "", r2 = d2;
            }
          }
        else
          i3 += t3[r2];
      return e2.child;
    };
    function Y2(t3, e2, n2, i3) {
      this.options.captureMetaData || (i3 = undefined);
      const s2 = this.options.updateTag(e2.tagname, n2, e2[":@"]);
      s2 === false || (typeof s2 == "string" ? (e2.tagname = s2, t3.addChild(e2, i3)) : t3.addChild(e2, i3));
    }
    const R = function(t3) {
      if (this.options.processEntities) {
        for (let e2 in this.docTypeEntities) {
          const n2 = this.docTypeEntities[e2];
          t3 = t3.replace(n2.regx, n2.val);
        }
        for (let e2 in this.lastEntities) {
          const n2 = this.lastEntities[e2];
          t3 = t3.replace(n2.regex, n2.val);
        }
        if (this.options.htmlEntities)
          for (let e2 in this.htmlEntities) {
            const n2 = this.htmlEntities[e2];
            t3 = t3.replace(n2.regex, n2.val);
          }
        t3 = t3.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return t3;
    };
    function q(t3, e2, n2, i3) {
      return t3 && (i3 === undefined && (i3 = e2.child.length === 0), (t3 = this.parseTextData(t3, e2.tagname, n2, false, !!e2[":@"] && Object.keys(e2[":@"]).length !== 0, i3)) !== undefined && t3 !== "" && e2.add(this.options.textNodeName, t3), t3 = ""), t3;
    }
    function Z(t3, e2, n2) {
      const i3 = "*." + n2;
      for (const n3 in t3) {
        const s2 = t3[n3];
        if (i3 === s2 || e2 === s2)
          return true;
      }
      return false;
    }
    function W(t3, e2, n2, i3) {
      const s2 = t3.indexOf(e2, n2);
      if (s2 === -1)
        throw new Error(i3);
      return s2 + e2.length - 1;
    }
    function z(t3, e2, n2, i3 = ">") {
      const s2 = function(t4, e3, n3 = ">") {
        let i4, s3 = "";
        for (let r3 = e3;r3 < t4.length; r3++) {
          let e4 = t4[r3];
          if (i4)
            e4 === i4 && (i4 = "");
          else if (e4 === '"' || e4 === "'")
            i4 = e4;
          else if (e4 === n3[0]) {
            if (!n3[1])
              return { data: s3, index: r3 };
            if (t4[r3 + 1] === n3[1])
              return { data: s3, index: r3 };
          } else
            e4 === "\t" && (e4 = " ");
          s3 += e4;
        }
      }(t3, e2 + 1, i3);
      if (!s2)
        return;
      let r2 = s2.data;
      const o2 = s2.index, a2 = r2.search(/\s/);
      let l2 = r2, u2 = true;
      a2 !== -1 && (l2 = r2.substring(0, a2), r2 = r2.substring(a2 + 1).trimStart());
      const h2 = l2;
      if (n2) {
        const t4 = l2.indexOf(":");
        t4 !== -1 && (l2 = l2.substr(t4 + 1), u2 = l2 !== s2.data.substr(t4 + 1));
      }
      return { tagName: l2, tagExp: r2, closeIndex: o2, attrExpPresent: u2, rawTagName: h2 };
    }
    function J(t3, e2, n2) {
      const i3 = n2;
      let s2 = 1;
      for (;n2 < t3.length; n2++)
        if (t3[n2] === "<")
          if (t3[n2 + 1] === "/") {
            const r2 = W(t3, ">", n2, `${e2} is not closed`);
            if (t3.substring(n2 + 2, r2).trim() === e2 && (s2--, s2 === 0))
              return { tagContent: t3.substring(i3, n2), i: r2 };
            n2 = r2;
          } else if (t3[n2 + 1] === "?")
            n2 = W(t3, "?>", n2 + 1, "StopNode is not closed.");
          else if (t3.substr(n2 + 1, 3) === "!--")
            n2 = W(t3, "-->", n2 + 3, "StopNode is not closed.");
          else if (t3.substr(n2 + 1, 2) === "![")
            n2 = W(t3, "]]>", n2, "StopNode is not closed.") - 2;
          else {
            const i4 = z(t3, n2, ">");
            i4 && ((i4 && i4.tagName) === e2 && i4.tagExp[i4.tagExp.length - 1] !== "/" && s2++, n2 = i4.closeIndex);
          }
    }
    function H(t3, e2, n2) {
      if (e2 && typeof t3 == "string") {
        const e3 = t3.trim();
        return e3 === "true" || e3 !== "false" && function(t4, e4 = {}) {
          if (e4 = Object.assign({}, V, e4), !t4 || typeof t4 != "string")
            return t4;
          let n3 = t4.trim();
          if (e4.skipLike !== undefined && e4.skipLike.test(n3))
            return t4;
          if (t4 === "0")
            return 0;
          if (e4.hex && j.test(n3))
            return function(t5) {
              if (parseInt)
                return parseInt(t5, 16);
              if (Number.parseInt)
                return Number.parseInt(t5, 16);
              if (window && window.parseInt)
                return window.parseInt(t5, 16);
              throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
            }(n3);
          if (n3.search(/.+[eE].+/) !== -1)
            return function(t5, e5, n4) {
              if (!n4.eNotation)
                return t5;
              const i4 = e5.match(M);
              if (i4) {
                let s2 = i4[1] || "";
                const r2 = i4[3].indexOf("e") === -1 ? "E" : "e", o2 = i4[2], a2 = s2 ? t5[o2.length + 1] === r2 : t5[o2.length] === r2;
                return o2.length > 1 && a2 ? t5 : o2.length !== 1 || !i4[3].startsWith(`.${r2}`) && i4[3][0] !== r2 ? n4.leadingZeros && !a2 ? (e5 = (i4[1] || "") + i4[3], Number(e5)) : t5 : Number(e5);
              }
              return t5;
            }(t4, n3, e4);
          {
            const s2 = D.exec(n3);
            if (s2) {
              const r2 = s2[1] || "", o2 = s2[2];
              let a2 = (i3 = s2[3]) && i3.indexOf(".") !== -1 ? ((i3 = i3.replace(/0+$/, "")) === "." ? i3 = "0" : i3[0] === "." ? i3 = "0" + i3 : i3[i3.length - 1] === "." && (i3 = i3.substring(0, i3.length - 1)), i3) : i3;
              const l2 = r2 ? t4[o2.length + 1] === "." : t4[o2.length] === ".";
              if (!e4.leadingZeros && (o2.length > 1 || o2.length === 1 && !l2))
                return t4;
              {
                const i4 = Number(n3), s3 = String(i4);
                if (i4 === 0 || i4 === -0)
                  return i4;
                if (s3.search(/[eE]/) !== -1)
                  return e4.eNotation ? i4 : t4;
                if (n3.indexOf(".") !== -1)
                  return s3 === "0" || s3 === a2 || s3 === `${r2}${a2}` ? i4 : t4;
                let l3 = o2 ? a2 : n3;
                return o2 ? l3 === s3 || r2 + l3 === s3 ? i4 : t4 : l3 === s3 || l3 === r2 + s3 ? i4 : t4;
              }
            }
            return t4;
          }
          var i3;
        }(t3, n2);
      }
      return t3 !== undefined ? t3 : "";
    }
    const K = T2.getMetaDataSymbol();
    function Q(t3, e2) {
      return tt(t3, e2);
    }
    function tt(t3, e2, n2) {
      let i3;
      const s2 = {};
      for (let r2 = 0;r2 < t3.length; r2++) {
        const o2 = t3[r2], a2 = et2(o2);
        let l2 = "";
        if (l2 = n2 === undefined ? a2 : n2 + "." + a2, a2 === e2.textNodeName)
          i3 === undefined ? i3 = o2[a2] : i3 += "" + o2[a2];
        else {
          if (a2 === undefined)
            continue;
          if (o2[a2]) {
            let t4 = tt(o2[a2], e2, l2);
            const n3 = it(t4, e2);
            o2[K] !== undefined && (t4[K] = o2[K]), o2[":@"] ? nt(t4, o2[":@"], l2, e2) : Object.keys(t4).length !== 1 || t4[e2.textNodeName] === undefined || e2.alwaysCreateTextNode ? Object.keys(t4).length === 0 && (e2.alwaysCreateTextNode ? t4[e2.textNodeName] = "" : t4 = "") : t4 = t4[e2.textNodeName], s2[a2] !== undefined && s2.hasOwnProperty(a2) ? (Array.isArray(s2[a2]) || (s2[a2] = [s2[a2]]), s2[a2].push(t4)) : e2.isArray(a2, l2, n3) ? s2[a2] = [t4] : s2[a2] = t4;
          }
        }
      }
      return typeof i3 == "string" ? i3.length > 0 && (s2[e2.textNodeName] = i3) : i3 !== undefined && (s2[e2.textNodeName] = i3), s2;
    }
    function et2(t3) {
      const e2 = Object.keys(t3);
      for (let t4 = 0;t4 < e2.length; t4++) {
        const n2 = e2[t4];
        if (n2 !== ":@")
          return n2;
      }
    }
    function nt(t3, e2, n2, i3) {
      if (e2) {
        const s2 = Object.keys(e2), r2 = s2.length;
        for (let o2 = 0;o2 < r2; o2++) {
          const r3 = s2[o2];
          i3.isArray(r3, n2 + "." + r3, true, true) ? t3[r3] = [e2[r3]] : t3[r3] = e2[r3];
        }
      }
    }
    function it(t3, e2) {
      const { textNodeName: n2 } = e2, i3 = Object.keys(t3).length;
      return i3 === 0 || !(i3 !== 1 || !t3[n2] && typeof t3[n2] != "boolean" && t3[n2] !== 0);
    }

    class st {
      constructor(t3) {
        this.externalEntities = {}, this.options = function(t4) {
          return Object.assign({}, v, t4);
        }(t3);
      }
      parse(t3, e2) {
        if (typeof t3 == "string")
          ;
        else {
          if (!t3.toString)
            throw new Error("XML data is accepted in String or Bytes[] form.");
          t3 = t3.toString();
        }
        if (e2) {
          e2 === true && (e2 = {});
          const n3 = a(t3, e2);
          if (n3 !== true)
            throw Error(`${n3.err.msg}:${n3.err.line}:${n3.err.col}`);
        }
        const n2 = new k2(this.options);
        n2.addExternalEntities(this.externalEntities);
        const i3 = n2.parseXml(t3);
        return this.options.preserveOrder || i3 === undefined ? i3 : Q(i3, this.options);
      }
      addEntity(t3, e2) {
        if (e2.indexOf("&") !== -1)
          throw new Error("Entity value can't have '&'");
        if (t3.indexOf("&") !== -1 || t3.indexOf(";") !== -1)
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        if (e2 === "&")
          throw new Error("An entity with value '&' is not permitted");
        this.externalEntities[t3] = e2;
      }
      static getMetaDataSymbol() {
        return T2.getMetaDataSymbol();
      }
    }
    function rt(t3, e2) {
      let n2 = "";
      return e2.format && e2.indentBy.length > 0 && (n2 = `
`), ot(t3, e2, "", n2);
    }
    function ot(t3, e2, n2, i3) {
      let s2 = "", r2 = false;
      for (let o2 = 0;o2 < t3.length; o2++) {
        const a2 = t3[o2], l2 = at(a2);
        if (l2 === undefined)
          continue;
        let u2 = "";
        if (u2 = n2.length === 0 ? l2 : `${n2}.${l2}`, l2 === e2.textNodeName) {
          let t4 = a2[l2];
          ut(u2, e2) || (t4 = e2.tagValueProcessor(l2, t4), t4 = ht(t4, e2)), r2 && (s2 += i3), s2 += t4, r2 = false;
          continue;
        }
        if (l2 === e2.cdataPropName) {
          r2 && (s2 += i3), s2 += `<![CDATA[${a2[l2][0][e2.textNodeName]}]]>`, r2 = false;
          continue;
        }
        if (l2 === e2.commentPropName) {
          s2 += i3 + `<!--${a2[l2][0][e2.textNodeName]}-->`, r2 = true;
          continue;
        }
        if (l2[0] === "?") {
          const t4 = lt(a2[":@"], e2), n3 = l2 === "?xml" ? "" : i3;
          let o3 = a2[l2][0][e2.textNodeName];
          o3 = o3.length !== 0 ? " " + o3 : "", s2 += n3 + `<${l2}${o3}${t4}?>`, r2 = true;
          continue;
        }
        let h2 = i3;
        h2 !== "" && (h2 += e2.indentBy);
        const d2 = i3 + `<${l2}${lt(a2[":@"], e2)}`, f2 = ot(a2[l2], e2, u2, h2);
        e2.unpairedTags.indexOf(l2) !== -1 ? e2.suppressUnpairedNode ? s2 += d2 + ">" : s2 += d2 + "/>" : f2 && f2.length !== 0 || !e2.suppressEmptyNode ? f2 && f2.endsWith(">") ? s2 += d2 + `>${f2}${i3}</${l2}>` : (s2 += d2 + ">", f2 && i3 !== "" && (f2.includes("/>") || f2.includes("</")) ? s2 += i3 + e2.indentBy + f2 + i3 : s2 += f2, s2 += `</${l2}>`) : s2 += d2 + "/>", r2 = true;
      }
      return s2;
    }
    function at(t3) {
      const e2 = Object.keys(t3);
      for (let n2 = 0;n2 < e2.length; n2++) {
        const i3 = e2[n2];
        if (t3.hasOwnProperty(i3) && i3 !== ":@")
          return i3;
      }
    }
    function lt(t3, e2) {
      let n2 = "";
      if (t3 && !e2.ignoreAttributes)
        for (let i3 in t3) {
          if (!t3.hasOwnProperty(i3))
            continue;
          let s2 = e2.attributeValueProcessor(i3, t3[i3]);
          s2 = ht(s2, e2), s2 === true && e2.suppressBooleanAttributes ? n2 += ` ${i3.substr(e2.attributeNamePrefix.length)}` : n2 += ` ${i3.substr(e2.attributeNamePrefix.length)}="${s2}"`;
        }
      return n2;
    }
    function ut(t3, e2) {
      let n2 = (t3 = t3.substr(0, t3.length - e2.textNodeName.length - 1)).substr(t3.lastIndexOf(".") + 1);
      for (let i3 in e2.stopNodes)
        if (e2.stopNodes[i3] === t3 || e2.stopNodes[i3] === "*." + n2)
          return true;
      return false;
    }
    function ht(t3, e2) {
      if (t3 && t3.length > 0 && e2.processEntities)
        for (let n2 = 0;n2 < e2.entities.length; n2++) {
          const i3 = e2.entities[n2];
          t3 = t3.replace(i3.regex, i3.val);
        }
      return t3;
    }
    const dt = { attributeNamePrefix: "@_", attributesGroupName: false, textNodeName: "#text", ignoreAttributes: true, cdataPropName: false, format: false, indentBy: "  ", suppressEmptyNode: false, suppressUnpairedNode: true, suppressBooleanAttributes: true, tagValueProcessor: function(t3, e2) {
      return e2;
    }, attributeValueProcessor: function(t3, e2) {
      return e2;
    }, preserveOrder: false, commentPropName: false, unpairedTags: [], entities: [{ regex: new RegExp("&", "g"), val: "&amp;" }, { regex: new RegExp(">", "g"), val: "&gt;" }, { regex: new RegExp("<", "g"), val: "&lt;" }, { regex: new RegExp("'", "g"), val: "&apos;" }, { regex: new RegExp('"', "g"), val: "&quot;" }], processEntities: true, stopNodes: [], oneListGroup: false };
    function ft(t3) {
      this.options = Object.assign({}, dt, t3), this.options.ignoreAttributes === true || this.options.attributesGroupName ? this.isAttribute = function() {
        return false;
      } : (this.ignoreAttributesFn = _2(this.options.ignoreAttributes), this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = gt), this.processTextOrObjNode = ct, this.options.format ? (this.indentate = pt, this.tagEndChar = `>
`, this.newLine = `
`) : (this.indentate = function() {
        return "";
      }, this.tagEndChar = ">", this.newLine = "");
    }
    function ct(t3, e2, n2, i3) {
      const s2 = this.j2x(t3, n2 + 1, i3.concat(e2));
      return t3[this.options.textNodeName] !== undefined && Object.keys(t3).length === 1 ? this.buildTextValNode(t3[this.options.textNodeName], e2, s2.attrStr, n2) : this.buildObjectNode(s2.val, e2, s2.attrStr, n2);
    }
    function pt(t3) {
      return this.options.indentBy.repeat(t3);
    }
    function gt(t3) {
      return !(!t3.startsWith(this.options.attributeNamePrefix) || t3 === this.options.textNodeName) && t3.substr(this.attrPrefixLen);
    }
    ft.prototype.build = function(t3) {
      return this.options.preserveOrder ? rt(t3, this.options) : (Array.isArray(t3) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (t3 = { [this.options.arrayNodeName]: t3 }), this.j2x(t3, 0, []).val);
    }, ft.prototype.j2x = function(t3, e2, n2) {
      let i3 = "", s2 = "";
      const r2 = n2.join(".");
      for (let o2 in t3)
        if (Object.prototype.hasOwnProperty.call(t3, o2))
          if (t3[o2] === undefined)
            this.isAttribute(o2) && (s2 += "");
          else if (t3[o2] === null)
            this.isAttribute(o2) || o2 === this.options.cdataPropName ? s2 += "" : o2[0] === "?" ? s2 += this.indentate(e2) + "<" + o2 + "?" + this.tagEndChar : s2 += this.indentate(e2) + "<" + o2 + "/" + this.tagEndChar;
          else if (t3[o2] instanceof Date)
            s2 += this.buildTextValNode(t3[o2], o2, "", e2);
          else if (typeof t3[o2] != "object") {
            const n3 = this.isAttribute(o2);
            if (n3 && !this.ignoreAttributesFn(n3, r2))
              i3 += this.buildAttrPairStr(n3, "" + t3[o2]);
            else if (!n3)
              if (o2 === this.options.textNodeName) {
                let e3 = this.options.tagValueProcessor(o2, "" + t3[o2]);
                s2 += this.replaceEntitiesValue(e3);
              } else
                s2 += this.buildTextValNode(t3[o2], o2, "", e2);
          } else if (Array.isArray(t3[o2])) {
            const i4 = t3[o2].length;
            let r3 = "", a2 = "";
            for (let l2 = 0;l2 < i4; l2++) {
              const i5 = t3[o2][l2];
              if (i5 === undefined)
                ;
              else if (i5 === null)
                o2[0] === "?" ? s2 += this.indentate(e2) + "<" + o2 + "?" + this.tagEndChar : s2 += this.indentate(e2) + "<" + o2 + "/" + this.tagEndChar;
              else if (typeof i5 == "object")
                if (this.options.oneListGroup) {
                  const t4 = this.j2x(i5, e2 + 1, n2.concat(o2));
                  r3 += t4.val, this.options.attributesGroupName && i5.hasOwnProperty(this.options.attributesGroupName) && (a2 += t4.attrStr);
                } else
                  r3 += this.processTextOrObjNode(i5, o2, e2, n2);
              else if (this.options.oneListGroup) {
                let t4 = this.options.tagValueProcessor(o2, i5);
                t4 = this.replaceEntitiesValue(t4), r3 += t4;
              } else
                r3 += this.buildTextValNode(i5, o2, "", e2);
            }
            this.options.oneListGroup && (r3 = this.buildObjectNode(r3, o2, a2, e2)), s2 += r3;
          } else if (this.options.attributesGroupName && o2 === this.options.attributesGroupName) {
            const e3 = Object.keys(t3[o2]), n3 = e3.length;
            for (let s3 = 0;s3 < n3; s3++)
              i3 += this.buildAttrPairStr(e3[s3], "" + t3[o2][e3[s3]]);
          } else
            s2 += this.processTextOrObjNode(t3[o2], o2, e2, n2);
      return { attrStr: i3, val: s2 };
    }, ft.prototype.buildAttrPairStr = function(t3, e2) {
      return e2 = this.options.attributeValueProcessor(t3, "" + e2), e2 = this.replaceEntitiesValue(e2), this.options.suppressBooleanAttributes && e2 === "true" ? " " + t3 : " " + t3 + '="' + e2 + '"';
    }, ft.prototype.buildObjectNode = function(t3, e2, n2, i3) {
      if (t3 === "")
        return e2[0] === "?" ? this.indentate(i3) + "<" + e2 + n2 + "?" + this.tagEndChar : this.indentate(i3) + "<" + e2 + n2 + this.closeTag(e2) + this.tagEndChar;
      {
        let s2 = "</" + e2 + this.tagEndChar, r2 = "";
        return e2[0] === "?" && (r2 = "?", s2 = ""), !n2 && n2 !== "" || t3.indexOf("<") !== -1 ? this.options.commentPropName !== false && e2 === this.options.commentPropName && r2.length === 0 ? this.indentate(i3) + `<!--${t3}-->` + this.newLine : this.indentate(i3) + "<" + e2 + n2 + r2 + this.tagEndChar + t3 + this.indentate(i3) + s2 : this.indentate(i3) + "<" + e2 + n2 + r2 + ">" + t3 + s2;
      }
    }, ft.prototype.closeTag = function(t3) {
      let e2 = "";
      return this.options.unpairedTags.indexOf(t3) !== -1 ? this.options.suppressUnpairedNode || (e2 = "/") : e2 = this.options.suppressEmptyNode ? "/" : `></${t3}`, e2;
    }, ft.prototype.buildTextValNode = function(t3, e2, n2, i3) {
      if (this.options.cdataPropName !== false && e2 === this.options.cdataPropName)
        return this.indentate(i3) + `<![CDATA[${t3}]]>` + this.newLine;
      if (this.options.commentPropName !== false && e2 === this.options.commentPropName)
        return this.indentate(i3) + `<!--${t3}-->` + this.newLine;
      if (e2[0] === "?")
        return this.indentate(i3) + "<" + e2 + n2 + "?" + this.tagEndChar;
      {
        let s2 = this.options.tagValueProcessor(e2, t3);
        return s2 = this.replaceEntitiesValue(s2), s2 === "" ? this.indentate(i3) + "<" + e2 + n2 + this.closeTag(e2) + this.tagEndChar : this.indentate(i3) + "<" + e2 + n2 + ">" + s2 + "</" + e2 + this.tagEndChar;
      }
    }, ft.prototype.replaceEntitiesValue = function(t3) {
      if (t3 && t3.length > 0 && this.options.processEntities)
        for (let e2 = 0;e2 < this.options.entities.length; e2++) {
          const n2 = this.options.entities[e2];
          t3 = t3.replace(n2.regex, n2.val);
        }
      return t3;
    };
    const mt = { validate: a };
    module.exports = e;
  })();
});

// node_modules/@aws-sdk/xml-builder/dist-cjs/xml-parser.js
var require_xml_parser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseXML = parseXML;
  var fast_xml_parser_1 = require_fxp();
  var parser = new fast_xml_parser_1.XMLParser({
    attributeNamePrefix: "",
    htmlEntities: true,
    ignoreAttributes: false,
    ignoreDeclaration: true,
    parseTagValue: false,
    trimValues: false,
    tagValueProcessor: (_2, val) => val.trim() === "" && val.includes(`
`) ? "" : undefined
  });
  parser.addEntity("#xD", "\r");
  parser.addEntity("#10", `
`);
  function parseXML(xmlString) {
    return parser.parse(xmlString, true);
  }
});

// node_modules/@aws-sdk/xml-builder/dist-cjs/index.js
var require_dist_cjs29 = __commonJS((exports) => {
  var xmlParser = require_xml_parser();
  function escapeAttribute(value) {
    return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
  }
  function escapeElement(value) {
    return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#x0D;").replace(/\n/g, "&#x0A;").replace(/\u0085/g, "&#x85;").replace(/\u2028/, "&#x2028;");
  }

  class XmlText {
    value;
    constructor(value) {
      this.value = value;
    }
    toString() {
      return escapeElement("" + this.value);
    }
  }

  class XmlNode {
    name;
    children;
    attributes = {};
    static of(name, childText, withName) {
      const node = new XmlNode(name);
      if (childText !== undefined) {
        node.addChildNode(new XmlText(childText));
      }
      if (withName !== undefined) {
        node.withName(withName);
      }
      return node;
    }
    constructor(name, children = []) {
      this.name = name;
      this.children = children;
    }
    withName(name) {
      this.name = name;
      return this;
    }
    addAttribute(name, value) {
      this.attributes[name] = value;
      return this;
    }
    addChildNode(child) {
      this.children.push(child);
      return this;
    }
    removeAttribute(name) {
      delete this.attributes[name];
      return this;
    }
    n(name) {
      this.name = name;
      return this;
    }
    c(child) {
      this.children.push(child);
      return this;
    }
    a(name, value) {
      if (value != null) {
        this.attributes[name] = value;
      }
      return this;
    }
    cc(input, field, withName = field) {
      if (input[field] != null) {
        const node = XmlNode.of(field, input[field]).withName(withName);
        this.c(node);
      }
    }
    l(input, listName, memberName, valueProvider) {
      if (input[listName] != null) {
        const nodes = valueProvider();
        nodes.map((node) => {
          node.withName(memberName);
          this.c(node);
        });
      }
    }
    lc(input, listName, memberName, valueProvider) {
      if (input[listName] != null) {
        const nodes = valueProvider();
        const containerNode = new XmlNode(memberName);
        nodes.map((node) => {
          containerNode.c(node);
        });
        this.c(containerNode);
      }
    }
    toString() {
      const hasChildren = Boolean(this.children.length);
      let xmlText = `<${this.name}`;
      const attributes = this.attributes;
      for (const attributeName of Object.keys(attributes)) {
        const attribute = attributes[attributeName];
        if (attribute != null) {
          xmlText += ` ${attributeName}="${escapeAttribute("" + attribute)}"`;
        }
      }
      return xmlText += !hasChildren ? "/>" : `>${this.children.map((c) => c.toString()).join("")}</${this.name}>`;
    }
  }
  Object.defineProperty(exports, "parseXML", {
    enumerable: true,
    get: function() {
      return xmlParser.parseXML;
    }
  });
  exports.XmlNode = XmlNode;
  exports.XmlText = XmlText;
});

// node_modules/@aws-sdk/core/dist-cjs/index.js
var require_dist_cjs30 = __commonJS((exports) => {
  var protocolHttp = require_dist_cjs3();
  var core2 = require_dist_cjs19();
  var propertyProvider = require_dist_cjs24();
  var client = require_client();
  var signatureV4 = require_dist_cjs25();
  var cbor = require_cbor();
  var schema = require_schema();
  var protocols = require_protocols();
  var serde = require_serde();
  var utilBase64 = require_dist_cjs11();
  var smithyClient = require_dist_cjs28();
  var utilUtf8 = require_dist_cjs10();
  var xmlBuilder = require_dist_cjs29();
  var state = {
    warningEmitted: false
  };
  var emitWarningIfUnsupportedVersion = (version) => {
    if (version && !state.warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 18) {
      state.warningEmitted = true;
      process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js 16.x on January 6, 2025.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/74kJMmI`);
    }
  };
  function setCredentialFeature(credentials, feature, value) {
    if (!credentials.$source) {
      credentials.$source = {};
    }
    credentials.$source[feature] = value;
    return credentials;
  }
  function setFeature(context, feature, value) {
    if (!context.__aws_sdk_context) {
      context.__aws_sdk_context = {
        features: {}
      };
    } else if (!context.__aws_sdk_context.features) {
      context.__aws_sdk_context.features = {};
    }
    context.__aws_sdk_context.features[feature] = value;
  }
  function setTokenFeature(token, feature, value) {
    if (!token.$source) {
      token.$source = {};
    }
    token.$source[feature] = value;
    return token;
  }
  var getDateHeader = (response) => protocolHttp.HttpResponse.isInstance(response) ? response.headers?.date ?? response.headers?.Date : undefined;
  var getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);
  var isClockSkewed = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 300000;
  var getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
    const clockTimeInMs = Date.parse(clockTime);
    if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
      return clockTimeInMs - Date.now();
    }
    return currentSystemClockOffset;
  };
  var throwSigningPropertyError = (name, property) => {
    if (!property) {
      throw new Error(`Property \`${name}\` is not resolved for AWS SDK SigV4Auth`);
    }
    return property;
  };
  var validateSigningProperties = async (signingProperties) => {
    const context = throwSigningPropertyError("context", signingProperties.context);
    const config = throwSigningPropertyError("config", signingProperties.config);
    const authScheme = context.endpointV2?.properties?.authSchemes?.[0];
    const signerFunction = throwSigningPropertyError("signer", config.signer);
    const signer = await signerFunction(authScheme);
    const signingRegion = signingProperties?.signingRegion;
    const signingRegionSet = signingProperties?.signingRegionSet;
    const signingName = signingProperties?.signingName;
    return {
      config,
      signer,
      signingRegion,
      signingRegionSet,
      signingName
    };
  };

  class AwsSdkSigV4Signer {
    async sign(httpRequest, identity, signingProperties) {
      if (!protocolHttp.HttpRequest.isInstance(httpRequest)) {
        throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
      }
      const validatedProps = await validateSigningProperties(signingProperties);
      const { config, signer } = validatedProps;
      let { signingRegion, signingName } = validatedProps;
      const handlerExecutionContext = signingProperties.context;
      if (handlerExecutionContext?.authSchemes?.length ?? 0 > 1) {
        const [first, second] = handlerExecutionContext.authSchemes;
        if (first?.name === "sigv4a" && second?.name === "sigv4") {
          signingRegion = second?.signingRegion ?? signingRegion;
          signingName = second?.signingName ?? signingName;
        }
      }
      const signedRequest = await signer.sign(httpRequest, {
        signingDate: getSkewCorrectedDate(config.systemClockOffset),
        signingRegion,
        signingService: signingName
      });
      return signedRequest;
    }
    errorHandler(signingProperties) {
      return (error) => {
        const serverTime = error.ServerTime ?? getDateHeader(error.$response);
        if (serverTime) {
          const config = throwSigningPropertyError("config", signingProperties.config);
          const initialSystemClockOffset = config.systemClockOffset;
          config.systemClockOffset = getUpdatedSystemClockOffset(serverTime, config.systemClockOffset);
          const clockSkewCorrected = config.systemClockOffset !== initialSystemClockOffset;
          if (clockSkewCorrected && error.$metadata) {
            error.$metadata.clockSkewCorrected = true;
          }
        }
        throw error;
      };
    }
    successHandler(httpResponse, signingProperties) {
      const dateHeader = getDateHeader(httpResponse);
      if (dateHeader) {
        const config = throwSigningPropertyError("config", signingProperties.config);
        config.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, config.systemClockOffset);
      }
    }
  }
  var AWSSDKSigV4Signer = AwsSdkSigV4Signer;

  class AwsSdkSigV4ASigner extends AwsSdkSigV4Signer {
    async sign(httpRequest, identity, signingProperties) {
      if (!protocolHttp.HttpRequest.isInstance(httpRequest)) {
        throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
      }
      const { config, signer, signingRegion, signingRegionSet, signingName } = await validateSigningProperties(signingProperties);
      const configResolvedSigningRegionSet = await config.sigv4aSigningRegionSet?.();
      const multiRegionOverride = (configResolvedSigningRegionSet ?? signingRegionSet ?? [signingRegion]).join(",");
      const signedRequest = await signer.sign(httpRequest, {
        signingDate: getSkewCorrectedDate(config.systemClockOffset),
        signingRegion: multiRegionOverride,
        signingService: signingName
      });
      return signedRequest;
    }
  }
  var getArrayForCommaSeparatedString = (str) => typeof str === "string" && str.length > 0 ? str.split(",").map((item) => item.trim()) : [];
  var getBearerTokenEnvKey = (signingName) => `AWS_BEARER_TOKEN_${signingName.replace(/[\s-]/g, "_").toUpperCase()}`;
  var NODE_AUTH_SCHEME_PREFERENCE_ENV_KEY = "AWS_AUTH_SCHEME_PREFERENCE";
  var NODE_AUTH_SCHEME_PREFERENCE_CONFIG_KEY = "auth_scheme_preference";
  var NODE_AUTH_SCHEME_PREFERENCE_OPTIONS = {
    environmentVariableSelector: (env3, options) => {
      if (options?.signingName) {
        const bearerTokenKey = getBearerTokenEnvKey(options.signingName);
        if (bearerTokenKey in env3)
          return ["httpBearerAuth"];
      }
      if (!(NODE_AUTH_SCHEME_PREFERENCE_ENV_KEY in env3))
        return;
      return getArrayForCommaSeparatedString(env3[NODE_AUTH_SCHEME_PREFERENCE_ENV_KEY]);
    },
    configFileSelector: (profile) => {
      if (!(NODE_AUTH_SCHEME_PREFERENCE_CONFIG_KEY in profile))
        return;
      return getArrayForCommaSeparatedString(profile[NODE_AUTH_SCHEME_PREFERENCE_CONFIG_KEY]);
    },
    default: []
  };
  var resolveAwsSdkSigV4AConfig = (config) => {
    config.sigv4aSigningRegionSet = core2.normalizeProvider(config.sigv4aSigningRegionSet);
    return config;
  };
  var NODE_SIGV4A_CONFIG_OPTIONS = {
    environmentVariableSelector(env3) {
      if (env3.AWS_SIGV4A_SIGNING_REGION_SET) {
        return env3.AWS_SIGV4A_SIGNING_REGION_SET.split(",").map((_2) => _2.trim());
      }
      throw new propertyProvider.ProviderError("AWS_SIGV4A_SIGNING_REGION_SET not set in env.", {
        tryNextLink: true
      });
    },
    configFileSelector(profile) {
      if (profile.sigv4a_signing_region_set) {
        return (profile.sigv4a_signing_region_set ?? "").split(",").map((_2) => _2.trim());
      }
      throw new propertyProvider.ProviderError("sigv4a_signing_region_set not set in profile.", {
        tryNextLink: true
      });
    },
    default: undefined
  };
  var resolveAwsSdkSigV4Config = (config) => {
    let inputCredentials = config.credentials;
    let isUserSupplied = !!config.credentials;
    let resolvedCredentials = undefined;
    Object.defineProperty(config, "credentials", {
      set(credentials) {
        if (credentials && credentials !== inputCredentials && credentials !== resolvedCredentials) {
          isUserSupplied = true;
        }
        inputCredentials = credentials;
        const memoizedProvider = normalizeCredentialProvider(config, {
          credentials: inputCredentials,
          credentialDefaultProvider: config.credentialDefaultProvider
        });
        const boundProvider = bindCallerConfig(config, memoizedProvider);
        if (isUserSupplied && !boundProvider.attributed) {
          resolvedCredentials = async (options) => boundProvider(options).then((creds) => client.setCredentialFeature(creds, "CREDENTIALS_CODE", "e"));
          resolvedCredentials.memoized = boundProvider.memoized;
          resolvedCredentials.configBound = boundProvider.configBound;
          resolvedCredentials.attributed = true;
        } else {
          resolvedCredentials = boundProvider;
        }
      },
      get() {
        return resolvedCredentials;
      },
      enumerable: true,
      configurable: true
    });
    config.credentials = inputCredentials;
    const { signingEscapePath = true, systemClockOffset = config.systemClockOffset || 0, sha256 } = config;
    let signer;
    if (config.signer) {
      signer = core2.normalizeProvider(config.signer);
    } else if (config.regionInfoProvider) {
      signer = () => core2.normalizeProvider(config.region)().then(async (region) => [
        await config.regionInfoProvider(region, {
          useFipsEndpoint: await config.useFipsEndpoint(),
          useDualstackEndpoint: await config.useDualstackEndpoint()
        }) || {},
        region
      ]).then(([regionInfo, region]) => {
        const { signingRegion, signingService } = regionInfo;
        config.signingRegion = config.signingRegion || signingRegion || region;
        config.signingName = config.signingName || signingService || config.serviceId;
        const params = {
          ...config,
          credentials: config.credentials,
          region: config.signingRegion,
          service: config.signingName,
          sha256,
          uriEscapePath: signingEscapePath
        };
        const SignerCtor = config.signerConstructor || signatureV4.SignatureV4;
        return new SignerCtor(params);
      });
    } else {
      signer = async (authScheme) => {
        authScheme = Object.assign({}, {
          name: "sigv4",
          signingName: config.signingName || config.defaultSigningName,
          signingRegion: await core2.normalizeProvider(config.region)(),
          properties: {}
        }, authScheme);
        const signingRegion = authScheme.signingRegion;
        const signingService = authScheme.signingName;
        config.signingRegion = config.signingRegion || signingRegion;
        config.signingName = config.signingName || signingService || config.serviceId;
        const params = {
          ...config,
          credentials: config.credentials,
          region: config.signingRegion,
          service: config.signingName,
          sha256,
          uriEscapePath: signingEscapePath
        };
        const SignerCtor = config.signerConstructor || signatureV4.SignatureV4;
        return new SignerCtor(params);
      };
    }
    const resolvedConfig = Object.assign(config, {
      systemClockOffset,
      signingEscapePath,
      signer
    });
    return resolvedConfig;
  };
  var resolveAWSSDKSigV4Config = resolveAwsSdkSigV4Config;
  function normalizeCredentialProvider(config, { credentials, credentialDefaultProvider }) {
    let credentialsProvider;
    if (credentials) {
      if (!credentials?.memoized) {
        credentialsProvider = core2.memoizeIdentityProvider(credentials, core2.isIdentityExpired, core2.doesIdentityRequireRefresh);
      } else {
        credentialsProvider = credentials;
      }
    } else {
      if (credentialDefaultProvider) {
        credentialsProvider = core2.normalizeProvider(credentialDefaultProvider(Object.assign({}, config, {
          parentClientConfig: config
        })));
      } else {
        credentialsProvider = async () => {
          throw new Error("@aws-sdk/core::resolveAwsSdkSigV4Config - `credentials` not provided and no credentialDefaultProvider was configured.");
        };
      }
    }
    credentialsProvider.memoized = true;
    return credentialsProvider;
  }
  function bindCallerConfig(config, credentialsProvider) {
    if (credentialsProvider.configBound) {
      return credentialsProvider;
    }
    const fn = async (options) => credentialsProvider({ ...options, callerClientConfig: config });
    fn.memoized = credentialsProvider.memoized;
    fn.configBound = true;
    return fn;
  }

  class ProtocolLib {
    resolveRestContentType(defaultContentType, inputSchema) {
      const members = inputSchema.getMemberSchemas();
      const httpPayloadMember = Object.values(members).find((m) => {
        return !!m.getMergedTraits().httpPayload;
      });
      if (httpPayloadMember) {
        const mediaType = httpPayloadMember.getMergedTraits().mediaType;
        if (mediaType) {
          return mediaType;
        } else if (httpPayloadMember.isStringSchema()) {
          return "text/plain";
        } else if (httpPayloadMember.isBlobSchema()) {
          return "application/octet-stream";
        } else {
          return defaultContentType;
        }
      } else if (!inputSchema.isUnitSchema()) {
        const hasBody = Object.values(members).find((m) => {
          const { httpQuery, httpQueryParams, httpHeader, httpLabel, httpPrefixHeaders } = m.getMergedTraits();
          const noPrefixHeaders = httpPrefixHeaders === undefined;
          return !httpQuery && !httpQueryParams && !httpHeader && !httpLabel && noPrefixHeaders;
        });
        if (hasBody) {
          return defaultContentType;
        }
      }
    }
    async getErrorSchemaOrThrowBaseException(errorIdentifier, defaultNamespace, response, dataObject, metadata, getErrorSchema) {
      let namespace = defaultNamespace;
      let errorName = errorIdentifier;
      if (errorIdentifier.includes("#")) {
        [namespace, errorName] = errorIdentifier.split("#");
      }
      const errorMetadata = {
        $metadata: metadata,
        $response: response,
        $fault: response.statusCode < 500 ? "client" : "server"
      };
      const registry = schema.TypeRegistry.for(namespace);
      try {
        const errorSchema = getErrorSchema?.(registry, errorName) ?? registry.getSchema(errorIdentifier);
        return { errorSchema, errorMetadata };
      } catch (e) {
        dataObject.message = dataObject.message ?? dataObject.Message ?? "UnknownError";
        const synthetic = schema.TypeRegistry.for("smithy.ts.sdk.synthetic." + namespace);
        const baseExceptionSchema = synthetic.getBaseException();
        if (baseExceptionSchema) {
          const ErrorCtor = synthetic.getErrorCtor(baseExceptionSchema) ?? Error;
          throw Object.assign(new ErrorCtor({ name: errorName }), errorMetadata, dataObject);
        }
        throw Object.assign(new Error(errorName), errorMetadata, dataObject);
      }
    }
    setQueryCompatError(output, response) {
      const queryErrorHeader = response.headers?.["x-amzn-query-error"];
      if (output !== undefined && queryErrorHeader != null) {
        const [Code, Type2] = queryErrorHeader.split(";");
        const entries = Object.entries(output);
        const Error2 = {
          Code,
          Type: Type2
        };
        Object.assign(output, Error2);
        for (const [k2, v] of entries) {
          Error2[k2] = v;
        }
        delete Error2.__type;
        output.Error = Error2;
      }
    }
    queryCompatOutput(queryCompatErrorData, errorData) {
      if (queryCompatErrorData.Error) {
        errorData.Error = queryCompatErrorData.Error;
      }
      if (queryCompatErrorData.Type) {
        errorData.Type = queryCompatErrorData.Type;
      }
      if (queryCompatErrorData.Code) {
        errorData.Code = queryCompatErrorData.Code;
      }
    }
  }

  class AwsSmithyRpcV2CborProtocol extends cbor.SmithyRpcV2CborProtocol {
    awsQueryCompatible;
    mixin = new ProtocolLib;
    constructor({ defaultNamespace, awsQueryCompatible }) {
      super({ defaultNamespace });
      this.awsQueryCompatible = !!awsQueryCompatible;
    }
    async serializeRequest(operationSchema, input, context) {
      const request = await super.serializeRequest(operationSchema, input, context);
      if (this.awsQueryCompatible) {
        request.headers["x-amzn-query-mode"] = "true";
      }
      return request;
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
      if (this.awsQueryCompatible) {
        this.mixin.setQueryCompatError(dataObject, response);
      }
      const errorName = cbor.loadSmithyRpcV2CborErrorCode(response, dataObject) ?? "Unknown";
      const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorName, this.options.defaultNamespace, response, dataObject, metadata);
      const ns = schema.NormalizedSchema.of(errorSchema);
      const message = dataObject.message ?? dataObject.Message ?? "Unknown";
      const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
      const exception = new ErrorCtor(message);
      const output = {};
      for (const [name, member] of ns.structIterator()) {
        output[name] = this.deserializer.readValue(member, dataObject[name]);
      }
      if (this.awsQueryCompatible) {
        this.mixin.queryCompatOutput(dataObject, output);
      }
      throw Object.assign(exception, errorMetadata, {
        $fault: ns.getMergedTraits().error,
        message
      }, output);
    }
  }
  var _toStr = (val) => {
    if (val == null) {
      return val;
    }
    if (typeof val === "number" || typeof val === "bigint") {
      const warning = new Error(`Received number ${val} where a string was expected.`);
      warning.name = "Warning";
      console.warn(warning);
      return String(val);
    }
    if (typeof val === "boolean") {
      const warning = new Error(`Received boolean ${val} where a string was expected.`);
      warning.name = "Warning";
      console.warn(warning);
      return String(val);
    }
    return val;
  };
  var _toBool = (val) => {
    if (val == null) {
      return val;
    }
    if (typeof val === "string") {
      const lowercase = val.toLowerCase();
      if (val !== "" && lowercase !== "false" && lowercase !== "true") {
        const warning = new Error(`Received string "${val}" where a boolean was expected.`);
        warning.name = "Warning";
        console.warn(warning);
      }
      return val !== "" && lowercase !== "false";
    }
    return val;
  };
  var _toNum = (val) => {
    if (val == null) {
      return val;
    }
    if (typeof val === "string") {
      const num = Number(val);
      if (num.toString() !== val) {
        const warning = new Error(`Received string "${val}" where a number was expected.`);
        warning.name = "Warning";
        console.warn(warning);
        return val;
      }
      return num;
    }
    return val;
  };

  class SerdeContextConfig {
    serdeContext;
    setSerdeContext(serdeContext) {
      this.serdeContext = serdeContext;
    }
  }
  function jsonReviver(key, value, context) {
    if (context?.source) {
      const numericString = context.source;
      if (typeof value === "number") {
        if (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER || numericString !== String(value)) {
          const isFractional = numericString.includes(".");
          if (isFractional) {
            return new serde.NumericValue(numericString, "bigDecimal");
          } else {
            return BigInt(numericString);
          }
        }
      }
    }
    return value;
  }
  var collectBodyString = (streamBody, context) => smithyClient.collectBody(streamBody, context).then((body) => (context?.utf8Encoder ?? utilUtf8.toUtf8)(body));
  var parseJsonBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
      try {
        return JSON.parse(encoded);
      } catch (e) {
        if (e?.name === "SyntaxError") {
          Object.defineProperty(e, "$responseBodyText", {
            value: encoded
          });
        }
        throw e;
      }
    }
    return {};
  });
  var parseJsonErrorBody = async (errorBody, context) => {
    const value = await parseJsonBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
  };
  var loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k2) => k2.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
      let cleanValue = rawValue;
      if (typeof cleanValue === "number") {
        cleanValue = cleanValue.toString();
      }
      if (cleanValue.indexOf(",") >= 0) {
        cleanValue = cleanValue.split(",")[0];
      }
      if (cleanValue.indexOf(":") >= 0) {
        cleanValue = cleanValue.split(":")[0];
      }
      if (cleanValue.indexOf("#") >= 0) {
        cleanValue = cleanValue.split("#")[1];
      }
      return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
      return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data && typeof data === "object") {
      const codeKey = findKey(data, "code");
      if (codeKey && data[codeKey] !== undefined) {
        return sanitizeErrorCode(data[codeKey]);
      }
      if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
      }
    }
  };

  class JsonShapeDeserializer extends SerdeContextConfig {
    settings;
    constructor(settings) {
      super();
      this.settings = settings;
    }
    async read(schema2, data) {
      return this._read(schema2, typeof data === "string" ? JSON.parse(data, jsonReviver) : await parseJsonBody(data, this.serdeContext));
    }
    readObject(schema2, data) {
      return this._read(schema2, data);
    }
    _read(schema$1, value) {
      const isObject2 = value !== null && typeof value === "object";
      const ns = schema.NormalizedSchema.of(schema$1);
      if (ns.isListSchema() && Array.isArray(value)) {
        const listMember = ns.getValueSchema();
        const out = [];
        const sparse = !!ns.getMergedTraits().sparse;
        for (const item of value) {
          if (sparse || item != null) {
            out.push(this._read(listMember, item));
          }
        }
        return out;
      } else if (ns.isMapSchema() && isObject2) {
        const mapMember = ns.getValueSchema();
        const out = {};
        const sparse = !!ns.getMergedTraits().sparse;
        for (const [_k, _v] of Object.entries(value)) {
          if (sparse || _v != null) {
            out[_k] = this._read(mapMember, _v);
          }
        }
        return out;
      } else if (ns.isStructSchema() && isObject2) {
        const out = {};
        for (const [memberName, memberSchema] of ns.structIterator()) {
          const fromKey = this.settings.jsonName ? memberSchema.getMergedTraits().jsonName ?? memberName : memberName;
          const deserializedValue = this._read(memberSchema, value[fromKey]);
          if (deserializedValue != null) {
            out[memberName] = deserializedValue;
          }
        }
        return out;
      }
      if (ns.isBlobSchema() && typeof value === "string") {
        return utilBase64.fromBase64(value);
      }
      const mediaType = ns.getMergedTraits().mediaType;
      if (ns.isStringSchema() && typeof value === "string" && mediaType) {
        const isJson = mediaType === "application/json" || mediaType.endsWith("+json");
        if (isJson) {
          return serde.LazyJsonString.from(value);
        }
      }
      if (ns.isTimestampSchema() && value != null) {
        const format = protocols.determineTimestampFormat(ns, this.settings);
        switch (format) {
          case 5:
            return serde.parseRfc3339DateTimeWithOffset(value);
          case 6:
            return serde.parseRfc7231DateTime(value);
          case 7:
            return serde.parseEpochTimestamp(value);
          default:
            console.warn("Missing timestamp format, parsing value with Date constructor:", value);
            return new Date(value);
        }
      }
      if (ns.isBigIntegerSchema() && (typeof value === "number" || typeof value === "string")) {
        return BigInt(value);
      }
      if (ns.isBigDecimalSchema() && value != null) {
        if (value instanceof serde.NumericValue) {
          return value;
        }
        const untyped = value;
        if (untyped.type === "bigDecimal" && "string" in untyped) {
          return new serde.NumericValue(untyped.string, untyped.type);
        }
        return new serde.NumericValue(String(value), "bigDecimal");
      }
      if (ns.isNumericSchema() && typeof value === "string") {
        switch (value) {
          case "Infinity":
            return Infinity;
          case "-Infinity":
            return -Infinity;
          case "NaN":
            return NaN;
        }
      }
      if (ns.isDocumentSchema()) {
        if (isObject2) {
          const out = Array.isArray(value) ? [] : {};
          for (const [k2, v] of Object.entries(value)) {
            if (v instanceof serde.NumericValue) {
              out[k2] = v;
            } else {
              out[k2] = this._read(ns, v);
            }
          }
          return out;
        } else {
          return structuredClone(value);
        }
      }
      return value;
    }
  }
  var NUMERIC_CONTROL_CHAR = String.fromCharCode(925);

  class JsonReplacer {
    values = new Map;
    counter = 0;
    stage = 0;
    createReplacer() {
      if (this.stage === 1) {
        throw new Error("@aws-sdk/core/protocols - JsonReplacer already created.");
      }
      if (this.stage === 2) {
        throw new Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
      }
      this.stage = 1;
      return (key, value) => {
        if (value instanceof serde.NumericValue) {
          const v = `${NUMERIC_CONTROL_CHAR + "nv" + this.counter++}_` + value.string;
          this.values.set(`"${v}"`, value.string);
          return v;
        }
        if (typeof value === "bigint") {
          const s = value.toString();
          const v = `${NUMERIC_CONTROL_CHAR + "b" + this.counter++}_` + s;
          this.values.set(`"${v}"`, s);
          return v;
        }
        return value;
      };
    }
    replaceInJson(json) {
      if (this.stage === 0) {
        throw new Error("@aws-sdk/core/protocols - JsonReplacer not created yet.");
      }
      if (this.stage === 2) {
        throw new Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
      }
      this.stage = 2;
      if (this.counter === 0) {
        return json;
      }
      for (const [key, value] of this.values) {
        json = json.replace(key, value);
      }
      return json;
    }
  }

  class JsonShapeSerializer extends SerdeContextConfig {
    settings;
    buffer;
    rootSchema;
    constructor(settings) {
      super();
      this.settings = settings;
    }
    write(schema$1, value) {
      this.rootSchema = schema.NormalizedSchema.of(schema$1);
      this.buffer = this._write(this.rootSchema, value);
    }
    writeDiscriminatedDocument(schema$1, value) {
      this.write(schema$1, value);
      if (typeof this.buffer === "object") {
        this.buffer.__type = schema.NormalizedSchema.of(schema$1).getName(true);
      }
    }
    flush() {
      const { rootSchema } = this;
      this.rootSchema = undefined;
      if (rootSchema?.isStructSchema() || rootSchema?.isDocumentSchema()) {
        const replacer = new JsonReplacer;
        return replacer.replaceInJson(JSON.stringify(this.buffer, replacer.createReplacer(), 0));
      }
      return this.buffer;
    }
    _write(schema$1, value, container) {
      const isObject2 = value !== null && typeof value === "object";
      const ns = schema.NormalizedSchema.of(schema$1);
      if (ns.isListSchema() && Array.isArray(value)) {
        const listMember = ns.getValueSchema();
        const out = [];
        const sparse = !!ns.getMergedTraits().sparse;
        for (const item of value) {
          if (sparse || item != null) {
            out.push(this._write(listMember, item));
          }
        }
        return out;
      } else if (ns.isMapSchema() && isObject2) {
        const mapMember = ns.getValueSchema();
        const out = {};
        const sparse = !!ns.getMergedTraits().sparse;
        for (const [_k, _v] of Object.entries(value)) {
          if (sparse || _v != null) {
            out[_k] = this._write(mapMember, _v);
          }
        }
        return out;
      } else if (ns.isStructSchema() && isObject2) {
        const out = {};
        for (const [memberName, memberSchema] of ns.structIterator()) {
          const targetKey = this.settings.jsonName ? memberSchema.getMergedTraits().jsonName ?? memberName : memberName;
          const serializableValue = this._write(memberSchema, value[memberName], ns);
          if (serializableValue !== undefined) {
            out[targetKey] = serializableValue;
          }
        }
        return out;
      }
      if (value === null && container?.isStructSchema()) {
        return;
      }
      if (ns.isBlobSchema() && (value instanceof Uint8Array || typeof value === "string") || ns.isDocumentSchema() && value instanceof Uint8Array) {
        if (ns === this.rootSchema) {
          return value;
        }
        if (!this.serdeContext?.base64Encoder) {
          return utilBase64.toBase64(value);
        }
        return this.serdeContext?.base64Encoder(value);
      }
      if ((ns.isTimestampSchema() || ns.isDocumentSchema()) && value instanceof Date) {
        const format = protocols.determineTimestampFormat(ns, this.settings);
        switch (format) {
          case 5:
            return value.toISOString().replace(".000Z", "Z");
          case 6:
            return serde.dateToUtcString(value);
          case 7:
            return value.getTime() / 1000;
          default:
            console.warn("Missing timestamp format, using epoch seconds", value);
            return value.getTime() / 1000;
        }
      }
      if (ns.isNumericSchema() && typeof value === "number") {
        if (Math.abs(value) === Infinity || isNaN(value)) {
          return String(value);
        }
      }
      if (ns.isStringSchema()) {
        if (typeof value === "undefined" && ns.isIdempotencyToken()) {
          return serde.generateIdempotencyToken();
        }
        const mediaType = ns.getMergedTraits().mediaType;
        if (value != null && mediaType) {
          const isJson = mediaType === "application/json" || mediaType.endsWith("+json");
          if (isJson) {
            return serde.LazyJsonString.from(value);
          }
        }
      }
      if (ns.isDocumentSchema()) {
        if (isObject2) {
          const out = Array.isArray(value) ? [] : {};
          for (const [k2, v] of Object.entries(value)) {
            if (v instanceof serde.NumericValue) {
              out[k2] = v;
            } else {
              out[k2] = this._write(ns, v);
            }
          }
          return out;
        } else {
          return structuredClone(value);
        }
      }
      return value;
    }
  }

  class JsonCodec extends SerdeContextConfig {
    settings;
    constructor(settings) {
      super();
      this.settings = settings;
    }
    createSerializer() {
      const serializer = new JsonShapeSerializer(this.settings);
      serializer.setSerdeContext(this.serdeContext);
      return serializer;
    }
    createDeserializer() {
      const deserializer = new JsonShapeDeserializer(this.settings);
      deserializer.setSerdeContext(this.serdeContext);
      return deserializer;
    }
  }

  class AwsJsonRpcProtocol extends protocols.RpcProtocol {
    serializer;
    deserializer;
    serviceTarget;
    codec;
    mixin = new ProtocolLib;
    awsQueryCompatible;
    constructor({ defaultNamespace, serviceTarget, awsQueryCompatible }) {
      super({
        defaultNamespace
      });
      this.serviceTarget = serviceTarget;
      this.codec = new JsonCodec({
        timestampFormat: {
          useTrait: true,
          default: 7
        },
        jsonName: false
      });
      this.serializer = this.codec.createSerializer();
      this.deserializer = this.codec.createDeserializer();
      this.awsQueryCompatible = !!awsQueryCompatible;
    }
    async serializeRequest(operationSchema, input, context) {
      const request = await super.serializeRequest(operationSchema, input, context);
      if (!request.path.endsWith("/")) {
        request.path += "/";
      }
      Object.assign(request.headers, {
        "content-type": `application/x-amz-json-${this.getJsonRpcVersion()}`,
        "x-amz-target": `${this.serviceTarget}.${operationSchema.name}`
      });
      if (this.awsQueryCompatible) {
        request.headers["x-amzn-query-mode"] = "true";
      }
      if (schema.deref(operationSchema.input) === "unit" || !request.body) {
        request.body = "{}";
      }
      return request;
    }
    getPayloadCodec() {
      return this.codec;
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
      if (this.awsQueryCompatible) {
        this.mixin.setQueryCompatError(dataObject, response);
      }
      const errorIdentifier = loadRestJsonErrorCode(response, dataObject) ?? "Unknown";
      const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, dataObject, metadata);
      const ns = schema.NormalizedSchema.of(errorSchema);
      const message = dataObject.message ?? dataObject.Message ?? "Unknown";
      const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
      const exception = new ErrorCtor(message);
      const output = {};
      for (const [name, member] of ns.structIterator()) {
        const target = member.getMergedTraits().jsonName ?? name;
        output[name] = this.codec.createDeserializer().readObject(member, dataObject[target]);
      }
      if (this.awsQueryCompatible) {
        this.mixin.queryCompatOutput(dataObject, output);
      }
      throw Object.assign(exception, errorMetadata, {
        $fault: ns.getMergedTraits().error,
        message
      }, output);
    }
  }

  class AwsJson1_0Protocol extends AwsJsonRpcProtocol {
    constructor({ defaultNamespace, serviceTarget, awsQueryCompatible }) {
      super({
        defaultNamespace,
        serviceTarget,
        awsQueryCompatible
      });
    }
    getShapeId() {
      return "aws.protocols#awsJson1_0";
    }
    getJsonRpcVersion() {
      return "1.0";
    }
    getDefaultContentType() {
      return "application/x-amz-json-1.0";
    }
  }

  class AwsJson1_1Protocol extends AwsJsonRpcProtocol {
    constructor({ defaultNamespace, serviceTarget, awsQueryCompatible }) {
      super({
        defaultNamespace,
        serviceTarget,
        awsQueryCompatible
      });
    }
    getShapeId() {
      return "aws.protocols#awsJson1_1";
    }
    getJsonRpcVersion() {
      return "1.1";
    }
    getDefaultContentType() {
      return "application/x-amz-json-1.1";
    }
  }

  class AwsRestJsonProtocol extends protocols.HttpBindingProtocol {
    serializer;
    deserializer;
    codec;
    mixin = new ProtocolLib;
    constructor({ defaultNamespace }) {
      super({
        defaultNamespace
      });
      const settings = {
        timestampFormat: {
          useTrait: true,
          default: 7
        },
        httpBindings: true,
        jsonName: true
      };
      this.codec = new JsonCodec(settings);
      this.serializer = new protocols.HttpInterceptingShapeSerializer(this.codec.createSerializer(), settings);
      this.deserializer = new protocols.HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), settings);
    }
    getShapeId() {
      return "aws.protocols#restJson1";
    }
    getPayloadCodec() {
      return this.codec;
    }
    setSerdeContext(serdeContext) {
      this.codec.setSerdeContext(serdeContext);
      super.setSerdeContext(serdeContext);
    }
    async serializeRequest(operationSchema, input, context) {
      const request = await super.serializeRequest(operationSchema, input, context);
      const inputSchema = schema.NormalizedSchema.of(operationSchema.input);
      if (!request.headers["content-type"]) {
        const contentType = this.mixin.resolveRestContentType(this.getDefaultContentType(), inputSchema);
        if (contentType) {
          request.headers["content-type"] = contentType;
        }
      }
      if (request.headers["content-type"] && !request.body) {
        request.body = "{}";
      }
      return request;
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
      const errorIdentifier = loadRestJsonErrorCode(response, dataObject) ?? "Unknown";
      const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, dataObject, metadata);
      const ns = schema.NormalizedSchema.of(errorSchema);
      const message = dataObject.message ?? dataObject.Message ?? "Unknown";
      const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
      const exception = new ErrorCtor(message);
      await this.deserializeHttpMessage(errorSchema, context, response, dataObject);
      const output = {};
      for (const [name, member] of ns.structIterator()) {
        const target = member.getMergedTraits().jsonName ?? name;
        output[name] = this.codec.createDeserializer().readObject(member, dataObject[target]);
      }
      throw Object.assign(exception, errorMetadata, {
        $fault: ns.getMergedTraits().error,
        message
      }, output);
    }
    getDefaultContentType() {
      return "application/json";
    }
  }
  var awsExpectUnion = (value) => {
    if (value == null) {
      return;
    }
    if (typeof value === "object" && "__type" in value) {
      delete value.__type;
    }
    return smithyClient.expectUnion(value);
  };

  class XmlShapeDeserializer extends SerdeContextConfig {
    settings;
    stringDeserializer;
    constructor(settings) {
      super();
      this.settings = settings;
      this.stringDeserializer = new protocols.FromStringShapeDeserializer(settings);
    }
    setSerdeContext(serdeContext) {
      this.serdeContext = serdeContext;
      this.stringDeserializer.setSerdeContext(serdeContext);
    }
    read(schema$1, bytes, key) {
      const ns = schema.NormalizedSchema.of(schema$1);
      const memberSchemas = ns.getMemberSchemas();
      const isEventPayload = ns.isStructSchema() && ns.isMemberSchema() && !!Object.values(memberSchemas).find((memberNs) => {
        return !!memberNs.getMemberTraits().eventPayload;
      });
      if (isEventPayload) {
        const output = {};
        const memberName = Object.keys(memberSchemas)[0];
        const eventMemberSchema = memberSchemas[memberName];
        if (eventMemberSchema.isBlobSchema()) {
          output[memberName] = bytes;
        } else {
          output[memberName] = this.read(memberSchemas[memberName], bytes);
        }
        return output;
      }
      const xmlString = (this.serdeContext?.utf8Encoder ?? utilUtf8.toUtf8)(bytes);
      const parsedObject = this.parseXml(xmlString);
      return this.readSchema(schema$1, key ? parsedObject[key] : parsedObject);
    }
    readSchema(_schema, value) {
      const ns = schema.NormalizedSchema.of(_schema);
      if (ns.isUnitSchema()) {
        return;
      }
      const traits = ns.getMergedTraits();
      if (ns.isListSchema() && !Array.isArray(value)) {
        return this.readSchema(ns, [value]);
      }
      if (value == null) {
        return value;
      }
      if (typeof value === "object") {
        const sparse = !!traits.sparse;
        const flat = !!traits.xmlFlattened;
        if (ns.isListSchema()) {
          const listValue = ns.getValueSchema();
          const buffer2 = [];
          const sourceKey = listValue.getMergedTraits().xmlName ?? "member";
          const source = flat ? value : (value[0] ?? value)[sourceKey];
          const sourceArray = Array.isArray(source) ? source : [source];
          for (const v of sourceArray) {
            if (v != null || sparse) {
              buffer2.push(this.readSchema(listValue, v));
            }
          }
          return buffer2;
        }
        const buffer = {};
        if (ns.isMapSchema()) {
          const keyNs = ns.getKeySchema();
          const memberNs = ns.getValueSchema();
          let entries;
          if (flat) {
            entries = Array.isArray(value) ? value : [value];
          } else {
            entries = Array.isArray(value.entry) ? value.entry : [value.entry];
          }
          const keyProperty = keyNs.getMergedTraits().xmlName ?? "key";
          const valueProperty = memberNs.getMergedTraits().xmlName ?? "value";
          for (const entry of entries) {
            const key = entry[keyProperty];
            const value2 = entry[valueProperty];
            if (value2 != null || sparse) {
              buffer[key] = this.readSchema(memberNs, value2);
            }
          }
          return buffer;
        }
        if (ns.isStructSchema()) {
          for (const [memberName, memberSchema] of ns.structIterator()) {
            const memberTraits = memberSchema.getMergedTraits();
            const xmlObjectKey = !memberTraits.httpPayload ? memberSchema.getMemberTraits().xmlName ?? memberName : memberTraits.xmlName ?? memberSchema.getName();
            if (value[xmlObjectKey] != null) {
              buffer[memberName] = this.readSchema(memberSchema, value[xmlObjectKey]);
            }
          }
          return buffer;
        }
        if (ns.isDocumentSchema()) {
          return value;
        }
        throw new Error(`@aws-sdk/core/protocols - xml deserializer unhandled schema type for ${ns.getName(true)}`);
      }
      if (ns.isListSchema()) {
        return [];
      }
      if (ns.isMapSchema() || ns.isStructSchema()) {
        return {};
      }
      return this.stringDeserializer.read(ns, value);
    }
    parseXml(xml) {
      if (xml.length) {
        let parsedObj;
        try {
          parsedObj = xmlBuilder.parseXML(xml);
        } catch (e) {
          if (e && typeof e === "object") {
            Object.defineProperty(e, "$responseBodyText", {
              value: xml
            });
          }
          throw e;
        }
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
          parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
          delete parsedObjToReturn[textNodeName];
        }
        return smithyClient.getValueFromTextNode(parsedObjToReturn);
      }
      return {};
    }
  }

  class QueryShapeSerializer extends SerdeContextConfig {
    settings;
    buffer;
    constructor(settings) {
      super();
      this.settings = settings;
    }
    write(schema$1, value, prefix = "") {
      if (this.buffer === undefined) {
        this.buffer = "";
      }
      const ns = schema.NormalizedSchema.of(schema$1);
      if (prefix && !prefix.endsWith(".")) {
        prefix += ".";
      }
      if (ns.isBlobSchema()) {
        if (typeof value === "string" || value instanceof Uint8Array) {
          this.writeKey(prefix);
          this.writeValue((this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(value));
        }
      } else if (ns.isBooleanSchema() || ns.isNumericSchema() || ns.isStringSchema()) {
        if (value != null) {
          this.writeKey(prefix);
          this.writeValue(String(value));
        } else if (ns.isIdempotencyToken()) {
          this.writeKey(prefix);
          this.writeValue(serde.generateIdempotencyToken());
        }
      } else if (ns.isBigIntegerSchema()) {
        if (value != null) {
          this.writeKey(prefix);
          this.writeValue(String(value));
        }
      } else if (ns.isBigDecimalSchema()) {
        if (value != null) {
          this.writeKey(prefix);
          this.writeValue(value instanceof serde.NumericValue ? value.string : String(value));
        }
      } else if (ns.isTimestampSchema()) {
        if (value instanceof Date) {
          this.writeKey(prefix);
          const format = protocols.determineTimestampFormat(ns, this.settings);
          switch (format) {
            case 5:
              this.writeValue(value.toISOString().replace(".000Z", "Z"));
              break;
            case 6:
              this.writeValue(smithyClient.dateToUtcString(value));
              break;
            case 7:
              this.writeValue(String(value.getTime() / 1000));
              break;
          }
        }
      } else if (ns.isDocumentSchema()) {
        throw new Error(`@aws-sdk/core/protocols - QuerySerializer unsupported document type ${ns.getName(true)}`);
      } else if (ns.isListSchema()) {
        if (Array.isArray(value)) {
          if (value.length === 0) {
            if (this.settings.serializeEmptyLists) {
              this.writeKey(prefix);
              this.writeValue("");
            }
          } else {
            const member = ns.getValueSchema();
            const flat = this.settings.flattenLists || ns.getMergedTraits().xmlFlattened;
            let i2 = 1;
            for (const item of value) {
              if (item == null) {
                continue;
              }
              const suffix = this.getKey("member", member.getMergedTraits().xmlName);
              const key = flat ? `${prefix}${i2}` : `${prefix}${suffix}.${i2}`;
              this.write(member, item, key);
              ++i2;
            }
          }
        }
      } else if (ns.isMapSchema()) {
        if (value && typeof value === "object") {
          const keySchema = ns.getKeySchema();
          const memberSchema = ns.getValueSchema();
          const flat = ns.getMergedTraits().xmlFlattened;
          let i2 = 1;
          for (const [k2, v] of Object.entries(value)) {
            if (v == null) {
              continue;
            }
            const keySuffix = this.getKey("key", keySchema.getMergedTraits().xmlName);
            const key = flat ? `${prefix}${i2}.${keySuffix}` : `${prefix}entry.${i2}.${keySuffix}`;
            const valueSuffix = this.getKey("value", memberSchema.getMergedTraits().xmlName);
            const valueKey = flat ? `${prefix}${i2}.${valueSuffix}` : `${prefix}entry.${i2}.${valueSuffix}`;
            this.write(keySchema, k2, key);
            this.write(memberSchema, v, valueKey);
            ++i2;
          }
        }
      } else if (ns.isStructSchema()) {
        if (value && typeof value === "object") {
          for (const [memberName, member] of ns.structIterator()) {
            if (value[memberName] == null && !member.isIdempotencyToken()) {
              continue;
            }
            const suffix = this.getKey(memberName, member.getMergedTraits().xmlName);
            const key = `${prefix}${suffix}`;
            this.write(member, value[memberName], key);
          }
        }
      } else if (ns.isUnitSchema())
        ;
      else {
        throw new Error(`@aws-sdk/core/protocols - QuerySerializer unrecognized schema type ${ns.getName(true)}`);
      }
    }
    flush() {
      if (this.buffer === undefined) {
        throw new Error("@aws-sdk/core/protocols - QuerySerializer cannot flush with nothing written to buffer.");
      }
      const str = this.buffer;
      delete this.buffer;
      return str;
    }
    getKey(memberName, xmlName) {
      const key = xmlName ?? memberName;
      if (this.settings.capitalizeKeys) {
        return key[0].toUpperCase() + key.slice(1);
      }
      return key;
    }
    writeKey(key) {
      if (key.endsWith(".")) {
        key = key.slice(0, key.length - 1);
      }
      this.buffer += `&${protocols.extendedEncodeURIComponent(key)}=`;
    }
    writeValue(value) {
      this.buffer += protocols.extendedEncodeURIComponent(value);
    }
  }

  class AwsQueryProtocol extends protocols.RpcProtocol {
    options;
    serializer;
    deserializer;
    mixin = new ProtocolLib;
    constructor(options) {
      super({
        defaultNamespace: options.defaultNamespace
      });
      this.options = options;
      const settings = {
        timestampFormat: {
          useTrait: true,
          default: 5
        },
        httpBindings: false,
        xmlNamespace: options.xmlNamespace,
        serviceNamespace: options.defaultNamespace,
        serializeEmptyLists: true
      };
      this.serializer = new QueryShapeSerializer(settings);
      this.deserializer = new XmlShapeDeserializer(settings);
    }
    getShapeId() {
      return "aws.protocols#awsQuery";
    }
    setSerdeContext(serdeContext) {
      this.serializer.setSerdeContext(serdeContext);
      this.deserializer.setSerdeContext(serdeContext);
    }
    getPayloadCodec() {
      throw new Error("AWSQuery protocol has no payload codec.");
    }
    async serializeRequest(operationSchema, input, context) {
      const request = await super.serializeRequest(operationSchema, input, context);
      if (!request.path.endsWith("/")) {
        request.path += "/";
      }
      Object.assign(request.headers, {
        "content-type": `application/x-www-form-urlencoded`
      });
      if (schema.deref(operationSchema.input) === "unit" || !request.body) {
        request.body = "";
      }
      const action = operationSchema.name.split("#")[1] ?? operationSchema.name;
      request.body = `Action=${action}&Version=${this.options.version}` + request.body;
      if (request.body.endsWith("&")) {
        request.body = request.body.slice(-1);
      }
      return request;
    }
    async deserializeResponse(operationSchema, context, response) {
      const deserializer = this.deserializer;
      const ns = schema.NormalizedSchema.of(operationSchema.output);
      const dataObject = {};
      if (response.statusCode >= 300) {
        const bytes2 = await protocols.collectBody(response.body, context);
        if (bytes2.byteLength > 0) {
          Object.assign(dataObject, await deserializer.read(15, bytes2));
        }
        await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));
      }
      for (const header in response.headers) {
        const value = response.headers[header];
        delete response.headers[header];
        response.headers[header.toLowerCase()] = value;
      }
      const shortName = operationSchema.name.split("#")[1] ?? operationSchema.name;
      const awsQueryResultKey = ns.isStructSchema() && this.useNestedResult() ? shortName + "Result" : undefined;
      const bytes = await protocols.collectBody(response.body, context);
      if (bytes.byteLength > 0) {
        Object.assign(dataObject, await deserializer.read(ns, bytes, awsQueryResultKey));
      }
      const output = {
        $metadata: this.deserializeMetadata(response),
        ...dataObject
      };
      return output;
    }
    useNestedResult() {
      return true;
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
      const errorIdentifier = this.loadQueryErrorCode(response, dataObject) ?? "Unknown";
      const errorData = this.loadQueryError(dataObject);
      const message = this.loadQueryErrorMessage(dataObject);
      errorData.message = message;
      errorData.Error = {
        Type: errorData.Type,
        Code: errorData.Code,
        Message: message
      };
      const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, errorData, metadata, (registry, errorName) => registry.find((schema$1) => schema.NormalizedSchema.of(schema$1).getMergedTraits().awsQueryError?.[0] === errorName));
      const ns = schema.NormalizedSchema.of(errorSchema);
      const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
      const exception = new ErrorCtor(message);
      const output = {
        Error: errorData.Error
      };
      for (const [name, member] of ns.structIterator()) {
        const target = member.getMergedTraits().xmlName ?? name;
        const value = errorData[target] ?? dataObject[target];
        output[name] = this.deserializer.readSchema(member, value);
      }
      throw Object.assign(exception, errorMetadata, {
        $fault: ns.getMergedTraits().error,
        message
      }, output);
    }
    loadQueryErrorCode(output, data) {
      const code = (data.Errors?.[0]?.Error ?? data.Errors?.Error ?? data.Error)?.Code;
      if (code !== undefined) {
        return code;
      }
      if (output.statusCode == 404) {
        return "NotFound";
      }
    }
    loadQueryError(data) {
      return data.Errors?.[0]?.Error ?? data.Errors?.Error ?? data.Error;
    }
    loadQueryErrorMessage(data) {
      const errorData = this.loadQueryError(data);
      return errorData?.message ?? errorData?.Message ?? data.message ?? data.Message ?? "Unknown";
    }
    getDefaultContentType() {
      return "application/x-www-form-urlencoded";
    }
  }

  class AwsEc2QueryProtocol extends AwsQueryProtocol {
    options;
    constructor(options) {
      super(options);
      this.options = options;
      const ec2Settings = {
        capitalizeKeys: true,
        flattenLists: true,
        serializeEmptyLists: false
      };
      Object.assign(this.serializer.settings, ec2Settings);
    }
    useNestedResult() {
      return false;
    }
  }
  var parseXmlBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
      let parsedObj;
      try {
        parsedObj = xmlBuilder.parseXML(encoded);
      } catch (e) {
        if (e && typeof e === "object") {
          Object.defineProperty(e, "$responseBodyText", {
            value: encoded
          });
        }
        throw e;
      }
      const textNodeName = "#text";
      const key = Object.keys(parsedObj)[0];
      const parsedObjToReturn = parsedObj[key];
      if (parsedObjToReturn[textNodeName]) {
        parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
        delete parsedObjToReturn[textNodeName];
      }
      return smithyClient.getValueFromTextNode(parsedObjToReturn);
    }
    return {};
  });
  var parseXmlErrorBody = async (errorBody, context) => {
    const value = await parseXmlBody(errorBody, context);
    if (value.Error) {
      value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
  };
  var loadRestXmlErrorCode = (output, data) => {
    if (data?.Error?.Code !== undefined) {
      return data.Error.Code;
    }
    if (data?.Code !== undefined) {
      return data.Code;
    }
    if (output.statusCode == 404) {
      return "NotFound";
    }
  };

  class XmlShapeSerializer extends SerdeContextConfig {
    settings;
    stringBuffer;
    byteBuffer;
    buffer;
    constructor(settings) {
      super();
      this.settings = settings;
    }
    write(schema$1, value) {
      const ns = schema.NormalizedSchema.of(schema$1);
      if (ns.isStringSchema() && typeof value === "string") {
        this.stringBuffer = value;
      } else if (ns.isBlobSchema()) {
        this.byteBuffer = "byteLength" in value ? value : (this.serdeContext?.base64Decoder ?? utilBase64.fromBase64)(value);
      } else {
        this.buffer = this.writeStruct(ns, value, undefined);
        const traits = ns.getMergedTraits();
        if (traits.httpPayload && !traits.xmlName) {
          this.buffer.withName(ns.getName());
        }
      }
    }
    flush() {
      if (this.byteBuffer !== undefined) {
        const bytes = this.byteBuffer;
        delete this.byteBuffer;
        return bytes;
      }
      if (this.stringBuffer !== undefined) {
        const str = this.stringBuffer;
        delete this.stringBuffer;
        return str;
      }
      const buffer = this.buffer;
      if (this.settings.xmlNamespace) {
        if (!buffer?.attributes?.["xmlns"]) {
          buffer.addAttribute("xmlns", this.settings.xmlNamespace);
        }
      }
      delete this.buffer;
      return buffer.toString();
    }
    writeStruct(ns, value, parentXmlns) {
      const traits = ns.getMergedTraits();
      const name = ns.isMemberSchema() && !traits.httpPayload ? ns.getMemberTraits().xmlName ?? ns.getMemberName() : traits.xmlName ?? ns.getName();
      if (!name || !ns.isStructSchema()) {
        throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write struct with empty name or non-struct, schema=${ns.getName(true)}.`);
      }
      const structXmlNode = xmlBuilder.XmlNode.of(name);
      const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);
      for (const [memberName, memberSchema] of ns.structIterator()) {
        const val = value[memberName];
        if (val != null || memberSchema.isIdempotencyToken()) {
          if (memberSchema.getMergedTraits().xmlAttribute) {
            structXmlNode.addAttribute(memberSchema.getMergedTraits().xmlName ?? memberName, this.writeSimple(memberSchema, val));
            continue;
          }
          if (memberSchema.isListSchema()) {
            this.writeList(memberSchema, val, structXmlNode, xmlns);
          } else if (memberSchema.isMapSchema()) {
            this.writeMap(memberSchema, val, structXmlNode, xmlns);
          } else if (memberSchema.isStructSchema()) {
            structXmlNode.addChildNode(this.writeStruct(memberSchema, val, xmlns));
          } else {
            const memberNode = xmlBuilder.XmlNode.of(memberSchema.getMergedTraits().xmlName ?? memberSchema.getMemberName());
            this.writeSimpleInto(memberSchema, val, memberNode, xmlns);
            structXmlNode.addChildNode(memberNode);
          }
        }
      }
      if (xmlns) {
        structXmlNode.addAttribute(xmlnsAttr, xmlns);
      }
      return structXmlNode;
    }
    writeList(listMember, array, container, parentXmlns) {
      if (!listMember.isMemberSchema()) {
        throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member list: ${listMember.getName(true)}`);
      }
      const listTraits = listMember.getMergedTraits();
      const listValueSchema = listMember.getValueSchema();
      const listValueTraits = listValueSchema.getMergedTraits();
      const sparse = !!listValueTraits.sparse;
      const flat = !!listTraits.xmlFlattened;
      const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(listMember, parentXmlns);
      const writeItem = (container2, value) => {
        if (listValueSchema.isListSchema()) {
          this.writeList(listValueSchema, Array.isArray(value) ? value : [value], container2, xmlns);
        } else if (listValueSchema.isMapSchema()) {
          this.writeMap(listValueSchema, value, container2, xmlns);
        } else if (listValueSchema.isStructSchema()) {
          const struct = this.writeStruct(listValueSchema, value, xmlns);
          container2.addChildNode(struct.withName(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? "member"));
        } else {
          const listItemNode = xmlBuilder.XmlNode.of(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? "member");
          this.writeSimpleInto(listValueSchema, value, listItemNode, xmlns);
          container2.addChildNode(listItemNode);
        }
      };
      if (flat) {
        for (const value of array) {
          if (sparse || value != null) {
            writeItem(container, value);
          }
        }
      } else {
        const listNode = xmlBuilder.XmlNode.of(listTraits.xmlName ?? listMember.getMemberName());
        if (xmlns) {
          listNode.addAttribute(xmlnsAttr, xmlns);
        }
        for (const value of array) {
          if (sparse || value != null) {
            writeItem(listNode, value);
          }
        }
        container.addChildNode(listNode);
      }
    }
    writeMap(mapMember, map3, container, parentXmlns, containerIsMap = false) {
      if (!mapMember.isMemberSchema()) {
        throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member map: ${mapMember.getName(true)}`);
      }
      const mapTraits = mapMember.getMergedTraits();
      const mapKeySchema = mapMember.getKeySchema();
      const mapKeyTraits = mapKeySchema.getMergedTraits();
      const keyTag = mapKeyTraits.xmlName ?? "key";
      const mapValueSchema = mapMember.getValueSchema();
      const mapValueTraits = mapValueSchema.getMergedTraits();
      const valueTag = mapValueTraits.xmlName ?? "value";
      const sparse = !!mapValueTraits.sparse;
      const flat = !!mapTraits.xmlFlattened;
      const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(mapMember, parentXmlns);
      const addKeyValue = (entry, key, val) => {
        const keyNode = xmlBuilder.XmlNode.of(keyTag, key);
        const [keyXmlnsAttr, keyXmlns] = this.getXmlnsAttribute(mapKeySchema, xmlns);
        if (keyXmlns) {
          keyNode.addAttribute(keyXmlnsAttr, keyXmlns);
        }
        entry.addChildNode(keyNode);
        let valueNode = xmlBuilder.XmlNode.of(valueTag);
        if (mapValueSchema.isListSchema()) {
          this.writeList(mapValueSchema, val, valueNode, xmlns);
        } else if (mapValueSchema.isMapSchema()) {
          this.writeMap(mapValueSchema, val, valueNode, xmlns, true);
        } else if (mapValueSchema.isStructSchema()) {
          valueNode = this.writeStruct(mapValueSchema, val, xmlns);
        } else {
          this.writeSimpleInto(mapValueSchema, val, valueNode, xmlns);
        }
        entry.addChildNode(valueNode);
      };
      if (flat) {
        for (const [key, val] of Object.entries(map3)) {
          if (sparse || val != null) {
            const entry = xmlBuilder.XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());
            addKeyValue(entry, key, val);
            container.addChildNode(entry);
          }
        }
      } else {
        let mapNode;
        if (!containerIsMap) {
          mapNode = xmlBuilder.XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());
          if (xmlns) {
            mapNode.addAttribute(xmlnsAttr, xmlns);
          }
          container.addChildNode(mapNode);
        }
        for (const [key, val] of Object.entries(map3)) {
          if (sparse || val != null) {
            const entry = xmlBuilder.XmlNode.of("entry");
            addKeyValue(entry, key, val);
            (containerIsMap ? container : mapNode).addChildNode(entry);
          }
        }
      }
    }
    writeSimple(_schema, value) {
      if (value === null) {
        throw new Error("@aws-sdk/core/protocols - (XML serializer) cannot write null value.");
      }
      const ns = schema.NormalizedSchema.of(_schema);
      let nodeContents = null;
      if (value && typeof value === "object") {
        if (ns.isBlobSchema()) {
          nodeContents = (this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(value);
        } else if (ns.isTimestampSchema() && value instanceof Date) {
          const format = protocols.determineTimestampFormat(ns, this.settings);
          switch (format) {
            case 5:
              nodeContents = value.toISOString().replace(".000Z", "Z");
              break;
            case 6:
              nodeContents = smithyClient.dateToUtcString(value);
              break;
            case 7:
              nodeContents = String(value.getTime() / 1000);
              break;
            default:
              console.warn("Missing timestamp format, using http date", value);
              nodeContents = smithyClient.dateToUtcString(value);
              break;
          }
        } else if (ns.isBigDecimalSchema() && value) {
          if (value instanceof serde.NumericValue) {
            return value.string;
          }
          return String(value);
        } else if (ns.isMapSchema() || ns.isListSchema()) {
          throw new Error("@aws-sdk/core/protocols - xml serializer, cannot call _write() on List/Map schema, call writeList or writeMap() instead.");
        } else {
          throw new Error(`@aws-sdk/core/protocols - xml serializer, unhandled schema type for object value and schema: ${ns.getName(true)}`);
        }
      }
      if (ns.isBooleanSchema() || ns.isNumericSchema() || ns.isBigIntegerSchema() || ns.isBigDecimalSchema()) {
        nodeContents = String(value);
      }
      if (ns.isStringSchema()) {
        if (value === undefined && ns.isIdempotencyToken()) {
          nodeContents = serde.generateIdempotencyToken();
        } else {
          nodeContents = String(value);
        }
      }
      if (nodeContents === null) {
        throw new Error(`Unhandled schema-value pair ${ns.getName(true)}=${value}`);
      }
      return nodeContents;
    }
    writeSimpleInto(_schema, value, into, parentXmlns) {
      const nodeContents = this.writeSimple(_schema, value);
      const ns = schema.NormalizedSchema.of(_schema);
      const content = new xmlBuilder.XmlText(nodeContents);
      const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);
      if (xmlns) {
        into.addAttribute(xmlnsAttr, xmlns);
      }
      into.addChildNode(content);
    }
    getXmlnsAttribute(ns, parentXmlns) {
      const traits = ns.getMergedTraits();
      const [prefix, xmlns] = traits.xmlNamespace ?? [];
      if (xmlns && xmlns !== parentXmlns) {
        return [prefix ? `xmlns:${prefix}` : "xmlns", xmlns];
      }
      return [undefined, undefined];
    }
  }

  class XmlCodec extends SerdeContextConfig {
    settings;
    constructor(settings) {
      super();
      this.settings = settings;
    }
    createSerializer() {
      const serializer = new XmlShapeSerializer(this.settings);
      serializer.setSerdeContext(this.serdeContext);
      return serializer;
    }
    createDeserializer() {
      const deserializer = new XmlShapeDeserializer(this.settings);
      deserializer.setSerdeContext(this.serdeContext);
      return deserializer;
    }
  }

  class AwsRestXmlProtocol extends protocols.HttpBindingProtocol {
    codec;
    serializer;
    deserializer;
    mixin = new ProtocolLib;
    constructor(options) {
      super(options);
      const settings = {
        timestampFormat: {
          useTrait: true,
          default: 5
        },
        httpBindings: true,
        xmlNamespace: options.xmlNamespace,
        serviceNamespace: options.defaultNamespace
      };
      this.codec = new XmlCodec(settings);
      this.serializer = new protocols.HttpInterceptingShapeSerializer(this.codec.createSerializer(), settings);
      this.deserializer = new protocols.HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), settings);
    }
    getPayloadCodec() {
      return this.codec;
    }
    getShapeId() {
      return "aws.protocols#restXml";
    }
    async serializeRequest(operationSchema, input, context) {
      const request = await super.serializeRequest(operationSchema, input, context);
      const inputSchema = schema.NormalizedSchema.of(operationSchema.input);
      if (!request.headers["content-type"]) {
        const contentType = this.mixin.resolveRestContentType(this.getDefaultContentType(), inputSchema);
        if (contentType) {
          request.headers["content-type"] = contentType;
        }
      }
      if (request.headers["content-type"] === this.getDefaultContentType()) {
        if (typeof request.body === "string") {
          request.body = '<?xml version="1.0" encoding="UTF-8"?>' + request.body;
        }
      }
      return request;
    }
    async deserializeResponse(operationSchema, context, response) {
      return super.deserializeResponse(operationSchema, context, response);
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
      const errorIdentifier = loadRestXmlErrorCode(response, dataObject) ?? "Unknown";
      const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, dataObject, metadata);
      const ns = schema.NormalizedSchema.of(errorSchema);
      const message = dataObject.Error?.message ?? dataObject.Error?.Message ?? dataObject.message ?? dataObject.Message ?? "Unknown";
      const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
      const exception = new ErrorCtor(message);
      await this.deserializeHttpMessage(errorSchema, context, response, dataObject);
      const output = {};
      for (const [name, member] of ns.structIterator()) {
        const target = member.getMergedTraits().xmlName ?? name;
        const value = dataObject.Error?.[target] ?? dataObject[target];
        output[name] = this.codec.createDeserializer().readSchema(member, value);
      }
      throw Object.assign(exception, errorMetadata, {
        $fault: ns.getMergedTraits().error,
        message
      }, output);
    }
    getDefaultContentType() {
      return "application/xml";
    }
  }
  exports.AWSSDKSigV4Signer = AWSSDKSigV4Signer;
  exports.AwsEc2QueryProtocol = AwsEc2QueryProtocol;
  exports.AwsJson1_0Protocol = AwsJson1_0Protocol;
  exports.AwsJson1_1Protocol = AwsJson1_1Protocol;
  exports.AwsJsonRpcProtocol = AwsJsonRpcProtocol;
  exports.AwsQueryProtocol = AwsQueryProtocol;
  exports.AwsRestJsonProtocol = AwsRestJsonProtocol;
  exports.AwsRestXmlProtocol = AwsRestXmlProtocol;
  exports.AwsSdkSigV4ASigner = AwsSdkSigV4ASigner;
  exports.AwsSdkSigV4Signer = AwsSdkSigV4Signer;
  exports.AwsSmithyRpcV2CborProtocol = AwsSmithyRpcV2CborProtocol;
  exports.JsonCodec = JsonCodec;
  exports.JsonShapeDeserializer = JsonShapeDeserializer;
  exports.JsonShapeSerializer = JsonShapeSerializer;
  exports.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS = NODE_AUTH_SCHEME_PREFERENCE_OPTIONS;
  exports.NODE_SIGV4A_CONFIG_OPTIONS = NODE_SIGV4A_CONFIG_OPTIONS;
  exports.XmlCodec = XmlCodec;
  exports.XmlShapeDeserializer = XmlShapeDeserializer;
  exports.XmlShapeSerializer = XmlShapeSerializer;
  exports._toBool = _toBool;
  exports._toNum = _toNum;
  exports._toStr = _toStr;
  exports.awsExpectUnion = awsExpectUnion;
  exports.emitWarningIfUnsupportedVersion = emitWarningIfUnsupportedVersion;
  exports.getBearerTokenEnvKey = getBearerTokenEnvKey;
  exports.loadRestJsonErrorCode = loadRestJsonErrorCode;
  exports.loadRestXmlErrorCode = loadRestXmlErrorCode;
  exports.parseJsonBody = parseJsonBody;
  exports.parseJsonErrorBody = parseJsonErrorBody;
  exports.parseXmlBody = parseXmlBody;
  exports.parseXmlErrorBody = parseXmlErrorBody;
  exports.resolveAWSSDKSigV4Config = resolveAWSSDKSigV4Config;
  exports.resolveAwsSdkSigV4AConfig = resolveAwsSdkSigV4AConfig;
  exports.resolveAwsSdkSigV4Config = resolveAwsSdkSigV4Config;
  exports.setCredentialFeature = setCredentialFeature;
  exports.setFeature = setFeature;
  exports.setTokenFeature = setTokenFeature;
  exports.state = state;
  exports.validateSigningProperties = validateSigningProperties;
});

// node_modules/@aws-sdk/middleware-user-agent/dist-cjs/index.js
var require_dist_cjs31 = __commonJS((exports) => {
  var core2 = require_dist_cjs19();
  var utilEndpoints = require_dist_cjs23();
  var protocolHttp = require_dist_cjs3();
  var core$1 = require_dist_cjs30();
  var DEFAULT_UA_APP_ID = undefined;
  function isValidUserAgentAppId(appId) {
    if (appId === undefined) {
      return true;
    }
    return typeof appId === "string" && appId.length <= 50;
  }
  function resolveUserAgentConfig(input) {
    const normalizedAppIdProvider = core2.normalizeProvider(input.userAgentAppId ?? DEFAULT_UA_APP_ID);
    const { customUserAgent } = input;
    return Object.assign(input, {
      customUserAgent: typeof customUserAgent === "string" ? [[customUserAgent]] : customUserAgent,
      userAgentAppId: async () => {
        const appId = await normalizedAppIdProvider();
        if (!isValidUserAgentAppId(appId)) {
          const logger = input.logger?.constructor?.name === "NoOpLogger" || !input.logger ? console : input.logger;
          if (typeof appId !== "string") {
            logger?.warn("userAgentAppId must be a string or undefined.");
          } else if (appId.length > 50) {
            logger?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.");
          }
        }
        return appId;
      }
    });
  }
  var ACCOUNT_ID_ENDPOINT_REGEX = /\d{12}\.ddb/;
  async function checkFeatures(context, config, args) {
    const request = args.request;
    if (request?.headers?.["smithy-protocol"] === "rpc-v2-cbor") {
      core$1.setFeature(context, "PROTOCOL_RPC_V2_CBOR", "M");
    }
    if (typeof config.retryStrategy === "function") {
      const retryStrategy = await config.retryStrategy();
      if (typeof retryStrategy.acquireInitialRetryToken === "function") {
        if (retryStrategy.constructor?.name?.includes("Adaptive")) {
          core$1.setFeature(context, "RETRY_MODE_ADAPTIVE", "F");
        } else {
          core$1.setFeature(context, "RETRY_MODE_STANDARD", "E");
        }
      } else {
        core$1.setFeature(context, "RETRY_MODE_LEGACY", "D");
      }
    }
    if (typeof config.accountIdEndpointMode === "function") {
      const endpointV2 = context.endpointV2;
      if (String(endpointV2?.url?.hostname).match(ACCOUNT_ID_ENDPOINT_REGEX)) {
        core$1.setFeature(context, "ACCOUNT_ID_ENDPOINT", "O");
      }
      switch (await config.accountIdEndpointMode?.()) {
        case "disabled":
          core$1.setFeature(context, "ACCOUNT_ID_MODE_DISABLED", "Q");
          break;
        case "preferred":
          core$1.setFeature(context, "ACCOUNT_ID_MODE_PREFERRED", "P");
          break;
        case "required":
          core$1.setFeature(context, "ACCOUNT_ID_MODE_REQUIRED", "R");
          break;
      }
    }
    const identity = context.__smithy_context?.selectedHttpAuthScheme?.identity;
    if (identity?.$source) {
      const credentials = identity;
      if (credentials.accountId) {
        core$1.setFeature(context, "RESOLVED_ACCOUNT_ID", "T");
      }
      for (const [key, value] of Object.entries(credentials.$source ?? {})) {
        core$1.setFeature(context, key, value);
      }
    }
  }
  var USER_AGENT = "user-agent";
  var X_AMZ_USER_AGENT = "x-amz-user-agent";
  var SPACE = " ";
  var UA_NAME_SEPARATOR = "/";
  var UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
  var UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
  var UA_ESCAPE_CHAR = "-";
  var BYTE_LIMIT = 1024;
  function encodeFeatures(features) {
    let buffer = "";
    for (const key in features) {
      const val = features[key];
      if (buffer.length + val.length + 1 <= BYTE_LIMIT) {
        if (buffer.length) {
          buffer += "," + val;
        } else {
          buffer += val;
        }
        continue;
      }
      break;
    }
    return buffer;
  }
  var userAgentMiddleware = (options) => (next, context) => async (args) => {
    const { request } = args;
    if (!protocolHttp.HttpRequest.isInstance(request)) {
      return next(args);
    }
    const { headers } = request;
    const userAgent = context?.userAgent?.map(escapeUserAgent) || [];
    const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
    await checkFeatures(context, options, args);
    const awsContext = context;
    defaultUserAgent.push(`m/${encodeFeatures(Object.assign({}, context.__smithy_context?.features, awsContext.__aws_sdk_context?.features))}`);
    const customUserAgent = options?.customUserAgent?.map(escapeUserAgent) || [];
    const appId = await options.userAgentAppId();
    if (appId) {
      defaultUserAgent.push(escapeUserAgent([`app/${appId}`]));
    }
    const prefix = utilEndpoints.getUserAgentPrefix();
    const sdkUserAgentValue = (prefix ? [prefix] : []).concat([...defaultUserAgent, ...userAgent, ...customUserAgent]).join(SPACE);
    const normalUAValue = [
      ...defaultUserAgent.filter((section) => section.startsWith("aws-sdk-")),
      ...customUserAgent
    ].join(SPACE);
    if (options.runtime !== "browser") {
      if (normalUAValue) {
        headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT] ? `${headers[USER_AGENT]} ${normalUAValue}` : normalUAValue;
      }
      headers[USER_AGENT] = sdkUserAgentValue;
    } else {
      headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
    }
    return next({
      ...args,
      request
    });
  };
  var escapeUserAgent = (userAgentPair) => {
    const name = userAgentPair[0].split(UA_NAME_SEPARATOR).map((part) => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR)).join(UA_NAME_SEPARATOR);
    const version = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);
    const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR);
    const prefix = name.substring(0, prefixSeparatorIndex);
    let uaName = name.substring(prefixSeparatorIndex + 1);
    if (prefix === "api") {
      uaName = uaName.toLowerCase();
    }
    return [prefix, uaName, version].filter((item) => item && item.length > 0).reduce((acc, item, index) => {
      switch (index) {
        case 0:
          return item;
        case 1:
          return `${acc}/${item}`;
        default:
          return `${acc}#${item}`;
      }
    }, "");
  };
  var getUserAgentMiddlewareOptions = {
    name: "getUserAgentMiddleware",
    step: "build",
    priority: "low",
    tags: ["SET_USER_AGENT", "USER_AGENT"],
    override: true
  };
  var getUserAgentPlugin = (config) => ({
    applyToStack: (clientStack) => {
      clientStack.add(userAgentMiddleware(config), getUserAgentMiddlewareOptions);
    }
  });
  exports.DEFAULT_UA_APP_ID = DEFAULT_UA_APP_ID;
  exports.getUserAgentMiddlewareOptions = getUserAgentMiddlewareOptions;
  exports.getUserAgentPlugin = getUserAgentPlugin;
  exports.resolveUserAgentConfig = resolveUserAgentConfig;
  exports.userAgentMiddleware = userAgentMiddleware;
});

// node_modules/@smithy/util-config-provider/dist-cjs/index.js
var require_dist_cjs32 = __commonJS((exports) => {
  var booleanSelector = (obj, key, type) => {
    if (!(key in obj))
      return;
    if (obj[key] === "true")
      return true;
    if (obj[key] === "false")
      return false;
    throw new Error(`Cannot load ${type} "${key}". Expected "true" or "false", got ${obj[key]}.`);
  };
  var numberSelector = (obj, key, type) => {
    if (!(key in obj))
      return;
    const numberValue = parseInt(obj[key], 10);
    if (Number.isNaN(numberValue)) {
      throw new TypeError(`Cannot load ${type} '${key}'. Expected number, got '${obj[key]}'.`);
    }
    return numberValue;
  };
  exports.SelectorType = undefined;
  (function(SelectorType) {
    SelectorType["ENV"] = "env";
    SelectorType["CONFIG"] = "shared config entry";
  })(exports.SelectorType || (exports.SelectorType = {}));
  exports.booleanSelector = booleanSelector;
  exports.numberSelector = numberSelector;
});

// node_modules/@smithy/config-resolver/dist-cjs/index.js
var require_dist_cjs33 = __commonJS((exports) => {
  var utilConfigProvider = require_dist_cjs32();
  var utilMiddleware2 = require_dist_cjs2();
  var utilEndpoints = require_dist_cjs20();
  var ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT";
  var CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint";
  var DEFAULT_USE_DUALSTACK_ENDPOINT = false;
  var NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env3) => utilConfigProvider.booleanSelector(env3, ENV_USE_DUALSTACK_ENDPOINT, utilConfigProvider.SelectorType.ENV),
    configFileSelector: (profile) => utilConfigProvider.booleanSelector(profile, CONFIG_USE_DUALSTACK_ENDPOINT, utilConfigProvider.SelectorType.CONFIG),
    default: false
  };
  var ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT";
  var CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint";
  var DEFAULT_USE_FIPS_ENDPOINT = false;
  var NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env3) => utilConfigProvider.booleanSelector(env3, ENV_USE_FIPS_ENDPOINT, utilConfigProvider.SelectorType.ENV),
    configFileSelector: (profile) => utilConfigProvider.booleanSelector(profile, CONFIG_USE_FIPS_ENDPOINT, utilConfigProvider.SelectorType.CONFIG),
    default: false
  };
  var resolveCustomEndpointsConfig = (input) => {
    const { tls, endpoint, urlParser, useDualstackEndpoint } = input;
    return Object.assign(input, {
      tls: tls ?? true,
      endpoint: utilMiddleware2.normalizeProvider(typeof endpoint === "string" ? urlParser(endpoint) : endpoint),
      isCustomEndpoint: true,
      useDualstackEndpoint: utilMiddleware2.normalizeProvider(useDualstackEndpoint ?? false)
    });
  };
  var getEndpointFromRegion = async (input) => {
    const { tls = true } = input;
    const region = await input.region();
    const dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
    if (!dnsHostRegex.test(region)) {
      throw new Error("Invalid region in client config");
    }
    const useDualstackEndpoint = await input.useDualstackEndpoint();
    const useFipsEndpoint = await input.useFipsEndpoint();
    const { hostname } = await input.regionInfoProvider(region, { useDualstackEndpoint, useFipsEndpoint }) ?? {};
    if (!hostname) {
      throw new Error("Cannot resolve hostname from client config");
    }
    return input.urlParser(`${tls ? "https:" : "http:"}//${hostname}`);
  };
  var resolveEndpointsConfig = (input) => {
    const useDualstackEndpoint = utilMiddleware2.normalizeProvider(input.useDualstackEndpoint ?? false);
    const { endpoint, useFipsEndpoint, urlParser, tls } = input;
    return Object.assign(input, {
      tls: tls ?? true,
      endpoint: endpoint ? utilMiddleware2.normalizeProvider(typeof endpoint === "string" ? urlParser(endpoint) : endpoint) : () => getEndpointFromRegion({ ...input, useDualstackEndpoint, useFipsEndpoint }),
      isCustomEndpoint: !!endpoint,
      useDualstackEndpoint
    });
  };
  var REGION_ENV_NAME = "AWS_REGION";
  var REGION_INI_NAME = "region";
  var NODE_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env3) => env3[REGION_ENV_NAME],
    configFileSelector: (profile) => profile[REGION_INI_NAME],
    default: () => {
      throw new Error("Region is missing");
    }
  };
  var NODE_REGION_CONFIG_FILE_OPTIONS = {
    preferredFile: "credentials"
  };
  var validRegions = new Set;
  var checkRegion = (region, check2 = utilEndpoints.isValidHostLabel) => {
    if (!validRegions.has(region) && !check2(region)) {
      throw new Error(`Region not accepted: region="${region}" is not a valid hostname component.`);
    } else {
      validRegions.add(region);
    }
  };
  var isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
  var getRealRegion = (region) => isFipsRegion(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region;
  var resolveRegionConfig = (input) => {
    const { region, useFipsEndpoint } = input;
    if (!region) {
      throw new Error("Region is missing");
    }
    return Object.assign(input, {
      region: async () => {
        const providedRegion = typeof region === "function" ? await region() : region;
        const realRegion = getRealRegion(providedRegion);
        checkRegion(realRegion);
        return realRegion;
      },
      useFipsEndpoint: async () => {
        const providedRegion = typeof region === "string" ? region : await region();
        if (isFipsRegion(providedRegion)) {
          return true;
        }
        return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
      }
    });
  };
  var getHostnameFromVariants = (variants = [], { useFipsEndpoint, useDualstackEndpoint }) => variants.find(({ tags }) => useFipsEndpoint === tags.includes("fips") && useDualstackEndpoint === tags.includes("dualstack"))?.hostname;
  var getResolvedHostname = (resolvedRegion, { regionHostname, partitionHostname }) => regionHostname ? regionHostname : partitionHostname ? partitionHostname.replace("{region}", resolvedRegion) : undefined;
  var getResolvedPartition = (region, { partitionHash }) => Object.keys(partitionHash || {}).find((key) => partitionHash[key].regions.includes(region)) ?? "aws";
  var getResolvedSigningRegion = (hostname, { signingRegion, regionRegex, useFipsEndpoint }) => {
    if (signingRegion) {
      return signingRegion;
    } else if (useFipsEndpoint) {
      const regionRegexJs = regionRegex.replace("\\\\", "\\").replace(/^\^/g, "\\.").replace(/\$$/g, "\\.");
      const regionRegexmatchArray = hostname.match(regionRegexJs);
      if (regionRegexmatchArray) {
        return regionRegexmatchArray[0].slice(1, -1);
      }
    }
  };
  var getRegionInfo = (region, { useFipsEndpoint = false, useDualstackEndpoint = false, signingService, regionHash, partitionHash }) => {
    const partition = getResolvedPartition(region, { partitionHash });
    const resolvedRegion = region in regionHash ? region : partitionHash[partition]?.endpoint ?? region;
    const hostnameOptions = { useFipsEndpoint, useDualstackEndpoint };
    const regionHostname = getHostnameFromVariants(regionHash[resolvedRegion]?.variants, hostnameOptions);
    const partitionHostname = getHostnameFromVariants(partitionHash[partition]?.variants, hostnameOptions);
    const hostname = getResolvedHostname(resolvedRegion, { regionHostname, partitionHostname });
    if (hostname === undefined) {
      throw new Error(`Endpoint resolution failed for: ${{ resolvedRegion, useFipsEndpoint, useDualstackEndpoint }}`);
    }
    const signingRegion = getResolvedSigningRegion(hostname, {
      signingRegion: regionHash[resolvedRegion]?.signingRegion,
      regionRegex: partitionHash[partition].regionRegex,
      useFipsEndpoint
    });
    return {
      partition,
      signingService,
      hostname,
      ...signingRegion && { signingRegion },
      ...regionHash[resolvedRegion]?.signingService && {
        signingService: regionHash[resolvedRegion].signingService
      }
    };
  };
  exports.CONFIG_USE_DUALSTACK_ENDPOINT = CONFIG_USE_DUALSTACK_ENDPOINT;
  exports.CONFIG_USE_FIPS_ENDPOINT = CONFIG_USE_FIPS_ENDPOINT;
  exports.DEFAULT_USE_DUALSTACK_ENDPOINT = DEFAULT_USE_DUALSTACK_ENDPOINT;
  exports.DEFAULT_USE_FIPS_ENDPOINT = DEFAULT_USE_FIPS_ENDPOINT;
  exports.ENV_USE_DUALSTACK_ENDPOINT = ENV_USE_DUALSTACK_ENDPOINT;
  exports.ENV_USE_FIPS_ENDPOINT = ENV_USE_FIPS_ENDPOINT;
  exports.NODE_REGION_CONFIG_FILE_OPTIONS = NODE_REGION_CONFIG_FILE_OPTIONS;
  exports.NODE_REGION_CONFIG_OPTIONS = NODE_REGION_CONFIG_OPTIONS;
  exports.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS;
  exports.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS;
  exports.REGION_ENV_NAME = REGION_ENV_NAME;
  exports.REGION_INI_NAME = REGION_INI_NAME;
  exports.getRegionInfo = getRegionInfo;
  exports.resolveCustomEndpointsConfig = resolveCustomEndpointsConfig;
  exports.resolveEndpointsConfig = resolveEndpointsConfig;
  exports.resolveRegionConfig = resolveRegionConfig;
});

// node_modules/@smithy/middleware-content-length/dist-cjs/index.js
var require_dist_cjs34 = __commonJS((exports) => {
  var protocolHttp = require_dist_cjs3();
  var CONTENT_LENGTH_HEADER = "content-length";
  function contentLengthMiddleware(bodyLengthChecker) {
    return (next) => async (args) => {
      const request = args.request;
      if (protocolHttp.HttpRequest.isInstance(request)) {
        const { body, headers } = request;
        if (body && Object.keys(headers).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER) === -1) {
          try {
            const length = bodyLengthChecker(body);
            request.headers = {
              ...request.headers,
              [CONTENT_LENGTH_HEADER]: String(length)
            };
          } catch (error) {}
        }
      }
      return next({
        ...args,
        request
      });
    };
  }
  var contentLengthMiddlewareOptions = {
    step: "build",
    tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
    name: "contentLengthMiddleware",
    override: true
  };
  var getContentLengthPlugin = (options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
    }
  });
  exports.contentLengthMiddleware = contentLengthMiddleware;
  exports.contentLengthMiddlewareOptions = contentLengthMiddlewareOptions;
  exports.getContentLengthPlugin = getContentLengthPlugin;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/getHomeDir.js
var require_getHomeDir = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getHomeDir = undefined;
  var os_1 = __require("os");
  var path_1 = __require("path");
  var homeDirCache = {};
  var getHomeDirCacheKey = () => {
    if (process && process.geteuid) {
      return `${process.geteuid()}`;
    }
    return "DEFAULT";
  };
  var getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${path_1.sep}` } = process.env;
    if (HOME)
      return HOME;
    if (USERPROFILE)
      return USERPROFILE;
    if (HOMEPATH)
      return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDirCacheKey();
    if (!homeDirCache[homeDirCacheKey])
      homeDirCache[homeDirCacheKey] = (0, os_1.homedir)();
    return homeDirCache[homeDirCacheKey];
  };
  exports.getHomeDir = getHomeDir;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/getSSOTokenFilepath.js
var require_getSSOTokenFilepath = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSSOTokenFilepath = undefined;
  var crypto_1 = __require("crypto");
  var path_1 = __require("path");
  var getHomeDir_1 = require_getHomeDir();
  var getSSOTokenFilepath = (id) => {
    const hasher = (0, crypto_1.createHash)("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "sso", "cache", `${cacheName}.json`);
  };
  exports.getSSOTokenFilepath = getSSOTokenFilepath;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/getSSOTokenFromFile.js
var require_getSSOTokenFromFile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSSOTokenFromFile = exports.tokenIntercept = undefined;
  var fs_1 = __require("fs");
  var getSSOTokenFilepath_1 = require_getSSOTokenFilepath();
  var { readFile } = fs_1.promises;
  exports.tokenIntercept = {};
  var getSSOTokenFromFile = async (id) => {
    if (exports.tokenIntercept[id]) {
      return exports.tokenIntercept[id];
    }
    const ssoTokenFilepath = (0, getSSOTokenFilepath_1.getSSOTokenFilepath)(id);
    const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
  };
  exports.getSSOTokenFromFile = getSSOTokenFromFile;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/slurpFile.js
var require_slurpFile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.slurpFile = exports.fileIntercept = exports.filePromisesHash = undefined;
  var fs_1 = __require("fs");
  var { readFile } = fs_1.promises;
  exports.filePromisesHash = {};
  exports.fileIntercept = {};
  var slurpFile = (path, options) => {
    if (exports.fileIntercept[path] !== undefined) {
      return exports.fileIntercept[path];
    }
    if (!exports.filePromisesHash[path] || options?.ignoreCache) {
      exports.filePromisesHash[path] = readFile(path, "utf8");
    }
    return exports.filePromisesHash[path];
  };
  exports.slurpFile = slurpFile;
});

// node_modules/@smithy/shared-ini-file-loader/dist-cjs/index.js
var require_dist_cjs35 = __commonJS((exports) => {
  var getHomeDir = require_getHomeDir();
  var getSSOTokenFilepath = require_getSSOTokenFilepath();
  var getSSOTokenFromFile = require_getSSOTokenFromFile();
  var path = __require("path");
  var types = require_dist_cjs();
  var slurpFile = require_slurpFile();
  var ENV_PROFILE = "AWS_PROFILE";
  var DEFAULT_PROFILE = "default";
  var getProfileName = (init) => init.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE;
  var CONFIG_PREFIX_SEPARATOR = ".";
  var getConfigData = (data) => Object.entries(data).filter(([key]) => {
    const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
    if (indexOfSeparator === -1) {
      return false;
    }
    return Object.values(types.IniSectionType).includes(key.substring(0, indexOfSeparator));
  }).reduce((acc, [key, value]) => {
    const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
    const updatedKey = key.substring(0, indexOfSeparator) === types.IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
    acc[updatedKey] = value;
    return acc;
  }, {
    ...data.default && { default: data.default }
  });
  var ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
  var getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || path.join(getHomeDir.getHomeDir(), ".aws", "config");
  var ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
  var getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || path.join(getHomeDir.getHomeDir(), ".aws", "credentials");
  var prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
  var profileNameBlockList = ["__proto__", "profile __proto__"];
  var parseIni = (iniData) => {
    const map3 = {};
    let currentSection;
    let currentSubSection;
    for (const iniLine of iniData.split(/\r?\n/)) {
      const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
      const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
      if (isSection) {
        currentSection = undefined;
        currentSubSection = undefined;
        const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
        const matches = prefixKeyRegex.exec(sectionName);
        if (matches) {
          const [, prefix, , name] = matches;
          if (Object.values(types.IniSectionType).includes(prefix)) {
            currentSection = [prefix, name].join(CONFIG_PREFIX_SEPARATOR);
          }
        } else {
          currentSection = sectionName;
        }
        if (profileNameBlockList.includes(sectionName)) {
          throw new Error(`Found invalid profile name "${sectionName}"`);
        }
      } else if (currentSection) {
        const indexOfEqualsSign = trimmedLine.indexOf("=");
        if (![0, -1].includes(indexOfEqualsSign)) {
          const [name, value] = [
            trimmedLine.substring(0, indexOfEqualsSign).trim(),
            trimmedLine.substring(indexOfEqualsSign + 1).trim()
          ];
          if (value === "") {
            currentSubSection = name;
          } else {
            if (currentSubSection && iniLine.trimStart() === iniLine) {
              currentSubSection = undefined;
            }
            map3[currentSection] = map3[currentSection] || {};
            const key = currentSubSection ? [currentSubSection, name].join(CONFIG_PREFIX_SEPARATOR) : name;
            map3[currentSection][key] = value;
          }
        }
      }
    }
    return map3;
  };
  var swallowError$1 = () => ({});
  var loadSharedConfigFiles = async (init = {}) => {
    const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath() } = init;
    const homeDir = getHomeDir.getHomeDir();
    const relativeHomeDirPrefix = "~/";
    let resolvedFilepath = filepath;
    if (filepath.startsWith(relativeHomeDirPrefix)) {
      resolvedFilepath = path.join(homeDir, filepath.slice(2));
    }
    let resolvedConfigFilepath = configFilepath;
    if (configFilepath.startsWith(relativeHomeDirPrefix)) {
      resolvedConfigFilepath = path.join(homeDir, configFilepath.slice(2));
    }
    const parsedFiles = await Promise.all([
      slurpFile.slurpFile(resolvedConfigFilepath, {
        ignoreCache: init.ignoreCache
      }).then(parseIni).then(getConfigData).catch(swallowError$1),
      slurpFile.slurpFile(resolvedFilepath, {
        ignoreCache: init.ignoreCache
      }).then(parseIni).catch(swallowError$1)
    ]);
    return {
      configFile: parsedFiles[0],
      credentialsFile: parsedFiles[1]
    };
  };
  var getSsoSessionData = (data) => Object.entries(data).filter(([key]) => key.startsWith(types.IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR)).reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value }), {});
  var swallowError = () => ({});
  var loadSsoSessionData = async (init = {}) => slurpFile.slurpFile(init.configFilepath ?? getConfigFilepath()).then(parseIni).then(getSsoSessionData).catch(swallowError);
  var mergeConfigFiles = (...files) => {
    const merged = {};
    for (const file of files) {
      for (const [key, values] of Object.entries(file)) {
        if (merged[key] !== undefined) {
          Object.assign(merged[key], values);
        } else {
          merged[key] = values;
        }
      }
    }
    return merged;
  };
  var parseKnownFiles = async (init) => {
    const parsedFiles = await loadSharedConfigFiles(init);
    return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
  };
  var externalDataInterceptor = {
    getFileRecord() {
      return slurpFile.fileIntercept;
    },
    interceptFile(path2, contents) {
      slurpFile.fileIntercept[path2] = Promise.resolve(contents);
    },
    getTokenRecord() {
      return getSSOTokenFromFile.tokenIntercept;
    },
    interceptToken(id, contents) {
      getSSOTokenFromFile.tokenIntercept[id] = contents;
    }
  };
  Object.defineProperty(exports, "getSSOTokenFromFile", {
    enumerable: true,
    get: function() {
      return getSSOTokenFromFile.getSSOTokenFromFile;
    }
  });
  exports.CONFIG_PREFIX_SEPARATOR = CONFIG_PREFIX_SEPARATOR;
  exports.DEFAULT_PROFILE = DEFAULT_PROFILE;
  exports.ENV_PROFILE = ENV_PROFILE;
  exports.externalDataInterceptor = externalDataInterceptor;
  exports.getProfileName = getProfileName;
  exports.loadSharedConfigFiles = loadSharedConfigFiles;
  exports.loadSsoSessionData = loadSsoSessionData;
  exports.parseKnownFiles = parseKnownFiles;
  Object.keys(getHomeDir).forEach(function(k2) {
    if (k2 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k2))
      Object.defineProperty(exports, k2, {
        enumerable: true,
        get: function() {
          return getHomeDir[k2];
        }
      });
  });
  Object.keys(getSSOTokenFilepath).forEach(function(k2) {
    if (k2 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k2))
      Object.defineProperty(exports, k2, {
        enumerable: true,
        get: function() {
          return getSSOTokenFilepath[k2];
        }
      });
  });
});

// node_modules/@smithy/node-config-provider/dist-cjs/index.js
var require_dist_cjs36 = __commonJS((exports) => {
  var propertyProvider = require_dist_cjs24();
  var sharedIniFileLoader = require_dist_cjs35();
  function getSelectorName(functionString) {
    try {
      const constants = new Set(Array.from(functionString.match(/([A-Z_]){3,}/g) ?? []));
      constants.delete("CONFIG");
      constants.delete("CONFIG_PREFIX_SEPARATOR");
      constants.delete("ENV");
      return [...constants].join(", ");
    } catch (e) {
      return functionString;
    }
  }
  var fromEnv = (envVarSelector, options) => async () => {
    try {
      const config = envVarSelector(process.env, options);
      if (config === undefined) {
        throw new Error;
      }
      return config;
    } catch (e) {
      throw new propertyProvider.CredentialsProviderError(e.message || `Not found in ENV: ${getSelectorName(envVarSelector.toString())}`, { logger: options?.logger });
    }
  };
  var fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init } = {}) => async () => {
    const profile = sharedIniFileLoader.getProfileName(init);
    const { configFile, credentialsFile } = await sharedIniFileLoader.loadSharedConfigFiles(init);
    const profileFromCredentials = credentialsFile[profile] || {};
    const profileFromConfig = configFile[profile] || {};
    const mergedProfile = preferredFile === "config" ? { ...profileFromCredentials, ...profileFromConfig } : { ...profileFromConfig, ...profileFromCredentials };
    try {
      const cfgFile = preferredFile === "config" ? configFile : credentialsFile;
      const configValue = configSelector(mergedProfile, cfgFile);
      if (configValue === undefined) {
        throw new Error;
      }
      return configValue;
    } catch (e) {
      throw new propertyProvider.CredentialsProviderError(e.message || `Not found in config files w/ profile [${profile}]: ${getSelectorName(configSelector.toString())}`, { logger: init.logger });
    }
  };
  var isFunction = (func) => typeof func === "function";
  var fromStatic = (defaultValue) => isFunction(defaultValue) ? async () => await defaultValue() : propertyProvider.fromStatic(defaultValue);
  var loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => {
    const { signingName, logger } = configuration;
    const envOptions = { signingName, logger };
    return propertyProvider.memoize(propertyProvider.chain(fromEnv(environmentVariableSelector, envOptions), fromSharedConfigFiles(configFileSelector, configuration), fromStatic(defaultValue)));
  };
  exports.loadConfig = loadConfig;
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/getEndpointUrlConfig.js
var require_getEndpointUrlConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEndpointUrlConfig = undefined;
  var shared_ini_file_loader_1 = require_dist_cjs35();
  var ENV_ENDPOINT_URL = "AWS_ENDPOINT_URL";
  var CONFIG_ENDPOINT_URL = "endpoint_url";
  var getEndpointUrlConfig = (serviceId) => ({
    environmentVariableSelector: (env3) => {
      const serviceSuffixParts = serviceId.split(" ").map((w) => w.toUpperCase());
      const serviceEndpointUrl = env3[[ENV_ENDPOINT_URL, ...serviceSuffixParts].join("_")];
      if (serviceEndpointUrl)
        return serviceEndpointUrl;
      const endpointUrl = env3[ENV_ENDPOINT_URL];
      if (endpointUrl)
        return endpointUrl;
      return;
    },
    configFileSelector: (profile, config) => {
      if (config && profile.services) {
        const servicesSection = config[["services", profile.services].join(shared_ini_file_loader_1.CONFIG_PREFIX_SEPARATOR)];
        if (servicesSection) {
          const servicePrefixParts = serviceId.split(" ").map((w) => w.toLowerCase());
          const endpointUrl2 = servicesSection[[servicePrefixParts.join("_"), CONFIG_ENDPOINT_URL].join(shared_ini_file_loader_1.CONFIG_PREFIX_SEPARATOR)];
          if (endpointUrl2)
            return endpointUrl2;
        }
      }
      const endpointUrl = profile[CONFIG_ENDPOINT_URL];
      if (endpointUrl)
        return endpointUrl;
      return;
    },
    default: undefined
  });
  exports.getEndpointUrlConfig = getEndpointUrlConfig;
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/getEndpointFromConfig.js
var require_getEndpointFromConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getEndpointFromConfig = undefined;
  var node_config_provider_1 = require_dist_cjs36();
  var getEndpointUrlConfig_1 = require_getEndpointUrlConfig();
  var getEndpointFromConfig = async (serviceId) => (0, node_config_provider_1.loadConfig)((0, getEndpointUrlConfig_1.getEndpointUrlConfig)(serviceId ?? ""))();
  exports.getEndpointFromConfig = getEndpointFromConfig;
});

// node_modules/@smithy/middleware-endpoint/dist-cjs/index.js
var require_dist_cjs37 = __commonJS((exports) => {
  var getEndpointFromConfig = require_getEndpointFromConfig();
  var urlParser = require_dist_cjs22();
  var core2 = require_dist_cjs19();
  var utilMiddleware2 = require_dist_cjs2();
  var middlewareSerde = require_dist_cjs7();
  var resolveParamsForS3 = async (endpointParams) => {
    const bucket = endpointParams?.Bucket || "";
    if (typeof endpointParams.Bucket === "string") {
      endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
    }
    if (isArnBucketName(bucket)) {
      if (endpointParams.ForcePathStyle === true) {
        throw new Error("Path-style addressing cannot be used with ARN buckets");
      }
    } else if (!isDnsCompatibleBucketName(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
      endpointParams.ForcePathStyle = true;
    }
    if (endpointParams.DisableMultiRegionAccessPoints) {
      endpointParams.disableMultiRegionAccessPoints = true;
      endpointParams.DisableMRAP = true;
    }
    return endpointParams;
  };
  var DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
  var IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
  var DOTS_PATTERN = /\.\./;
  var isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
  var isArnBucketName = (bucketName) => {
    const [arn, partition, service, , , bucket] = bucketName.split(":");
    const isArn = arn === "arn" && bucketName.split(":").length >= 6;
    const isValidArn = Boolean(isArn && partition && service && bucket);
    if (isArn && !isValidArn) {
      throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
    }
    return isValidArn;
  };
  var createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {
    const configProvider = async () => {
      const configValue = config[configKey] ?? config[canonicalEndpointParamKey];
      if (typeof configValue === "function") {
        return configValue();
      }
      return configValue;
    };
    if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
      return async () => {
        const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
        const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;
        return configValue;
      };
    }
    if (configKey === "accountId" || canonicalEndpointParamKey === "AccountId") {
      return async () => {
        const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
        const configValue = credentials?.accountId ?? credentials?.AccountId;
        return configValue;
      };
    }
    if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
      return async () => {
        if (config.isCustomEndpoint === false) {
          return;
        }
        const endpoint = await configProvider();
        if (endpoint && typeof endpoint === "object") {
          if ("url" in endpoint) {
            return endpoint.url.href;
          }
          if ("hostname" in endpoint) {
            const { protocol, hostname, port, path } = endpoint;
            return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
          }
        }
        return endpoint;
      };
    }
    return configProvider;
  };
  var toEndpointV1 = (endpoint) => {
    if (typeof endpoint === "object") {
      if ("url" in endpoint) {
        return urlParser.parseUrl(endpoint.url);
      }
      return endpoint;
    }
    return urlParser.parseUrl(endpoint);
  };
  var getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
    if (!clientConfig.isCustomEndpoint) {
      let endpointFromConfig;
      if (clientConfig.serviceConfiguredEndpoint) {
        endpointFromConfig = await clientConfig.serviceConfiguredEndpoint();
      } else {
        endpointFromConfig = await getEndpointFromConfig.getEndpointFromConfig(clientConfig.serviceId);
      }
      if (endpointFromConfig) {
        clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
        clientConfig.isCustomEndpoint = true;
      }
    }
    const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
    if (typeof clientConfig.endpointProvider !== "function") {
      throw new Error("config.endpointProvider is not set.");
    }
    const endpoint = clientConfig.endpointProvider(endpointParams, context);
    return endpoint;
  };
  var resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
    const endpointParams = {};
    const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
    for (const [name, instruction] of Object.entries(instructions)) {
      switch (instruction.type) {
        case "staticContextParams":
          endpointParams[name] = instruction.value;
          break;
        case "contextParams":
          endpointParams[name] = commandInput[instruction.name];
          break;
        case "clientContextParams":
        case "builtInParams":
          endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();
          break;
        case "operationContextParams":
          endpointParams[name] = instruction.get(commandInput);
          break;
        default:
          throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
      }
    }
    if (Object.keys(instructions).length === 0) {
      Object.assign(endpointParams, clientConfig);
    }
    if (String(clientConfig.serviceId).toLowerCase() === "s3") {
      await resolveParamsForS3(endpointParams);
    }
    return endpointParams;
  };
  var endpointMiddleware = ({ config, instructions }) => {
    return (next, context) => async (args) => {
      if (config.isCustomEndpoint) {
        core2.setFeature(context, "ENDPOINT_OVERRIDE", "N");
      }
      const endpoint = await getEndpointFromInstructions(args.input, {
        getEndpointParameterInstructions() {
          return instructions;
        }
      }, { ...config }, context);
      context.endpointV2 = endpoint;
      context.authSchemes = endpoint.properties?.authSchemes;
      const authScheme = context.authSchemes?.[0];
      if (authScheme) {
        context["signing_region"] = authScheme.signingRegion;
        context["signing_service"] = authScheme.signingName;
        const smithyContext = utilMiddleware2.getSmithyContext(context);
        const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
        if (httpAuthOption) {
          httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
            signing_region: authScheme.signingRegion,
            signingRegion: authScheme.signingRegion,
            signing_service: authScheme.signingName,
            signingName: authScheme.signingName,
            signingRegionSet: authScheme.signingRegionSet
          }, authScheme.properties);
        }
      }
      return next({
        ...args
      });
    };
  };
  var endpointMiddlewareOptions = {
    step: "serialize",
    tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
    name: "endpointV2Middleware",
    override: true,
    relation: "before",
    toMiddleware: middlewareSerde.serializerMiddlewareOption.name
  };
  var getEndpointPlugin = (config, instructions) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(endpointMiddleware({
        config,
        instructions
      }), endpointMiddlewareOptions);
    }
  });
  var resolveEndpointConfig = (input) => {
    const tls = input.tls ?? true;
    const { endpoint, useDualstackEndpoint, useFipsEndpoint } = input;
    const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await utilMiddleware2.normalizeProvider(endpoint)()) : undefined;
    const isCustomEndpoint = !!endpoint;
    const resolvedConfig = Object.assign(input, {
      endpoint: customEndpointProvider,
      tls,
      isCustomEndpoint,
      useDualstackEndpoint: utilMiddleware2.normalizeProvider(useDualstackEndpoint ?? false),
      useFipsEndpoint: utilMiddleware2.normalizeProvider(useFipsEndpoint ?? false)
    });
    let configuredEndpointPromise = undefined;
    resolvedConfig.serviceConfiguredEndpoint = async () => {
      if (input.serviceId && !configuredEndpointPromise) {
        configuredEndpointPromise = getEndpointFromConfig.getEndpointFromConfig(input.serviceId);
      }
      return configuredEndpointPromise;
    };
    return resolvedConfig;
  };
  var resolveEndpointRequiredConfig = (input) => {
    const { endpoint } = input;
    if (endpoint === undefined) {
      input.endpoint = async () => {
        throw new Error("@smithy/middleware-endpoint: (default endpointRuleSet) endpoint is not set - you must configure an endpoint.");
      };
    }
    return input;
  };
  exports.endpointMiddleware = endpointMiddleware;
  exports.endpointMiddlewareOptions = endpointMiddlewareOptions;
  exports.getEndpointFromInstructions = getEndpointFromInstructions;
  exports.getEndpointPlugin = getEndpointPlugin;
  exports.resolveEndpointConfig = resolveEndpointConfig;
  exports.resolveEndpointRequiredConfig = resolveEndpointRequiredConfig;
  exports.resolveParams = resolveParams;
  exports.toEndpointV1 = toEndpointV1;
});

// node_modules/@smithy/service-error-classification/dist-cjs/index.js
var require_dist_cjs38 = __commonJS((exports) => {
  var CLOCK_SKEW_ERROR_CODES = [
    "AuthFailure",
    "InvalidSignatureException",
    "RequestExpired",
    "RequestInTheFuture",
    "RequestTimeTooSkewed",
    "SignatureDoesNotMatch"
  ];
  var THROTTLING_ERROR_CODES = [
    "BandwidthLimitExceeded",
    "EC2ThrottledException",
    "LimitExceededException",
    "PriorRequestNotComplete",
    "ProvisionedThroughputExceededException",
    "RequestLimitExceeded",
    "RequestThrottled",
    "RequestThrottledException",
    "SlowDown",
    "ThrottledException",
    "Throttling",
    "ThrottlingException",
    "TooManyRequestsException",
    "TransactionInProgressException"
  ];
  var TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
  var TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
  var NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];
  var NODEJS_NETWORK_ERROR_CODES = ["EHOSTUNREACH", "ENETUNREACH", "ENOTFOUND"];
  var isRetryableByTrait = (error) => error?.$retryable !== undefined;
  var isClockSkewError = (error) => CLOCK_SKEW_ERROR_CODES.includes(error.name);
  var isClockSkewCorrectedError = (error) => error.$metadata?.clockSkewCorrected;
  var isBrowserNetworkError = (error) => {
    const errorMessages = new Set([
      "Failed to fetch",
      "NetworkError when attempting to fetch resource",
      "The Internet connection appears to be offline",
      "Load failed",
      "Network request failed"
    ]);
    const isValid = error && error instanceof TypeError;
    if (!isValid) {
      return false;
    }
    return errorMessages.has(error.message);
  };
  var isThrottlingError = (error) => error.$metadata?.httpStatusCode === 429 || THROTTLING_ERROR_CODES.includes(error.name) || error.$retryable?.throttling == true;
  var isTransientError = (error, depth = 0) => isRetryableByTrait(error) || isClockSkewCorrectedError(error) || TRANSIENT_ERROR_CODES.includes(error.name) || NODEJS_TIMEOUT_ERROR_CODES.includes(error?.code || "") || NODEJS_NETWORK_ERROR_CODES.includes(error?.code || "") || TRANSIENT_ERROR_STATUS_CODES.includes(error.$metadata?.httpStatusCode || 0) || isBrowserNetworkError(error) || error.cause !== undefined && depth <= 10 && isTransientError(error.cause, depth + 1);
  var isServerError = (error) => {
    if (error.$metadata?.httpStatusCode !== undefined) {
      const statusCode = error.$metadata.httpStatusCode;
      if (500 <= statusCode && statusCode <= 599 && !isTransientError(error)) {
        return true;
      }
      return false;
    }
    return false;
  };
  exports.isBrowserNetworkError = isBrowserNetworkError;
  exports.isClockSkewCorrectedError = isClockSkewCorrectedError;
  exports.isClockSkewError = isClockSkewError;
  exports.isRetryableByTrait = isRetryableByTrait;
  exports.isServerError = isServerError;
  exports.isThrottlingError = isThrottlingError;
  exports.isTransientError = isTransientError;
});

// node_modules/@smithy/util-retry/dist-cjs/index.js
var require_dist_cjs39 = __commonJS((exports) => {
  var serviceErrorClassification = require_dist_cjs38();
  exports.RETRY_MODES = undefined;
  (function(RETRY_MODES) {
    RETRY_MODES["STANDARD"] = "standard";
    RETRY_MODES["ADAPTIVE"] = "adaptive";
  })(exports.RETRY_MODES || (exports.RETRY_MODES = {}));
  var DEFAULT_MAX_ATTEMPTS = 3;
  var DEFAULT_RETRY_MODE = exports.RETRY_MODES.STANDARD;

  class DefaultRateLimiter {
    static setTimeoutFn = setTimeout;
    beta;
    minCapacity;
    minFillRate;
    scaleConstant;
    smooth;
    currentCapacity = 0;
    enabled = false;
    lastMaxRate = 0;
    measuredTxRate = 0;
    requestCount = 0;
    fillRate;
    lastThrottleTime;
    lastTimestamp = 0;
    lastTxRateBucket;
    maxCapacity;
    timeWindow = 0;
    constructor(options) {
      this.beta = options?.beta ?? 0.7;
      this.minCapacity = options?.minCapacity ?? 1;
      this.minFillRate = options?.minFillRate ?? 0.5;
      this.scaleConstant = options?.scaleConstant ?? 0.4;
      this.smooth = options?.smooth ?? 0.8;
      const currentTimeInSeconds = this.getCurrentTimeInSeconds();
      this.lastThrottleTime = currentTimeInSeconds;
      this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
      this.fillRate = this.minFillRate;
      this.maxCapacity = this.minCapacity;
    }
    getCurrentTimeInSeconds() {
      return Date.now() / 1000;
    }
    async getSendToken() {
      return this.acquireTokenBucket(1);
    }
    async acquireTokenBucket(amount) {
      if (!this.enabled) {
        return;
      }
      this.refillTokenBucket();
      if (amount > this.currentCapacity) {
        const delay = (amount - this.currentCapacity) / this.fillRate * 1000;
        await new Promise((resolve) => DefaultRateLimiter.setTimeoutFn(resolve, delay));
      }
      this.currentCapacity = this.currentCapacity - amount;
    }
    refillTokenBucket() {
      const timestamp = this.getCurrentTimeInSeconds();
      if (!this.lastTimestamp) {
        this.lastTimestamp = timestamp;
        return;
      }
      const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
      this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
      this.lastTimestamp = timestamp;
    }
    updateClientSendingRate(response) {
      let calculatedRate;
      this.updateMeasuredRate();
      if (serviceErrorClassification.isThrottlingError(response)) {
        const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
        this.lastMaxRate = rateToUse;
        this.calculateTimeWindow();
        this.lastThrottleTime = this.getCurrentTimeInSeconds();
        calculatedRate = this.cubicThrottle(rateToUse);
        this.enableTokenBucket();
      } else {
        this.calculateTimeWindow();
        calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
      }
      const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
      this.updateTokenBucketRate(newRate);
    }
    calculateTimeWindow() {
      this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
    }
    cubicThrottle(rateToUse) {
      return this.getPrecise(rateToUse * this.beta);
    }
    cubicSuccess(timestamp) {
      return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
    }
    enableTokenBucket() {
      this.enabled = true;
    }
    updateTokenBucketRate(newRate) {
      this.refillTokenBucket();
      this.fillRate = Math.max(newRate, this.minFillRate);
      this.maxCapacity = Math.max(newRate, this.minCapacity);
      this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
    }
    updateMeasuredRate() {
      const t2 = this.getCurrentTimeInSeconds();
      const timeBucket = Math.floor(t2 * 2) / 2;
      this.requestCount++;
      if (timeBucket > this.lastTxRateBucket) {
        const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
        this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
        this.requestCount = 0;
        this.lastTxRateBucket = timeBucket;
      }
    }
    getPrecise(num) {
      return parseFloat(num.toFixed(8));
    }
  }
  var DEFAULT_RETRY_DELAY_BASE = 100;
  var MAXIMUM_RETRY_DELAY = 20 * 1000;
  var THROTTLING_RETRY_DELAY_BASE = 500;
  var INITIAL_RETRY_TOKENS = 500;
  var RETRY_COST = 5;
  var TIMEOUT_RETRY_COST = 10;
  var NO_RETRY_INCREMENT = 1;
  var INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
  var REQUEST_HEADER = "amz-sdk-request";
  var getDefaultRetryBackoffStrategy = () => {
    let delayBase = DEFAULT_RETRY_DELAY_BASE;
    const computeNextBackoffDelay = (attempts) => {
      return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
    };
    const setDelayBase = (delay) => {
      delayBase = delay;
    };
    return {
      computeNextBackoffDelay,
      setDelayBase
    };
  };
  var createDefaultRetryToken = ({ retryDelay, retryCount, retryCost }) => {
    const getRetryCount = () => retryCount;
    const getRetryDelay = () => Math.min(MAXIMUM_RETRY_DELAY, retryDelay);
    const getRetryCost = () => retryCost;
    return {
      getRetryCount,
      getRetryDelay,
      getRetryCost
    };
  };

  class StandardRetryStrategy {
    maxAttempts;
    mode = exports.RETRY_MODES.STANDARD;
    capacity = INITIAL_RETRY_TOKENS;
    retryBackoffStrategy = getDefaultRetryBackoffStrategy();
    maxAttemptsProvider;
    constructor(maxAttempts) {
      this.maxAttempts = maxAttempts;
      this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
    }
    async acquireInitialRetryToken(retryTokenScope) {
      return createDefaultRetryToken({
        retryDelay: DEFAULT_RETRY_DELAY_BASE,
        retryCount: 0
      });
    }
    async refreshRetryTokenForRetry(token, errorInfo) {
      const maxAttempts = await this.getMaxAttempts();
      if (this.shouldRetry(token, errorInfo, maxAttempts)) {
        const errorType = errorInfo.errorType;
        this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);
        const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
        const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;
        const capacityCost = this.getCapacityCost(errorType);
        this.capacity -= capacityCost;
        return createDefaultRetryToken({
          retryDelay,
          retryCount: token.getRetryCount() + 1,
          retryCost: capacityCost
        });
      }
      throw new Error("No retry token available");
    }
    recordSuccess(token) {
      this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));
    }
    getCapacity() {
      return this.capacity;
    }
    async getMaxAttempts() {
      try {
        return await this.maxAttemptsProvider();
      } catch (error) {
        console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
        return DEFAULT_MAX_ATTEMPTS;
      }
    }
    shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
      const attempts = tokenToRenew.getRetryCount() + 1;
      return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
    }
    getCapacityCost(errorType) {
      return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST : RETRY_COST;
    }
    isRetryableError(errorType) {
      return errorType === "THROTTLING" || errorType === "TRANSIENT";
    }
  }

  class AdaptiveRetryStrategy {
    maxAttemptsProvider;
    rateLimiter;
    standardRetryStrategy;
    mode = exports.RETRY_MODES.ADAPTIVE;
    constructor(maxAttemptsProvider, options) {
      this.maxAttemptsProvider = maxAttemptsProvider;
      const { rateLimiter } = options ?? {};
      this.rateLimiter = rateLimiter ?? new DefaultRateLimiter;
      this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);
    }
    async acquireInitialRetryToken(retryTokenScope) {
      await this.rateLimiter.getSendToken();
      return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
      this.rateLimiter.updateClientSendingRate(errorInfo);
      return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
    }
    recordSuccess(token) {
      this.rateLimiter.updateClientSendingRate({});
      this.standardRetryStrategy.recordSuccess(token);
    }
  }

  class ConfiguredRetryStrategy extends StandardRetryStrategy {
    computeNextBackoffDelay;
    constructor(maxAttempts, computeNextBackoffDelay = DEFAULT_RETRY_DELAY_BASE) {
      super(typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts);
      if (typeof computeNextBackoffDelay === "number") {
        this.computeNextBackoffDelay = () => computeNextBackoffDelay;
      } else {
        this.computeNextBackoffDelay = computeNextBackoffDelay;
      }
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
      const token = await super.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
      token.getRetryDelay = () => this.computeNextBackoffDelay(token.getRetryCount());
      return token;
    }
  }
  exports.AdaptiveRetryStrategy = AdaptiveRetryStrategy;
  exports.ConfiguredRetryStrategy = ConfiguredRetryStrategy;
  exports.DEFAULT_MAX_ATTEMPTS = DEFAULT_MAX_ATTEMPTS;
  exports.DEFAULT_RETRY_DELAY_BASE = DEFAULT_RETRY_DELAY_BASE;
  exports.DEFAULT_RETRY_MODE = DEFAULT_RETRY_MODE;
  exports.DefaultRateLimiter = DefaultRateLimiter;
  exports.INITIAL_RETRY_TOKENS = INITIAL_RETRY_TOKENS;
  exports.INVOCATION_ID_HEADER = INVOCATION_ID_HEADER;
  exports.MAXIMUM_RETRY_DELAY = MAXIMUM_RETRY_DELAY;
  exports.NO_RETRY_INCREMENT = NO_RETRY_INCREMENT;
  exports.REQUEST_HEADER = REQUEST_HEADER;
  exports.RETRY_COST = RETRY_COST;
  exports.StandardRetryStrategy = StandardRetryStrategy;
  exports.THROTTLING_RETRY_DELAY_BASE = THROTTLING_RETRY_DELAY_BASE;
  exports.TIMEOUT_RETRY_COST = TIMEOUT_RETRY_COST;
});

// node_modules/@smithy/middleware-retry/dist-cjs/isStreamingPayload/isStreamingPayload.js
var require_isStreamingPayload = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isStreamingPayload = undefined;
  var stream_1 = __require("stream");
  var isStreamingPayload = (request) => request?.body instanceof stream_1.Readable || typeof ReadableStream !== "undefined" && request?.body instanceof ReadableStream;
  exports.isStreamingPayload = isStreamingPayload;
});

// node_modules/@smithy/middleware-retry/dist-cjs/index.js
var require_dist_cjs40 = __commonJS((exports) => {
  var utilRetry = require_dist_cjs39();
  var protocolHttp = require_dist_cjs3();
  var serviceErrorClassification = require_dist_cjs38();
  var uuid = require_dist_cjs18();
  var utilMiddleware2 = require_dist_cjs2();
  var smithyClient = require_dist_cjs28();
  var isStreamingPayload = require_isStreamingPayload();
  var getDefaultRetryQuota = (initialRetryTokens, options) => {
    const MAX_CAPACITY = initialRetryTokens;
    const noRetryIncrement = utilRetry.NO_RETRY_INCREMENT;
    const retryCost = utilRetry.RETRY_COST;
    const timeoutRetryCost = utilRetry.TIMEOUT_RETRY_COST;
    let availableCapacity = initialRetryTokens;
    const getCapacityAmount = (error) => error.name === "TimeoutError" ? timeoutRetryCost : retryCost;
    const hasRetryTokens = (error) => getCapacityAmount(error) <= availableCapacity;
    const retrieveRetryTokens = (error) => {
      if (!hasRetryTokens(error)) {
        throw new Error("No retry token available");
      }
      const capacityAmount = getCapacityAmount(error);
      availableCapacity -= capacityAmount;
      return capacityAmount;
    };
    const releaseRetryTokens = (capacityReleaseAmount) => {
      availableCapacity += capacityReleaseAmount ?? noRetryIncrement;
      availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);
    };
    return Object.freeze({
      hasRetryTokens,
      retrieveRetryTokens,
      releaseRetryTokens
    });
  };
  var defaultDelayDecider = (delayBase, attempts) => Math.floor(Math.min(utilRetry.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
  var defaultRetryDecider = (error) => {
    if (!error) {
      return false;
    }
    return serviceErrorClassification.isRetryableByTrait(error) || serviceErrorClassification.isClockSkewError(error) || serviceErrorClassification.isThrottlingError(error) || serviceErrorClassification.isTransientError(error);
  };
  var asSdkError = (error) => {
    if (error instanceof Error)
      return error;
    if (error instanceof Object)
      return Object.assign(new Error, error);
    if (typeof error === "string")
      return new Error(error);
    return new Error(`AWS SDK error wrapper for ${error}`);
  };

  class StandardRetryStrategy {
    maxAttemptsProvider;
    retryDecider;
    delayDecider;
    retryQuota;
    mode = utilRetry.RETRY_MODES.STANDARD;
    constructor(maxAttemptsProvider, options) {
      this.maxAttemptsProvider = maxAttemptsProvider;
      this.retryDecider = options?.retryDecider ?? defaultRetryDecider;
      this.delayDecider = options?.delayDecider ?? defaultDelayDecider;
      this.retryQuota = options?.retryQuota ?? getDefaultRetryQuota(utilRetry.INITIAL_RETRY_TOKENS);
    }
    shouldRetry(error, attempts, maxAttempts) {
      return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);
    }
    async getMaxAttempts() {
      let maxAttempts;
      try {
        maxAttempts = await this.maxAttemptsProvider();
      } catch (error) {
        maxAttempts = utilRetry.DEFAULT_MAX_ATTEMPTS;
      }
      return maxAttempts;
    }
    async retry(next, args, options) {
      let retryTokenAmount;
      let attempts = 0;
      let totalDelay = 0;
      const maxAttempts = await this.getMaxAttempts();
      const { request } = args;
      if (protocolHttp.HttpRequest.isInstance(request)) {
        request.headers[utilRetry.INVOCATION_ID_HEADER] = uuid.v4();
      }
      while (true) {
        try {
          if (protocolHttp.HttpRequest.isInstance(request)) {
            request.headers[utilRetry.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
          }
          if (options?.beforeRequest) {
            await options.beforeRequest();
          }
          const { response, output } = await next(args);
          if (options?.afterRequest) {
            options.afterRequest(response);
          }
          this.retryQuota.releaseRetryTokens(retryTokenAmount);
          output.$metadata.attempts = attempts + 1;
          output.$metadata.totalRetryDelay = totalDelay;
          return { response, output };
        } catch (e) {
          const err3 = asSdkError(e);
          attempts++;
          if (this.shouldRetry(err3, attempts, maxAttempts)) {
            retryTokenAmount = this.retryQuota.retrieveRetryTokens(err3);
            const delayFromDecider = this.delayDecider(serviceErrorClassification.isThrottlingError(err3) ? utilRetry.THROTTLING_RETRY_DELAY_BASE : utilRetry.DEFAULT_RETRY_DELAY_BASE, attempts);
            const delayFromResponse = getDelayFromRetryAfterHeader(err3.$response);
            const delay = Math.max(delayFromResponse || 0, delayFromDecider);
            totalDelay += delay;
            await new Promise((resolve) => setTimeout(resolve, delay));
            continue;
          }
          if (!err3.$metadata) {
            err3.$metadata = {};
          }
          err3.$metadata.attempts = attempts;
          err3.$metadata.totalRetryDelay = totalDelay;
          throw err3;
        }
      }
    }
  }
  var getDelayFromRetryAfterHeader = (response) => {
    if (!protocolHttp.HttpResponse.isInstance(response))
      return;
    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName)
      return;
    const retryAfter = response.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds))
      return retryAfterSeconds * 1000;
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate.getTime() - Date.now();
  };

  class AdaptiveRetryStrategy extends StandardRetryStrategy {
    rateLimiter;
    constructor(maxAttemptsProvider, options) {
      const { rateLimiter, ...superOptions } = options ?? {};
      super(maxAttemptsProvider, superOptions);
      this.rateLimiter = rateLimiter ?? new utilRetry.DefaultRateLimiter;
      this.mode = utilRetry.RETRY_MODES.ADAPTIVE;
    }
    async retry(next, args) {
      return super.retry(next, args, {
        beforeRequest: async () => {
          return this.rateLimiter.getSendToken();
        },
        afterRequest: (response) => {
          this.rateLimiter.updateClientSendingRate(response);
        }
      });
    }
  }
  var ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS";
  var CONFIG_MAX_ATTEMPTS = "max_attempts";
  var NODE_MAX_ATTEMPT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env3) => {
      const value = env3[ENV_MAX_ATTEMPTS];
      if (!value)
        return;
      const maxAttempt = parseInt(value);
      if (Number.isNaN(maxAttempt)) {
        throw new Error(`Environment variable ${ENV_MAX_ATTEMPTS} mast be a number, got "${value}"`);
      }
      return maxAttempt;
    },
    configFileSelector: (profile) => {
      const value = profile[CONFIG_MAX_ATTEMPTS];
      if (!value)
        return;
      const maxAttempt = parseInt(value);
      if (Number.isNaN(maxAttempt)) {
        throw new Error(`Shared config file entry ${CONFIG_MAX_ATTEMPTS} mast be a number, got "${value}"`);
      }
      return maxAttempt;
    },
    default: utilRetry.DEFAULT_MAX_ATTEMPTS
  };
  var resolveRetryConfig = (input) => {
    const { retryStrategy, retryMode: _retryMode, maxAttempts: _maxAttempts } = input;
    const maxAttempts = utilMiddleware2.normalizeProvider(_maxAttempts ?? utilRetry.DEFAULT_MAX_ATTEMPTS);
    return Object.assign(input, {
      maxAttempts,
      retryStrategy: async () => {
        if (retryStrategy) {
          return retryStrategy;
        }
        const retryMode = await utilMiddleware2.normalizeProvider(_retryMode)();
        if (retryMode === utilRetry.RETRY_MODES.ADAPTIVE) {
          return new utilRetry.AdaptiveRetryStrategy(maxAttempts);
        }
        return new utilRetry.StandardRetryStrategy(maxAttempts);
      }
    });
  };
  var ENV_RETRY_MODE = "AWS_RETRY_MODE";
  var CONFIG_RETRY_MODE = "retry_mode";
  var NODE_RETRY_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env3) => env3[ENV_RETRY_MODE],
    configFileSelector: (profile) => profile[CONFIG_RETRY_MODE],
    default: utilRetry.DEFAULT_RETRY_MODE
  };
  var omitRetryHeadersMiddleware = () => (next) => async (args) => {
    const { request } = args;
    if (protocolHttp.HttpRequest.isInstance(request)) {
      delete request.headers[utilRetry.INVOCATION_ID_HEADER];
      delete request.headers[utilRetry.REQUEST_HEADER];
    }
    return next(args);
  };
  var omitRetryHeadersMiddlewareOptions = {
    name: "omitRetryHeadersMiddleware",
    tags: ["RETRY", "HEADERS", "OMIT_RETRY_HEADERS"],
    relation: "before",
    toMiddleware: "awsAuthMiddleware",
    override: true
  };
  var getOmitRetryHeadersPlugin = (options) => ({
    applyToStack: (clientStack) => {
      clientStack.addRelativeTo(omitRetryHeadersMiddleware(), omitRetryHeadersMiddlewareOptions);
    }
  });
  var retryMiddleware = (options) => (next, context) => async (args) => {
    let retryStrategy = await options.retryStrategy();
    const maxAttempts = await options.maxAttempts();
    if (isRetryStrategyV2(retryStrategy)) {
      retryStrategy = retryStrategy;
      let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
      let lastError = new Error;
      let attempts = 0;
      let totalRetryDelay = 0;
      const { request } = args;
      const isRequest = protocolHttp.HttpRequest.isInstance(request);
      if (isRequest) {
        request.headers[utilRetry.INVOCATION_ID_HEADER] = uuid.v4();
      }
      while (true) {
        try {
          if (isRequest) {
            request.headers[utilRetry.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
          }
          const { response, output } = await next(args);
          retryStrategy.recordSuccess(retryToken);
          output.$metadata.attempts = attempts + 1;
          output.$metadata.totalRetryDelay = totalRetryDelay;
          return { response, output };
        } catch (e) {
          const retryErrorInfo = getRetryErrorInfo(e);
          lastError = asSdkError(e);
          if (isRequest && isStreamingPayload.isStreamingPayload(request)) {
            (context.logger instanceof smithyClient.NoOpLogger ? console : context.logger)?.warn("An error was encountered in a non-retryable streaming request.");
            throw lastError;
          }
          try {
            retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
          } catch (refreshError) {
            if (!lastError.$metadata) {
              lastError.$metadata = {};
            }
            lastError.$metadata.attempts = attempts + 1;
            lastError.$metadata.totalRetryDelay = totalRetryDelay;
            throw lastError;
          }
          attempts = retryToken.getRetryCount();
          const delay = retryToken.getRetryDelay();
          totalRetryDelay += delay;
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
    } else {
      retryStrategy = retryStrategy;
      if (retryStrategy?.mode)
        context.userAgent = [...context.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
      return retryStrategy.retry(next, args);
    }
  };
  var isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined";
  var getRetryErrorInfo = (error) => {
    const errorInfo = {
      error,
      errorType: getRetryErrorType(error)
    };
    const retryAfterHint = getRetryAfterHint(error.$response);
    if (retryAfterHint) {
      errorInfo.retryAfterHint = retryAfterHint;
    }
    return errorInfo;
  };
  var getRetryErrorType = (error) => {
    if (serviceErrorClassification.isThrottlingError(error))
      return "THROTTLING";
    if (serviceErrorClassification.isTransientError(error))
      return "TRANSIENT";
    if (serviceErrorClassification.isServerError(error))
      return "SERVER_ERROR";
    return "CLIENT_ERROR";
  };
  var retryMiddlewareOptions = {
    name: "retryMiddleware",
    tags: ["RETRY"],
    step: "finalizeRequest",
    priority: "high",
    override: true
  };
  var getRetryPlugin = (options) => ({
    applyToStack: (clientStack) => {
      clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
    }
  });
  var getRetryAfterHint = (response) => {
    if (!protocolHttp.HttpResponse.isInstance(response))
      return;
    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName)
      return;
    const retryAfter = response.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds))
      return new Date(retryAfterSeconds * 1000);
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate;
  };
  exports.AdaptiveRetryStrategy = AdaptiveRetryStrategy;
  exports.CONFIG_MAX_ATTEMPTS = CONFIG_MAX_ATTEMPTS;
  exports.CONFIG_RETRY_MODE = CONFIG_RETRY_MODE;
  exports.ENV_MAX_ATTEMPTS = ENV_MAX_ATTEMPTS;
  exports.ENV_RETRY_MODE = ENV_RETRY_MODE;
  exports.NODE_MAX_ATTEMPT_CONFIG_OPTIONS = NODE_MAX_ATTEMPT_CONFIG_OPTIONS;
  exports.NODE_RETRY_MODE_CONFIG_OPTIONS = NODE_RETRY_MODE_CONFIG_OPTIONS;
  exports.StandardRetryStrategy = StandardRetryStrategy;
  exports.defaultDelayDecider = defaultDelayDecider;
  exports.defaultRetryDecider = defaultRetryDecider;
  exports.getOmitRetryHeadersPlugin = getOmitRetryHeadersPlugin;
  exports.getRetryAfterHint = getRetryAfterHint;
  exports.getRetryPlugin = getRetryPlugin;
  exports.omitRetryHeadersMiddleware = omitRetryHeadersMiddleware;
  exports.omitRetryHeadersMiddlewareOptions = omitRetryHeadersMiddlewareOptions;
  exports.resolveRetryConfig = resolveRetryConfig;
  exports.retryMiddleware = retryMiddleware;
  exports.retryMiddlewareOptions = retryMiddlewareOptions;
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/auth/httpAuthSchemeProvider.js
function createAwsAuthSigv4HttpAuthOption(authParameters) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "dynamodb",
      region: authParameters.region
    },
    propertiesExtractor: (config, context) => ({
      signingProperties: {
        config,
        context
      }
    })
  };
}
var import_core4, import_util_middleware, defaultDynamoDBHttpAuthSchemeParametersProvider = async (config, context, input) => {
  return {
    operation: import_util_middleware.getSmithyContext(context).operation,
    region: await import_util_middleware.normalizeProvider(config.region)() || (() => {
      throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
    })()
  };
}, defaultDynamoDBHttpAuthSchemeProvider = (authParameters) => {
  const options = [];
  switch (authParameters.operation) {
    default: {
      options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
    }
  }
  return options;
}, resolveHttpAuthSchemeConfig = (config) => {
  const config_0 = import_core4.resolveAwsSdkSigV4Config(config);
  return Object.assign(config_0, {
    authSchemePreference: import_util_middleware.normalizeProvider(config.authSchemePreference ?? [])
  });
};
var init_httpAuthSchemeProvider = __esm(() => {
  import_core4 = __toESM(require_dist_cjs30(), 1);
  import_util_middleware = __toESM(require_dist_cjs2(), 1);
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters = (options) => {
  return Object.assign(options, {
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "dynamodb"
  });
}, commonParams;
var init_EndpointParameters = __esm(() => {
  commonParams = {
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    AccountId: { type: "builtInParams", name: "accountId" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
    AccountIdEndpointMode: { type: "builtInParams", name: "accountIdEndpointMode" }
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/models/DynamoDBServiceException.js
var import_smithy_client, DynamoDBServiceException;
var init_DynamoDBServiceException = __esm(() => {
  import_smithy_client = __toESM(require_dist_cjs28(), 1);
  DynamoDBServiceException = class DynamoDBServiceException extends import_smithy_client.ServiceException {
    constructor(options) {
      super(options);
      Object.setPrototypeOf(this, DynamoDBServiceException.prototype);
    }
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/models/models_0.js
var BackupInUseException, BackupNotFoundException, InternalServerError, RequestLimitExceeded, ThrottlingException, InvalidEndpointException, ProvisionedThroughputExceededException, ResourceNotFoundException, ItemCollectionSizeLimitExceededException, ReplicatedWriteConflictException, ContinuousBackupsUnavailableException, LimitExceededException, TableInUseException, TableNotFoundException, GlobalTableAlreadyExistsException, ResourceInUseException, TransactionConflictException, PolicyNotFoundException, ExportNotFoundException, GlobalTableNotFoundException, ImportNotFoundException, DuplicateItemException, IdempotentParameterMismatchException, TransactionInProgressException, ExportConflictException, InvalidExportTimeException, PointInTimeRecoveryUnavailableException, ImportConflictException, TableAlreadyExistsException, InvalidRestoreTimeException, ReplicaAlreadyExistsException, ReplicaNotFoundException, IndexNotFoundException, AttributeValue, ConditionalCheckFailedException, TransactionCanceledException;
var init_models_0 = __esm(() => {
  init_DynamoDBServiceException();
  BackupInUseException = class BackupInUseException extends DynamoDBServiceException {
    name = "BackupInUseException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "BackupInUseException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, BackupInUseException.prototype);
    }
  };
  BackupNotFoundException = class BackupNotFoundException extends DynamoDBServiceException {
    name = "BackupNotFoundException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "BackupNotFoundException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, BackupNotFoundException.prototype);
    }
  };
  InternalServerError = class InternalServerError extends DynamoDBServiceException {
    name = "InternalServerError";
    $fault = "server";
    constructor(opts) {
      super({
        name: "InternalServerError",
        $fault: "server",
        ...opts
      });
      Object.setPrototypeOf(this, InternalServerError.prototype);
    }
  };
  RequestLimitExceeded = class RequestLimitExceeded extends DynamoDBServiceException {
    name = "RequestLimitExceeded";
    $fault = "client";
    ThrottlingReasons;
    constructor(opts) {
      super({
        name: "RequestLimitExceeded",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, RequestLimitExceeded.prototype);
      this.ThrottlingReasons = opts.ThrottlingReasons;
    }
  };
  ThrottlingException = class ThrottlingException extends DynamoDBServiceException {
    name = "ThrottlingException";
    $fault = "client";
    throttlingReasons;
    constructor(opts) {
      super({
        name: "ThrottlingException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ThrottlingException.prototype);
      this.throttlingReasons = opts.throttlingReasons;
    }
  };
  InvalidEndpointException = class InvalidEndpointException extends DynamoDBServiceException {
    name = "InvalidEndpointException";
    $fault = "client";
    Message;
    constructor(opts) {
      super({
        name: "InvalidEndpointException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, InvalidEndpointException.prototype);
      this.Message = opts.Message;
    }
  };
  ProvisionedThroughputExceededException = class ProvisionedThroughputExceededException extends DynamoDBServiceException {
    name = "ProvisionedThroughputExceededException";
    $fault = "client";
    ThrottlingReasons;
    constructor(opts) {
      super({
        name: "ProvisionedThroughputExceededException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ProvisionedThroughputExceededException.prototype);
      this.ThrottlingReasons = opts.ThrottlingReasons;
    }
  };
  ResourceNotFoundException = class ResourceNotFoundException extends DynamoDBServiceException {
    name = "ResourceNotFoundException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "ResourceNotFoundException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
    }
  };
  ItemCollectionSizeLimitExceededException = class ItemCollectionSizeLimitExceededException extends DynamoDBServiceException {
    name = "ItemCollectionSizeLimitExceededException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "ItemCollectionSizeLimitExceededException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ItemCollectionSizeLimitExceededException.prototype);
    }
  };
  ReplicatedWriteConflictException = class ReplicatedWriteConflictException extends DynamoDBServiceException {
    name = "ReplicatedWriteConflictException";
    $fault = "client";
    $retryable = {};
    constructor(opts) {
      super({
        name: "ReplicatedWriteConflictException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ReplicatedWriteConflictException.prototype);
    }
  };
  ContinuousBackupsUnavailableException = class ContinuousBackupsUnavailableException extends DynamoDBServiceException {
    name = "ContinuousBackupsUnavailableException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "ContinuousBackupsUnavailableException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ContinuousBackupsUnavailableException.prototype);
    }
  };
  LimitExceededException = class LimitExceededException extends DynamoDBServiceException {
    name = "LimitExceededException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "LimitExceededException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, LimitExceededException.prototype);
    }
  };
  TableInUseException = class TableInUseException extends DynamoDBServiceException {
    name = "TableInUseException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "TableInUseException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, TableInUseException.prototype);
    }
  };
  TableNotFoundException = class TableNotFoundException extends DynamoDBServiceException {
    name = "TableNotFoundException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "TableNotFoundException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, TableNotFoundException.prototype);
    }
  };
  GlobalTableAlreadyExistsException = class GlobalTableAlreadyExistsException extends DynamoDBServiceException {
    name = "GlobalTableAlreadyExistsException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "GlobalTableAlreadyExistsException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, GlobalTableAlreadyExistsException.prototype);
    }
  };
  ResourceInUseException = class ResourceInUseException extends DynamoDBServiceException {
    name = "ResourceInUseException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "ResourceInUseException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ResourceInUseException.prototype);
    }
  };
  TransactionConflictException = class TransactionConflictException extends DynamoDBServiceException {
    name = "TransactionConflictException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "TransactionConflictException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, TransactionConflictException.prototype);
    }
  };
  PolicyNotFoundException = class PolicyNotFoundException extends DynamoDBServiceException {
    name = "PolicyNotFoundException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "PolicyNotFoundException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, PolicyNotFoundException.prototype);
    }
  };
  ExportNotFoundException = class ExportNotFoundException extends DynamoDBServiceException {
    name = "ExportNotFoundException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "ExportNotFoundException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ExportNotFoundException.prototype);
    }
  };
  GlobalTableNotFoundException = class GlobalTableNotFoundException extends DynamoDBServiceException {
    name = "GlobalTableNotFoundException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "GlobalTableNotFoundException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, GlobalTableNotFoundException.prototype);
    }
  };
  ImportNotFoundException = class ImportNotFoundException extends DynamoDBServiceException {
    name = "ImportNotFoundException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "ImportNotFoundException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ImportNotFoundException.prototype);
    }
  };
  DuplicateItemException = class DuplicateItemException extends DynamoDBServiceException {
    name = "DuplicateItemException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "DuplicateItemException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, DuplicateItemException.prototype);
    }
  };
  IdempotentParameterMismatchException = class IdempotentParameterMismatchException extends DynamoDBServiceException {
    name = "IdempotentParameterMismatchException";
    $fault = "client";
    Message;
    constructor(opts) {
      super({
        name: "IdempotentParameterMismatchException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, IdempotentParameterMismatchException.prototype);
      this.Message = opts.Message;
    }
  };
  TransactionInProgressException = class TransactionInProgressException extends DynamoDBServiceException {
    name = "TransactionInProgressException";
    $fault = "client";
    Message;
    constructor(opts) {
      super({
        name: "TransactionInProgressException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, TransactionInProgressException.prototype);
      this.Message = opts.Message;
    }
  };
  ExportConflictException = class ExportConflictException extends DynamoDBServiceException {
    name = "ExportConflictException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "ExportConflictException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ExportConflictException.prototype);
    }
  };
  InvalidExportTimeException = class InvalidExportTimeException extends DynamoDBServiceException {
    name = "InvalidExportTimeException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "InvalidExportTimeException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, InvalidExportTimeException.prototype);
    }
  };
  PointInTimeRecoveryUnavailableException = class PointInTimeRecoveryUnavailableException extends DynamoDBServiceException {
    name = "PointInTimeRecoveryUnavailableException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "PointInTimeRecoveryUnavailableException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, PointInTimeRecoveryUnavailableException.prototype);
    }
  };
  ImportConflictException = class ImportConflictException extends DynamoDBServiceException {
    name = "ImportConflictException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "ImportConflictException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ImportConflictException.prototype);
    }
  };
  TableAlreadyExistsException = class TableAlreadyExistsException extends DynamoDBServiceException {
    name = "TableAlreadyExistsException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "TableAlreadyExistsException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, TableAlreadyExistsException.prototype);
    }
  };
  InvalidRestoreTimeException = class InvalidRestoreTimeException extends DynamoDBServiceException {
    name = "InvalidRestoreTimeException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "InvalidRestoreTimeException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, InvalidRestoreTimeException.prototype);
    }
  };
  ReplicaAlreadyExistsException = class ReplicaAlreadyExistsException extends DynamoDBServiceException {
    name = "ReplicaAlreadyExistsException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "ReplicaAlreadyExistsException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ReplicaAlreadyExistsException.prototype);
    }
  };
  ReplicaNotFoundException = class ReplicaNotFoundException extends DynamoDBServiceException {
    name = "ReplicaNotFoundException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "ReplicaNotFoundException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ReplicaNotFoundException.prototype);
    }
  };
  IndexNotFoundException = class IndexNotFoundException extends DynamoDBServiceException {
    name = "IndexNotFoundException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "IndexNotFoundException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, IndexNotFoundException.prototype);
    }
  };
  (function(AttributeValue2) {
    AttributeValue2.visit = (value, visitor) => {
      if (value.S !== undefined)
        return visitor.S(value.S);
      if (value.N !== undefined)
        return visitor.N(value.N);
      if (value.B !== undefined)
        return visitor.B(value.B);
      if (value.SS !== undefined)
        return visitor.SS(value.SS);
      if (value.NS !== undefined)
        return visitor.NS(value.NS);
      if (value.BS !== undefined)
        return visitor.BS(value.BS);
      if (value.M !== undefined)
        return visitor.M(value.M);
      if (value.L !== undefined)
        return visitor.L(value.L);
      if (value.NULL !== undefined)
        return visitor.NULL(value.NULL);
      if (value.BOOL !== undefined)
        return visitor.BOOL(value.BOOL);
      return visitor._(value.$unknown[0], value.$unknown[1]);
    };
  })(AttributeValue || (AttributeValue = {}));
  ConditionalCheckFailedException = class ConditionalCheckFailedException extends DynamoDBServiceException {
    name = "ConditionalCheckFailedException";
    $fault = "client";
    Item;
    constructor(opts) {
      super({
        name: "ConditionalCheckFailedException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ConditionalCheckFailedException.prototype);
      this.Item = opts.Item;
    }
  };
  TransactionCanceledException = class TransactionCanceledException extends DynamoDBServiceException {
    name = "TransactionCanceledException";
    $fault = "client";
    Message;
    CancellationReasons;
    constructor(opts) {
      super({
        name: "TransactionCanceledException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, TransactionCanceledException.prototype);
      this.Message = opts.Message;
      this.CancellationReasons = opts.CancellationReasons;
    }
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/protocols/Aws_json1_0.js
function sharedHeaders(operation) {
  return {
    "content-type": "application/x-amz-json-1.0",
    "x-amz-target": `DynamoDB_20120810.${operation}`
  };
}
var import_core5, import_protocol_http, import_smithy_client2, import_uuid, se_BatchExecuteStatementCommand = async (input, context) => {
  const headers = sharedHeaders("BatchExecuteStatement");
  let body;
  body = JSON.stringify(se_BatchExecuteStatementInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_BatchGetItemCommand = async (input, context) => {
  const headers = sharedHeaders("BatchGetItem");
  let body;
  body = JSON.stringify(se_BatchGetItemInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_BatchWriteItemCommand = async (input, context) => {
  const headers = sharedHeaders("BatchWriteItem");
  let body;
  body = JSON.stringify(se_BatchWriteItemInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_CreateBackupCommand = async (input, context) => {
  const headers = sharedHeaders("CreateBackup");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_CreateGlobalTableCommand = async (input, context) => {
  const headers = sharedHeaders("CreateGlobalTable");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_CreateTableCommand = async (input, context) => {
  const headers = sharedHeaders("CreateTable");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_DeleteBackupCommand = async (input, context) => {
  const headers = sharedHeaders("DeleteBackup");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_DeleteItemCommand = async (input, context) => {
  const headers = sharedHeaders("DeleteItem");
  let body;
  body = JSON.stringify(se_DeleteItemInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_DeleteResourcePolicyCommand = async (input, context) => {
  const headers = sharedHeaders("DeleteResourcePolicy");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_DeleteTableCommand = async (input, context) => {
  const headers = sharedHeaders("DeleteTable");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_DescribeBackupCommand = async (input, context) => {
  const headers = sharedHeaders("DescribeBackup");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_DescribeContinuousBackupsCommand = async (input, context) => {
  const headers = sharedHeaders("DescribeContinuousBackups");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_DescribeContributorInsightsCommand = async (input, context) => {
  const headers = sharedHeaders("DescribeContributorInsights");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_DescribeEndpointsCommand = async (input, context) => {
  const headers = sharedHeaders("DescribeEndpoints");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_DescribeExportCommand = async (input, context) => {
  const headers = sharedHeaders("DescribeExport");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_DescribeGlobalTableCommand = async (input, context) => {
  const headers = sharedHeaders("DescribeGlobalTable");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_DescribeGlobalTableSettingsCommand = async (input, context) => {
  const headers = sharedHeaders("DescribeGlobalTableSettings");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_DescribeImportCommand = async (input, context) => {
  const headers = sharedHeaders("DescribeImport");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_DescribeKinesisStreamingDestinationCommand = async (input, context) => {
  const headers = sharedHeaders("DescribeKinesisStreamingDestination");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_DescribeLimitsCommand = async (input, context) => {
  const headers = sharedHeaders("DescribeLimits");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_DescribeTableCommand = async (input, context) => {
  const headers = sharedHeaders("DescribeTable");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_DescribeTableReplicaAutoScalingCommand = async (input, context) => {
  const headers = sharedHeaders("DescribeTableReplicaAutoScaling");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_DescribeTimeToLiveCommand = async (input, context) => {
  const headers = sharedHeaders("DescribeTimeToLive");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_DisableKinesisStreamingDestinationCommand = async (input, context) => {
  const headers = sharedHeaders("DisableKinesisStreamingDestination");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_EnableKinesisStreamingDestinationCommand = async (input, context) => {
  const headers = sharedHeaders("EnableKinesisStreamingDestination");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_ExecuteStatementCommand = async (input, context) => {
  const headers = sharedHeaders("ExecuteStatement");
  let body;
  body = JSON.stringify(se_ExecuteStatementInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_ExecuteTransactionCommand = async (input, context) => {
  const headers = sharedHeaders("ExecuteTransaction");
  let body;
  body = JSON.stringify(se_ExecuteTransactionInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_ExportTableToPointInTimeCommand = async (input, context) => {
  const headers = sharedHeaders("ExportTableToPointInTime");
  let body;
  body = JSON.stringify(se_ExportTableToPointInTimeInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_GetItemCommand = async (input, context) => {
  const headers = sharedHeaders("GetItem");
  let body;
  body = JSON.stringify(se_GetItemInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_GetResourcePolicyCommand = async (input, context) => {
  const headers = sharedHeaders("GetResourcePolicy");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_ImportTableCommand = async (input, context) => {
  const headers = sharedHeaders("ImportTable");
  let body;
  body = JSON.stringify(se_ImportTableInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_ListBackupsCommand = async (input, context) => {
  const headers = sharedHeaders("ListBackups");
  let body;
  body = JSON.stringify(se_ListBackupsInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_ListContributorInsightsCommand = async (input, context) => {
  const headers = sharedHeaders("ListContributorInsights");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_ListExportsCommand = async (input, context) => {
  const headers = sharedHeaders("ListExports");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_ListGlobalTablesCommand = async (input, context) => {
  const headers = sharedHeaders("ListGlobalTables");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_ListImportsCommand = async (input, context) => {
  const headers = sharedHeaders("ListImports");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_ListTablesCommand = async (input, context) => {
  const headers = sharedHeaders("ListTables");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_ListTagsOfResourceCommand = async (input, context) => {
  const headers = sharedHeaders("ListTagsOfResource");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_PutItemCommand = async (input, context) => {
  const headers = sharedHeaders("PutItem");
  let body;
  body = JSON.stringify(se_PutItemInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_PutResourcePolicyCommand = async (input, context) => {
  const headers = sharedHeaders("PutResourcePolicy");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_QueryCommand = async (input, context) => {
  const headers = sharedHeaders("Query");
  let body;
  body = JSON.stringify(se_QueryInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_RestoreTableFromBackupCommand = async (input, context) => {
  const headers = sharedHeaders("RestoreTableFromBackup");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_RestoreTableToPointInTimeCommand = async (input, context) => {
  const headers = sharedHeaders("RestoreTableToPointInTime");
  let body;
  body = JSON.stringify(se_RestoreTableToPointInTimeInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_ScanCommand = async (input, context) => {
  const headers = sharedHeaders("Scan");
  let body;
  body = JSON.stringify(se_ScanInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_TagResourceCommand = async (input, context) => {
  const headers = sharedHeaders("TagResource");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_TransactGetItemsCommand = async (input, context) => {
  const headers = sharedHeaders("TransactGetItems");
  let body;
  body = JSON.stringify(se_TransactGetItemsInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_TransactWriteItemsCommand = async (input, context) => {
  const headers = sharedHeaders("TransactWriteItems");
  let body;
  body = JSON.stringify(se_TransactWriteItemsInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_UntagResourceCommand = async (input, context) => {
  const headers = sharedHeaders("UntagResource");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_UpdateContinuousBackupsCommand = async (input, context) => {
  const headers = sharedHeaders("UpdateContinuousBackups");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_UpdateContributorInsightsCommand = async (input, context) => {
  const headers = sharedHeaders("UpdateContributorInsights");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_UpdateGlobalTableCommand = async (input, context) => {
  const headers = sharedHeaders("UpdateGlobalTable");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_UpdateGlobalTableSettingsCommand = async (input, context) => {
  const headers = sharedHeaders("UpdateGlobalTableSettings");
  let body;
  body = JSON.stringify(se_UpdateGlobalTableSettingsInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_UpdateItemCommand = async (input, context) => {
  const headers = sharedHeaders("UpdateItem");
  let body;
  body = JSON.stringify(se_UpdateItemInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_UpdateKinesisStreamingDestinationCommand = async (input, context) => {
  const headers = sharedHeaders("UpdateKinesisStreamingDestination");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_UpdateTableCommand = async (input, context) => {
  const headers = sharedHeaders("UpdateTable");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_UpdateTableReplicaAutoScalingCommand = async (input, context) => {
  const headers = sharedHeaders("UpdateTableReplicaAutoScaling");
  let body;
  body = JSON.stringify(se_UpdateTableReplicaAutoScalingInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, se_UpdateTimeToLiveCommand = async (input, context) => {
  const headers = sharedHeaders("UpdateTimeToLive");
  let body;
  body = JSON.stringify(import_smithy_client2._json(input));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}, de_BatchExecuteStatementCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_BatchExecuteStatementOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_BatchGetItemCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_BatchGetItemOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_BatchWriteItemCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_BatchWriteItemOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_CreateBackupCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_CreateBackupOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_CreateGlobalTableCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_CreateGlobalTableOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_CreateTableCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_CreateTableOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_DeleteBackupCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_DeleteBackupOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_DeleteItemCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_DeleteItemOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_DeleteResourcePolicyCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = import_smithy_client2._json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_DeleteTableCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_DeleteTableOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_DescribeBackupCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_DescribeBackupOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_DescribeContinuousBackupsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_DescribeContinuousBackupsOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_DescribeContributorInsightsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_DescribeContributorInsightsOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_DescribeEndpointsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = import_smithy_client2._json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_DescribeExportCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_DescribeExportOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_DescribeGlobalTableCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_DescribeGlobalTableOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_DescribeGlobalTableSettingsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_DescribeGlobalTableSettingsOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_DescribeImportCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_DescribeImportOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_DescribeKinesisStreamingDestinationCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = import_smithy_client2._json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_DescribeLimitsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = import_smithy_client2._json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_DescribeTableCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_DescribeTableOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_DescribeTableReplicaAutoScalingCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_DescribeTableReplicaAutoScalingOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_DescribeTimeToLiveCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = import_smithy_client2._json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_DisableKinesisStreamingDestinationCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = import_smithy_client2._json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_EnableKinesisStreamingDestinationCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = import_smithy_client2._json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_ExecuteStatementCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_ExecuteStatementOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_ExecuteTransactionCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_ExecuteTransactionOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_ExportTableToPointInTimeCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_ExportTableToPointInTimeOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_GetItemCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_GetItemOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_GetResourcePolicyCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = import_smithy_client2._json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_ImportTableCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_ImportTableOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_ListBackupsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_ListBackupsOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_ListContributorInsightsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = import_smithy_client2._json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_ListExportsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = import_smithy_client2._json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_ListGlobalTablesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = import_smithy_client2._json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_ListImportsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_ListImportsOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_ListTablesCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = import_smithy_client2._json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_ListTagsOfResourceCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = import_smithy_client2._json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_PutItemCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_PutItemOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_PutResourcePolicyCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = import_smithy_client2._json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_QueryCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_QueryOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_RestoreTableFromBackupCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_RestoreTableFromBackupOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_RestoreTableToPointInTimeCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_RestoreTableToPointInTimeOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_ScanCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_ScanOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_TagResourceCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  await import_smithy_client2.collectBody(output.body, context);
  const response = {
    $metadata: deserializeMetadata(output)
  };
  return response;
}, de_TransactGetItemsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_TransactGetItemsOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_TransactWriteItemsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_TransactWriteItemsOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_UntagResourceCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  await import_smithy_client2.collectBody(output.body, context);
  const response = {
    $metadata: deserializeMetadata(output)
  };
  return response;
}, de_UpdateContinuousBackupsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_UpdateContinuousBackupsOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_UpdateContributorInsightsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = import_smithy_client2._json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_UpdateGlobalTableCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_UpdateGlobalTableOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_UpdateGlobalTableSettingsCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_UpdateGlobalTableSettingsOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_UpdateItemCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_UpdateItemOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_UpdateKinesisStreamingDestinationCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = import_smithy_client2._json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_UpdateTableCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_UpdateTableOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_UpdateTableReplicaAutoScalingCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_UpdateTableReplicaAutoScalingOutput(data, context);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_UpdateTimeToLiveCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError(output, context);
  }
  const data = await import_core5.parseJsonBody(output.body, context);
  let contents = {};
  contents = import_smithy_client2._json(data);
  const response = {
    $metadata: deserializeMetadata(output),
    ...contents
  };
  return response;
}, de_CommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await import_core5.parseJsonErrorBody(output.body, context)
  };
  const errorCode = import_core5.loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalServerError":
    case "com.amazonaws.dynamodb#InternalServerError":
      throw await de_InternalServerErrorRes(parsedOutput, context);
    case "RequestLimitExceeded":
    case "com.amazonaws.dynamodb#RequestLimitExceeded":
      throw await de_RequestLimitExceededRes(parsedOutput, context);
    case "ThrottlingException":
    case "com.amazonaws.dynamodb#ThrottlingException":
      throw await de_ThrottlingExceptionRes(parsedOutput, context);
    case "InvalidEndpointException":
    case "com.amazonaws.dynamodb#InvalidEndpointException":
      throw await de_InvalidEndpointExceptionRes(parsedOutput, context);
    case "ProvisionedThroughputExceededException":
    case "com.amazonaws.dynamodb#ProvisionedThroughputExceededException":
      throw await de_ProvisionedThroughputExceededExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.dynamodb#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
    case "ItemCollectionSizeLimitExceededException":
    case "com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException":
      throw await de_ItemCollectionSizeLimitExceededExceptionRes(parsedOutput, context);
    case "ReplicatedWriteConflictException":
    case "com.amazonaws.dynamodb#ReplicatedWriteConflictException":
      throw await de_ReplicatedWriteConflictExceptionRes(parsedOutput, context);
    case "BackupInUseException":
    case "com.amazonaws.dynamodb#BackupInUseException":
      throw await de_BackupInUseExceptionRes(parsedOutput, context);
    case "ContinuousBackupsUnavailableException":
    case "com.amazonaws.dynamodb#ContinuousBackupsUnavailableException":
      throw await de_ContinuousBackupsUnavailableExceptionRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.dynamodb#LimitExceededException":
      throw await de_LimitExceededExceptionRes(parsedOutput, context);
    case "TableInUseException":
    case "com.amazonaws.dynamodb#TableInUseException":
      throw await de_TableInUseExceptionRes(parsedOutput, context);
    case "TableNotFoundException":
    case "com.amazonaws.dynamodb#TableNotFoundException":
      throw await de_TableNotFoundExceptionRes(parsedOutput, context);
    case "GlobalTableAlreadyExistsException":
    case "com.amazonaws.dynamodb#GlobalTableAlreadyExistsException":
      throw await de_GlobalTableAlreadyExistsExceptionRes(parsedOutput, context);
    case "ResourceInUseException":
    case "com.amazonaws.dynamodb#ResourceInUseException":
      throw await de_ResourceInUseExceptionRes(parsedOutput, context);
    case "BackupNotFoundException":
    case "com.amazonaws.dynamodb#BackupNotFoundException":
      throw await de_BackupNotFoundExceptionRes(parsedOutput, context);
    case "ConditionalCheckFailedException":
    case "com.amazonaws.dynamodb#ConditionalCheckFailedException":
      throw await de_ConditionalCheckFailedExceptionRes(parsedOutput, context);
    case "TransactionConflictException":
    case "com.amazonaws.dynamodb#TransactionConflictException":
      throw await de_TransactionConflictExceptionRes(parsedOutput, context);
    case "PolicyNotFoundException":
    case "com.amazonaws.dynamodb#PolicyNotFoundException":
      throw await de_PolicyNotFoundExceptionRes(parsedOutput, context);
    case "ExportNotFoundException":
    case "com.amazonaws.dynamodb#ExportNotFoundException":
      throw await de_ExportNotFoundExceptionRes(parsedOutput, context);
    case "GlobalTableNotFoundException":
    case "com.amazonaws.dynamodb#GlobalTableNotFoundException":
      throw await de_GlobalTableNotFoundExceptionRes(parsedOutput, context);
    case "ImportNotFoundException":
    case "com.amazonaws.dynamodb#ImportNotFoundException":
      throw await de_ImportNotFoundExceptionRes(parsedOutput, context);
    case "DuplicateItemException":
    case "com.amazonaws.dynamodb#DuplicateItemException":
      throw await de_DuplicateItemExceptionRes(parsedOutput, context);
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.dynamodb#IdempotentParameterMismatchException":
      throw await de_IdempotentParameterMismatchExceptionRes(parsedOutput, context);
    case "TransactionCanceledException":
    case "com.amazonaws.dynamodb#TransactionCanceledException":
      throw await de_TransactionCanceledExceptionRes(parsedOutput, context);
    case "TransactionInProgressException":
    case "com.amazonaws.dynamodb#TransactionInProgressException":
      throw await de_TransactionInProgressExceptionRes(parsedOutput, context);
    case "ExportConflictException":
    case "com.amazonaws.dynamodb#ExportConflictException":
      throw await de_ExportConflictExceptionRes(parsedOutput, context);
    case "InvalidExportTimeException":
    case "com.amazonaws.dynamodb#InvalidExportTimeException":
      throw await de_InvalidExportTimeExceptionRes(parsedOutput, context);
    case "PointInTimeRecoveryUnavailableException":
    case "com.amazonaws.dynamodb#PointInTimeRecoveryUnavailableException":
      throw await de_PointInTimeRecoveryUnavailableExceptionRes(parsedOutput, context);
    case "ImportConflictException":
    case "com.amazonaws.dynamodb#ImportConflictException":
      throw await de_ImportConflictExceptionRes(parsedOutput, context);
    case "TableAlreadyExistsException":
    case "com.amazonaws.dynamodb#TableAlreadyExistsException":
      throw await de_TableAlreadyExistsExceptionRes(parsedOutput, context);
    case "InvalidRestoreTimeException":
    case "com.amazonaws.dynamodb#InvalidRestoreTimeException":
      throw await de_InvalidRestoreTimeExceptionRes(parsedOutput, context);
    case "ReplicaAlreadyExistsException":
    case "com.amazonaws.dynamodb#ReplicaAlreadyExistsException":
      throw await de_ReplicaAlreadyExistsExceptionRes(parsedOutput, context);
    case "ReplicaNotFoundException":
    case "com.amazonaws.dynamodb#ReplicaNotFoundException":
      throw await de_ReplicaNotFoundExceptionRes(parsedOutput, context);
    case "IndexNotFoundException":
    case "com.amazonaws.dynamodb#IndexNotFoundException":
      throw await de_IndexNotFoundExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError({
        output,
        parsedBody,
        errorCode
      });
  }
}, de_BackupInUseExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new BackupInUseException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_BackupNotFoundExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new BackupNotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_ConditionalCheckFailedExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_ConditionalCheckFailedException(body, context);
  const exception = new ConditionalCheckFailedException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_ContinuousBackupsUnavailableExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new ContinuousBackupsUnavailableException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_DuplicateItemExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new DuplicateItemException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_ExportConflictExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new ExportConflictException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_ExportNotFoundExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new ExportNotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_GlobalTableAlreadyExistsExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new GlobalTableAlreadyExistsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_GlobalTableNotFoundExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new GlobalTableNotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_IdempotentParameterMismatchExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new IdempotentParameterMismatchException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_ImportConflictExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new ImportConflictException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_ImportNotFoundExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new ImportNotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_IndexNotFoundExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new IndexNotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_InternalServerErrorRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new InternalServerError({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_InvalidEndpointExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new InvalidEndpointException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_InvalidExportTimeExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new InvalidExportTimeException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_InvalidRestoreTimeExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new InvalidRestoreTimeException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_ItemCollectionSizeLimitExceededExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new ItemCollectionSizeLimitExceededException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_LimitExceededExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new LimitExceededException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_PointInTimeRecoveryUnavailableExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new PointInTimeRecoveryUnavailableException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_PolicyNotFoundExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new PolicyNotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_ProvisionedThroughputExceededExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new ProvisionedThroughputExceededException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_ReplicaAlreadyExistsExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new ReplicaAlreadyExistsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_ReplicaNotFoundExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new ReplicaNotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_ReplicatedWriteConflictExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new ReplicatedWriteConflictException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_RequestLimitExceededRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new RequestLimitExceeded({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_ResourceInUseExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new ResourceInUseException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new ResourceNotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_TableAlreadyExistsExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new TableAlreadyExistsException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_TableInUseExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new TableInUseException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_TableNotFoundExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new TableNotFoundException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_ThrottlingExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new ThrottlingException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_TransactionCanceledExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = de_TransactionCanceledException(body, context);
  const exception = new TransactionCanceledException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_TransactionConflictExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new TransactionConflictException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, de_TransactionInProgressExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client2._json(body);
  const exception = new TransactionInProgressException({
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  });
  return import_smithy_client2.decorateServiceException(exception, body);
}, se_AttributeUpdates = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = se_AttributeValueUpdate(value, context);
    return acc;
  }, {});
}, se_AttributeValue = (input, context) => {
  return AttributeValue.visit(input, {
    B: (value) => ({ B: context.base64Encoder(value) }),
    BOOL: (value) => ({ BOOL: value }),
    BS: (value) => ({ BS: se_BinarySetAttributeValue(value, context) }),
    L: (value) => ({ L: se_ListAttributeValue(value, context) }),
    M: (value) => ({ M: se_MapAttributeValue(value, context) }),
    N: (value) => ({ N: value }),
    NS: (value) => ({ NS: import_smithy_client2._json(value) }),
    NULL: (value) => ({ NULL: value }),
    S: (value) => ({ S: value }),
    SS: (value) => ({ SS: import_smithy_client2._json(value) }),
    _: (name, value) => ({ [name]: value })
  });
}, se_AttributeValueList = (input, context) => {
  return input.filter((e) => e != null).map((entry) => {
    return se_AttributeValue(entry, context);
  });
}, se_AttributeValueUpdate = (input, context) => {
  return import_smithy_client2.take(input, {
    Action: [],
    Value: (_2) => se_AttributeValue(_2, context)
  });
}, se_AutoScalingPolicyUpdate = (input, context) => {
  return import_smithy_client2.take(input, {
    PolicyName: [],
    TargetTrackingScalingPolicyConfiguration: (_2) => se_AutoScalingTargetTrackingScalingPolicyConfigurationUpdate(_2, context)
  });
}, se_AutoScalingSettingsUpdate = (input, context) => {
  return import_smithy_client2.take(input, {
    AutoScalingDisabled: [],
    AutoScalingRoleArn: [],
    MaximumUnits: [],
    MinimumUnits: [],
    ScalingPolicyUpdate: (_2) => se_AutoScalingPolicyUpdate(_2, context)
  });
}, se_AutoScalingTargetTrackingScalingPolicyConfigurationUpdate = (input, context) => {
  return import_smithy_client2.take(input, {
    DisableScaleIn: [],
    ScaleInCooldown: [],
    ScaleOutCooldown: [],
    TargetValue: import_smithy_client2.serializeFloat
  });
}, se_BatchExecuteStatementInput = (input, context) => {
  return import_smithy_client2.take(input, {
    ReturnConsumedCapacity: [],
    Statements: (_2) => se_PartiQLBatchRequest(_2, context)
  });
}, se_BatchGetItemInput = (input, context) => {
  return import_smithy_client2.take(input, {
    RequestItems: (_2) => se_BatchGetRequestMap(_2, context),
    ReturnConsumedCapacity: []
  });
}, se_BatchGetRequestMap = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = se_KeysAndAttributes(value, context);
    return acc;
  }, {});
}, se_BatchStatementRequest = (input, context) => {
  return import_smithy_client2.take(input, {
    ConsistentRead: [],
    Parameters: (_2) => se_PreparedStatementParameters(_2, context),
    ReturnValuesOnConditionCheckFailure: [],
    Statement: []
  });
}, se_BatchWriteItemInput = (input, context) => {
  return import_smithy_client2.take(input, {
    RequestItems: (_2) => se_BatchWriteItemRequestMap(_2, context),
    ReturnConsumedCapacity: [],
    ReturnItemCollectionMetrics: []
  });
}, se_BatchWriteItemRequestMap = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = se_WriteRequests(value, context);
    return acc;
  }, {});
}, se_BinarySetAttributeValue = (input, context) => {
  return input.filter((e) => e != null).map((entry) => {
    return context.base64Encoder(entry);
  });
}, se_Condition = (input, context) => {
  return import_smithy_client2.take(input, {
    AttributeValueList: (_2) => se_AttributeValueList(_2, context),
    ComparisonOperator: []
  });
}, se_ConditionCheck = (input, context) => {
  return import_smithy_client2.take(input, {
    ConditionExpression: [],
    ExpressionAttributeNames: import_smithy_client2._json,
    ExpressionAttributeValues: (_2) => se_ExpressionAttributeValueMap(_2, context),
    Key: (_2) => se_Key(_2, context),
    ReturnValuesOnConditionCheckFailure: [],
    TableName: []
  });
}, se_Delete = (input, context) => {
  return import_smithy_client2.take(input, {
    ConditionExpression: [],
    ExpressionAttributeNames: import_smithy_client2._json,
    ExpressionAttributeValues: (_2) => se_ExpressionAttributeValueMap(_2, context),
    Key: (_2) => se_Key(_2, context),
    ReturnValuesOnConditionCheckFailure: [],
    TableName: []
  });
}, se_DeleteItemInput = (input, context) => {
  return import_smithy_client2.take(input, {
    ConditionExpression: [],
    ConditionalOperator: [],
    Expected: (_2) => se_ExpectedAttributeMap(_2, context),
    ExpressionAttributeNames: import_smithy_client2._json,
    ExpressionAttributeValues: (_2) => se_ExpressionAttributeValueMap(_2, context),
    Key: (_2) => se_Key(_2, context),
    ReturnConsumedCapacity: [],
    ReturnItemCollectionMetrics: [],
    ReturnValues: [],
    ReturnValuesOnConditionCheckFailure: [],
    TableName: []
  });
}, se_DeleteRequest = (input, context) => {
  return import_smithy_client2.take(input, {
    Key: (_2) => se_Key(_2, context)
  });
}, se_ExecuteStatementInput = (input, context) => {
  return import_smithy_client2.take(input, {
    ConsistentRead: [],
    Limit: [],
    NextToken: [],
    Parameters: (_2) => se_PreparedStatementParameters(_2, context),
    ReturnConsumedCapacity: [],
    ReturnValuesOnConditionCheckFailure: [],
    Statement: []
  });
}, se_ExecuteTransactionInput = (input, context) => {
  return import_smithy_client2.take(input, {
    ClientRequestToken: [true, (_2) => _2 ?? import_uuid.v4()],
    ReturnConsumedCapacity: [],
    TransactStatements: (_2) => se_ParameterizedStatements(_2, context)
  });
}, se_ExpectedAttributeMap = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = se_ExpectedAttributeValue(value, context);
    return acc;
  }, {});
}, se_ExpectedAttributeValue = (input, context) => {
  return import_smithy_client2.take(input, {
    AttributeValueList: (_2) => se_AttributeValueList(_2, context),
    ComparisonOperator: [],
    Exists: [],
    Value: (_2) => se_AttributeValue(_2, context)
  });
}, se_ExportTableToPointInTimeInput = (input, context) => {
  return import_smithy_client2.take(input, {
    ClientToken: [true, (_2) => _2 ?? import_uuid.v4()],
    ExportFormat: [],
    ExportTime: (_2) => _2.getTime() / 1000,
    ExportType: [],
    IncrementalExportSpecification: (_2) => se_IncrementalExportSpecification(_2, context),
    S3Bucket: [],
    S3BucketOwner: [],
    S3Prefix: [],
    S3SseAlgorithm: [],
    S3SseKmsKeyId: [],
    TableArn: []
  });
}, se_ExpressionAttributeValueMap = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = se_AttributeValue(value, context);
    return acc;
  }, {});
}, se_FilterConditionMap = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = se_Condition(value, context);
    return acc;
  }, {});
}, se_Get = (input, context) => {
  return import_smithy_client2.take(input, {
    ExpressionAttributeNames: import_smithy_client2._json,
    Key: (_2) => se_Key(_2, context),
    ProjectionExpression: [],
    TableName: []
  });
}, se_GetItemInput = (input, context) => {
  return import_smithy_client2.take(input, {
    AttributesToGet: import_smithy_client2._json,
    ConsistentRead: [],
    ExpressionAttributeNames: import_smithy_client2._json,
    Key: (_2) => se_Key(_2, context),
    ProjectionExpression: [],
    ReturnConsumedCapacity: [],
    TableName: []
  });
}, se_GlobalSecondaryIndexAutoScalingUpdate = (input, context) => {
  return import_smithy_client2.take(input, {
    IndexName: [],
    ProvisionedWriteCapacityAutoScalingUpdate: (_2) => se_AutoScalingSettingsUpdate(_2, context)
  });
}, se_GlobalSecondaryIndexAutoScalingUpdateList = (input, context) => {
  return input.filter((e) => e != null).map((entry) => {
    return se_GlobalSecondaryIndexAutoScalingUpdate(entry, context);
  });
}, se_GlobalTableGlobalSecondaryIndexSettingsUpdate = (input, context) => {
  return import_smithy_client2.take(input, {
    IndexName: [],
    ProvisionedWriteCapacityAutoScalingSettingsUpdate: (_2) => se_AutoScalingSettingsUpdate(_2, context),
    ProvisionedWriteCapacityUnits: []
  });
}, se_GlobalTableGlobalSecondaryIndexSettingsUpdateList = (input, context) => {
  return input.filter((e) => e != null).map((entry) => {
    return se_GlobalTableGlobalSecondaryIndexSettingsUpdate(entry, context);
  });
}, se_ImportTableInput = (input, context) => {
  return import_smithy_client2.take(input, {
    ClientToken: [true, (_2) => _2 ?? import_uuid.v4()],
    InputCompressionType: [],
    InputFormat: [],
    InputFormatOptions: import_smithy_client2._json,
    S3BucketSource: import_smithy_client2._json,
    TableCreationParameters: import_smithy_client2._json
  });
}, se_IncrementalExportSpecification = (input, context) => {
  return import_smithy_client2.take(input, {
    ExportFromTime: (_2) => _2.getTime() / 1000,
    ExportToTime: (_2) => _2.getTime() / 1000,
    ExportViewType: []
  });
}, se_Key = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = se_AttributeValue(value, context);
    return acc;
  }, {});
}, se_KeyConditions = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = se_Condition(value, context);
    return acc;
  }, {});
}, se_KeyList = (input, context) => {
  return input.filter((e) => e != null).map((entry) => {
    return se_Key(entry, context);
  });
}, se_KeysAndAttributes = (input, context) => {
  return import_smithy_client2.take(input, {
    AttributesToGet: import_smithy_client2._json,
    ConsistentRead: [],
    ExpressionAttributeNames: import_smithy_client2._json,
    Keys: (_2) => se_KeyList(_2, context),
    ProjectionExpression: []
  });
}, se_ListAttributeValue = (input, context) => {
  return input.filter((e) => e != null).map((entry) => {
    return se_AttributeValue(entry, context);
  });
}, se_ListBackupsInput = (input, context) => {
  return import_smithy_client2.take(input, {
    BackupType: [],
    ExclusiveStartBackupArn: [],
    Limit: [],
    TableName: [],
    TimeRangeLowerBound: (_2) => _2.getTime() / 1000,
    TimeRangeUpperBound: (_2) => _2.getTime() / 1000
  });
}, se_MapAttributeValue = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = se_AttributeValue(value, context);
    return acc;
  }, {});
}, se_ParameterizedStatement = (input, context) => {
  return import_smithy_client2.take(input, {
    Parameters: (_2) => se_PreparedStatementParameters(_2, context),
    ReturnValuesOnConditionCheckFailure: [],
    Statement: []
  });
}, se_ParameterizedStatements = (input, context) => {
  return input.filter((e) => e != null).map((entry) => {
    return se_ParameterizedStatement(entry, context);
  });
}, se_PartiQLBatchRequest = (input, context) => {
  return input.filter((e) => e != null).map((entry) => {
    return se_BatchStatementRequest(entry, context);
  });
}, se_PreparedStatementParameters = (input, context) => {
  return input.filter((e) => e != null).map((entry) => {
    return se_AttributeValue(entry, context);
  });
}, se_Put = (input, context) => {
  return import_smithy_client2.take(input, {
    ConditionExpression: [],
    ExpressionAttributeNames: import_smithy_client2._json,
    ExpressionAttributeValues: (_2) => se_ExpressionAttributeValueMap(_2, context),
    Item: (_2) => se_PutItemInputAttributeMap(_2, context),
    ReturnValuesOnConditionCheckFailure: [],
    TableName: []
  });
}, se_PutItemInput = (input, context) => {
  return import_smithy_client2.take(input, {
    ConditionExpression: [],
    ConditionalOperator: [],
    Expected: (_2) => se_ExpectedAttributeMap(_2, context),
    ExpressionAttributeNames: import_smithy_client2._json,
    ExpressionAttributeValues: (_2) => se_ExpressionAttributeValueMap(_2, context),
    Item: (_2) => se_PutItemInputAttributeMap(_2, context),
    ReturnConsumedCapacity: [],
    ReturnItemCollectionMetrics: [],
    ReturnValues: [],
    ReturnValuesOnConditionCheckFailure: [],
    TableName: []
  });
}, se_PutItemInputAttributeMap = (input, context) => {
  return Object.entries(input).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = se_AttributeValue(value, context);
    return acc;
  }, {});
}, se_PutRequest = (input, context) => {
  return import_smithy_client2.take(input, {
    Item: (_2) => se_PutItemInputAttributeMap(_2, context)
  });
}, se_QueryInput = (input, context) => {
  return import_smithy_client2.take(input, {
    AttributesToGet: import_smithy_client2._json,
    ConditionalOperator: [],
    ConsistentRead: [],
    ExclusiveStartKey: (_2) => se_Key(_2, context),
    ExpressionAttributeNames: import_smithy_client2._json,
    ExpressionAttributeValues: (_2) => se_ExpressionAttributeValueMap(_2, context),
    FilterExpression: [],
    IndexName: [],
    KeyConditionExpression: [],
    KeyConditions: (_2) => se_KeyConditions(_2, context),
    Limit: [],
    ProjectionExpression: [],
    QueryFilter: (_2) => se_FilterConditionMap(_2, context),
    ReturnConsumedCapacity: [],
    ScanIndexForward: [],
    Select: [],
    TableName: []
  });
}, se_ReplicaAutoScalingUpdate = (input, context) => {
  return import_smithy_client2.take(input, {
    RegionName: [],
    ReplicaGlobalSecondaryIndexUpdates: (_2) => se_ReplicaGlobalSecondaryIndexAutoScalingUpdateList(_2, context),
    ReplicaProvisionedReadCapacityAutoScalingUpdate: (_2) => se_AutoScalingSettingsUpdate(_2, context)
  });
}, se_ReplicaAutoScalingUpdateList = (input, context) => {
  return input.filter((e) => e != null).map((entry) => {
    return se_ReplicaAutoScalingUpdate(entry, context);
  });
}, se_ReplicaGlobalSecondaryIndexAutoScalingUpdate = (input, context) => {
  return import_smithy_client2.take(input, {
    IndexName: [],
    ProvisionedReadCapacityAutoScalingUpdate: (_2) => se_AutoScalingSettingsUpdate(_2, context)
  });
}, se_ReplicaGlobalSecondaryIndexAutoScalingUpdateList = (input, context) => {
  return input.filter((e) => e != null).map((entry) => {
    return se_ReplicaGlobalSecondaryIndexAutoScalingUpdate(entry, context);
  });
}, se_ReplicaGlobalSecondaryIndexSettingsUpdate = (input, context) => {
  return import_smithy_client2.take(input, {
    IndexName: [],
    ProvisionedReadCapacityAutoScalingSettingsUpdate: (_2) => se_AutoScalingSettingsUpdate(_2, context),
    ProvisionedReadCapacityUnits: []
  });
}, se_ReplicaGlobalSecondaryIndexSettingsUpdateList = (input, context) => {
  return input.filter((e) => e != null).map((entry) => {
    return se_ReplicaGlobalSecondaryIndexSettingsUpdate(entry, context);
  });
}, se_ReplicaSettingsUpdate = (input, context) => {
  return import_smithy_client2.take(input, {
    RegionName: [],
    ReplicaGlobalSecondaryIndexSettingsUpdate: (_2) => se_ReplicaGlobalSecondaryIndexSettingsUpdateList(_2, context),
    ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate: (_2) => se_AutoScalingSettingsUpdate(_2, context),
    ReplicaProvisionedReadCapacityUnits: [],
    ReplicaTableClass: []
  });
}, se_ReplicaSettingsUpdateList = (input, context) => {
  return input.filter((e) => e != null).map((entry) => {
    return se_ReplicaSettingsUpdate(entry, context);
  });
}, se_RestoreTableToPointInTimeInput = (input, context) => {
  return import_smithy_client2.take(input, {
    BillingModeOverride: [],
    GlobalSecondaryIndexOverride: import_smithy_client2._json,
    LocalSecondaryIndexOverride: import_smithy_client2._json,
    OnDemandThroughputOverride: import_smithy_client2._json,
    ProvisionedThroughputOverride: import_smithy_client2._json,
    RestoreDateTime: (_2) => _2.getTime() / 1000,
    SSESpecificationOverride: import_smithy_client2._json,
    SourceTableArn: [],
    SourceTableName: [],
    TargetTableName: [],
    UseLatestRestorableTime: []
  });
}, se_ScanInput = (input, context) => {
  return import_smithy_client2.take(input, {
    AttributesToGet: import_smithy_client2._json,
    ConditionalOperator: [],
    ConsistentRead: [],
    ExclusiveStartKey: (_2) => se_Key(_2, context),
    ExpressionAttributeNames: import_smithy_client2._json,
    ExpressionAttributeValues: (_2) => se_ExpressionAttributeValueMap(_2, context),
    FilterExpression: [],
    IndexName: [],
    Limit: [],
    ProjectionExpression: [],
    ReturnConsumedCapacity: [],
    ScanFilter: (_2) => se_FilterConditionMap(_2, context),
    Segment: [],
    Select: [],
    TableName: [],
    TotalSegments: []
  });
}, se_TransactGetItem = (input, context) => {
  return import_smithy_client2.take(input, {
    Get: (_2) => se_Get(_2, context)
  });
}, se_TransactGetItemList = (input, context) => {
  return input.filter((e) => e != null).map((entry) => {
    return se_TransactGetItem(entry, context);
  });
}, se_TransactGetItemsInput = (input, context) => {
  return import_smithy_client2.take(input, {
    ReturnConsumedCapacity: [],
    TransactItems: (_2) => se_TransactGetItemList(_2, context)
  });
}, se_TransactWriteItem = (input, context) => {
  return import_smithy_client2.take(input, {
    ConditionCheck: (_2) => se_ConditionCheck(_2, context),
    Delete: (_2) => se_Delete(_2, context),
    Put: (_2) => se_Put(_2, context),
    Update: (_2) => se_Update(_2, context)
  });
}, se_TransactWriteItemList = (input, context) => {
  return input.filter((e) => e != null).map((entry) => {
    return se_TransactWriteItem(entry, context);
  });
}, se_TransactWriteItemsInput = (input, context) => {
  return import_smithy_client2.take(input, {
    ClientRequestToken: [true, (_2) => _2 ?? import_uuid.v4()],
    ReturnConsumedCapacity: [],
    ReturnItemCollectionMetrics: [],
    TransactItems: (_2) => se_TransactWriteItemList(_2, context)
  });
}, se_Update = (input, context) => {
  return import_smithy_client2.take(input, {
    ConditionExpression: [],
    ExpressionAttributeNames: import_smithy_client2._json,
    ExpressionAttributeValues: (_2) => se_ExpressionAttributeValueMap(_2, context),
    Key: (_2) => se_Key(_2, context),
    ReturnValuesOnConditionCheckFailure: [],
    TableName: [],
    UpdateExpression: []
  });
}, se_UpdateGlobalTableSettingsInput = (input, context) => {
  return import_smithy_client2.take(input, {
    GlobalTableBillingMode: [],
    GlobalTableGlobalSecondaryIndexSettingsUpdate: (_2) => se_GlobalTableGlobalSecondaryIndexSettingsUpdateList(_2, context),
    GlobalTableName: [],
    GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate: (_2) => se_AutoScalingSettingsUpdate(_2, context),
    GlobalTableProvisionedWriteCapacityUnits: [],
    ReplicaSettingsUpdate: (_2) => se_ReplicaSettingsUpdateList(_2, context)
  });
}, se_UpdateItemInput = (input, context) => {
  return import_smithy_client2.take(input, {
    AttributeUpdates: (_2) => se_AttributeUpdates(_2, context),
    ConditionExpression: [],
    ConditionalOperator: [],
    Expected: (_2) => se_ExpectedAttributeMap(_2, context),
    ExpressionAttributeNames: import_smithy_client2._json,
    ExpressionAttributeValues: (_2) => se_ExpressionAttributeValueMap(_2, context),
    Key: (_2) => se_Key(_2, context),
    ReturnConsumedCapacity: [],
    ReturnItemCollectionMetrics: [],
    ReturnValues: [],
    ReturnValuesOnConditionCheckFailure: [],
    TableName: [],
    UpdateExpression: []
  });
}, se_UpdateTableReplicaAutoScalingInput = (input, context) => {
  return import_smithy_client2.take(input, {
    GlobalSecondaryIndexUpdates: (_2) => se_GlobalSecondaryIndexAutoScalingUpdateList(_2, context),
    ProvisionedWriteCapacityAutoScalingUpdate: (_2) => se_AutoScalingSettingsUpdate(_2, context),
    ReplicaUpdates: (_2) => se_ReplicaAutoScalingUpdateList(_2, context),
    TableName: []
  });
}, se_WriteRequest = (input, context) => {
  return import_smithy_client2.take(input, {
    DeleteRequest: (_2) => se_DeleteRequest(_2, context),
    PutRequest: (_2) => se_PutRequest(_2, context)
  });
}, se_WriteRequests = (input, context) => {
  return input.filter((e) => e != null).map((entry) => {
    return se_WriteRequest(entry, context);
  });
}, de_ArchivalSummary = (output, context) => {
  return import_smithy_client2.take(output, {
    ArchivalBackupArn: import_smithy_client2.expectString,
    ArchivalDateTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    ArchivalReason: import_smithy_client2.expectString
  });
}, de_AttributeMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_AttributeValue(import_core5.awsExpectUnion(value), context);
    return acc;
  }, {});
}, de_AttributeValue = (output, context) => {
  if (output.B != null) {
    return {
      B: context.base64Decoder(output.B)
    };
  }
  if (import_smithy_client2.expectBoolean(output.BOOL) !== undefined) {
    return { BOOL: import_smithy_client2.expectBoolean(output.BOOL) };
  }
  if (output.BS != null) {
    return {
      BS: de_BinarySetAttributeValue(output.BS, context)
    };
  }
  if (output.L != null) {
    return {
      L: de_ListAttributeValue(output.L, context)
    };
  }
  if (output.M != null) {
    return {
      M: de_MapAttributeValue(output.M, context)
    };
  }
  if (import_smithy_client2.expectString(output.N) !== undefined) {
    return { N: import_smithy_client2.expectString(output.N) };
  }
  if (output.NS != null) {
    return {
      NS: import_smithy_client2._json(output.NS)
    };
  }
  if (import_smithy_client2.expectBoolean(output.NULL) !== undefined) {
    return { NULL: import_smithy_client2.expectBoolean(output.NULL) };
  }
  if (import_smithy_client2.expectString(output.S) !== undefined) {
    return { S: import_smithy_client2.expectString(output.S) };
  }
  if (output.SS != null) {
    return {
      SS: import_smithy_client2._json(output.SS)
    };
  }
  return { $unknown: Object.entries(output)[0] };
}, de_AutoScalingPolicyDescription = (output, context) => {
  return import_smithy_client2.take(output, {
    PolicyName: import_smithy_client2.expectString,
    TargetTrackingScalingPolicyConfiguration: (_2) => de_AutoScalingTargetTrackingScalingPolicyConfigurationDescription(_2, context)
  });
}, de_AutoScalingPolicyDescriptionList = (output, context) => {
  const retVal = (output || []).filter((e) => e != null).map((entry) => {
    return de_AutoScalingPolicyDescription(entry, context);
  });
  return retVal;
}, de_AutoScalingSettingsDescription = (output, context) => {
  return import_smithy_client2.take(output, {
    AutoScalingDisabled: import_smithy_client2.expectBoolean,
    AutoScalingRoleArn: import_smithy_client2.expectString,
    MaximumUnits: import_smithy_client2.expectLong,
    MinimumUnits: import_smithy_client2.expectLong,
    ScalingPolicies: (_2) => de_AutoScalingPolicyDescriptionList(_2, context)
  });
}, de_AutoScalingTargetTrackingScalingPolicyConfigurationDescription = (output, context) => {
  return import_smithy_client2.take(output, {
    DisableScaleIn: import_smithy_client2.expectBoolean,
    ScaleInCooldown: import_smithy_client2.expectInt32,
    ScaleOutCooldown: import_smithy_client2.expectInt32,
    TargetValue: import_smithy_client2.limitedParseDouble
  });
}, de_BackupDescription = (output, context) => {
  return import_smithy_client2.take(output, {
    BackupDetails: (_2) => de_BackupDetails(_2, context),
    SourceTableDetails: (_2) => de_SourceTableDetails(_2, context),
    SourceTableFeatureDetails: (_2) => de_SourceTableFeatureDetails(_2, context)
  });
}, de_BackupDetails = (output, context) => {
  return import_smithy_client2.take(output, {
    BackupArn: import_smithy_client2.expectString,
    BackupCreationDateTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    BackupExpiryDateTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    BackupName: import_smithy_client2.expectString,
    BackupSizeBytes: import_smithy_client2.expectLong,
    BackupStatus: import_smithy_client2.expectString,
    BackupType: import_smithy_client2.expectString
  });
}, de_BackupSummaries = (output, context) => {
  const retVal = (output || []).filter((e) => e != null).map((entry) => {
    return de_BackupSummary(entry, context);
  });
  return retVal;
}, de_BackupSummary = (output, context) => {
  return import_smithy_client2.take(output, {
    BackupArn: import_smithy_client2.expectString,
    BackupCreationDateTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    BackupExpiryDateTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    BackupName: import_smithy_client2.expectString,
    BackupSizeBytes: import_smithy_client2.expectLong,
    BackupStatus: import_smithy_client2.expectString,
    BackupType: import_smithy_client2.expectString,
    TableArn: import_smithy_client2.expectString,
    TableId: import_smithy_client2.expectString,
    TableName: import_smithy_client2.expectString
  });
}, de_BatchExecuteStatementOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    ConsumedCapacity: (_2) => de_ConsumedCapacityMultiple(_2, context),
    Responses: (_2) => de_PartiQLBatchResponse(_2, context)
  });
}, de_BatchGetItemOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    ConsumedCapacity: (_2) => de_ConsumedCapacityMultiple(_2, context),
    Responses: (_2) => de_BatchGetResponseMap(_2, context),
    UnprocessedKeys: (_2) => de_BatchGetRequestMap(_2, context)
  });
}, de_BatchGetRequestMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_KeysAndAttributes(value, context);
    return acc;
  }, {});
}, de_BatchGetResponseMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_ItemList(value, context);
    return acc;
  }, {});
}, de_BatchStatementError = (output, context) => {
  return import_smithy_client2.take(output, {
    Code: import_smithy_client2.expectString,
    Item: (_2) => de_AttributeMap(_2, context),
    Message: import_smithy_client2.expectString
  });
}, de_BatchStatementResponse = (output, context) => {
  return import_smithy_client2.take(output, {
    Error: (_2) => de_BatchStatementError(_2, context),
    Item: (_2) => de_AttributeMap(_2, context),
    TableName: import_smithy_client2.expectString
  });
}, de_BatchWriteItemOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    ConsumedCapacity: (_2) => de_ConsumedCapacityMultiple(_2, context),
    ItemCollectionMetrics: (_2) => de_ItemCollectionMetricsPerTable(_2, context),
    UnprocessedItems: (_2) => de_BatchWriteItemRequestMap(_2, context)
  });
}, de_BatchWriteItemRequestMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_WriteRequests(value, context);
    return acc;
  }, {});
}, de_BillingModeSummary = (output, context) => {
  return import_smithy_client2.take(output, {
    BillingMode: import_smithy_client2.expectString,
    LastUpdateToPayPerRequestDateTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2)))
  });
}, de_BinarySetAttributeValue = (output, context) => {
  const retVal = (output || []).filter((e) => e != null).map((entry) => {
    return context.base64Decoder(entry);
  });
  return retVal;
}, de_CancellationReason = (output, context) => {
  return import_smithy_client2.take(output, {
    Code: import_smithy_client2.expectString,
    Item: (_2) => de_AttributeMap(_2, context),
    Message: import_smithy_client2.expectString
  });
}, de_CancellationReasonList = (output, context) => {
  const retVal = (output || []).filter((e) => e != null).map((entry) => {
    return de_CancellationReason(entry, context);
  });
  return retVal;
}, de_Capacity = (output, context) => {
  return import_smithy_client2.take(output, {
    CapacityUnits: import_smithy_client2.limitedParseDouble,
    ReadCapacityUnits: import_smithy_client2.limitedParseDouble,
    WriteCapacityUnits: import_smithy_client2.limitedParseDouble
  });
}, de_ConditionalCheckFailedException = (output, context) => {
  return import_smithy_client2.take(output, {
    Item: (_2) => de_AttributeMap(_2, context),
    message: import_smithy_client2.expectString
  });
}, de_ConsumedCapacity = (output, context) => {
  return import_smithy_client2.take(output, {
    CapacityUnits: import_smithy_client2.limitedParseDouble,
    GlobalSecondaryIndexes: (_2) => de_SecondaryIndexesCapacityMap(_2, context),
    LocalSecondaryIndexes: (_2) => de_SecondaryIndexesCapacityMap(_2, context),
    ReadCapacityUnits: import_smithy_client2.limitedParseDouble,
    Table: (_2) => de_Capacity(_2, context),
    TableName: import_smithy_client2.expectString,
    WriteCapacityUnits: import_smithy_client2.limitedParseDouble
  });
}, de_ConsumedCapacityMultiple = (output, context) => {
  const retVal = (output || []).filter((e) => e != null).map((entry) => {
    return de_ConsumedCapacity(entry, context);
  });
  return retVal;
}, de_ContinuousBackupsDescription = (output, context) => {
  return import_smithy_client2.take(output, {
    ContinuousBackupsStatus: import_smithy_client2.expectString,
    PointInTimeRecoveryDescription: (_2) => de_PointInTimeRecoveryDescription(_2, context)
  });
}, de_CreateBackupOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    BackupDetails: (_2) => de_BackupDetails(_2, context)
  });
}, de_CreateGlobalTableOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    GlobalTableDescription: (_2) => de_GlobalTableDescription(_2, context)
  });
}, de_CreateTableOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    TableDescription: (_2) => de_TableDescription(_2, context)
  });
}, de_DeleteBackupOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    BackupDescription: (_2) => de_BackupDescription(_2, context)
  });
}, de_DeleteItemOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    Attributes: (_2) => de_AttributeMap(_2, context),
    ConsumedCapacity: (_2) => de_ConsumedCapacity(_2, context),
    ItemCollectionMetrics: (_2) => de_ItemCollectionMetrics(_2, context)
  });
}, de_DeleteRequest = (output, context) => {
  return import_smithy_client2.take(output, {
    Key: (_2) => de_Key(_2, context)
  });
}, de_DeleteTableOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    TableDescription: (_2) => de_TableDescription(_2, context)
  });
}, de_DescribeBackupOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    BackupDescription: (_2) => de_BackupDescription(_2, context)
  });
}, de_DescribeContinuousBackupsOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    ContinuousBackupsDescription: (_2) => de_ContinuousBackupsDescription(_2, context)
  });
}, de_DescribeContributorInsightsOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    ContributorInsightsMode: import_smithy_client2.expectString,
    ContributorInsightsRuleList: import_smithy_client2._json,
    ContributorInsightsStatus: import_smithy_client2.expectString,
    FailureException: import_smithy_client2._json,
    IndexName: import_smithy_client2.expectString,
    LastUpdateDateTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    TableName: import_smithy_client2.expectString
  });
}, de_DescribeExportOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    ExportDescription: (_2) => de_ExportDescription(_2, context)
  });
}, de_DescribeGlobalTableOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    GlobalTableDescription: (_2) => de_GlobalTableDescription(_2, context)
  });
}, de_DescribeGlobalTableSettingsOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    GlobalTableName: import_smithy_client2.expectString,
    ReplicaSettings: (_2) => de_ReplicaSettingsDescriptionList(_2, context)
  });
}, de_DescribeImportOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    ImportTableDescription: (_2) => de_ImportTableDescription(_2, context)
  });
}, de_DescribeTableOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    Table: (_2) => de_TableDescription(_2, context)
  });
}, de_DescribeTableReplicaAutoScalingOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    TableAutoScalingDescription: (_2) => de_TableAutoScalingDescription(_2, context)
  });
}, de_ExecuteStatementOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    ConsumedCapacity: (_2) => de_ConsumedCapacity(_2, context),
    Items: (_2) => de_ItemList(_2, context),
    LastEvaluatedKey: (_2) => de_Key(_2, context),
    NextToken: import_smithy_client2.expectString
  });
}, de_ExecuteTransactionOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    ConsumedCapacity: (_2) => de_ConsumedCapacityMultiple(_2, context),
    Responses: (_2) => de_ItemResponseList(_2, context)
  });
}, de_ExportDescription = (output, context) => {
  return import_smithy_client2.take(output, {
    BilledSizeBytes: import_smithy_client2.expectLong,
    ClientToken: import_smithy_client2.expectString,
    EndTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    ExportArn: import_smithy_client2.expectString,
    ExportFormat: import_smithy_client2.expectString,
    ExportManifest: import_smithy_client2.expectString,
    ExportStatus: import_smithy_client2.expectString,
    ExportTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    ExportType: import_smithy_client2.expectString,
    FailureCode: import_smithy_client2.expectString,
    FailureMessage: import_smithy_client2.expectString,
    IncrementalExportSpecification: (_2) => de_IncrementalExportSpecification(_2, context),
    ItemCount: import_smithy_client2.expectLong,
    S3Bucket: import_smithy_client2.expectString,
    S3BucketOwner: import_smithy_client2.expectString,
    S3Prefix: import_smithy_client2.expectString,
    S3SseAlgorithm: import_smithy_client2.expectString,
    S3SseKmsKeyId: import_smithy_client2.expectString,
    StartTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    TableArn: import_smithy_client2.expectString,
    TableId: import_smithy_client2.expectString
  });
}, de_ExportTableToPointInTimeOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    ExportDescription: (_2) => de_ExportDescription(_2, context)
  });
}, de_GetItemOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    ConsumedCapacity: (_2) => de_ConsumedCapacity(_2, context),
    Item: (_2) => de_AttributeMap(_2, context)
  });
}, de_GlobalSecondaryIndexDescription = (output, context) => {
  return import_smithy_client2.take(output, {
    Backfilling: import_smithy_client2.expectBoolean,
    IndexArn: import_smithy_client2.expectString,
    IndexName: import_smithy_client2.expectString,
    IndexSizeBytes: import_smithy_client2.expectLong,
    IndexStatus: import_smithy_client2.expectString,
    ItemCount: import_smithy_client2.expectLong,
    KeySchema: import_smithy_client2._json,
    OnDemandThroughput: import_smithy_client2._json,
    Projection: import_smithy_client2._json,
    ProvisionedThroughput: (_2) => de_ProvisionedThroughputDescription(_2, context),
    WarmThroughput: import_smithy_client2._json
  });
}, de_GlobalSecondaryIndexDescriptionList = (output, context) => {
  const retVal = (output || []).filter((e) => e != null).map((entry) => {
    return de_GlobalSecondaryIndexDescription(entry, context);
  });
  return retVal;
}, de_GlobalTableDescription = (output, context) => {
  return import_smithy_client2.take(output, {
    CreationDateTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    GlobalTableArn: import_smithy_client2.expectString,
    GlobalTableName: import_smithy_client2.expectString,
    GlobalTableStatus: import_smithy_client2.expectString,
    ReplicationGroup: (_2) => de_ReplicaDescriptionList(_2, context)
  });
}, de_ImportSummary = (output, context) => {
  return import_smithy_client2.take(output, {
    CloudWatchLogGroupArn: import_smithy_client2.expectString,
    EndTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    ImportArn: import_smithy_client2.expectString,
    ImportStatus: import_smithy_client2.expectString,
    InputFormat: import_smithy_client2.expectString,
    S3BucketSource: import_smithy_client2._json,
    StartTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    TableArn: import_smithy_client2.expectString
  });
}, de_ImportSummaryList = (output, context) => {
  const retVal = (output || []).filter((e) => e != null).map((entry) => {
    return de_ImportSummary(entry, context);
  });
  return retVal;
}, de_ImportTableDescription = (output, context) => {
  return import_smithy_client2.take(output, {
    ClientToken: import_smithy_client2.expectString,
    CloudWatchLogGroupArn: import_smithy_client2.expectString,
    EndTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    ErrorCount: import_smithy_client2.expectLong,
    FailureCode: import_smithy_client2.expectString,
    FailureMessage: import_smithy_client2.expectString,
    ImportArn: import_smithy_client2.expectString,
    ImportStatus: import_smithy_client2.expectString,
    ImportedItemCount: import_smithy_client2.expectLong,
    InputCompressionType: import_smithy_client2.expectString,
    InputFormat: import_smithy_client2.expectString,
    InputFormatOptions: import_smithy_client2._json,
    ProcessedItemCount: import_smithy_client2.expectLong,
    ProcessedSizeBytes: import_smithy_client2.expectLong,
    S3BucketSource: import_smithy_client2._json,
    StartTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    TableArn: import_smithy_client2.expectString,
    TableCreationParameters: import_smithy_client2._json,
    TableId: import_smithy_client2.expectString
  });
}, de_ImportTableOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    ImportTableDescription: (_2) => de_ImportTableDescription(_2, context)
  });
}, de_IncrementalExportSpecification = (output, context) => {
  return import_smithy_client2.take(output, {
    ExportFromTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    ExportToTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    ExportViewType: import_smithy_client2.expectString
  });
}, de_ItemCollectionKeyAttributeMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_AttributeValue(import_core5.awsExpectUnion(value), context);
    return acc;
  }, {});
}, de_ItemCollectionMetrics = (output, context) => {
  return import_smithy_client2.take(output, {
    ItemCollectionKey: (_2) => de_ItemCollectionKeyAttributeMap(_2, context),
    SizeEstimateRangeGB: (_2) => de_ItemCollectionSizeEstimateRange(_2, context)
  });
}, de_ItemCollectionMetricsMultiple = (output, context) => {
  const retVal = (output || []).filter((e) => e != null).map((entry) => {
    return de_ItemCollectionMetrics(entry, context);
  });
  return retVal;
}, de_ItemCollectionMetricsPerTable = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_ItemCollectionMetricsMultiple(value, context);
    return acc;
  }, {});
}, de_ItemCollectionSizeEstimateRange = (output, context) => {
  const retVal = (output || []).filter((e) => e != null).map((entry) => {
    return import_smithy_client2.limitedParseDouble(entry);
  });
  return retVal;
}, de_ItemList = (output, context) => {
  const retVal = (output || []).filter((e) => e != null).map((entry) => {
    return de_AttributeMap(entry, context);
  });
  return retVal;
}, de_ItemResponse = (output, context) => {
  return import_smithy_client2.take(output, {
    Item: (_2) => de_AttributeMap(_2, context)
  });
}, de_ItemResponseList = (output, context) => {
  const retVal = (output || []).filter((e) => e != null).map((entry) => {
    return de_ItemResponse(entry, context);
  });
  return retVal;
}, de_Key = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_AttributeValue(import_core5.awsExpectUnion(value), context);
    return acc;
  }, {});
}, de_KeyList = (output, context) => {
  const retVal = (output || []).filter((e) => e != null).map((entry) => {
    return de_Key(entry, context);
  });
  return retVal;
}, de_KeysAndAttributes = (output, context) => {
  return import_smithy_client2.take(output, {
    AttributesToGet: import_smithy_client2._json,
    ConsistentRead: import_smithy_client2.expectBoolean,
    ExpressionAttributeNames: import_smithy_client2._json,
    Keys: (_2) => de_KeyList(_2, context),
    ProjectionExpression: import_smithy_client2.expectString
  });
}, de_ListAttributeValue = (output, context) => {
  const retVal = (output || []).filter((e) => e != null).map((entry) => {
    return de_AttributeValue(import_core5.awsExpectUnion(entry), context);
  });
  return retVal;
}, de_ListBackupsOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    BackupSummaries: (_2) => de_BackupSummaries(_2, context),
    LastEvaluatedBackupArn: import_smithy_client2.expectString
  });
}, de_ListImportsOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    ImportSummaryList: (_2) => de_ImportSummaryList(_2, context),
    NextToken: import_smithy_client2.expectString
  });
}, de_MapAttributeValue = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_AttributeValue(import_core5.awsExpectUnion(value), context);
    return acc;
  }, {});
}, de_PartiQLBatchResponse = (output, context) => {
  const retVal = (output || []).filter((e) => e != null).map((entry) => {
    return de_BatchStatementResponse(entry, context);
  });
  return retVal;
}, de_PointInTimeRecoveryDescription = (output, context) => {
  return import_smithy_client2.take(output, {
    EarliestRestorableDateTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    LatestRestorableDateTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    PointInTimeRecoveryStatus: import_smithy_client2.expectString,
    RecoveryPeriodInDays: import_smithy_client2.expectInt32
  });
}, de_ProvisionedThroughputDescription = (output, context) => {
  return import_smithy_client2.take(output, {
    LastDecreaseDateTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    LastIncreaseDateTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    NumberOfDecreasesToday: import_smithy_client2.expectLong,
    ReadCapacityUnits: import_smithy_client2.expectLong,
    WriteCapacityUnits: import_smithy_client2.expectLong
  });
}, de_PutItemInputAttributeMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_AttributeValue(import_core5.awsExpectUnion(value), context);
    return acc;
  }, {});
}, de_PutItemOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    Attributes: (_2) => de_AttributeMap(_2, context),
    ConsumedCapacity: (_2) => de_ConsumedCapacity(_2, context),
    ItemCollectionMetrics: (_2) => de_ItemCollectionMetrics(_2, context)
  });
}, de_PutRequest = (output, context) => {
  return import_smithy_client2.take(output, {
    Item: (_2) => de_PutItemInputAttributeMap(_2, context)
  });
}, de_QueryOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    ConsumedCapacity: (_2) => de_ConsumedCapacity(_2, context),
    Count: import_smithy_client2.expectInt32,
    Items: (_2) => de_ItemList(_2, context),
    LastEvaluatedKey: (_2) => de_Key(_2, context),
    ScannedCount: import_smithy_client2.expectInt32
  });
}, de_ReplicaAutoScalingDescription = (output, context) => {
  return import_smithy_client2.take(output, {
    GlobalSecondaryIndexes: (_2) => de_ReplicaGlobalSecondaryIndexAutoScalingDescriptionList(_2, context),
    RegionName: import_smithy_client2.expectString,
    ReplicaProvisionedReadCapacityAutoScalingSettings: (_2) => de_AutoScalingSettingsDescription(_2, context),
    ReplicaProvisionedWriteCapacityAutoScalingSettings: (_2) => de_AutoScalingSettingsDescription(_2, context),
    ReplicaStatus: import_smithy_client2.expectString
  });
}, de_ReplicaAutoScalingDescriptionList = (output, context) => {
  const retVal = (output || []).filter((e) => e != null).map((entry) => {
    return de_ReplicaAutoScalingDescription(entry, context);
  });
  return retVal;
}, de_ReplicaDescription = (output, context) => {
  return import_smithy_client2.take(output, {
    GlobalSecondaryIndexes: import_smithy_client2._json,
    KMSMasterKeyId: import_smithy_client2.expectString,
    OnDemandThroughputOverride: import_smithy_client2._json,
    ProvisionedThroughputOverride: import_smithy_client2._json,
    RegionName: import_smithy_client2.expectString,
    ReplicaInaccessibleDateTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    ReplicaStatus: import_smithy_client2.expectString,
    ReplicaStatusDescription: import_smithy_client2.expectString,
    ReplicaStatusPercentProgress: import_smithy_client2.expectString,
    ReplicaTableClassSummary: (_2) => de_TableClassSummary(_2, context),
    WarmThroughput: import_smithy_client2._json
  });
}, de_ReplicaDescriptionList = (output, context) => {
  const retVal = (output || []).filter((e) => e != null).map((entry) => {
    return de_ReplicaDescription(entry, context);
  });
  return retVal;
}, de_ReplicaGlobalSecondaryIndexAutoScalingDescription = (output, context) => {
  return import_smithy_client2.take(output, {
    IndexName: import_smithy_client2.expectString,
    IndexStatus: import_smithy_client2.expectString,
    ProvisionedReadCapacityAutoScalingSettings: (_2) => de_AutoScalingSettingsDescription(_2, context),
    ProvisionedWriteCapacityAutoScalingSettings: (_2) => de_AutoScalingSettingsDescription(_2, context)
  });
}, de_ReplicaGlobalSecondaryIndexAutoScalingDescriptionList = (output, context) => {
  const retVal = (output || []).filter((e) => e != null).map((entry) => {
    return de_ReplicaGlobalSecondaryIndexAutoScalingDescription(entry, context);
  });
  return retVal;
}, de_ReplicaGlobalSecondaryIndexSettingsDescription = (output, context) => {
  return import_smithy_client2.take(output, {
    IndexName: import_smithy_client2.expectString,
    IndexStatus: import_smithy_client2.expectString,
    ProvisionedReadCapacityAutoScalingSettings: (_2) => de_AutoScalingSettingsDescription(_2, context),
    ProvisionedReadCapacityUnits: import_smithy_client2.expectLong,
    ProvisionedWriteCapacityAutoScalingSettings: (_2) => de_AutoScalingSettingsDescription(_2, context),
    ProvisionedWriteCapacityUnits: import_smithy_client2.expectLong
  });
}, de_ReplicaGlobalSecondaryIndexSettingsDescriptionList = (output, context) => {
  const retVal = (output || []).filter((e) => e != null).map((entry) => {
    return de_ReplicaGlobalSecondaryIndexSettingsDescription(entry, context);
  });
  return retVal;
}, de_ReplicaSettingsDescription = (output, context) => {
  return import_smithy_client2.take(output, {
    RegionName: import_smithy_client2.expectString,
    ReplicaBillingModeSummary: (_2) => de_BillingModeSummary(_2, context),
    ReplicaGlobalSecondaryIndexSettings: (_2) => de_ReplicaGlobalSecondaryIndexSettingsDescriptionList(_2, context),
    ReplicaProvisionedReadCapacityAutoScalingSettings: (_2) => de_AutoScalingSettingsDescription(_2, context),
    ReplicaProvisionedReadCapacityUnits: import_smithy_client2.expectLong,
    ReplicaProvisionedWriteCapacityAutoScalingSettings: (_2) => de_AutoScalingSettingsDescription(_2, context),
    ReplicaProvisionedWriteCapacityUnits: import_smithy_client2.expectLong,
    ReplicaStatus: import_smithy_client2.expectString,
    ReplicaTableClassSummary: (_2) => de_TableClassSummary(_2, context)
  });
}, de_ReplicaSettingsDescriptionList = (output, context) => {
  const retVal = (output || []).filter((e) => e != null).map((entry) => {
    return de_ReplicaSettingsDescription(entry, context);
  });
  return retVal;
}, de_RestoreSummary = (output, context) => {
  return import_smithy_client2.take(output, {
    RestoreDateTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    RestoreInProgress: import_smithy_client2.expectBoolean,
    SourceBackupArn: import_smithy_client2.expectString,
    SourceTableArn: import_smithy_client2.expectString
  });
}, de_RestoreTableFromBackupOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    TableDescription: (_2) => de_TableDescription(_2, context)
  });
}, de_RestoreTableToPointInTimeOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    TableDescription: (_2) => de_TableDescription(_2, context)
  });
}, de_ScanOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    ConsumedCapacity: (_2) => de_ConsumedCapacity(_2, context),
    Count: import_smithy_client2.expectInt32,
    Items: (_2) => de_ItemList(_2, context),
    LastEvaluatedKey: (_2) => de_Key(_2, context),
    ScannedCount: import_smithy_client2.expectInt32
  });
}, de_SecondaryIndexesCapacityMap = (output, context) => {
  return Object.entries(output).reduce((acc, [key, value]) => {
    if (value === null) {
      return acc;
    }
    acc[key] = de_Capacity(value, context);
    return acc;
  }, {});
}, de_SourceTableDetails = (output, context) => {
  return import_smithy_client2.take(output, {
    BillingMode: import_smithy_client2.expectString,
    ItemCount: import_smithy_client2.expectLong,
    KeySchema: import_smithy_client2._json,
    OnDemandThroughput: import_smithy_client2._json,
    ProvisionedThroughput: import_smithy_client2._json,
    TableArn: import_smithy_client2.expectString,
    TableCreationDateTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    TableId: import_smithy_client2.expectString,
    TableName: import_smithy_client2.expectString,
    TableSizeBytes: import_smithy_client2.expectLong
  });
}, de_SourceTableFeatureDetails = (output, context) => {
  return import_smithy_client2.take(output, {
    GlobalSecondaryIndexes: import_smithy_client2._json,
    LocalSecondaryIndexes: import_smithy_client2._json,
    SSEDescription: (_2) => de_SSEDescription(_2, context),
    StreamDescription: import_smithy_client2._json,
    TimeToLiveDescription: import_smithy_client2._json
  });
}, de_SSEDescription = (output, context) => {
  return import_smithy_client2.take(output, {
    InaccessibleEncryptionDateTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    KMSMasterKeyArn: import_smithy_client2.expectString,
    SSEType: import_smithy_client2.expectString,
    Status: import_smithy_client2.expectString
  });
}, de_TableAutoScalingDescription = (output, context) => {
  return import_smithy_client2.take(output, {
    Replicas: (_2) => de_ReplicaAutoScalingDescriptionList(_2, context),
    TableName: import_smithy_client2.expectString,
    TableStatus: import_smithy_client2.expectString
  });
}, de_TableClassSummary = (output, context) => {
  return import_smithy_client2.take(output, {
    LastUpdateDateTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    TableClass: import_smithy_client2.expectString
  });
}, de_TableDescription = (output, context) => {
  return import_smithy_client2.take(output, {
    ArchivalSummary: (_2) => de_ArchivalSummary(_2, context),
    AttributeDefinitions: import_smithy_client2._json,
    BillingModeSummary: (_2) => de_BillingModeSummary(_2, context),
    CreationDateTime: (_2) => import_smithy_client2.expectNonNull(import_smithy_client2.parseEpochTimestamp(import_smithy_client2.expectNumber(_2))),
    DeletionProtectionEnabled: import_smithy_client2.expectBoolean,
    GlobalSecondaryIndexes: (_2) => de_GlobalSecondaryIndexDescriptionList(_2, context),
    GlobalTableVersion: import_smithy_client2.expectString,
    GlobalTableWitnesses: import_smithy_client2._json,
    ItemCount: import_smithy_client2.expectLong,
    KeySchema: import_smithy_client2._json,
    LatestStreamArn: import_smithy_client2.expectString,
    LatestStreamLabel: import_smithy_client2.expectString,
    LocalSecondaryIndexes: import_smithy_client2._json,
    MultiRegionConsistency: import_smithy_client2.expectString,
    OnDemandThroughput: import_smithy_client2._json,
    ProvisionedThroughput: (_2) => de_ProvisionedThroughputDescription(_2, context),
    Replicas: (_2) => de_ReplicaDescriptionList(_2, context),
    RestoreSummary: (_2) => de_RestoreSummary(_2, context),
    SSEDescription: (_2) => de_SSEDescription(_2, context),
    StreamSpecification: import_smithy_client2._json,
    TableArn: import_smithy_client2.expectString,
    TableClassSummary: (_2) => de_TableClassSummary(_2, context),
    TableId: import_smithy_client2.expectString,
    TableName: import_smithy_client2.expectString,
    TableSizeBytes: import_smithy_client2.expectLong,
    TableStatus: import_smithy_client2.expectString,
    WarmThroughput: import_smithy_client2._json
  });
}, de_TransactGetItemsOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    ConsumedCapacity: (_2) => de_ConsumedCapacityMultiple(_2, context),
    Responses: (_2) => de_ItemResponseList(_2, context)
  });
}, de_TransactionCanceledException = (output, context) => {
  return import_smithy_client2.take(output, {
    CancellationReasons: (_2) => de_CancellationReasonList(_2, context),
    Message: import_smithy_client2.expectString
  });
}, de_TransactWriteItemsOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    ConsumedCapacity: (_2) => de_ConsumedCapacityMultiple(_2, context),
    ItemCollectionMetrics: (_2) => de_ItemCollectionMetricsPerTable(_2, context)
  });
}, de_UpdateContinuousBackupsOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    ContinuousBackupsDescription: (_2) => de_ContinuousBackupsDescription(_2, context)
  });
}, de_UpdateGlobalTableOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    GlobalTableDescription: (_2) => de_GlobalTableDescription(_2, context)
  });
}, de_UpdateGlobalTableSettingsOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    GlobalTableName: import_smithy_client2.expectString,
    ReplicaSettings: (_2) => de_ReplicaSettingsDescriptionList(_2, context)
  });
}, de_UpdateItemOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    Attributes: (_2) => de_AttributeMap(_2, context),
    ConsumedCapacity: (_2) => de_ConsumedCapacity(_2, context),
    ItemCollectionMetrics: (_2) => de_ItemCollectionMetrics(_2, context)
  });
}, de_UpdateTableOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    TableDescription: (_2) => de_TableDescription(_2, context)
  });
}, de_UpdateTableReplicaAutoScalingOutput = (output, context) => {
  return import_smithy_client2.take(output, {
    TableAutoScalingDescription: (_2) => de_TableAutoScalingDescription(_2, context)
  });
}, de_WriteRequest = (output, context) => {
  return import_smithy_client2.take(output, {
    DeleteRequest: (_2) => de_DeleteRequest(_2, context),
    PutRequest: (_2) => de_PutRequest(_2, context)
  });
}, de_WriteRequests = (output, context) => {
  const retVal = (output || []).filter((e) => e != null).map((entry) => {
    return de_WriteRequest(entry, context);
  });
  return retVal;
}, deserializeMetadata = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
}), throwDefaultError, buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const contents = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
    headers
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new import_protocol_http.HttpRequest(contents);
};
var init_Aws_json1_0 = __esm(() => {
  init_DynamoDBServiceException();
  init_models_0();
  import_core5 = __toESM(require_dist_cjs30(), 1);
  import_protocol_http = __toESM(require_dist_cjs3(), 1);
  import_smithy_client2 = __toESM(require_dist_cjs28(), 1);
  import_uuid = __toESM(require_dist_cjs18(), 1);
  throwDefaultError = import_smithy_client2.withBaseException(DynamoDBServiceException);
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DescribeEndpointsCommand.js
var import_middleware_endpoint, import_middleware_serde, import_smithy_client3, DescribeEndpointsCommand;
var init_DescribeEndpointsCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde = __toESM(require_dist_cjs7(), 1);
  import_smithy_client3 = __toESM(require_dist_cjs28(), 1);
  DescribeEndpointsCommand = class DescribeEndpointsCommand extends import_smithy_client3.Command.classBuilder().ep(commonParams).m(function(Command, cs, config, o) {
    return [
      import_middleware_serde.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "DescribeEndpoints", {}).n("DynamoDBClient", "DescribeEndpointsCommand").f(undefined, undefined).ser(se_DescribeEndpointsCommand).de(de_DescribeEndpointsCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/package.json
var package_default;
var init_package = __esm(() => {
  package_default = {
    name: "@aws-sdk/client-dynamodb",
    description: "AWS SDK for JavaScript Dynamodb Client for Node.js, Browser and React Native",
    version: "3.914.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline client-dynamodb",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client": "node ../../scripts/generate-clients/single-service --solo dynamodb"
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: false,
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.914.0",
      "@aws-sdk/credential-provider-node": "3.914.0",
      "@aws-sdk/middleware-endpoint-discovery": "3.914.0",
      "@aws-sdk/middleware-host-header": "3.914.0",
      "@aws-sdk/middleware-logger": "3.914.0",
      "@aws-sdk/middleware-recursion-detection": "3.914.0",
      "@aws-sdk/middleware-user-agent": "3.914.0",
      "@aws-sdk/region-config-resolver": "3.914.0",
      "@aws-sdk/types": "3.914.0",
      "@aws-sdk/util-endpoints": "3.914.0",
      "@aws-sdk/util-user-agent-browser": "3.914.0",
      "@aws-sdk/util-user-agent-node": "3.914.0",
      "@smithy/config-resolver": "^4.4.0",
      "@smithy/core": "^3.17.0",
      "@smithy/fetch-http-handler": "^5.3.4",
      "@smithy/hash-node": "^4.2.3",
      "@smithy/invalid-dependency": "^4.2.3",
      "@smithy/middleware-content-length": "^4.2.3",
      "@smithy/middleware-endpoint": "^4.3.4",
      "@smithy/middleware-retry": "^4.4.4",
      "@smithy/middleware-serde": "^4.2.3",
      "@smithy/middleware-stack": "^4.2.3",
      "@smithy/node-config-provider": "^4.3.3",
      "@smithy/node-http-handler": "^4.4.2",
      "@smithy/protocol-http": "^5.3.3",
      "@smithy/smithy-client": "^4.9.0",
      "@smithy/types": "^4.8.0",
      "@smithy/url-parser": "^4.2.3",
      "@smithy/util-base64": "^4.3.0",
      "@smithy/util-body-length-browser": "^4.2.0",
      "@smithy/util-body-length-node": "^4.2.1",
      "@smithy/util-defaults-mode-browser": "^4.3.3",
      "@smithy/util-defaults-mode-node": "^4.2.5",
      "@smithy/util-endpoints": "^3.2.3",
      "@smithy/util-middleware": "^4.2.3",
      "@smithy/util-retry": "^4.2.3",
      "@smithy/util-utf8": "^4.2.0",
      "@smithy/util-waiter": "^4.2.3",
      "@smithy/uuid": "^1.1.0",
      tslib: "^2.6.2"
    },
    devDependencies: {
      "@tsconfig/node18": "18.2.4",
      "@types/node": "^18.19.69",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.8.3"
    },
    engines: {
      node: ">=18.0.0"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": [
          "dist-types/ts3.4/*"
        ]
      }
    },
    files: [
      "dist-*/**"
    ],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    browser: {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-dynamodb",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-dynamodb"
    }
  };
});

// node_modules/@aws-sdk/credential-provider-env/dist-es/fromEnv.js
var import_client, import_property_provider, ENV_KEY = "AWS_ACCESS_KEY_ID", ENV_SECRET = "AWS_SECRET_ACCESS_KEY", ENV_SESSION = "AWS_SESSION_TOKEN", ENV_EXPIRATION = "AWS_CREDENTIAL_EXPIRATION", ENV_CREDENTIAL_SCOPE = "AWS_CREDENTIAL_SCOPE", ENV_ACCOUNT_ID = "AWS_ACCOUNT_ID", fromEnv = (init) => async () => {
  init?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv");
  const accessKeyId = process.env[ENV_KEY];
  const secretAccessKey = process.env[ENV_SECRET];
  const sessionToken = process.env[ENV_SESSION];
  const expiry = process.env[ENV_EXPIRATION];
  const credentialScope = process.env[ENV_CREDENTIAL_SCOPE];
  const accountId = process.env[ENV_ACCOUNT_ID];
  if (accessKeyId && secretAccessKey) {
    const credentials = {
      accessKeyId,
      secretAccessKey,
      ...sessionToken && { sessionToken },
      ...expiry && { expiration: new Date(expiry) },
      ...credentialScope && { credentialScope },
      ...accountId && { accountId }
    };
    import_client.setCredentialFeature(credentials, "CREDENTIALS_ENV_VARS", "g");
    return credentials;
  }
  throw new import_property_provider.CredentialsProviderError("Unable to find environment variable credentials.", { logger: init?.logger });
};
var init_fromEnv = __esm(() => {
  import_client = __toESM(require_client(), 1);
  import_property_provider = __toESM(require_dist_cjs24(), 1);
});

// node_modules/@aws-sdk/credential-provider-env/dist-es/index.js
var exports_dist_es = {};
__export(exports_dist_es, {
  fromEnv: () => fromEnv,
  ENV_SESSION: () => ENV_SESSION,
  ENV_SECRET: () => ENV_SECRET,
  ENV_KEY: () => ENV_KEY,
  ENV_EXPIRATION: () => ENV_EXPIRATION,
  ENV_CREDENTIAL_SCOPE: () => ENV_CREDENTIAL_SCOPE,
  ENV_ACCOUNT_ID: () => ENV_ACCOUNT_ID
});
var init_dist_es3 = __esm(() => {
  init_fromEnv();
});

// node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/httpRequest.js
import { Buffer as Buffer2 } from "buffer";
import { request } from "http";
function httpRequest(options) {
  return new Promise((resolve, reject) => {
    const req = request({
      method: "GET",
      ...options,
      hostname: options.hostname?.replace(/^\[(.+)\]$/, "$1")
    });
    req.on("error", (err3) => {
      reject(Object.assign(new import_property_provider2.ProviderError("Unable to connect to instance metadata service"), err3));
      req.destroy();
    });
    req.on("timeout", () => {
      reject(new import_property_provider2.ProviderError("TimeoutError from instance metadata service"));
      req.destroy();
    });
    req.on("response", (res) => {
      const { statusCode = 400 } = res;
      if (statusCode < 200 || 300 <= statusCode) {
        reject(Object.assign(new import_property_provider2.ProviderError("Error response received from instance metadata service"), { statusCode }));
        req.destroy();
      }
      const chunks = [];
      res.on("data", (chunk) => {
        chunks.push(chunk);
      });
      res.on("end", () => {
        resolve(Buffer2.concat(chunks));
        req.destroy();
      });
    });
    req.end();
  });
}
var import_property_provider2;
var init_httpRequest = __esm(() => {
  import_property_provider2 = __toESM(require_dist_cjs24(), 1);
});

// node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/ImdsCredentials.js
var isImdsCredentials = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.AccessKeyId === "string" && typeof arg.SecretAccessKey === "string" && typeof arg.Token === "string" && typeof arg.Expiration === "string", fromImdsCredentials = (creds) => ({
  accessKeyId: creds.AccessKeyId,
  secretAccessKey: creds.SecretAccessKey,
  sessionToken: creds.Token,
  expiration: new Date(creds.Expiration),
  ...creds.AccountId && { accountId: creds.AccountId }
});

// node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/RemoteProviderInit.js
var DEFAULT_TIMEOUT = 1000, DEFAULT_MAX_RETRIES = 0, providerConfigFromInit = ({ maxRetries = DEFAULT_MAX_RETRIES, timeout = DEFAULT_TIMEOUT }) => ({ maxRetries, timeout });

// node_modules/@smithy/credential-provider-imds/dist-es/remoteProvider/retry.js
var retry = (toRetry, maxRetries) => {
  let promise = toRetry();
  for (let i2 = 0;i2 < maxRetries; i2++) {
    promise = promise.catch(toRetry);
  }
  return promise;
};

// node_modules/@smithy/credential-provider-imds/dist-es/fromContainerMetadata.js
import { parse as parse2 } from "url";
var import_property_provider3, ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI", ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI", ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN", fromContainerMetadata = (init = {}) => {
  const { timeout, maxRetries } = providerConfigFromInit(init);
  return () => retry(async () => {
    const requestOptions = await getCmdsUri({ logger: init.logger });
    const credsResponse = JSON.parse(await requestFromEcsImds(timeout, requestOptions));
    if (!isImdsCredentials(credsResponse)) {
      throw new import_property_provider3.CredentialsProviderError("Invalid response received from instance metadata service.", {
        logger: init.logger
      });
    }
    return fromImdsCredentials(credsResponse);
  }, maxRetries);
}, requestFromEcsImds = async (timeout, options) => {
  if (process.env[ENV_CMDS_AUTH_TOKEN]) {
    options.headers = {
      ...options.headers,
      Authorization: process.env[ENV_CMDS_AUTH_TOKEN]
    };
  }
  const buffer = await httpRequest({
    ...options,
    timeout
  });
  return buffer.toString();
}, CMDS_IP = "169.254.170.2", GREENGRASS_HOSTS, GREENGRASS_PROTOCOLS, getCmdsUri = async ({ logger }) => {
  if (process.env[ENV_CMDS_RELATIVE_URI]) {
    return {
      hostname: CMDS_IP,
      path: process.env[ENV_CMDS_RELATIVE_URI]
    };
  }
  if (process.env[ENV_CMDS_FULL_URI]) {
    const parsed = parse2(process.env[ENV_CMDS_FULL_URI]);
    if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS)) {
      throw new import_property_provider3.CredentialsProviderError(`${parsed.hostname} is not a valid container metadata service hostname`, {
        tryNextLink: false,
        logger
      });
    }
    if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS)) {
      throw new import_property_provider3.CredentialsProviderError(`${parsed.protocol} is not a valid container metadata service protocol`, {
        tryNextLink: false,
        logger
      });
    }
    return {
      ...parsed,
      port: parsed.port ? parseInt(parsed.port, 10) : undefined
    };
  }
  throw new import_property_provider3.CredentialsProviderError("The container metadata credential provider cannot be used unless" + ` the ${ENV_CMDS_RELATIVE_URI} or ${ENV_CMDS_FULL_URI} environment` + " variable is set", {
    tryNextLink: false,
    logger
  });
};
var init_fromContainerMetadata = __esm(() => {
  init_httpRequest();
  import_property_provider3 = __toESM(require_dist_cjs24(), 1);
  GREENGRASS_HOSTS = {
    localhost: true,
    "127.0.0.1": true
  };
  GREENGRASS_PROTOCOLS = {
    "http:": true,
    "https:": true
  };
});

// node_modules/@smithy/credential-provider-imds/dist-es/error/InstanceMetadataV1FallbackError.js
var import_property_provider4, InstanceMetadataV1FallbackError;
var init_InstanceMetadataV1FallbackError = __esm(() => {
  import_property_provider4 = __toESM(require_dist_cjs24(), 1);
  InstanceMetadataV1FallbackError = class InstanceMetadataV1FallbackError extends import_property_provider4.CredentialsProviderError {
    tryNextLink;
    name = "InstanceMetadataV1FallbackError";
    constructor(message, tryNextLink = true) {
      super(message, tryNextLink);
      this.tryNextLink = tryNextLink;
      Object.setPrototypeOf(this, InstanceMetadataV1FallbackError.prototype);
    }
  };
});

// node_modules/@smithy/credential-provider-imds/dist-es/config/Endpoint.js
var Endpoint2;
var init_Endpoint2 = __esm(() => {
  (function(Endpoint3) {
    Endpoint3["IPv4"] = "http://169.254.169.254";
    Endpoint3["IPv6"] = "http://[fd00:ec2::254]";
  })(Endpoint2 || (Endpoint2 = {}));
});

// node_modules/@smithy/credential-provider-imds/dist-es/config/EndpointConfigOptions.js
var ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT", CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint", ENDPOINT_CONFIG_OPTIONS;
var init_EndpointConfigOptions = __esm(() => {
  ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env3) => env3[ENV_ENDPOINT_NAME],
    configFileSelector: (profile) => profile[CONFIG_ENDPOINT_NAME],
    default: undefined
  };
});

// node_modules/@smithy/credential-provider-imds/dist-es/config/EndpointMode.js
var EndpointMode;
var init_EndpointMode = __esm(() => {
  (function(EndpointMode2) {
    EndpointMode2["IPv4"] = "IPv4";
    EndpointMode2["IPv6"] = "IPv6";
  })(EndpointMode || (EndpointMode = {}));
});

// node_modules/@smithy/credential-provider-imds/dist-es/config/EndpointModeConfigOptions.js
var ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE", CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode", ENDPOINT_MODE_CONFIG_OPTIONS;
var init_EndpointModeConfigOptions = __esm(() => {
  init_EndpointMode();
  ENDPOINT_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env3) => env3[ENV_ENDPOINT_MODE_NAME],
    configFileSelector: (profile) => profile[CONFIG_ENDPOINT_MODE_NAME],
    default: EndpointMode.IPv4
  };
});

// node_modules/@smithy/credential-provider-imds/dist-es/utils/getInstanceMetadataEndpoint.js
var import_node_config_provider, import_url_parser, getInstanceMetadataEndpoint = async () => import_url_parser.parseUrl(await getFromEndpointConfig() || await getFromEndpointModeConfig()), getFromEndpointConfig = async () => import_node_config_provider.loadConfig(ENDPOINT_CONFIG_OPTIONS)(), getFromEndpointModeConfig = async () => {
  const endpointMode = await import_node_config_provider.loadConfig(ENDPOINT_MODE_CONFIG_OPTIONS)();
  switch (endpointMode) {
    case EndpointMode.IPv4:
      return Endpoint2.IPv4;
    case EndpointMode.IPv6:
      return Endpoint2.IPv6;
    default:
      throw new Error(`Unsupported endpoint mode: ${endpointMode}.` + ` Select from ${Object.values(EndpointMode)}`);
  }
};
var init_getInstanceMetadataEndpoint = __esm(() => {
  init_Endpoint2();
  init_EndpointConfigOptions();
  init_EndpointMode();
  init_EndpointModeConfigOptions();
  import_node_config_provider = __toESM(require_dist_cjs36(), 1);
  import_url_parser = __toESM(require_dist_cjs22(), 1);
});

// node_modules/@smithy/credential-provider-imds/dist-es/utils/getExtendedInstanceMetadataCredentials.js
var STATIC_STABILITY_REFRESH_INTERVAL_SECONDS, STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS, STATIC_STABILITY_DOC_URL = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html", getExtendedInstanceMetadataCredentials = (credentials, logger) => {
  const refreshInterval = STATIC_STABILITY_REFRESH_INTERVAL_SECONDS + Math.floor(Math.random() * STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS);
  const newExpiration = new Date(Date.now() + refreshInterval * 1000);
  logger.warn("Attempting credential expiration extension due to a credential service availability issue. A refresh of these " + `credentials will be attempted after ${new Date(newExpiration)}.
For more information, please visit: ` + STATIC_STABILITY_DOC_URL);
  const originalExpiration = credentials.originalExpiration ?? credentials.expiration;
  return {
    ...credentials,
    ...originalExpiration ? { originalExpiration } : {},
    expiration: newExpiration
  };
};
var init_getExtendedInstanceMetadataCredentials = __esm(() => {
  STATIC_STABILITY_REFRESH_INTERVAL_SECONDS = 5 * 60;
  STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS = 5 * 60;
});

// node_modules/@smithy/credential-provider-imds/dist-es/utils/staticStabilityProvider.js
var staticStabilityProvider = (provider, options = {}) => {
  const logger = options?.logger || console;
  let pastCredentials;
  return async () => {
    let credentials;
    try {
      credentials = await provider();
      if (credentials.expiration && credentials.expiration.getTime() < Date.now()) {
        credentials = getExtendedInstanceMetadataCredentials(credentials, logger);
      }
    } catch (e) {
      if (pastCredentials) {
        logger.warn("Credential renew failed: ", e);
        credentials = getExtendedInstanceMetadataCredentials(pastCredentials, logger);
      } else {
        throw e;
      }
    }
    pastCredentials = credentials;
    return credentials;
  };
};
var init_staticStabilityProvider = __esm(() => {
  init_getExtendedInstanceMetadataCredentials();
});

// node_modules/@smithy/credential-provider-imds/dist-es/fromInstanceMetadata.js
var import_node_config_provider2, import_property_provider5, IMDS_PATH = "/latest/meta-data/iam/security-credentials/", IMDS_TOKEN_PATH = "/latest/api/token", AWS_EC2_METADATA_V1_DISABLED = "AWS_EC2_METADATA_V1_DISABLED", PROFILE_AWS_EC2_METADATA_V1_DISABLED = "ec2_metadata_v1_disabled", X_AWS_EC2_METADATA_TOKEN = "x-aws-ec2-metadata-token", fromInstanceMetadata = (init = {}) => staticStabilityProvider(getInstanceMetadataProvider(init), { logger: init.logger }), getInstanceMetadataProvider = (init = {}) => {
  let disableFetchToken = false;
  const { logger, profile } = init;
  const { timeout, maxRetries } = providerConfigFromInit(init);
  const getCredentials = async (maxRetries2, options) => {
    const isImdsV1Fallback = disableFetchToken || options.headers?.[X_AWS_EC2_METADATA_TOKEN] == null;
    if (isImdsV1Fallback) {
      let fallbackBlockedFromProfile = false;
      let fallbackBlockedFromProcessEnv = false;
      const configValue = await import_node_config_provider2.loadConfig({
        environmentVariableSelector: (env3) => {
          const envValue = env3[AWS_EC2_METADATA_V1_DISABLED];
          fallbackBlockedFromProcessEnv = !!envValue && envValue !== "false";
          if (envValue === undefined) {
            throw new import_property_provider5.CredentialsProviderError(`${AWS_EC2_METADATA_V1_DISABLED} not set in env, checking config file next.`, { logger: init.logger });
          }
          return fallbackBlockedFromProcessEnv;
        },
        configFileSelector: (profile2) => {
          const profileValue = profile2[PROFILE_AWS_EC2_METADATA_V1_DISABLED];
          fallbackBlockedFromProfile = !!profileValue && profileValue !== "false";
          return fallbackBlockedFromProfile;
        },
        default: false
      }, {
        profile
      })();
      if (init.ec2MetadataV1Disabled || configValue) {
        const causes = [];
        if (init.ec2MetadataV1Disabled)
          causes.push("credential provider initialization (runtime option ec2MetadataV1Disabled)");
        if (fallbackBlockedFromProfile)
          causes.push(`config file profile (${PROFILE_AWS_EC2_METADATA_V1_DISABLED})`);
        if (fallbackBlockedFromProcessEnv)
          causes.push(`process environment variable (${AWS_EC2_METADATA_V1_DISABLED})`);
        throw new InstanceMetadataV1FallbackError(`AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${causes.join(", ")}].`);
      }
    }
    const imdsProfile = (await retry(async () => {
      let profile2;
      try {
        profile2 = await getProfile(options);
      } catch (err3) {
        if (err3.statusCode === 401) {
          disableFetchToken = false;
        }
        throw err3;
      }
      return profile2;
    }, maxRetries2)).trim();
    return retry(async () => {
      let creds;
      try {
        creds = await getCredentialsFromProfile(imdsProfile, options, init);
      } catch (err3) {
        if (err3.statusCode === 401) {
          disableFetchToken = false;
        }
        throw err3;
      }
      return creds;
    }, maxRetries2);
  };
  return async () => {
    const endpoint = await getInstanceMetadataEndpoint();
    if (disableFetchToken) {
      logger?.debug("AWS SDK Instance Metadata", "using v1 fallback (no token fetch)");
      return getCredentials(maxRetries, { ...endpoint, timeout });
    } else {
      let token;
      try {
        token = (await getMetadataToken({ ...endpoint, timeout })).toString();
      } catch (error) {
        if (error?.statusCode === 400) {
          throw Object.assign(error, {
            message: "EC2 Metadata token request returned error"
          });
        } else if (error.message === "TimeoutError" || [403, 404, 405].includes(error.statusCode)) {
          disableFetchToken = true;
        }
        logger?.debug("AWS SDK Instance Metadata", "using v1 fallback (initial)");
        return getCredentials(maxRetries, { ...endpoint, timeout });
      }
      return getCredentials(maxRetries, {
        ...endpoint,
        headers: {
          [X_AWS_EC2_METADATA_TOKEN]: token
        },
        timeout
      });
    }
  };
}, getMetadataToken = async (options) => httpRequest({
  ...options,
  path: IMDS_TOKEN_PATH,
  method: "PUT",
  headers: {
    "x-aws-ec2-metadata-token-ttl-seconds": "21600"
  }
}), getProfile = async (options) => (await httpRequest({ ...options, path: IMDS_PATH })).toString(), getCredentialsFromProfile = async (profile, options, init) => {
  const credentialsResponse = JSON.parse((await httpRequest({
    ...options,
    path: IMDS_PATH + profile
  })).toString());
  if (!isImdsCredentials(credentialsResponse)) {
    throw new import_property_provider5.CredentialsProviderError("Invalid response received from instance metadata service.", {
      logger: init.logger
    });
  }
  return fromImdsCredentials(credentialsResponse);
};
var init_fromInstanceMetadata = __esm(() => {
  init_InstanceMetadataV1FallbackError();
  init_httpRequest();
  init_getInstanceMetadataEndpoint();
  init_staticStabilityProvider();
  import_node_config_provider2 = __toESM(require_dist_cjs36(), 1);
  import_property_provider5 = __toESM(require_dist_cjs24(), 1);
});

// node_modules/@smithy/credential-provider-imds/dist-es/types.js
var init_types = () => {};

// node_modules/@smithy/credential-provider-imds/dist-es/index.js
var exports_dist_es2 = {};
__export(exports_dist_es2, {
  providerConfigFromInit: () => providerConfigFromInit,
  httpRequest: () => httpRequest,
  getInstanceMetadataEndpoint: () => getInstanceMetadataEndpoint,
  fromInstanceMetadata: () => fromInstanceMetadata,
  fromContainerMetadata: () => fromContainerMetadata,
  Endpoint: () => Endpoint2,
  ENV_CMDS_RELATIVE_URI: () => ENV_CMDS_RELATIVE_URI,
  ENV_CMDS_FULL_URI: () => ENV_CMDS_FULL_URI,
  ENV_CMDS_AUTH_TOKEN: () => ENV_CMDS_AUTH_TOKEN,
  DEFAULT_TIMEOUT: () => DEFAULT_TIMEOUT,
  DEFAULT_MAX_RETRIES: () => DEFAULT_MAX_RETRIES
});
var init_dist_es4 = __esm(() => {
  init_httpRequest();
  init_getInstanceMetadataEndpoint();
  init_Endpoint2();
  init_fromContainerMetadata();
  init_fromInstanceMetadata();
  init_types();
});

// node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/checkUrl.js
var import_property_provider6, ECS_CONTAINER_HOST = "169.254.170.2", EKS_CONTAINER_HOST_IPv4 = "169.254.170.23", EKS_CONTAINER_HOST_IPv6 = "[fd00:ec2::23]", checkUrl = (url, logger) => {
  if (url.protocol === "https:") {
    return;
  }
  if (url.hostname === ECS_CONTAINER_HOST || url.hostname === EKS_CONTAINER_HOST_IPv4 || url.hostname === EKS_CONTAINER_HOST_IPv6) {
    return;
  }
  if (url.hostname.includes("[")) {
    if (url.hostname === "[::1]" || url.hostname === "[0000:0000:0000:0000:0000:0000:0000:0001]") {
      return;
    }
  } else {
    if (url.hostname === "localhost") {
      return;
    }
    const ipComponents = url.hostname.split(".");
    const inRange = (component) => {
      const num = parseInt(component, 10);
      return 0 <= num && num <= 255;
    };
    if (ipComponents[0] === "127" && inRange(ipComponents[1]) && inRange(ipComponents[2]) && inRange(ipComponents[3]) && ipComponents.length === 4) {
      return;
    }
  }
  throw new import_property_provider6.CredentialsProviderError(`URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`, { logger });
};
var init_checkUrl = __esm(() => {
  import_property_provider6 = __toESM(require_dist_cjs24(), 1);
});

// node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/requestHelpers.js
function createGetRequest(url) {
  return new import_protocol_http2.HttpRequest({
    protocol: url.protocol,
    hostname: url.hostname,
    port: Number(url.port),
    path: url.pathname,
    query: Array.from(url.searchParams.entries()).reduce((acc, [k2, v]) => {
      acc[k2] = v;
      return acc;
    }, {}),
    fragment: url.hash
  });
}
async function getCredentials(response, logger) {
  const stream = import_util_stream.sdkStreamMixin(response.body);
  const str = await stream.transformToString();
  if (response.statusCode === 200) {
    const parsed = JSON.parse(str);
    if (typeof parsed.AccessKeyId !== "string" || typeof parsed.SecretAccessKey !== "string" || typeof parsed.Token !== "string" || typeof parsed.Expiration !== "string") {
      throw new import_property_provider7.CredentialsProviderError("HTTP credential provider response not of the required format, an object matching: " + "{ AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }", { logger });
    }
    return {
      accessKeyId: parsed.AccessKeyId,
      secretAccessKey: parsed.SecretAccessKey,
      sessionToken: parsed.Token,
      expiration: import_smithy_client4.parseRfc3339DateTime(parsed.Expiration)
    };
  }
  if (response.statusCode >= 400 && response.statusCode < 500) {
    let parsedBody = {};
    try {
      parsedBody = JSON.parse(str);
    } catch (e) {}
    throw Object.assign(new import_property_provider7.CredentialsProviderError(`Server responded with status: ${response.statusCode}`, { logger }), {
      Code: parsedBody.Code,
      Message: parsedBody.Message
    });
  }
  throw new import_property_provider7.CredentialsProviderError(`Server responded with status: ${response.statusCode}`, { logger });
}
var import_property_provider7, import_protocol_http2, import_smithy_client4, import_util_stream;
var init_requestHelpers = __esm(() => {
  import_property_provider7 = __toESM(require_dist_cjs24(), 1);
  import_protocol_http2 = __toESM(require_dist_cjs3(), 1);
  import_smithy_client4 = __toESM(require_dist_cjs28(), 1);
  import_util_stream = __toESM(require_dist_cjs17(), 1);
});

// node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/retry-wrapper.js
var retryWrapper = (toRetry, maxRetries, delayMs) => {
  return async () => {
    for (let i2 = 0;i2 < maxRetries; ++i2) {
      try {
        return await toRetry();
      } catch (e) {
        await new Promise((resolve) => setTimeout(resolve, delayMs));
      }
    }
    return await toRetry();
  };
};

// node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/fromHttp.js
import fs from "fs/promises";
var import_client2, import_node_http_handler, import_property_provider8, AWS_CONTAINER_CREDENTIALS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI", DEFAULT_LINK_LOCAL_HOST = "http://169.254.170.2", AWS_CONTAINER_CREDENTIALS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI", AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE = "AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE", AWS_CONTAINER_AUTHORIZATION_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN", fromHttp = (options = {}) => {
  options.logger?.debug("@aws-sdk/credential-provider-http - fromHttp");
  let host;
  const relative = options.awsContainerCredentialsRelativeUri ?? process.env[AWS_CONTAINER_CREDENTIALS_RELATIVE_URI];
  const full = options.awsContainerCredentialsFullUri ?? process.env[AWS_CONTAINER_CREDENTIALS_FULL_URI];
  const token = options.awsContainerAuthorizationToken ?? process.env[AWS_CONTAINER_AUTHORIZATION_TOKEN];
  const tokenFile = options.awsContainerAuthorizationTokenFile ?? process.env[AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE];
  const warn = options.logger?.constructor?.name === "NoOpLogger" || !options.logger?.warn ? console.warn : options.logger.warn.bind(options.logger);
  if (relative && full) {
    warn("@aws-sdk/credential-provider-http: " + "you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri.");
    warn("awsContainerCredentialsFullUri will take precedence.");
  }
  if (token && tokenFile) {
    warn("@aws-sdk/credential-provider-http: " + "you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile.");
    warn("awsContainerAuthorizationToken will take precedence.");
  }
  if (full) {
    host = full;
  } else if (relative) {
    host = `${DEFAULT_LINK_LOCAL_HOST}${relative}`;
  } else {
    throw new import_property_provider8.CredentialsProviderError(`No HTTP credential provider host provided.
Set AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`, { logger: options.logger });
  }
  const url = new URL(host);
  checkUrl(url, options.logger);
  const requestHandler = import_node_http_handler.NodeHttpHandler.create({
    requestTimeout: options.timeout ?? 1000,
    connectionTimeout: options.timeout ?? 1000
  });
  return retryWrapper(async () => {
    const request2 = createGetRequest(url);
    if (token) {
      request2.headers.Authorization = token;
    } else if (tokenFile) {
      request2.headers.Authorization = (await fs.readFile(tokenFile)).toString();
    }
    try {
      const result = await requestHandler.handle(request2);
      return getCredentials(result.response).then((creds) => import_client2.setCredentialFeature(creds, "CREDENTIALS_HTTP", "z"));
    } catch (e) {
      throw new import_property_provider8.CredentialsProviderError(String(e), { logger: options.logger });
    }
  }, options.maxRetries ?? 3, options.timeout ?? 1000);
};
var init_fromHttp = __esm(() => {
  init_checkUrl();
  init_requestHelpers();
  import_client2 = __toESM(require_client(), 1);
  import_node_http_handler = __toESM(require_dist_cjs14(), 1);
  import_property_provider8 = __toESM(require_dist_cjs24(), 1);
});

// node_modules/@aws-sdk/credential-provider-http/dist-es/index.js
var exports_dist_es3 = {};
__export(exports_dist_es3, {
  fromHttp: () => fromHttp
});
var init_dist_es5 = __esm(() => {
  init_fromHttp();
});

// node_modules/@aws-sdk/credential-provider-node/dist-es/remoteProvider.js
var import_property_provider9, ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED", remoteProvider = async (init) => {
  const { ENV_CMDS_FULL_URI: ENV_CMDS_FULL_URI2, ENV_CMDS_RELATIVE_URI: ENV_CMDS_RELATIVE_URI2, fromContainerMetadata: fromContainerMetadata3, fromInstanceMetadata: fromInstanceMetadata3 } = await Promise.resolve().then(() => (init_dist_es4(), exports_dist_es2));
  if (process.env[ENV_CMDS_RELATIVE_URI2] || process.env[ENV_CMDS_FULL_URI2]) {
    init.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata");
    const { fromHttp: fromHttp2 } = await Promise.resolve().then(() => (init_dist_es5(), exports_dist_es3));
    return import_property_provider9.chain(fromHttp2(init), fromContainerMetadata3(init));
  }
  if (process.env[ENV_IMDS_DISABLED] && process.env[ENV_IMDS_DISABLED] !== "false") {
    return async () => {
      throw new import_property_provider9.CredentialsProviderError("EC2 Instance Metadata Service access disabled", { logger: init.logger });
    };
  }
  init.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata");
  return fromInstanceMetadata3(init);
};
var init_remoteProvider = __esm(() => {
  import_property_provider9 = __toESM(require_dist_cjs24(), 1);
});

// node_modules/@aws-sdk/credential-provider-sso/dist-es/isSsoProfile.js
var isSsoProfile = (arg) => arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string");

// node_modules/@aws-sdk/token-providers/dist-es/fromEnvSigningName.js
var init_fromEnvSigningName = () => {};

// node_modules/@aws-sdk/token-providers/dist-es/constants.js
var EXPIRE_WINDOW_MS, REFRESH_MESSAGE = `To refresh this SSO session run 'aws sso login' with the corresponding profile.`;
var init_constants = __esm(() => {
  EXPIRE_WINDOW_MS = 5 * 60 * 1000;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso-oidc/auth/httpAuthSchemeProvider.js
var require_httpAuthSchemeProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveHttpAuthSchemeConfig = exports.defaultSSOOIDCHttpAuthSchemeProvider = exports.defaultSSOOIDCHttpAuthSchemeParametersProvider = undefined;
  var core_1 = require_dist_cjs30();
  var util_middleware_1 = require_dist_cjs2();
  var defaultSSOOIDCHttpAuthSchemeParametersProvider = async (config, context, input) => {
    return {
      operation: (0, util_middleware_1.getSmithyContext)(context).operation,
      region: await (0, util_middleware_1.normalizeProvider)(config.region)() || (() => {
        throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
      })()
    };
  };
  exports.defaultSSOOIDCHttpAuthSchemeParametersProvider = defaultSSOOIDCHttpAuthSchemeParametersProvider;
  function createAwsAuthSigv4HttpAuthOption2(authParameters) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "sso-oauth",
        region: authParameters.region
      },
      propertiesExtractor: (config, context) => ({
        signingProperties: {
          config,
          context
        }
      })
    };
  }
  function createSmithyApiNoAuthHttpAuthOption(authParameters) {
    return {
      schemeId: "smithy.api#noAuth"
    };
  }
  var defaultSSOOIDCHttpAuthSchemeProvider = (authParameters) => {
    const options = [];
    switch (authParameters.operation) {
      case "CreateToken": {
        options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
        break;
      }
      default: {
        options.push(createAwsAuthSigv4HttpAuthOption2(authParameters));
      }
    }
    return options;
  };
  exports.defaultSSOOIDCHttpAuthSchemeProvider = defaultSSOOIDCHttpAuthSchemeProvider;
  var resolveHttpAuthSchemeConfig2 = (config) => {
    const config_0 = (0, core_1.resolveAwsSdkSigV4Config)(config);
    return Object.assign(config_0, {
      authSchemePreference: (0, util_middleware_1.normalizeProvider)(config.authSchemePreference ?? [])
    });
  };
  exports.resolveHttpAuthSchemeConfig = resolveHttpAuthSchemeConfig2;
});

// node_modules/@aws-sdk/nested-clients/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "@aws-sdk/nested-clients",
    version: "3.914.0",
    description: "Nested clients for AWS SDK packages.",
    main: "./dist-cjs/index.js",
    module: "./dist-es/index.js",
    types: "./dist-types/index.d.ts",
    scripts: {
      build: "yarn lint && concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline nested-clients",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      lint: "node ../../scripts/validation/submodules-linter.js --pkg nested-clients",
      test: "yarn g:vitest run",
      "test:watch": "yarn g:vitest watch"
    },
    engines: {
      node: ">=18.0.0"
    },
    sideEffects: false,
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.914.0",
      "@aws-sdk/middleware-host-header": "3.914.0",
      "@aws-sdk/middleware-logger": "3.914.0",
      "@aws-sdk/middleware-recursion-detection": "3.914.0",
      "@aws-sdk/middleware-user-agent": "3.914.0",
      "@aws-sdk/region-config-resolver": "3.914.0",
      "@aws-sdk/types": "3.914.0",
      "@aws-sdk/util-endpoints": "3.914.0",
      "@aws-sdk/util-user-agent-browser": "3.914.0",
      "@aws-sdk/util-user-agent-node": "3.914.0",
      "@smithy/config-resolver": "^4.4.0",
      "@smithy/core": "^3.17.0",
      "@smithy/fetch-http-handler": "^5.3.4",
      "@smithy/hash-node": "^4.2.3",
      "@smithy/invalid-dependency": "^4.2.3",
      "@smithy/middleware-content-length": "^4.2.3",
      "@smithy/middleware-endpoint": "^4.3.4",
      "@smithy/middleware-retry": "^4.4.4",
      "@smithy/middleware-serde": "^4.2.3",
      "@smithy/middleware-stack": "^4.2.3",
      "@smithy/node-config-provider": "^4.3.3",
      "@smithy/node-http-handler": "^4.4.2",
      "@smithy/protocol-http": "^5.3.3",
      "@smithy/smithy-client": "^4.9.0",
      "@smithy/types": "^4.8.0",
      "@smithy/url-parser": "^4.2.3",
      "@smithy/util-base64": "^4.3.0",
      "@smithy/util-body-length-browser": "^4.2.0",
      "@smithy/util-body-length-node": "^4.2.1",
      "@smithy/util-defaults-mode-browser": "^4.3.3",
      "@smithy/util-defaults-mode-node": "^4.2.5",
      "@smithy/util-endpoints": "^3.2.3",
      "@smithy/util-middleware": "^4.2.3",
      "@smithy/util-retry": "^4.2.3",
      "@smithy/util-utf8": "^4.2.0",
      tslib: "^2.6.2"
    },
    devDependencies: {
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.8.3"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": [
          "dist-types/ts3.4/*"
        ]
      }
    },
    files: [
      "./sso-oidc.d.ts",
      "./sso-oidc.js",
      "./sts.d.ts",
      "./sts.js",
      "dist-*/**"
    ],
    browser: {
      "./dist-es/submodules/sso-oidc/runtimeConfig": "./dist-es/submodules/sso-oidc/runtimeConfig.browser",
      "./dist-es/submodules/sts/runtimeConfig": "./dist-es/submodules/sts/runtimeConfig.browser"
    },
    "react-native": {},
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/nested-clients",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "packages/nested-clients"
    },
    exports: {
      "./sso-oidc": {
        types: "./dist-types/submodules/sso-oidc/index.d.ts",
        module: "./dist-es/submodules/sso-oidc/index.js",
        node: "./dist-cjs/submodules/sso-oidc/index.js",
        import: "./dist-es/submodules/sso-oidc/index.js",
        require: "./dist-cjs/submodules/sso-oidc/index.js"
      },
      "./sts": {
        types: "./dist-types/submodules/sts/index.d.ts",
        module: "./dist-es/submodules/sts/index.js",
        node: "./dist-cjs/submodules/sts/index.js",
        import: "./dist-es/submodules/sts/index.js",
        require: "./dist-cjs/submodules/sts/index.js"
      }
    }
  };
});

// node_modules/@aws-sdk/util-user-agent-node/dist-cjs/index.js
var require_dist_cjs41 = __commonJS((exports) => {
  var os = __require("os");
  var process2 = __require("process");
  var middlewareUserAgent = require_dist_cjs31();
  var crtAvailability = {
    isCrtAvailable: false
  };
  var isCrtAvailable = () => {
    if (crtAvailability.isCrtAvailable) {
      return ["md/crt-avail"];
    }
    return null;
  };
  var createDefaultUserAgentProvider = ({ serviceId, clientVersion }) => {
    return async (config) => {
      const sections = [
        ["aws-sdk-js", clientVersion],
        ["ua", "2.1"],
        [`os/${os.platform()}`, os.release()],
        ["lang/js"],
        ["md/nodejs", `${process2.versions.node}`]
      ];
      const crtAvailable = isCrtAvailable();
      if (crtAvailable) {
        sections.push(crtAvailable);
      }
      if (serviceId) {
        sections.push([`api/${serviceId}`, clientVersion]);
      }
      if (process2.env.AWS_EXECUTION_ENV) {
        sections.push([`exec-env/${process2.env.AWS_EXECUTION_ENV}`]);
      }
      const appId = await config?.userAgentAppId?.();
      const resolvedUserAgent = appId ? [...sections, [`app/${appId}`]] : [...sections];
      return resolvedUserAgent;
    };
  };
  var defaultUserAgent = createDefaultUserAgentProvider;
  var UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID";
  var UA_APP_ID_INI_NAME = "sdk_ua_app_id";
  var UA_APP_ID_INI_NAME_DEPRECATED = "sdk-ua-app-id";
  var NODE_APP_ID_CONFIG_OPTIONS = {
    environmentVariableSelector: (env3) => env3[UA_APP_ID_ENV_NAME],
    configFileSelector: (profile) => profile[UA_APP_ID_INI_NAME] ?? profile[UA_APP_ID_INI_NAME_DEPRECATED],
    default: middlewareUserAgent.DEFAULT_UA_APP_ID
  };
  exports.NODE_APP_ID_CONFIG_OPTIONS = NODE_APP_ID_CONFIG_OPTIONS;
  exports.UA_APP_ID_ENV_NAME = UA_APP_ID_ENV_NAME;
  exports.UA_APP_ID_INI_NAME = UA_APP_ID_INI_NAME;
  exports.createDefaultUserAgentProvider = createDefaultUserAgentProvider;
  exports.crtAvailability = crtAvailability;
  exports.defaultUserAgent = defaultUserAgent;
});

// node_modules/@smithy/hash-node/dist-cjs/index.js
var require_dist_cjs42 = __commonJS((exports) => {
  var utilBufferFrom = require_dist_cjs9();
  var utilUtf8 = require_dist_cjs10();
  var buffer = __require("buffer");
  var crypto2 = __require("crypto");

  class Hash2 {
    algorithmIdentifier;
    secret;
    hash;
    constructor(algorithmIdentifier, secret) {
      this.algorithmIdentifier = algorithmIdentifier;
      this.secret = secret;
      this.reset();
    }
    update(toHash, encoding) {
      this.hash.update(utilUtf8.toUint8Array(castSourceData(toHash, encoding)));
    }
    digest() {
      return Promise.resolve(this.hash.digest());
    }
    reset() {
      this.hash = this.secret ? crypto2.createHmac(this.algorithmIdentifier, castSourceData(this.secret)) : crypto2.createHash(this.algorithmIdentifier);
    }
  }
  function castSourceData(toCast, encoding) {
    if (buffer.Buffer.isBuffer(toCast)) {
      return toCast;
    }
    if (typeof toCast === "string") {
      return utilBufferFrom.fromString(toCast, encoding);
    }
    if (ArrayBuffer.isView(toCast)) {
      return utilBufferFrom.fromArrayBuffer(toCast.buffer, toCast.byteOffset, toCast.byteLength);
    }
    return utilBufferFrom.fromArrayBuffer(toCast);
  }
  exports.Hash = Hash2;
});

// node_modules/@smithy/util-body-length-node/dist-cjs/index.js
var require_dist_cjs43 = __commonJS((exports) => {
  var node_fs = __require("fs");
  var calculateBodyLength = (body) => {
    if (!body) {
      return 0;
    }
    if (typeof body === "string") {
      return Buffer.byteLength(body);
    } else if (typeof body.byteLength === "number") {
      return body.byteLength;
    } else if (typeof body.size === "number") {
      return body.size;
    } else if (typeof body.start === "number" && typeof body.end === "number") {
      return body.end + 1 - body.start;
    } else if (body instanceof node_fs.ReadStream) {
      if (body.path != null) {
        return node_fs.lstatSync(body.path).size;
      } else if (typeof body.fd === "number") {
        return node_fs.fstatSync(body.fd).size;
      }
    }
    throw new Error(`Body Length computation failed for ${body}`);
  };
  exports.calculateBodyLength = calculateBodyLength;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso-oidc/endpoint/ruleset.js
var require_ruleset = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ruleSet = undefined;
  var u = "required";
  var v = "fn";
  var w = "argv";
  var x2 = "ref";
  var a = true;
  var b = "isSet";
  var c = "booleanEquals";
  var d = "error";
  var e = "endpoint";
  var f = "tree";
  var g = "PartitionResult";
  var h = "getAttr";
  var i2 = { [u]: false, type: "String" };
  var j = { [u]: true, default: false, type: "Boolean" };
  var k2 = { [x2]: "Endpoint" };
  var l = { [v]: c, [w]: [{ [x2]: "UseFIPS" }, true] };
  var m = { [v]: c, [w]: [{ [x2]: "UseDualStack" }, true] };
  var n = {};
  var o = { [v]: h, [w]: [{ [x2]: g }, "supportsFIPS"] };
  var p = { [x2]: g };
  var q = { [v]: c, [w]: [true, { [v]: h, [w]: [p, "supportsDualStack"] }] };
  var r = [l];
  var s = [m];
  var t2 = [{ [x2]: "Region" }];
  var _data = { version: "1.0", parameters: { Region: i2, UseDualStack: j, UseFIPS: j, Endpoint: i2 }, rules: [{ conditions: [{ [v]: b, [w]: [k2] }], rules: [{ conditions: r, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d }, { conditions: s, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d }, { endpoint: { url: k2, properties: n, headers: n }, type: e }], type: f }, { conditions: [{ [v]: b, [w]: t2 }], rules: [{ conditions: [{ [v]: "aws.partition", [w]: t2, assign: g }], rules: [{ conditions: [l, m], rules: [{ conditions: [{ [v]: c, [w]: [a, o] }, q], rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }], type: f }, { conditions: r, rules: [{ conditions: [{ [v]: c, [w]: [o, a] }], rules: [{ conditions: [{ [v]: "stringEquals", [w]: [{ [v]: h, [w]: [p, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://oidc.{Region}.amazonaws.com", properties: n, headers: n }, type: e }, { endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS is enabled but this partition does not support FIPS", type: d }], type: f }, { conditions: s, rules: [{ conditions: [q], rules: [{ endpoint: { url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "DualStack is enabled but this partition does not support DualStack", type: d }], type: f }, { endpoint: { url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }], type: f }, { error: "Invalid Configuration: Missing Region", type: d }] };
  exports.ruleSet = _data;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso-oidc/endpoint/endpointResolver.js
var require_endpointResolver = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultEndpointResolver = undefined;
  var util_endpoints_1 = require_dist_cjs23();
  var util_endpoints_2 = require_dist_cjs20();
  var ruleset_1 = require_ruleset();
  var cache = new util_endpoints_2.EndpointCache({
    size: 50,
    params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
  });
  var defaultEndpointResolver = (endpointParams, context = {}) => {
    return cache.get(endpointParams, () => (0, util_endpoints_2.resolveEndpoint)(ruleset_1.ruleSet, {
      endpointParams,
      logger: context.logger
    }));
  };
  exports.defaultEndpointResolver = defaultEndpointResolver;
  util_endpoints_2.customEndpointFunctions.aws = util_endpoints_1.awsEndpointFunctions;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso-oidc/runtimeConfig.shared.js
var require_runtimeConfig_shared = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var core_1 = require_dist_cjs30();
  var core_2 = require_dist_cjs19();
  var smithy_client_1 = require_dist_cjs28();
  var url_parser_1 = require_dist_cjs22();
  var util_base64_1 = require_dist_cjs11();
  var util_utf8_1 = require_dist_cjs10();
  var httpAuthSchemeProvider_1 = require_httpAuthSchemeProvider();
  var endpointResolver_1 = require_endpointResolver();
  var getRuntimeConfig = (config) => {
    return {
      apiVersion: "2019-06-10",
      base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
      base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
      disableHostPrefix: config?.disableHostPrefix ?? false,
      endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
      extensions: config?.extensions ?? [],
      httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? httpAuthSchemeProvider_1.defaultSSOOIDCHttpAuthSchemeProvider,
      httpAuthSchemes: config?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
          signer: new core_1.AwsSdkSigV4Signer
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new core_2.NoAuthSigner
        }
      ],
      logger: config?.logger ?? new smithy_client_1.NoOpLogger,
      serviceId: config?.serviceId ?? "SSO OIDC",
      urlParser: config?.urlParser ?? url_parser_1.parseUrl,
      utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
      utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig;
});

// node_modules/@smithy/util-defaults-mode-node/dist-cjs/index.js
var require_dist_cjs44 = __commonJS((exports) => {
  var configResolver = require_dist_cjs33();
  var nodeConfigProvider = require_dist_cjs36();
  var propertyProvider = require_dist_cjs24();
  var AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV";
  var AWS_REGION_ENV = "AWS_REGION";
  var AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION";
  var ENV_IMDS_DISABLED2 = "AWS_EC2_METADATA_DISABLED";
  var DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
  var IMDS_REGION_PATH = "/latest/meta-data/placement/region";
  var AWS_DEFAULTS_MODE_ENV = "AWS_DEFAULTS_MODE";
  var AWS_DEFAULTS_MODE_CONFIG = "defaults_mode";
  var NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env3) => {
      return env3[AWS_DEFAULTS_MODE_ENV];
    },
    configFileSelector: (profile) => {
      return profile[AWS_DEFAULTS_MODE_CONFIG];
    },
    default: "legacy"
  };
  var resolveDefaultsModeConfig = ({ region = nodeConfigProvider.loadConfig(configResolver.NODE_REGION_CONFIG_OPTIONS), defaultsMode = nodeConfigProvider.loadConfig(NODE_DEFAULTS_MODE_CONFIG_OPTIONS) } = {}) => propertyProvider.memoize(async () => {
    const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
    switch (mode?.toLowerCase()) {
      case "auto":
        return resolveNodeDefaultsModeAuto(region);
      case "in-region":
      case "cross-region":
      case "mobile":
      case "standard":
      case "legacy":
        return Promise.resolve(mode?.toLocaleLowerCase());
      case undefined:
        return Promise.resolve("legacy");
      default:
        throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
    }
  });
  var resolveNodeDefaultsModeAuto = async (clientRegion) => {
    if (clientRegion) {
      const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
      const inferredRegion = await inferPhysicalRegion();
      if (!inferredRegion) {
        return "standard";
      }
      if (resolvedRegion === inferredRegion) {
        return "in-region";
      } else {
        return "cross-region";
      }
    }
    return "standard";
  };
  var inferPhysicalRegion = async () => {
    if (process.env[AWS_EXECUTION_ENV] && (process.env[AWS_REGION_ENV] || process.env[AWS_DEFAULT_REGION_ENV])) {
      return process.env[AWS_REGION_ENV] ?? process.env[AWS_DEFAULT_REGION_ENV];
    }
    if (!process.env[ENV_IMDS_DISABLED2]) {
      try {
        const { getInstanceMetadataEndpoint: getInstanceMetadataEndpoint2, httpRequest: httpRequest2 } = await Promise.resolve().then(() => (init_dist_es4(), exports_dist_es2));
        const endpoint = await getInstanceMetadataEndpoint2();
        return (await httpRequest2({ ...endpoint, path: IMDS_REGION_PATH })).toString();
      } catch (e) {}
    }
  };
  exports.resolveDefaultsModeConfig = resolveDefaultsModeConfig;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso-oidc/runtimeConfig.js
var require_runtimeConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var tslib_1 = require_tslib();
  var package_json_1 = tslib_1.__importDefault(require_package());
  var core_1 = require_dist_cjs30();
  var util_user_agent_node_1 = require_dist_cjs41();
  var config_resolver_1 = require_dist_cjs33();
  var hash_node_1 = require_dist_cjs42();
  var middleware_retry_1 = require_dist_cjs40();
  var node_config_provider_1 = require_dist_cjs36();
  var node_http_handler_1 = require_dist_cjs14();
  var util_body_length_node_1 = require_dist_cjs43();
  var util_retry_1 = require_dist_cjs39();
  var runtimeConfig_shared_1 = require_runtimeConfig_shared();
  var smithy_client_1 = require_dist_cjs28();
  var util_defaults_mode_node_1 = require_dist_cjs44();
  var smithy_client_2 = require_dist_cjs28();
  var getRuntimeConfig = (config) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    (0, core_1.emitWarningIfUnsupportedVersion)(process.version);
    const loaderConfig = {
      profile: config?.profile,
      logger: clientSharedValues.logger
    };
    return {
      ...clientSharedValues,
      ...config,
      runtime: "node",
      defaultsMode,
      authSchemePreference: config?.authSchemePreference ?? (0, node_config_provider_1.loadConfig)(core_1.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
      bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
      defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, util_user_agent_node_1.createDefaultUserAgentProvider)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
      maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
      region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, { ...config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS, ...loaderConfig }),
      requestHandler: node_http_handler_1.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
      retryMode: config?.retryMode ?? (0, node_config_provider_1.loadConfig)({
        ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
        default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
      }, config),
      sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
      streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
      useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
      useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
      userAgentAppId: config?.userAgentAppId ?? (0, node_config_provider_1.loadConfig)(util_user_agent_node_1.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig;
});

// node_modules/@aws-sdk/region-config-resolver/dist-cjs/index.js
var require_dist_cjs45 = __commonJS((exports) => {
  var configResolver = require_dist_cjs33();
  var getAwsRegionExtensionConfiguration = (runtimeConfig) => {
    return {
      setRegion(region) {
        runtimeConfig.region = region;
      },
      region() {
        return runtimeConfig.region;
      }
    };
  };
  var resolveAwsRegionExtensionConfiguration = (awsRegionExtensionConfiguration) => {
    return {
      region: awsRegionExtensionConfiguration.region()
    };
  };
  Object.defineProperty(exports, "NODE_REGION_CONFIG_FILE_OPTIONS", {
    enumerable: true,
    get: function() {
      return configResolver.NODE_REGION_CONFIG_FILE_OPTIONS;
    }
  });
  Object.defineProperty(exports, "NODE_REGION_CONFIG_OPTIONS", {
    enumerable: true,
    get: function() {
      return configResolver.NODE_REGION_CONFIG_OPTIONS;
    }
  });
  Object.defineProperty(exports, "REGION_ENV_NAME", {
    enumerable: true,
    get: function() {
      return configResolver.REGION_ENV_NAME;
    }
  });
  Object.defineProperty(exports, "REGION_INI_NAME", {
    enumerable: true,
    get: function() {
      return configResolver.REGION_INI_NAME;
    }
  });
  Object.defineProperty(exports, "resolveRegionConfig", {
    enumerable: true,
    get: function() {
      return configResolver.resolveRegionConfig;
    }
  });
  exports.getAwsRegionExtensionConfiguration = getAwsRegionExtensionConfiguration;
  exports.resolveAwsRegionExtensionConfiguration = resolveAwsRegionExtensionConfiguration;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sso-oidc/index.js
var require_sso_oidc = __commonJS((exports) => {
  var middlewareHostHeader = require_dist_cjs4();
  var middlewareLogger = require_dist_cjs5();
  var middlewareRecursionDetection = require_dist_cjs6();
  var middlewareUserAgent = require_dist_cjs31();
  var configResolver = require_dist_cjs33();
  var core2 = require_dist_cjs19();
  var middlewareContentLength = require_dist_cjs34();
  var middlewareEndpoint = require_dist_cjs37();
  var middlewareRetry = require_dist_cjs40();
  var smithyClient = require_dist_cjs28();
  var httpAuthSchemeProvider = require_httpAuthSchemeProvider();
  var runtimeConfig = require_runtimeConfig();
  var regionConfigResolver = require_dist_cjs45();
  var protocolHttp = require_dist_cjs3();
  var middlewareSerde = require_dist_cjs7();
  var core$1 = require_dist_cjs30();
  var resolveClientEndpointParameters2 = (options) => {
    return Object.assign(options, {
      useDualstackEndpoint: options.useDualstackEndpoint ?? false,
      useFipsEndpoint: options.useFipsEndpoint ?? false,
      defaultSigningName: "sso-oauth"
    });
  };
  var commonParams2 = {
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
  };
  var getHttpAuthExtensionConfiguration = (runtimeConfig2) => {
    const _httpAuthSchemes = runtimeConfig2.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig2.httpAuthSchemeProvider;
    let _credentials = runtimeConfig2.credentials;
    return {
      setHttpAuthScheme(httpAuthScheme) {
        const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
        if (index === -1) {
          _httpAuthSchemes.push(httpAuthScheme);
        } else {
          _httpAuthSchemes.splice(index, 1, httpAuthScheme);
        }
      },
      httpAuthSchemes() {
        return _httpAuthSchemes;
      },
      setHttpAuthSchemeProvider(httpAuthSchemeProvider2) {
        _httpAuthSchemeProvider = httpAuthSchemeProvider2;
      },
      httpAuthSchemeProvider() {
        return _httpAuthSchemeProvider;
      },
      setCredentials(credentials) {
        _credentials = credentials;
      },
      credentials() {
        return _credentials;
      }
    };
  };
  var resolveHttpAuthRuntimeConfig = (config) => {
    return {
      httpAuthSchemes: config.httpAuthSchemes(),
      httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
      credentials: config.credentials()
    };
  };
  var resolveRuntimeExtensions = (runtimeConfig2, extensions2) => {
    const extensionConfiguration = Object.assign(regionConfigResolver.getAwsRegionExtensionConfiguration(runtimeConfig2), smithyClient.getDefaultExtensionConfiguration(runtimeConfig2), protocolHttp.getHttpHandlerExtensionConfiguration(runtimeConfig2), getHttpAuthExtensionConfiguration(runtimeConfig2));
    extensions2.forEach((extension) => extension.configure(extensionConfiguration));
    return Object.assign(runtimeConfig2, regionConfigResolver.resolveAwsRegionExtensionConfiguration(extensionConfiguration), smithyClient.resolveDefaultRuntimeConfig(extensionConfiguration), protocolHttp.resolveHttpHandlerRuntimeConfig(extensionConfiguration), resolveHttpAuthRuntimeConfig(extensionConfiguration));
  };

  class SSOOIDCClient extends smithyClient.Client {
    config;
    constructor(...[configuration]) {
      const _config_0 = runtimeConfig.getRuntimeConfig(configuration || {});
      super(_config_0);
      this.initConfig = _config_0;
      const _config_1 = resolveClientEndpointParameters2(_config_0);
      const _config_2 = middlewareUserAgent.resolveUserAgentConfig(_config_1);
      const _config_3 = middlewareRetry.resolveRetryConfig(_config_2);
      const _config_4 = configResolver.resolveRegionConfig(_config_3);
      const _config_5 = middlewareHostHeader.resolveHostHeaderConfig(_config_4);
      const _config_6 = middlewareEndpoint.resolveEndpointConfig(_config_5);
      const _config_7 = httpAuthSchemeProvider.resolveHttpAuthSchemeConfig(_config_6);
      const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);
      this.config = _config_8;
      this.middlewareStack.use(middlewareUserAgent.getUserAgentPlugin(this.config));
      this.middlewareStack.use(middlewareRetry.getRetryPlugin(this.config));
      this.middlewareStack.use(middlewareContentLength.getContentLengthPlugin(this.config));
      this.middlewareStack.use(middlewareHostHeader.getHostHeaderPlugin(this.config));
      this.middlewareStack.use(middlewareLogger.getLoggerPlugin(this.config));
      this.middlewareStack.use(middlewareRecursionDetection.getRecursionDetectionPlugin(this.config));
      this.middlewareStack.use(core2.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
        httpAuthSchemeParametersProvider: httpAuthSchemeProvider.defaultSSOOIDCHttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (config) => new core2.DefaultIdentityProviderConfig({
          "aws.auth#sigv4": config.credentials
        })
      }));
      this.middlewareStack.use(core2.getHttpSigningPlugin(this.config));
    }
    destroy() {
      super.destroy();
    }
  }

  class SSOOIDCServiceException extends smithyClient.ServiceException {
    constructor(options) {
      super(options);
      Object.setPrototypeOf(this, SSOOIDCServiceException.prototype);
    }
  }
  var AccessDeniedExceptionReason = {
    KMS_ACCESS_DENIED: "KMS_AccessDeniedException"
  };

  class AccessDeniedException extends SSOOIDCServiceException {
    name = "AccessDeniedException";
    $fault = "client";
    error;
    reason;
    error_description;
    constructor(opts) {
      super({
        name: "AccessDeniedException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, AccessDeniedException.prototype);
      this.error = opts.error;
      this.reason = opts.reason;
      this.error_description = opts.error_description;
    }
  }

  class AuthorizationPendingException extends SSOOIDCServiceException {
    name = "AuthorizationPendingException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "AuthorizationPendingException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, AuthorizationPendingException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  }
  var CreateTokenRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.clientSecret && { clientSecret: smithyClient.SENSITIVE_STRING },
    ...obj.refreshToken && { refreshToken: smithyClient.SENSITIVE_STRING },
    ...obj.codeVerifier && { codeVerifier: smithyClient.SENSITIVE_STRING }
  });
  var CreateTokenResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.accessToken && { accessToken: smithyClient.SENSITIVE_STRING },
    ...obj.refreshToken && { refreshToken: smithyClient.SENSITIVE_STRING },
    ...obj.idToken && { idToken: smithyClient.SENSITIVE_STRING }
  });

  class ExpiredTokenException extends SSOOIDCServiceException {
    name = "ExpiredTokenException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "ExpiredTokenException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ExpiredTokenException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  }

  class InternalServerException extends SSOOIDCServiceException {
    name = "InternalServerException";
    $fault = "server";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "InternalServerException",
        $fault: "server",
        ...opts
      });
      Object.setPrototypeOf(this, InternalServerException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  }

  class InvalidClientException extends SSOOIDCServiceException {
    name = "InvalidClientException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "InvalidClientException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, InvalidClientException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  }

  class InvalidGrantException extends SSOOIDCServiceException {
    name = "InvalidGrantException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "InvalidGrantException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, InvalidGrantException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  }
  var InvalidRequestExceptionReason = {
    KMS_DISABLED_KEY: "KMS_DisabledException",
    KMS_INVALID_KEY_USAGE: "KMS_InvalidKeyUsageException",
    KMS_INVALID_STATE: "KMS_InvalidStateException",
    KMS_KEY_NOT_FOUND: "KMS_NotFoundException"
  };

  class InvalidRequestException extends SSOOIDCServiceException {
    name = "InvalidRequestException";
    $fault = "client";
    error;
    reason;
    error_description;
    constructor(opts) {
      super({
        name: "InvalidRequestException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, InvalidRequestException.prototype);
      this.error = opts.error;
      this.reason = opts.reason;
      this.error_description = opts.error_description;
    }
  }

  class InvalidScopeException extends SSOOIDCServiceException {
    name = "InvalidScopeException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "InvalidScopeException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, InvalidScopeException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  }

  class SlowDownException extends SSOOIDCServiceException {
    name = "SlowDownException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "SlowDownException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, SlowDownException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  }

  class UnauthorizedClientException extends SSOOIDCServiceException {
    name = "UnauthorizedClientException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "UnauthorizedClientException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, UnauthorizedClientException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  }

  class UnsupportedGrantTypeException extends SSOOIDCServiceException {
    name = "UnsupportedGrantTypeException";
    $fault = "client";
    error;
    error_description;
    constructor(opts) {
      super({
        name: "UnsupportedGrantTypeException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, UnsupportedGrantTypeException.prototype);
      this.error = opts.error;
      this.error_description = opts.error_description;
    }
  }
  var se_CreateTokenCommand = async (input, context) => {
    const b = core2.requestBuilder(input, context);
    const headers = {
      "content-type": "application/json"
    };
    b.bp("/token");
    let body;
    body = JSON.stringify(smithyClient.take(input, {
      clientId: [],
      clientSecret: [],
      code: [],
      codeVerifier: [],
      deviceCode: [],
      grantType: [],
      redirectUri: [],
      refreshToken: [],
      scope: (_2) => smithyClient._json(_2)
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
  };
  var de_CreateTokenCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
      return de_CommandError2(output, context);
    }
    const contents = smithyClient.map({
      $metadata: deserializeMetadata2(output)
    });
    const data = smithyClient.expectNonNull(smithyClient.expectObject(await core$1.parseJsonBody(output.body, context)), "body");
    const doc = smithyClient.take(data, {
      accessToken: smithyClient.expectString,
      expiresIn: smithyClient.expectInt32,
      idToken: smithyClient.expectString,
      refreshToken: smithyClient.expectString,
      tokenType: smithyClient.expectString
    });
    Object.assign(contents, doc);
    return contents;
  };
  var de_CommandError2 = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await core$1.parseJsonErrorBody(output.body, context)
    };
    const errorCode = core$1.loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "AccessDeniedException":
      case "com.amazonaws.ssooidc#AccessDeniedException":
        throw await de_AccessDeniedExceptionRes(parsedOutput);
      case "AuthorizationPendingException":
      case "com.amazonaws.ssooidc#AuthorizationPendingException":
        throw await de_AuthorizationPendingExceptionRes(parsedOutput);
      case "ExpiredTokenException":
      case "com.amazonaws.ssooidc#ExpiredTokenException":
        throw await de_ExpiredTokenExceptionRes(parsedOutput);
      case "InternalServerException":
      case "com.amazonaws.ssooidc#InternalServerException":
        throw await de_InternalServerExceptionRes(parsedOutput);
      case "InvalidClientException":
      case "com.amazonaws.ssooidc#InvalidClientException":
        throw await de_InvalidClientExceptionRes(parsedOutput);
      case "InvalidGrantException":
      case "com.amazonaws.ssooidc#InvalidGrantException":
        throw await de_InvalidGrantExceptionRes(parsedOutput);
      case "InvalidRequestException":
      case "com.amazonaws.ssooidc#InvalidRequestException":
        throw await de_InvalidRequestExceptionRes(parsedOutput);
      case "InvalidScopeException":
      case "com.amazonaws.ssooidc#InvalidScopeException":
        throw await de_InvalidScopeExceptionRes(parsedOutput);
      case "SlowDownException":
      case "com.amazonaws.ssooidc#SlowDownException":
        throw await de_SlowDownExceptionRes(parsedOutput);
      case "UnauthorizedClientException":
      case "com.amazonaws.ssooidc#UnauthorizedClientException":
        throw await de_UnauthorizedClientExceptionRes(parsedOutput);
      case "UnsupportedGrantTypeException":
      case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
        throw await de_UnsupportedGrantTypeExceptionRes(parsedOutput);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError2({
          output,
          parsedBody,
          errorCode
        });
    }
  };
  var throwDefaultError2 = smithyClient.withBaseException(SSOOIDCServiceException);
  var de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
      error: smithyClient.expectString,
      error_description: smithyClient.expectString,
      reason: smithyClient.expectString
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
  };
  var de_AuthorizationPendingExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
      error: smithyClient.expectString,
      error_description: smithyClient.expectString
    });
    Object.assign(contents, doc);
    const exception = new AuthorizationPendingException({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
  };
  var de_ExpiredTokenExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
      error: smithyClient.expectString,
      error_description: smithyClient.expectString
    });
    Object.assign(contents, doc);
    const exception = new ExpiredTokenException({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
  };
  var de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
      error: smithyClient.expectString,
      error_description: smithyClient.expectString
    });
    Object.assign(contents, doc);
    const exception = new InternalServerException({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
  };
  var de_InvalidClientExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
      error: smithyClient.expectString,
      error_description: smithyClient.expectString
    });
    Object.assign(contents, doc);
    const exception = new InvalidClientException({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
  };
  var de_InvalidGrantExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
      error: smithyClient.expectString,
      error_description: smithyClient.expectString
    });
    Object.assign(contents, doc);
    const exception = new InvalidGrantException({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
  };
  var de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
      error: smithyClient.expectString,
      error_description: smithyClient.expectString,
      reason: smithyClient.expectString
    });
    Object.assign(contents, doc);
    const exception = new InvalidRequestException({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
  };
  var de_InvalidScopeExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
      error: smithyClient.expectString,
      error_description: smithyClient.expectString
    });
    Object.assign(contents, doc);
    const exception = new InvalidScopeException({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
  };
  var de_SlowDownExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
      error: smithyClient.expectString,
      error_description: smithyClient.expectString
    });
    Object.assign(contents, doc);
    const exception = new SlowDownException({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
  };
  var de_UnauthorizedClientExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
      error: smithyClient.expectString,
      error_description: smithyClient.expectString
    });
    Object.assign(contents, doc);
    const exception = new UnauthorizedClientException({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
  };
  var de_UnsupportedGrantTypeExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
      error: smithyClient.expectString,
      error_description: smithyClient.expectString
    });
    Object.assign(contents, doc);
    const exception = new UnsupportedGrantTypeException({
      $metadata: deserializeMetadata2(parsedOutput),
      ...contents
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
  };
  var deserializeMetadata2 = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"]
  });

  class CreateTokenCommand extends smithyClient.Command.classBuilder().ep(commonParams2).m(function(Command, cs, config, o) {
    return [
      middlewareSerde.getSerdePlugin(config, this.serialize, this.deserialize),
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("AWSSSOOIDCService", "CreateToken", {}).n("SSOOIDCClient", "CreateTokenCommand").f(CreateTokenRequestFilterSensitiveLog, CreateTokenResponseFilterSensitiveLog).ser(se_CreateTokenCommand).de(de_CreateTokenCommand).build() {
  }
  var commands = {
    CreateTokenCommand
  };

  class SSOOIDC extends SSOOIDCClient {
  }
  smithyClient.createAggregatedClient(commands, SSOOIDC);
  Object.defineProperty(exports, "$Command", {
    enumerable: true,
    get: function() {
      return smithyClient.Command;
    }
  });
  Object.defineProperty(exports, "__Client", {
    enumerable: true,
    get: function() {
      return smithyClient.Client;
    }
  });
  exports.AccessDeniedException = AccessDeniedException;
  exports.AccessDeniedExceptionReason = AccessDeniedExceptionReason;
  exports.AuthorizationPendingException = AuthorizationPendingException;
  exports.CreateTokenCommand = CreateTokenCommand;
  exports.CreateTokenRequestFilterSensitiveLog = CreateTokenRequestFilterSensitiveLog;
  exports.CreateTokenResponseFilterSensitiveLog = CreateTokenResponseFilterSensitiveLog;
  exports.ExpiredTokenException = ExpiredTokenException;
  exports.InternalServerException = InternalServerException;
  exports.InvalidClientException = InvalidClientException;
  exports.InvalidGrantException = InvalidGrantException;
  exports.InvalidRequestException = InvalidRequestException;
  exports.InvalidRequestExceptionReason = InvalidRequestExceptionReason;
  exports.InvalidScopeException = InvalidScopeException;
  exports.SSOOIDC = SSOOIDC;
  exports.SSOOIDCClient = SSOOIDCClient;
  exports.SSOOIDCServiceException = SSOOIDCServiceException;
  exports.SlowDownException = SlowDownException;
  exports.UnauthorizedClientException = UnauthorizedClientException;
  exports.UnsupportedGrantTypeException = UnsupportedGrantTypeException;
});

// node_modules/@aws-sdk/token-providers/dist-es/getSsoOidcClient.js
var getSsoOidcClient = async (ssoRegion, init = {}) => {
  const { SSOOIDCClient } = await Promise.resolve().then(() => __toESM(require_sso_oidc(), 1));
  const ssoOidcClient = new SSOOIDCClient(Object.assign({}, init.clientConfig ?? {}, {
    region: ssoRegion ?? init.clientConfig?.region,
    logger: init.clientConfig?.logger ?? init.parentClientConfig?.logger
  }));
  return ssoOidcClient;
};

// node_modules/@aws-sdk/token-providers/dist-es/getNewSsoOidcToken.js
var getNewSsoOidcToken = async (ssoToken, ssoRegion, init = {}) => {
  const { CreateTokenCommand } = await Promise.resolve().then(() => __toESM(require_sso_oidc(), 1));
  const ssoOidcClient = await getSsoOidcClient(ssoRegion, init);
  return ssoOidcClient.send(new CreateTokenCommand({
    clientId: ssoToken.clientId,
    clientSecret: ssoToken.clientSecret,
    refreshToken: ssoToken.refreshToken,
    grantType: "refresh_token"
  }));
};
var init_getNewSsoOidcToken = () => {};

// node_modules/@aws-sdk/token-providers/dist-es/validateTokenExpiry.js
var import_property_provider10, validateTokenExpiry = (token) => {
  if (token.expiration && token.expiration.getTime() < Date.now()) {
    throw new import_property_provider10.TokenProviderError(`Token is expired. ${REFRESH_MESSAGE}`, false);
  }
};
var init_validateTokenExpiry = __esm(() => {
  init_constants();
  import_property_provider10 = __toESM(require_dist_cjs24(), 1);
});

// node_modules/@aws-sdk/token-providers/dist-es/validateTokenKey.js
var import_property_provider11, validateTokenKey = (key, value, forRefresh = false) => {
  if (typeof value === "undefined") {
    throw new import_property_provider11.TokenProviderError(`Value not present for '${key}' in SSO Token${forRefresh ? ". Cannot refresh" : ""}. ${REFRESH_MESSAGE}`, false);
  }
};
var init_validateTokenKey = __esm(() => {
  init_constants();
  import_property_provider11 = __toESM(require_dist_cjs24(), 1);
});

// node_modules/@aws-sdk/token-providers/dist-es/writeSSOTokenToFile.js
import { promises as fsPromises } from "fs";
var import_shared_ini_file_loader, writeFile, writeSSOTokenToFile = (id, ssoToken) => {
  const tokenFilepath = import_shared_ini_file_loader.getSSOTokenFilepath(id);
  const tokenString = JSON.stringify(ssoToken, null, 2);
  return writeFile(tokenFilepath, tokenString);
};
var init_writeSSOTokenToFile = __esm(() => {
  import_shared_ini_file_loader = __toESM(require_dist_cjs35(), 1);
  ({ writeFile } = fsPromises);
});

// node_modules/@aws-sdk/token-providers/dist-es/fromSso.js
var import_property_provider12, import_shared_ini_file_loader2, lastRefreshAttemptTime, fromSso = (_init = {}) => async ({ callerClientConfig } = {}) => {
  const init = {
    ..._init,
    parentClientConfig: {
      ...callerClientConfig,
      ..._init.parentClientConfig
    }
  };
  init.logger?.debug("@aws-sdk/token-providers - fromSso");
  const profiles = await import_shared_ini_file_loader2.parseKnownFiles(init);
  const profileName = import_shared_ini_file_loader2.getProfileName({
    profile: init.profile ?? callerClientConfig?.profile
  });
  const profile = profiles[profileName];
  if (!profile) {
    throw new import_property_provider12.TokenProviderError(`Profile '${profileName}' could not be found in shared credentials file.`, false);
  } else if (!profile["sso_session"]) {
    throw new import_property_provider12.TokenProviderError(`Profile '${profileName}' is missing required property 'sso_session'.`);
  }
  const ssoSessionName = profile["sso_session"];
  const ssoSessions = await import_shared_ini_file_loader2.loadSsoSessionData(init);
  const ssoSession = ssoSessions[ssoSessionName];
  if (!ssoSession) {
    throw new import_property_provider12.TokenProviderError(`Sso session '${ssoSessionName}' could not be found in shared credentials file.`, false);
  }
  for (const ssoSessionRequiredKey of ["sso_start_url", "sso_region"]) {
    if (!ssoSession[ssoSessionRequiredKey]) {
      throw new import_property_provider12.TokenProviderError(`Sso session '${ssoSessionName}' is missing required property '${ssoSessionRequiredKey}'.`, false);
    }
  }
  const ssoStartUrl = ssoSession["sso_start_url"];
  const ssoRegion = ssoSession["sso_region"];
  let ssoToken;
  try {
    ssoToken = await import_shared_ini_file_loader2.getSSOTokenFromFile(ssoSessionName);
  } catch (e) {
    throw new import_property_provider12.TokenProviderError(`The SSO session token associated with profile=${profileName} was not found or is invalid. ${REFRESH_MESSAGE}`, false);
  }
  validateTokenKey("accessToken", ssoToken.accessToken);
  validateTokenKey("expiresAt", ssoToken.expiresAt);
  const { accessToken, expiresAt } = ssoToken;
  const existingToken = { token: accessToken, expiration: new Date(expiresAt) };
  if (existingToken.expiration.getTime() - Date.now() > EXPIRE_WINDOW_MS) {
    return existingToken;
  }
  if (Date.now() - lastRefreshAttemptTime.getTime() < 30 * 1000) {
    validateTokenExpiry(existingToken);
    return existingToken;
  }
  validateTokenKey("clientId", ssoToken.clientId, true);
  validateTokenKey("clientSecret", ssoToken.clientSecret, true);
  validateTokenKey("refreshToken", ssoToken.refreshToken, true);
  try {
    lastRefreshAttemptTime.setTime(Date.now());
    const newSsoOidcToken = await getNewSsoOidcToken(ssoToken, ssoRegion, init);
    validateTokenKey("accessToken", newSsoOidcToken.accessToken);
    validateTokenKey("expiresIn", newSsoOidcToken.expiresIn);
    const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1000);
    try {
      await writeSSOTokenToFile(ssoSessionName, {
        ...ssoToken,
        accessToken: newSsoOidcToken.accessToken,
        expiresAt: newTokenExpiration.toISOString(),
        refreshToken: newSsoOidcToken.refreshToken
      });
    } catch (error) {}
    return {
      token: newSsoOidcToken.accessToken,
      expiration: newTokenExpiration
    };
  } catch (error) {
    validateTokenExpiry(existingToken);
    return existingToken;
  }
};
var init_fromSso = __esm(() => {
  init_constants();
  init_getNewSsoOidcToken();
  init_validateTokenExpiry();
  init_validateTokenKey();
  init_writeSSOTokenToFile();
  import_property_provider12 = __toESM(require_dist_cjs24(), 1);
  import_shared_ini_file_loader2 = __toESM(require_dist_cjs35(), 1);
  lastRefreshAttemptTime = new Date(0);
});

// node_modules/@aws-sdk/token-providers/dist-es/fromStatic.js
var init_fromStatic = () => {};

// node_modules/@aws-sdk/token-providers/dist-es/nodeProvider.js
var init_nodeProvider = () => {};

// node_modules/@aws-sdk/token-providers/dist-es/index.js
var init_dist_es6 = __esm(() => {
  init_fromEnvSigningName();
  init_fromSso();
  init_fromStatic();
  init_nodeProvider();
});

// node_modules/@aws-sdk/client-sso/dist-es/auth/httpAuthSchemeProvider.js
function createAwsAuthSigv4HttpAuthOption2(authParameters) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "awsssoportal",
      region: authParameters.region
    },
    propertiesExtractor: (config, context) => ({
      signingProperties: {
        config,
        context
      }
    })
  };
}
function createSmithyApiNoAuthHttpAuthOption(authParameters) {
  return {
    schemeId: "smithy.api#noAuth"
  };
}
var import_core6, import_util_middleware2, defaultSSOHttpAuthSchemeParametersProvider = async (config, context, input) => {
  return {
    operation: import_util_middleware2.getSmithyContext(context).operation,
    region: await import_util_middleware2.normalizeProvider(config.region)() || (() => {
      throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
    })()
  };
}, defaultSSOHttpAuthSchemeProvider = (authParameters) => {
  const options = [];
  switch (authParameters.operation) {
    case "GetRoleCredentials": {
      options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
      break;
    }
    case "ListAccountRoles": {
      options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
      break;
    }
    case "ListAccounts": {
      options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
      break;
    }
    case "Logout": {
      options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
      break;
    }
    default: {
      options.push(createAwsAuthSigv4HttpAuthOption2(authParameters));
    }
  }
  return options;
}, resolveHttpAuthSchemeConfig2 = (config) => {
  const config_0 = import_core6.resolveAwsSdkSigV4Config(config);
  return Object.assign(config_0, {
    authSchemePreference: import_util_middleware2.normalizeProvider(config.authSchemePreference ?? [])
  });
};
var init_httpAuthSchemeProvider2 = __esm(() => {
  import_core6 = __toESM(require_dist_cjs30(), 1);
  import_util_middleware2 = __toESM(require_dist_cjs2(), 1);
});

// node_modules/@aws-sdk/client-sso/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters2 = (options) => {
  return Object.assign(options, {
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "awsssoportal"
  });
}, commonParams2;
var init_EndpointParameters2 = __esm(() => {
  commonParams2 = {
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
  };
});

// node_modules/@aws-sdk/client-sso/package.json
var package_default2;
var init_package2 = __esm(() => {
  package_default2 = {
    name: "@aws-sdk/client-sso",
    description: "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
    version: "3.914.0",
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      "build:cjs": "node ../../scripts/compilation/inline client-sso",
      "build:es": "tsc -p tsconfig.es.json",
      "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
      "build:types": "tsc -p tsconfig.types.json",
      "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
      clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
      "extract:docs": "api-extractor run --local",
      "generate:client": "node ../../scripts/generate-clients/single-service --solo sso"
    },
    main: "./dist-cjs/index.js",
    types: "./dist-types/index.d.ts",
    module: "./dist-es/index.js",
    sideEffects: false,
    dependencies: {
      "@aws-crypto/sha256-browser": "5.2.0",
      "@aws-crypto/sha256-js": "5.2.0",
      "@aws-sdk/core": "3.914.0",
      "@aws-sdk/middleware-host-header": "3.914.0",
      "@aws-sdk/middleware-logger": "3.914.0",
      "@aws-sdk/middleware-recursion-detection": "3.914.0",
      "@aws-sdk/middleware-user-agent": "3.914.0",
      "@aws-sdk/region-config-resolver": "3.914.0",
      "@aws-sdk/types": "3.914.0",
      "@aws-sdk/util-endpoints": "3.914.0",
      "@aws-sdk/util-user-agent-browser": "3.914.0",
      "@aws-sdk/util-user-agent-node": "3.914.0",
      "@smithy/config-resolver": "^4.4.0",
      "@smithy/core": "^3.17.0",
      "@smithy/fetch-http-handler": "^5.3.4",
      "@smithy/hash-node": "^4.2.3",
      "@smithy/invalid-dependency": "^4.2.3",
      "@smithy/middleware-content-length": "^4.2.3",
      "@smithy/middleware-endpoint": "^4.3.4",
      "@smithy/middleware-retry": "^4.4.4",
      "@smithy/middleware-serde": "^4.2.3",
      "@smithy/middleware-stack": "^4.2.3",
      "@smithy/node-config-provider": "^4.3.3",
      "@smithy/node-http-handler": "^4.4.2",
      "@smithy/protocol-http": "^5.3.3",
      "@smithy/smithy-client": "^4.9.0",
      "@smithy/types": "^4.8.0",
      "@smithy/url-parser": "^4.2.3",
      "@smithy/util-base64": "^4.3.0",
      "@smithy/util-body-length-browser": "^4.2.0",
      "@smithy/util-body-length-node": "^4.2.1",
      "@smithy/util-defaults-mode-browser": "^4.3.3",
      "@smithy/util-defaults-mode-node": "^4.2.5",
      "@smithy/util-endpoints": "^3.2.3",
      "@smithy/util-middleware": "^4.2.3",
      "@smithy/util-retry": "^4.2.3",
      "@smithy/util-utf8": "^4.2.0",
      tslib: "^2.6.2"
    },
    devDependencies: {
      "@tsconfig/node18": "18.2.4",
      "@types/node": "^18.19.69",
      concurrently: "7.0.0",
      "downlevel-dts": "0.10.1",
      rimraf: "3.0.2",
      typescript: "~5.8.3"
    },
    engines: {
      node: ">=18.0.0"
    },
    typesVersions: {
      "<4.0": {
        "dist-types/*": [
          "dist-types/ts3.4/*"
        ]
      }
    },
    files: [
      "dist-*/**"
    ],
    author: {
      name: "AWS SDK for JavaScript Team",
      url: "https://aws.amazon.com/javascript/"
    },
    license: "Apache-2.0",
    browser: {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
    },
    "react-native": {
      "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
    },
    homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
    repository: {
      type: "git",
      url: "https://github.com/aws/aws-sdk-js-v3.git",
      directory: "clients/client-sso"
    }
  };
});

// node_modules/@aws-sdk/client-sso/dist-es/endpoint/ruleset.js
var u = "required", v = "fn", w = "argv", x2 = "ref", a = true, b = "isSet", c = "booleanEquals", d = "error", e = "endpoint", f = "tree", g = "PartitionResult", h = "getAttr", i2, j, k2, l, m, n, o, p, q, r, s, t2, _data, ruleSet;
var init_ruleset = __esm(() => {
  i2 = { [u]: false, type: "String" };
  j = { [u]: true, default: false, type: "Boolean" };
  k2 = { [x2]: "Endpoint" };
  l = { [v]: c, [w]: [{ [x2]: "UseFIPS" }, true] };
  m = { [v]: c, [w]: [{ [x2]: "UseDualStack" }, true] };
  n = {};
  o = { [v]: h, [w]: [{ [x2]: g }, "supportsFIPS"] };
  p = { [x2]: g };
  q = { [v]: c, [w]: [true, { [v]: h, [w]: [p, "supportsDualStack"] }] };
  r = [l];
  s = [m];
  t2 = [{ [x2]: "Region" }];
  _data = { version: "1.0", parameters: { Region: i2, UseDualStack: j, UseFIPS: j, Endpoint: i2 }, rules: [{ conditions: [{ [v]: b, [w]: [k2] }], rules: [{ conditions: r, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d }, { conditions: s, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d }, { endpoint: { url: k2, properties: n, headers: n }, type: e }], type: f }, { conditions: [{ [v]: b, [w]: t2 }], rules: [{ conditions: [{ [v]: "aws.partition", [w]: t2, assign: g }], rules: [{ conditions: [l, m], rules: [{ conditions: [{ [v]: c, [w]: [a, o] }, q], rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }], type: f }, { conditions: r, rules: [{ conditions: [{ [v]: c, [w]: [o, a] }], rules: [{ conditions: [{ [v]: "stringEquals", [w]: [{ [v]: h, [w]: [p, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://portal.sso.{Region}.amazonaws.com", properties: n, headers: n }, type: e }, { endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS is enabled but this partition does not support FIPS", type: d }], type: f }, { conditions: s, rules: [{ conditions: [q], rules: [{ endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "DualStack is enabled but this partition does not support DualStack", type: d }], type: f }, { endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }], type: f }, { error: "Invalid Configuration: Missing Region", type: d }] };
  ruleSet = _data;
});

// node_modules/@aws-sdk/client-sso/dist-es/endpoint/endpointResolver.js
var import_util_endpoints, import_util_endpoints2, cache, defaultEndpointResolver = (endpointParams, context = {}) => {
  return cache.get(endpointParams, () => import_util_endpoints2.resolveEndpoint(ruleSet, {
    endpointParams,
    logger: context.logger
  }));
};
var init_endpointResolver = __esm(() => {
  init_ruleset();
  import_util_endpoints = __toESM(require_dist_cjs23(), 1);
  import_util_endpoints2 = __toESM(require_dist_cjs20(), 1);
  cache = new import_util_endpoints2.EndpointCache({
    size: 50,
    params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
  });
  import_util_endpoints2.customEndpointFunctions.aws = import_util_endpoints.awsEndpointFunctions;
});

// node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.shared.js
var import_core7, import_core8, import_smithy_client5, import_url_parser2, import_util_base64, import_util_utf8, getRuntimeConfig = (config) => {
  return {
    apiVersion: "2019-06-10",
    base64Decoder: config?.base64Decoder ?? import_util_base64.fromBase64,
    base64Encoder: config?.base64Encoder ?? import_util_base64.toBase64,
    disableHostPrefix: config?.disableHostPrefix ?? false,
    endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,
    extensions: config?.extensions ?? [],
    httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultSSOHttpAuthSchemeProvider,
    httpAuthSchemes: config?.httpAuthSchemes ?? [
      {
        schemeId: "aws.auth#sigv4",
        identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
        signer: new import_core7.AwsSdkSigV4Signer
      },
      {
        schemeId: "smithy.api#noAuth",
        identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
        signer: new import_core8.NoAuthSigner
      }
    ],
    logger: config?.logger ?? new import_smithy_client5.NoOpLogger,
    serviceId: config?.serviceId ?? "SSO",
    urlParser: config?.urlParser ?? import_url_parser2.parseUrl,
    utf8Decoder: config?.utf8Decoder ?? import_util_utf8.fromUtf8,
    utf8Encoder: config?.utf8Encoder ?? import_util_utf8.toUtf8
  };
};
var init_runtimeConfig_shared = __esm(() => {
  init_httpAuthSchemeProvider2();
  init_endpointResolver();
  import_core7 = __toESM(require_dist_cjs30(), 1);
  import_core8 = __toESM(require_dist_cjs19(), 1);
  import_smithy_client5 = __toESM(require_dist_cjs28(), 1);
  import_url_parser2 = __toESM(require_dist_cjs22(), 1);
  import_util_base64 = __toESM(require_dist_cjs11(), 1);
  import_util_utf8 = __toESM(require_dist_cjs10(), 1);
});

// node_modules/@aws-sdk/client-sso/dist-es/runtimeConfig.js
var import_core9, import_util_user_agent_node, import_config_resolver, import_hash_node, import_middleware_retry, import_node_config_provider3, import_node_http_handler2, import_util_body_length_node, import_util_retry, import_smithy_client6, import_util_defaults_mode_node, import_smithy_client7, getRuntimeConfig2 = (config) => {
  import_smithy_client7.emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = import_util_defaults_mode_node.resolveDefaultsModeConfig(config);
  const defaultConfigProvider = () => defaultsMode().then(import_smithy_client6.loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig(config);
  import_core9.emitWarningIfUnsupportedVersion(process.version);
  const loaderConfig = {
    profile: config?.profile,
    logger: clientSharedValues.logger
  };
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    authSchemePreference: config?.authSchemePreference ?? import_node_config_provider3.loadConfig(import_core9.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
    bodyLengthChecker: config?.bodyLengthChecker ?? import_util_body_length_node.calculateBodyLength,
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? import_util_user_agent_node.createDefaultUserAgentProvider({ serviceId: clientSharedValues.serviceId, clientVersion: package_default2.version }),
    maxAttempts: config?.maxAttempts ?? import_node_config_provider3.loadConfig(import_middleware_retry.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
    region: config?.region ?? import_node_config_provider3.loadConfig(import_config_resolver.NODE_REGION_CONFIG_OPTIONS, { ...import_config_resolver.NODE_REGION_CONFIG_FILE_OPTIONS, ...loaderConfig }),
    requestHandler: import_node_http_handler2.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
    retryMode: config?.retryMode ?? import_node_config_provider3.loadConfig({
      ...import_middleware_retry.NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || import_util_retry.DEFAULT_RETRY_MODE
    }, config),
    sha256: config?.sha256 ?? import_hash_node.Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? import_node_http_handler2.streamCollector,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? import_node_config_provider3.loadConfig(import_config_resolver.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
    useFipsEndpoint: config?.useFipsEndpoint ?? import_node_config_provider3.loadConfig(import_config_resolver.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
    userAgentAppId: config?.userAgentAppId ?? import_node_config_provider3.loadConfig(import_util_user_agent_node.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
  };
};
var init_runtimeConfig = __esm(() => {
  init_package2();
  init_runtimeConfig_shared();
  import_core9 = __toESM(require_dist_cjs30(), 1);
  import_util_user_agent_node = __toESM(require_dist_cjs41(), 1);
  import_config_resolver = __toESM(require_dist_cjs33(), 1);
  import_hash_node = __toESM(require_dist_cjs42(), 1);
  import_middleware_retry = __toESM(require_dist_cjs40(), 1);
  import_node_config_provider3 = __toESM(require_dist_cjs36(), 1);
  import_node_http_handler2 = __toESM(require_dist_cjs14(), 1);
  import_util_body_length_node = __toESM(require_dist_cjs43(), 1);
  import_util_retry = __toESM(require_dist_cjs39(), 1);
  import_smithy_client6 = __toESM(require_dist_cjs28(), 1);
  import_util_defaults_mode_node = __toESM(require_dist_cjs44(), 1);
  import_smithy_client7 = __toESM(require_dist_cjs28(), 1);
});

// node_modules/@aws-sdk/client-sso/dist-es/auth/httpAuthExtensionConfiguration.js
var getHttpAuthExtensionConfiguration = (runtimeConfig) => {
  const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
  let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
  let _credentials = runtimeConfig.credentials;
  return {
    setHttpAuthScheme(httpAuthScheme) {
      const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
      if (index === -1) {
        _httpAuthSchemes.push(httpAuthScheme);
      } else {
        _httpAuthSchemes.splice(index, 1, httpAuthScheme);
      }
    },
    httpAuthSchemes() {
      return _httpAuthSchemes;
    },
    setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
      _httpAuthSchemeProvider = httpAuthSchemeProvider;
    },
    httpAuthSchemeProvider() {
      return _httpAuthSchemeProvider;
    },
    setCredentials(credentials) {
      _credentials = credentials;
    },
    credentials() {
      return _credentials;
    }
  };
}, resolveHttpAuthRuntimeConfig = (config) => {
  return {
    httpAuthSchemes: config.httpAuthSchemes(),
    httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
    credentials: config.credentials()
  };
};

// node_modules/@aws-sdk/client-sso/dist-es/runtimeExtensions.js
var import_region_config_resolver, import_protocol_http3, import_smithy_client8, resolveRuntimeExtensions = (runtimeConfig, extensions2) => {
  const extensionConfiguration = Object.assign(import_region_config_resolver.getAwsRegionExtensionConfiguration(runtimeConfig), import_smithy_client8.getDefaultExtensionConfiguration(runtimeConfig), import_protocol_http3.getHttpHandlerExtensionConfiguration(runtimeConfig), getHttpAuthExtensionConfiguration(runtimeConfig));
  extensions2.forEach((extension) => extension.configure(extensionConfiguration));
  return Object.assign(runtimeConfig, import_region_config_resolver.resolveAwsRegionExtensionConfiguration(extensionConfiguration), import_smithy_client8.resolveDefaultRuntimeConfig(extensionConfiguration), import_protocol_http3.resolveHttpHandlerRuntimeConfig(extensionConfiguration), resolveHttpAuthRuntimeConfig(extensionConfiguration));
};
var init_runtimeExtensions = __esm(() => {
  import_region_config_resolver = __toESM(require_dist_cjs45(), 1);
  import_protocol_http3 = __toESM(require_dist_cjs3(), 1);
  import_smithy_client8 = __toESM(require_dist_cjs28(), 1);
});

// node_modules/@aws-sdk/client-sso/dist-es/SSOClient.js
var import_middleware_host_header, import_middleware_logger, import_middleware_recursion_detection, import_middleware_user_agent, import_config_resolver2, import_core10, import_middleware_content_length, import_middleware_endpoint2, import_middleware_retry2, import_smithy_client9, SSOClient;
var init_SSOClient = __esm(() => {
  init_httpAuthSchemeProvider2();
  init_EndpointParameters2();
  init_runtimeConfig();
  init_runtimeExtensions();
  import_middleware_host_header = __toESM(require_dist_cjs4(), 1);
  import_middleware_logger = __toESM(require_dist_cjs5(), 1);
  import_middleware_recursion_detection = __toESM(require_dist_cjs6(), 1);
  import_middleware_user_agent = __toESM(require_dist_cjs31(), 1);
  import_config_resolver2 = __toESM(require_dist_cjs33(), 1);
  import_core10 = __toESM(require_dist_cjs19(), 1);
  import_middleware_content_length = __toESM(require_dist_cjs34(), 1);
  import_middleware_endpoint2 = __toESM(require_dist_cjs37(), 1);
  import_middleware_retry2 = __toESM(require_dist_cjs40(), 1);
  import_smithy_client9 = __toESM(require_dist_cjs28(), 1);
  SSOClient = class SSOClient extends import_smithy_client9.Client {
    config;
    constructor(...[configuration]) {
      const _config_0 = getRuntimeConfig2(configuration || {});
      super(_config_0);
      this.initConfig = _config_0;
      const _config_1 = resolveClientEndpointParameters2(_config_0);
      const _config_2 = import_middleware_user_agent.resolveUserAgentConfig(_config_1);
      const _config_3 = import_middleware_retry2.resolveRetryConfig(_config_2);
      const _config_4 = import_config_resolver2.resolveRegionConfig(_config_3);
      const _config_5 = import_middleware_host_header.resolveHostHeaderConfig(_config_4);
      const _config_6 = import_middleware_endpoint2.resolveEndpointConfig(_config_5);
      const _config_7 = resolveHttpAuthSchemeConfig2(_config_6);
      const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);
      this.config = _config_8;
      this.middlewareStack.use(import_middleware_user_agent.getUserAgentPlugin(this.config));
      this.middlewareStack.use(import_middleware_retry2.getRetryPlugin(this.config));
      this.middlewareStack.use(import_middleware_content_length.getContentLengthPlugin(this.config));
      this.middlewareStack.use(import_middleware_host_header.getHostHeaderPlugin(this.config));
      this.middlewareStack.use(import_middleware_logger.getLoggerPlugin(this.config));
      this.middlewareStack.use(import_middleware_recursion_detection.getRecursionDetectionPlugin(this.config));
      this.middlewareStack.use(import_core10.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
        httpAuthSchemeParametersProvider: defaultSSOHttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (config) => new import_core10.DefaultIdentityProviderConfig({
          "aws.auth#sigv4": config.credentials
        })
      }));
      this.middlewareStack.use(import_core10.getHttpSigningPlugin(this.config));
    }
    destroy() {
      super.destroy();
    }
  };
});

// node_modules/@aws-sdk/client-sso/dist-es/models/SSOServiceException.js
var import_smithy_client10, SSOServiceException;
var init_SSOServiceException = __esm(() => {
  import_smithy_client10 = __toESM(require_dist_cjs28(), 1);
  SSOServiceException = class SSOServiceException extends import_smithy_client10.ServiceException {
    constructor(options) {
      super(options);
      Object.setPrototypeOf(this, SSOServiceException.prototype);
    }
  };
});

// node_modules/@aws-sdk/client-sso/dist-es/models/models_0.js
var import_smithy_client11, InvalidRequestException, ResourceNotFoundException2, TooManyRequestsException, UnauthorizedException, GetRoleCredentialsRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.accessToken && { accessToken: import_smithy_client11.SENSITIVE_STRING }
}), RoleCredentialsFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.secretAccessKey && { secretAccessKey: import_smithy_client11.SENSITIVE_STRING },
  ...obj.sessionToken && { sessionToken: import_smithy_client11.SENSITIVE_STRING }
}), GetRoleCredentialsResponseFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.roleCredentials && { roleCredentials: RoleCredentialsFilterSensitiveLog(obj.roleCredentials) }
}), ListAccountRolesRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.accessToken && { accessToken: import_smithy_client11.SENSITIVE_STRING }
}), ListAccountsRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.accessToken && { accessToken: import_smithy_client11.SENSITIVE_STRING }
}), LogoutRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.accessToken && { accessToken: import_smithy_client11.SENSITIVE_STRING }
});
var init_models_02 = __esm(() => {
  init_SSOServiceException();
  import_smithy_client11 = __toESM(require_dist_cjs28(), 1);
  InvalidRequestException = class InvalidRequestException extends SSOServiceException {
    name = "InvalidRequestException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "InvalidRequestException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, InvalidRequestException.prototype);
    }
  };
  ResourceNotFoundException2 = class ResourceNotFoundException2 extends SSOServiceException {
    name = "ResourceNotFoundException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "ResourceNotFoundException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ResourceNotFoundException2.prototype);
    }
  };
  TooManyRequestsException = class TooManyRequestsException extends SSOServiceException {
    name = "TooManyRequestsException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "TooManyRequestsException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, TooManyRequestsException.prototype);
    }
  };
  UnauthorizedException = class UnauthorizedException extends SSOServiceException {
    name = "UnauthorizedException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "UnauthorizedException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, UnauthorizedException.prototype);
    }
  };
});

// node_modules/@aws-sdk/client-sso/dist-es/protocols/Aws_restJson1.js
var import_core11, import_core12, import_smithy_client12, se_GetRoleCredentialsCommand = async (input, context) => {
  const b2 = import_core12.requestBuilder(input, context);
  const headers = import_smithy_client12.map({}, import_smithy_client12.isSerializableHeaderValue, {
    [_xasbt]: input[_aT]
  });
  b2.bp("/federation/credentials");
  const query = import_smithy_client12.map({
    [_rn]: [, import_smithy_client12.expectNonNull(input[_rN], `roleName`)],
    [_ai]: [, import_smithy_client12.expectNonNull(input[_aI], `accountId`)]
  });
  let body;
  b2.m("GET").h(headers).q(query).b(body);
  return b2.build();
}, se_ListAccountRolesCommand = async (input, context) => {
  const b2 = import_core12.requestBuilder(input, context);
  const headers = import_smithy_client12.map({}, import_smithy_client12.isSerializableHeaderValue, {
    [_xasbt]: input[_aT]
  });
  b2.bp("/assignment/roles");
  const query = import_smithy_client12.map({
    [_nt]: [, input[_nT]],
    [_mr]: [() => input.maxResults !== undefined, () => input[_mR].toString()],
    [_ai]: [, import_smithy_client12.expectNonNull(input[_aI], `accountId`)]
  });
  let body;
  b2.m("GET").h(headers).q(query).b(body);
  return b2.build();
}, se_ListAccountsCommand = async (input, context) => {
  const b2 = import_core12.requestBuilder(input, context);
  const headers = import_smithy_client12.map({}, import_smithy_client12.isSerializableHeaderValue, {
    [_xasbt]: input[_aT]
  });
  b2.bp("/assignment/accounts");
  const query = import_smithy_client12.map({
    [_nt]: [, input[_nT]],
    [_mr]: [() => input.maxResults !== undefined, () => input[_mR].toString()]
  });
  let body;
  b2.m("GET").h(headers).q(query).b(body);
  return b2.build();
}, se_LogoutCommand = async (input, context) => {
  const b2 = import_core12.requestBuilder(input, context);
  const headers = import_smithy_client12.map({}, import_smithy_client12.isSerializableHeaderValue, {
    [_xasbt]: input[_aT]
  });
  b2.bp("/logout");
  let body;
  b2.m("POST").h(headers).b(body);
  return b2.build();
}, de_GetRoleCredentialsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError2(output, context);
  }
  const contents = import_smithy_client12.map({
    $metadata: deserializeMetadata2(output)
  });
  const data = import_smithy_client12.expectNonNull(import_smithy_client12.expectObject(await import_core11.parseJsonBody(output.body, context)), "body");
  const doc = import_smithy_client12.take(data, {
    roleCredentials: import_smithy_client12._json
  });
  Object.assign(contents, doc);
  return contents;
}, de_ListAccountRolesCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError2(output, context);
  }
  const contents = import_smithy_client12.map({
    $metadata: deserializeMetadata2(output)
  });
  const data = import_smithy_client12.expectNonNull(import_smithy_client12.expectObject(await import_core11.parseJsonBody(output.body, context)), "body");
  const doc = import_smithy_client12.take(data, {
    nextToken: import_smithy_client12.expectString,
    roleList: import_smithy_client12._json
  });
  Object.assign(contents, doc);
  return contents;
}, de_ListAccountsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError2(output, context);
  }
  const contents = import_smithy_client12.map({
    $metadata: deserializeMetadata2(output)
  });
  const data = import_smithy_client12.expectNonNull(import_smithy_client12.expectObject(await import_core11.parseJsonBody(output.body, context)), "body");
  const doc = import_smithy_client12.take(data, {
    accountList: import_smithy_client12._json,
    nextToken: import_smithy_client12.expectString
  });
  Object.assign(contents, doc);
  return contents;
}, de_LogoutCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError2(output, context);
  }
  const contents = import_smithy_client12.map({
    $metadata: deserializeMetadata2(output)
  });
  await import_smithy_client12.collectBody(output.body, context);
  return contents;
}, de_CommandError2 = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await import_core11.parseJsonErrorBody(output.body, context)
  };
  const errorCode = import_core11.loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.sso#InvalidRequestException":
      throw await de_InvalidRequestExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.sso#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes2(parsedOutput, context);
    case "TooManyRequestsException":
    case "com.amazonaws.sso#TooManyRequestsException":
      throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
    case "UnauthorizedException":
    case "com.amazonaws.sso#UnauthorizedException":
      throw await de_UnauthorizedExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError2({
        output,
        parsedBody,
        errorCode
      });
  }
}, throwDefaultError2, de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
  const contents = import_smithy_client12.map({});
  const data = parsedOutput.body;
  const doc = import_smithy_client12.take(data, {
    message: import_smithy_client12.expectString
  });
  Object.assign(contents, doc);
  const exception = new InvalidRequestException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return import_smithy_client12.decorateServiceException(exception, parsedOutput.body);
}, de_ResourceNotFoundExceptionRes2 = async (parsedOutput, context) => {
  const contents = import_smithy_client12.map({});
  const data = parsedOutput.body;
  const doc = import_smithy_client12.take(data, {
    message: import_smithy_client12.expectString
  });
  Object.assign(contents, doc);
  const exception = new ResourceNotFoundException2({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return import_smithy_client12.decorateServiceException(exception, parsedOutput.body);
}, de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
  const contents = import_smithy_client12.map({});
  const data = parsedOutput.body;
  const doc = import_smithy_client12.take(data, {
    message: import_smithy_client12.expectString
  });
  Object.assign(contents, doc);
  const exception = new TooManyRequestsException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return import_smithy_client12.decorateServiceException(exception, parsedOutput.body);
}, de_UnauthorizedExceptionRes = async (parsedOutput, context) => {
  const contents = import_smithy_client12.map({});
  const data = parsedOutput.body;
  const doc = import_smithy_client12.take(data, {
    message: import_smithy_client12.expectString
  });
  Object.assign(contents, doc);
  const exception = new UnauthorizedException({
    $metadata: deserializeMetadata2(parsedOutput),
    ...contents
  });
  return import_smithy_client12.decorateServiceException(exception, parsedOutput.body);
}, deserializeMetadata2 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
}), _aI = "accountId", _aT = "accessToken", _ai = "account_id", _mR = "maxResults", _mr = "max_result", _nT = "nextToken", _nt = "next_token", _rN = "roleName", _rn = "role_name", _xasbt = "x-amz-sso_bearer_token";
var init_Aws_restJson1 = __esm(() => {
  init_models_02();
  init_SSOServiceException();
  import_core11 = __toESM(require_dist_cjs30(), 1);
  import_core12 = __toESM(require_dist_cjs19(), 1);
  import_smithy_client12 = __toESM(require_dist_cjs28(), 1);
  throwDefaultError2 = import_smithy_client12.withBaseException(SSOServiceException);
});

// node_modules/@aws-sdk/client-sso/dist-es/commands/GetRoleCredentialsCommand.js
var import_middleware_endpoint3, import_middleware_serde2, import_smithy_client13, GetRoleCredentialsCommand;
var init_GetRoleCredentialsCommand = __esm(() => {
  init_EndpointParameters2();
  init_models_02();
  init_Aws_restJson1();
  import_middleware_endpoint3 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde2 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client13 = __toESM(require_dist_cjs28(), 1);
  GetRoleCredentialsCommand = class GetRoleCredentialsCommand extends import_smithy_client13.Command.classBuilder().ep(commonParams2).m(function(Command, cs, config, o2) {
    return [
      import_middleware_serde2.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint3.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("SWBPortalService", "GetRoleCredentials", {}).n("SSOClient", "GetRoleCredentialsCommand").f(GetRoleCredentialsRequestFilterSensitiveLog, GetRoleCredentialsResponseFilterSensitiveLog).ser(se_GetRoleCredentialsCommand).de(de_GetRoleCredentialsCommand).build() {
  };
});

// node_modules/@aws-sdk/client-sso/dist-es/commands/ListAccountRolesCommand.js
var import_middleware_endpoint4, import_middleware_serde3, import_smithy_client14, ListAccountRolesCommand;
var init_ListAccountRolesCommand = __esm(() => {
  init_EndpointParameters2();
  init_models_02();
  init_Aws_restJson1();
  import_middleware_endpoint4 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde3 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client14 = __toESM(require_dist_cjs28(), 1);
  ListAccountRolesCommand = class ListAccountRolesCommand extends import_smithy_client14.Command.classBuilder().ep(commonParams2).m(function(Command, cs, config, o2) {
    return [
      import_middleware_serde3.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint4.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("SWBPortalService", "ListAccountRoles", {}).n("SSOClient", "ListAccountRolesCommand").f(ListAccountRolesRequestFilterSensitiveLog, undefined).ser(se_ListAccountRolesCommand).de(de_ListAccountRolesCommand).build() {
  };
});

// node_modules/@aws-sdk/client-sso/dist-es/commands/ListAccountsCommand.js
var import_middleware_endpoint5, import_middleware_serde4, import_smithy_client15, ListAccountsCommand;
var init_ListAccountsCommand = __esm(() => {
  init_EndpointParameters2();
  init_models_02();
  init_Aws_restJson1();
  import_middleware_endpoint5 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde4 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client15 = __toESM(require_dist_cjs28(), 1);
  ListAccountsCommand = class ListAccountsCommand extends import_smithy_client15.Command.classBuilder().ep(commonParams2).m(function(Command, cs, config, o2) {
    return [
      import_middleware_serde4.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint5.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("SWBPortalService", "ListAccounts", {}).n("SSOClient", "ListAccountsCommand").f(ListAccountsRequestFilterSensitiveLog, undefined).ser(se_ListAccountsCommand).de(de_ListAccountsCommand).build() {
  };
});

// node_modules/@aws-sdk/client-sso/dist-es/commands/LogoutCommand.js
var import_middleware_endpoint6, import_middleware_serde5, import_smithy_client16, LogoutCommand;
var init_LogoutCommand = __esm(() => {
  init_EndpointParameters2();
  init_models_02();
  init_Aws_restJson1();
  import_middleware_endpoint6 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde5 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client16 = __toESM(require_dist_cjs28(), 1);
  LogoutCommand = class LogoutCommand extends import_smithy_client16.Command.classBuilder().ep(commonParams2).m(function(Command, cs, config, o2) {
    return [
      import_middleware_serde5.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint6.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("SWBPortalService", "Logout", {}).n("SSOClient", "LogoutCommand").f(LogoutRequestFilterSensitiveLog, undefined).ser(se_LogoutCommand).de(de_LogoutCommand).build() {
  };
});

// node_modules/@aws-sdk/client-sso/dist-es/SSO.js
var import_smithy_client17, commands, SSO;
var init_SSO = __esm(() => {
  init_GetRoleCredentialsCommand();
  init_ListAccountRolesCommand();
  init_ListAccountsCommand();
  init_LogoutCommand();
  init_SSOClient();
  import_smithy_client17 = __toESM(require_dist_cjs28(), 1);
  commands = {
    GetRoleCredentialsCommand,
    ListAccountRolesCommand,
    ListAccountsCommand,
    LogoutCommand
  };
  SSO = class SSO extends SSOClient {
  };
  import_smithy_client17.createAggregatedClient(commands, SSO);
});

// node_modules/@aws-sdk/client-sso/dist-es/commands/index.js
var init_commands = __esm(() => {
  init_GetRoleCredentialsCommand();
  init_ListAccountRolesCommand();
  init_ListAccountsCommand();
  init_LogoutCommand();
});

// node_modules/@aws-sdk/client-sso/dist-es/pagination/Interfaces.js
var init_Interfaces = () => {};

// node_modules/@aws-sdk/client-sso/dist-es/pagination/ListAccountRolesPaginator.js
var import_core13, paginateListAccountRoles;
var init_ListAccountRolesPaginator = __esm(() => {
  init_ListAccountRolesCommand();
  init_SSOClient();
  import_core13 = __toESM(require_dist_cjs19(), 1);
  paginateListAccountRoles = import_core13.createPaginator(SSOClient, ListAccountRolesCommand, "nextToken", "nextToken", "maxResults");
});

// node_modules/@aws-sdk/client-sso/dist-es/pagination/ListAccountsPaginator.js
var import_core14, paginateListAccounts;
var init_ListAccountsPaginator = __esm(() => {
  init_ListAccountsCommand();
  init_SSOClient();
  import_core14 = __toESM(require_dist_cjs19(), 1);
  paginateListAccounts = import_core14.createPaginator(SSOClient, ListAccountsCommand, "nextToken", "nextToken", "maxResults");
});

// node_modules/@aws-sdk/client-sso/dist-es/pagination/index.js
var init_pagination = __esm(() => {
  init_Interfaces();
  init_ListAccountRolesPaginator();
  init_ListAccountsPaginator();
});

// node_modules/@aws-sdk/client-sso/dist-es/models/index.js
var init_models = __esm(() => {
  init_models_02();
});

// node_modules/@aws-sdk/client-sso/dist-es/index.js
var init_dist_es7 = __esm(() => {
  init_SSOClient();
  init_SSO();
  init_commands();
  init_pagination();
  init_models();
});

// node_modules/@aws-sdk/credential-provider-sso/dist-es/loadSso.js
var exports_loadSso = {};
__export(exports_loadSso, {
  SSOClient: () => SSOClient,
  GetRoleCredentialsCommand: () => GetRoleCredentialsCommand
});
var init_loadSso = __esm(() => {
  init_dist_es7();
});

// node_modules/@aws-sdk/credential-provider-sso/dist-es/resolveSSOCredentials.js
var import_client3, import_property_provider13, import_shared_ini_file_loader3, SHOULD_FAIL_CREDENTIAL_CHAIN = false, resolveSSOCredentials = async ({ ssoStartUrl, ssoSession, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, clientConfig, parentClientConfig, profile, filepath, configFilepath, ignoreCache, logger }) => {
  let token;
  const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;
  if (ssoSession) {
    try {
      const _token = await fromSso({
        profile,
        filepath,
        configFilepath,
        ignoreCache
      })();
      token = {
        accessToken: _token.token,
        expiresAt: new Date(_token.expiration).toISOString()
      };
    } catch (e2) {
      throw new import_property_provider13.CredentialsProviderError(e2.message, {
        tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
        logger
      });
    }
  } else {
    try {
      token = await import_shared_ini_file_loader3.getSSOTokenFromFile(ssoStartUrl);
    } catch (e2) {
      throw new import_property_provider13.CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, {
        tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
        logger
      });
    }
  }
  if (new Date(token.expiresAt).getTime() - Date.now() <= 0) {
    throw new import_property_provider13.CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, {
      tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
      logger
    });
  }
  const { accessToken } = token;
  const { SSOClient: SSOClient3, GetRoleCredentialsCommand: GetRoleCredentialsCommand3 } = await Promise.resolve().then(() => (init_loadSso(), exports_loadSso));
  const sso = ssoClient || new SSOClient3(Object.assign({}, clientConfig ?? {}, {
    logger: clientConfig?.logger ?? parentClientConfig?.logger,
    region: clientConfig?.region ?? ssoRegion
  }));
  let ssoResp;
  try {
    ssoResp = await sso.send(new GetRoleCredentialsCommand3({
      accountId: ssoAccountId,
      roleName: ssoRoleName,
      accessToken
    }));
  } catch (e2) {
    throw new import_property_provider13.CredentialsProviderError(e2, {
      tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
      logger
    });
  }
  const { roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration, credentialScope, accountId } = {} } = ssoResp;
  if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {
    throw new import_property_provider13.CredentialsProviderError("SSO returns an invalid temporary credential.", {
      tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
      logger
    });
  }
  const credentials = {
    accessKeyId,
    secretAccessKey,
    sessionToken,
    expiration: new Date(expiration),
    ...credentialScope && { credentialScope },
    ...accountId && { accountId }
  };
  if (ssoSession) {
    import_client3.setCredentialFeature(credentials, "CREDENTIALS_SSO", "s");
  } else {
    import_client3.setCredentialFeature(credentials, "CREDENTIALS_SSO_LEGACY", "u");
  }
  return credentials;
};
var init_resolveSSOCredentials = __esm(() => {
  init_dist_es6();
  import_client3 = __toESM(require_client(), 1);
  import_property_provider13 = __toESM(require_dist_cjs24(), 1);
  import_shared_ini_file_loader3 = __toESM(require_dist_cjs35(), 1);
});

// node_modules/@aws-sdk/credential-provider-sso/dist-es/validateSsoProfile.js
var import_property_provider14, validateSsoProfile = (profile, logger) => {
  const { sso_start_url, sso_account_id, sso_region, sso_role_name } = profile;
  if (!sso_start_url || !sso_account_id || !sso_region || !sso_role_name) {
    throw new import_property_provider14.CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", ` + `"sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(profile).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, { tryNextLink: false, logger });
  }
  return profile;
};
var init_validateSsoProfile = __esm(() => {
  import_property_provider14 = __toESM(require_dist_cjs24(), 1);
});

// node_modules/@aws-sdk/credential-provider-sso/dist-es/fromSSO.js
var import_property_provider15, import_shared_ini_file_loader4, fromSSO = (init = {}) => async ({ callerClientConfig } = {}) => {
  init.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO");
  const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoSession } = init;
  const { ssoClient } = init;
  const profileName = import_shared_ini_file_loader4.getProfileName({
    profile: init.profile ?? callerClientConfig?.profile
  });
  if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
    const profiles = await import_shared_ini_file_loader4.parseKnownFiles(init);
    const profile = profiles[profileName];
    if (!profile) {
      throw new import_property_provider15.CredentialsProviderError(`Profile ${profileName} was not found.`, { logger: init.logger });
    }
    if (!isSsoProfile(profile)) {
      throw new import_property_provider15.CredentialsProviderError(`Profile ${profileName} is not configured with SSO credentials.`, {
        logger: init.logger
      });
    }
    if (profile?.sso_session) {
      const ssoSessions = await import_shared_ini_file_loader4.loadSsoSessionData(init);
      const session = ssoSessions[profile.sso_session];
      const conflictMsg = ` configurations in profile ${profileName} and sso-session ${profile.sso_session}`;
      if (ssoRegion && ssoRegion !== session.sso_region) {
        throw new import_property_provider15.CredentialsProviderError(`Conflicting SSO region` + conflictMsg, {
          tryNextLink: false,
          logger: init.logger
        });
      }
      if (ssoStartUrl && ssoStartUrl !== session.sso_start_url) {
        throw new import_property_provider15.CredentialsProviderError(`Conflicting SSO start_url` + conflictMsg, {
          tryNextLink: false,
          logger: init.logger
        });
      }
      profile.sso_region = session.sso_region;
      profile.sso_start_url = session.sso_start_url;
    }
    const { sso_start_url, sso_account_id, sso_region, sso_role_name, sso_session } = validateSsoProfile(profile, init.logger);
    return resolveSSOCredentials({
      ssoStartUrl: sso_start_url,
      ssoSession: sso_session,
      ssoAccountId: sso_account_id,
      ssoRegion: sso_region,
      ssoRoleName: sso_role_name,
      ssoClient,
      clientConfig: init.clientConfig,
      parentClientConfig: init.parentClientConfig,
      profile: profileName,
      filepath: init.filepath,
      configFilepath: init.configFilepath,
      ignoreCache: init.ignoreCache,
      logger: init.logger
    });
  } else if (!ssoStartUrl || !ssoAccountId || !ssoRegion || !ssoRoleName) {
    throw new import_property_provider15.CredentialsProviderError("Incomplete configuration. The fromSSO() argument hash must include " + '"ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"', { tryNextLink: false, logger: init.logger });
  } else {
    return resolveSSOCredentials({
      ssoStartUrl,
      ssoSession,
      ssoAccountId,
      ssoRegion,
      ssoRoleName,
      ssoClient,
      clientConfig: init.clientConfig,
      parentClientConfig: init.parentClientConfig,
      profile: profileName,
      filepath: init.filepath,
      configFilepath: init.configFilepath,
      ignoreCache: init.ignoreCache,
      logger: init.logger
    });
  }
};
var init_fromSSO = __esm(() => {
  init_resolveSSOCredentials();
  init_validateSsoProfile();
  import_property_provider15 = __toESM(require_dist_cjs24(), 1);
  import_shared_ini_file_loader4 = __toESM(require_dist_cjs35(), 1);
});

// node_modules/@aws-sdk/credential-provider-sso/dist-es/types.js
var init_types2 = () => {};

// node_modules/@aws-sdk/credential-provider-sso/dist-es/index.js
var exports_dist_es4 = {};
__export(exports_dist_es4, {
  validateSsoProfile: () => validateSsoProfile,
  isSsoProfile: () => isSsoProfile,
  fromSSO: () => fromSSO
});
var init_dist_es8 = __esm(() => {
  init_fromSSO();
  init_types2();
  init_validateSsoProfile();
});

// node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveCredentialSource.js
var import_client4, import_property_provider16, resolveCredentialSource = (credentialSource, profileName, logger) => {
  const sourceProvidersMap = {
    EcsContainer: async (options) => {
      const { fromHttp: fromHttp2 } = await Promise.resolve().then(() => (init_dist_es5(), exports_dist_es3));
      const { fromContainerMetadata: fromContainerMetadata3 } = await Promise.resolve().then(() => (init_dist_es4(), exports_dist_es2));
      logger?.debug("@aws-sdk/credential-provider-ini - credential_source is EcsContainer");
      return async () => import_property_provider16.chain(fromHttp2(options ?? {}), fromContainerMetadata3(options))().then(setNamedProvider);
    },
    Ec2InstanceMetadata: async (options) => {
      logger?.debug("@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata");
      const { fromInstanceMetadata: fromInstanceMetadata3 } = await Promise.resolve().then(() => (init_dist_es4(), exports_dist_es2));
      return async () => fromInstanceMetadata3(options)().then(setNamedProvider);
    },
    Environment: async (options) => {
      logger?.debug("@aws-sdk/credential-provider-ini - credential_source is Environment");
      const { fromEnv: fromEnv3 } = await Promise.resolve().then(() => (init_dist_es3(), exports_dist_es));
      return async () => fromEnv3(options)().then(setNamedProvider);
    }
  };
  if (credentialSource in sourceProvidersMap) {
    return sourceProvidersMap[credentialSource];
  } else {
    throw new import_property_provider16.CredentialsProviderError(`Unsupported credential source in profile ${profileName}. Got ${credentialSource}, expected EcsContainer or Ec2InstanceMetadata or Environment.`, { logger });
  }
}, setNamedProvider = (creds) => import_client4.setCredentialFeature(creds, "CREDENTIALS_PROFILE_NAMED_PROVIDER", "p");
var init_resolveCredentialSource = __esm(() => {
  import_client4 = __toESM(require_client(), 1);
  import_property_provider16 = __toESM(require_dist_cjs24(), 1);
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/auth/httpAuthSchemeProvider.js
var require_httpAuthSchemeProvider2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveHttpAuthSchemeConfig = exports.resolveStsAuthConfig = exports.defaultSTSHttpAuthSchemeProvider = exports.defaultSTSHttpAuthSchemeParametersProvider = undefined;
  var core_1 = require_dist_cjs30();
  var util_middleware_1 = require_dist_cjs2();
  var STSClient_1 = require_STSClient();
  var defaultSTSHttpAuthSchemeParametersProvider = async (config, context, input) => {
    return {
      operation: (0, util_middleware_1.getSmithyContext)(context).operation,
      region: await (0, util_middleware_1.normalizeProvider)(config.region)() || (() => {
        throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
      })()
    };
  };
  exports.defaultSTSHttpAuthSchemeParametersProvider = defaultSTSHttpAuthSchemeParametersProvider;
  function createAwsAuthSigv4HttpAuthOption3(authParameters) {
    return {
      schemeId: "aws.auth#sigv4",
      signingProperties: {
        name: "sts",
        region: authParameters.region
      },
      propertiesExtractor: (config, context) => ({
        signingProperties: {
          config,
          context
        }
      })
    };
  }
  function createSmithyApiNoAuthHttpAuthOption2(authParameters) {
    return {
      schemeId: "smithy.api#noAuth"
    };
  }
  var defaultSTSHttpAuthSchemeProvider = (authParameters) => {
    const options = [];
    switch (authParameters.operation) {
      case "AssumeRoleWithWebIdentity": {
        options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
        break;
      }
      default: {
        options.push(createAwsAuthSigv4HttpAuthOption3(authParameters));
      }
    }
    return options;
  };
  exports.defaultSTSHttpAuthSchemeProvider = defaultSTSHttpAuthSchemeProvider;
  var resolveStsAuthConfig = (input) => Object.assign(input, {
    stsClientCtor: STSClient_1.STSClient
  });
  exports.resolveStsAuthConfig = resolveStsAuthConfig;
  var resolveHttpAuthSchemeConfig3 = (config) => {
    const config_0 = (0, exports.resolveStsAuthConfig)(config);
    const config_1 = (0, core_1.resolveAwsSdkSigV4Config)(config_0);
    return Object.assign(config_1, {
      authSchemePreference: (0, util_middleware_1.normalizeProvider)(config.authSchemePreference ?? [])
    });
  };
  exports.resolveHttpAuthSchemeConfig = resolveHttpAuthSchemeConfig3;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/endpoint/EndpointParameters.js
var require_EndpointParameters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.commonParams = exports.resolveClientEndpointParameters = undefined;
  var resolveClientEndpointParameters3 = (options) => {
    return Object.assign(options, {
      useDualstackEndpoint: options.useDualstackEndpoint ?? false,
      useFipsEndpoint: options.useFipsEndpoint ?? false,
      useGlobalEndpoint: options.useGlobalEndpoint ?? false,
      defaultSigningName: "sts"
    });
  };
  exports.resolveClientEndpointParameters = resolveClientEndpointParameters3;
  exports.commonParams = {
    UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
  };
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/endpoint/ruleset.js
var require_ruleset2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ruleSet = undefined;
  var F = "required";
  var G = "type";
  var H = "fn";
  var I = "argv";
  var J = "ref";
  var a2 = false;
  var b2 = true;
  var c2 = "booleanEquals";
  var d2 = "stringEquals";
  var e2 = "sigv4";
  var f2 = "sts";
  var g2 = "us-east-1";
  var h2 = "endpoint";
  var i3 = "https://sts.{Region}.{PartitionResult#dnsSuffix}";
  var j2 = "tree";
  var k3 = "error";
  var l2 = "getAttr";
  var m2 = { [F]: false, [G]: "String" };
  var n2 = { [F]: true, default: false, [G]: "Boolean" };
  var o2 = { [J]: "Endpoint" };
  var p2 = { [H]: "isSet", [I]: [{ [J]: "Region" }] };
  var q2 = { [J]: "Region" };
  var r2 = { [H]: "aws.partition", [I]: [q2], assign: "PartitionResult" };
  var s2 = { [J]: "UseFIPS" };
  var t3 = { [J]: "UseDualStack" };
  var u2 = { url: "https://sts.amazonaws.com", properties: { authSchemes: [{ name: e2, signingName: f2, signingRegion: g2 }] }, headers: {} };
  var v2 = {};
  var w2 = { conditions: [{ [H]: d2, [I]: [q2, "aws-global"] }], [h2]: u2, [G]: h2 };
  var x3 = { [H]: c2, [I]: [s2, true] };
  var y = { [H]: c2, [I]: [t3, true] };
  var z = { [H]: l2, [I]: [{ [J]: "PartitionResult" }, "supportsFIPS"] };
  var A = { [J]: "PartitionResult" };
  var B = { [H]: c2, [I]: [true, { [H]: l2, [I]: [A, "supportsDualStack"] }] };
  var C = [{ [H]: "isSet", [I]: [o2] }];
  var D = [x3];
  var E = [y];
  var _data2 = { version: "1.0", parameters: { Region: m2, UseDualStack: n2, UseFIPS: n2, Endpoint: m2, UseGlobalEndpoint: n2 }, rules: [{ conditions: [{ [H]: c2, [I]: [{ [J]: "UseGlobalEndpoint" }, b2] }, { [H]: "not", [I]: C }, p2, r2, { [H]: c2, [I]: [s2, a2] }, { [H]: c2, [I]: [t3, a2] }], rules: [{ conditions: [{ [H]: d2, [I]: [q2, "ap-northeast-1"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "ap-south-1"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "ap-southeast-1"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "ap-southeast-2"] }], endpoint: u2, [G]: h2 }, w2, { conditions: [{ [H]: d2, [I]: [q2, "ca-central-1"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "eu-central-1"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "eu-north-1"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "eu-west-1"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "eu-west-2"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "eu-west-3"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "sa-east-1"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, g2] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "us-east-2"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "us-west-1"] }], endpoint: u2, [G]: h2 }, { conditions: [{ [H]: d2, [I]: [q2, "us-west-2"] }], endpoint: u2, [G]: h2 }, { endpoint: { url: i3, properties: { authSchemes: [{ name: e2, signingName: f2, signingRegion: "{Region}" }] }, headers: v2 }, [G]: h2 }], [G]: j2 }, { conditions: C, rules: [{ conditions: D, error: "Invalid Configuration: FIPS and custom endpoint are not supported", [G]: k3 }, { conditions: E, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", [G]: k3 }, { endpoint: { url: o2, properties: v2, headers: v2 }, [G]: h2 }], [G]: j2 }, { conditions: [p2], rules: [{ conditions: [r2], rules: [{ conditions: [x3, y], rules: [{ conditions: [{ [H]: c2, [I]: [b2, z] }, B], rules: [{ endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v2, headers: v2 }, [G]: h2 }], [G]: j2 }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", [G]: k3 }], [G]: j2 }, { conditions: D, rules: [{ conditions: [{ [H]: c2, [I]: [z, b2] }], rules: [{ conditions: [{ [H]: d2, [I]: [{ [H]: l2, [I]: [A, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://sts.{Region}.amazonaws.com", properties: v2, headers: v2 }, [G]: h2 }, { endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}", properties: v2, headers: v2 }, [G]: h2 }], [G]: j2 }, { error: "FIPS is enabled but this partition does not support FIPS", [G]: k3 }], [G]: j2 }, { conditions: E, rules: [{ conditions: [B], rules: [{ endpoint: { url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v2, headers: v2 }, [G]: h2 }], [G]: j2 }, { error: "DualStack is enabled but this partition does not support DualStack", [G]: k3 }], [G]: j2 }, w2, { endpoint: { url: i3, properties: v2, headers: v2 }, [G]: h2 }], [G]: j2 }], [G]: j2 }, { error: "Invalid Configuration: Missing Region", [G]: k3 }] };
  exports.ruleSet = _data2;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/endpoint/endpointResolver.js
var require_endpointResolver2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultEndpointResolver = undefined;
  var util_endpoints_1 = require_dist_cjs23();
  var util_endpoints_2 = require_dist_cjs20();
  var ruleset_1 = require_ruleset2();
  var cache2 = new util_endpoints_2.EndpointCache({
    size: 50,
    params: ["Endpoint", "Region", "UseDualStack", "UseFIPS", "UseGlobalEndpoint"]
  });
  var defaultEndpointResolver2 = (endpointParams, context = {}) => {
    return cache2.get(endpointParams, () => (0, util_endpoints_2.resolveEndpoint)(ruleset_1.ruleSet, {
      endpointParams,
      logger: context.logger
    }));
  };
  exports.defaultEndpointResolver = defaultEndpointResolver2;
  util_endpoints_2.customEndpointFunctions.aws = util_endpoints_1.awsEndpointFunctions;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/runtimeConfig.shared.js
var require_runtimeConfig_shared2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var core_1 = require_dist_cjs30();
  var core_2 = require_dist_cjs19();
  var smithy_client_1 = require_dist_cjs28();
  var url_parser_1 = require_dist_cjs22();
  var util_base64_1 = require_dist_cjs11();
  var util_utf8_1 = require_dist_cjs10();
  var httpAuthSchemeProvider_1 = require_httpAuthSchemeProvider2();
  var endpointResolver_1 = require_endpointResolver2();
  var getRuntimeConfig3 = (config) => {
    return {
      apiVersion: "2011-06-15",
      base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
      base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
      disableHostPrefix: config?.disableHostPrefix ?? false,
      endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
      extensions: config?.extensions ?? [],
      httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? httpAuthSchemeProvider_1.defaultSTSHttpAuthSchemeProvider,
      httpAuthSchemes: config?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
          signer: new core_1.AwsSdkSigV4Signer
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new core_2.NoAuthSigner
        }
      ],
      logger: config?.logger ?? new smithy_client_1.NoOpLogger,
      serviceId: config?.serviceId ?? "STS",
      urlParser: config?.urlParser ?? url_parser_1.parseUrl,
      utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
      utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig3;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/runtimeConfig.js
var require_runtimeConfig2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeConfig = undefined;
  var tslib_1 = require_tslib();
  var package_json_1 = tslib_1.__importDefault(require_package());
  var core_1 = require_dist_cjs30();
  var util_user_agent_node_1 = require_dist_cjs41();
  var config_resolver_1 = require_dist_cjs33();
  var core_2 = require_dist_cjs19();
  var hash_node_1 = require_dist_cjs42();
  var middleware_retry_1 = require_dist_cjs40();
  var node_config_provider_1 = require_dist_cjs36();
  var node_http_handler_1 = require_dist_cjs14();
  var util_body_length_node_1 = require_dist_cjs43();
  var util_retry_1 = require_dist_cjs39();
  var runtimeConfig_shared_1 = require_runtimeConfig_shared2();
  var smithy_client_1 = require_dist_cjs28();
  var util_defaults_mode_node_1 = require_dist_cjs44();
  var smithy_client_2 = require_dist_cjs28();
  var getRuntimeConfig3 = (config) => {
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    (0, core_1.emitWarningIfUnsupportedVersion)(process.version);
    const loaderConfig = {
      profile: config?.profile,
      logger: clientSharedValues.logger
    };
    return {
      ...clientSharedValues,
      ...config,
      runtime: "node",
      defaultsMode,
      authSchemePreference: config?.authSchemePreference ?? (0, node_config_provider_1.loadConfig)(core_1.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
      bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
      defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, util_user_agent_node_1.createDefaultUserAgentProvider)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
      httpAuthSchemes: config?.httpAuthSchemes ?? [
        {
          schemeId: "aws.auth#sigv4",
          identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4") || (async (idProps) => await config.credentialDefaultProvider(idProps?.__config || {})()),
          signer: new core_1.AwsSdkSigV4Signer
        },
        {
          schemeId: "smithy.api#noAuth",
          identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
          signer: new core_2.NoAuthSigner
        }
      ],
      maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
      region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, { ...config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS, ...loaderConfig }),
      requestHandler: node_http_handler_1.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
      retryMode: config?.retryMode ?? (0, node_config_provider_1.loadConfig)({
        ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
        default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
      }, config),
      sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
      streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
      useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
      useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
      userAgentAppId: config?.userAgentAppId ?? (0, node_config_provider_1.loadConfig)(util_user_agent_node_1.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
    };
  };
  exports.getRuntimeConfig = getRuntimeConfig3;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/auth/httpAuthExtensionConfiguration.js
var require_httpAuthExtensionConfiguration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveHttpAuthRuntimeConfig = exports.getHttpAuthExtensionConfiguration = undefined;
  var getHttpAuthExtensionConfiguration2 = (runtimeConfig) => {
    const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
    let _credentials = runtimeConfig.credentials;
    return {
      setHttpAuthScheme(httpAuthScheme) {
        const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
        if (index === -1) {
          _httpAuthSchemes.push(httpAuthScheme);
        } else {
          _httpAuthSchemes.splice(index, 1, httpAuthScheme);
        }
      },
      httpAuthSchemes() {
        return _httpAuthSchemes;
      },
      setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
        _httpAuthSchemeProvider = httpAuthSchemeProvider;
      },
      httpAuthSchemeProvider() {
        return _httpAuthSchemeProvider;
      },
      setCredentials(credentials) {
        _credentials = credentials;
      },
      credentials() {
        return _credentials;
      }
    };
  };
  exports.getHttpAuthExtensionConfiguration = getHttpAuthExtensionConfiguration2;
  var resolveHttpAuthRuntimeConfig2 = (config) => {
    return {
      httpAuthSchemes: config.httpAuthSchemes(),
      httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
      credentials: config.credentials()
    };
  };
  exports.resolveHttpAuthRuntimeConfig = resolveHttpAuthRuntimeConfig2;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/runtimeExtensions.js
var require_runtimeExtensions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveRuntimeExtensions = undefined;
  var region_config_resolver_1 = require_dist_cjs45();
  var protocol_http_1 = require_dist_cjs3();
  var smithy_client_1 = require_dist_cjs28();
  var httpAuthExtensionConfiguration_1 = require_httpAuthExtensionConfiguration();
  var resolveRuntimeExtensions2 = (runtimeConfig, extensions2) => {
    const extensionConfiguration = Object.assign((0, region_config_resolver_1.getAwsRegionExtensionConfiguration)(runtimeConfig), (0, smithy_client_1.getDefaultExtensionConfiguration)(runtimeConfig), (0, protocol_http_1.getHttpHandlerExtensionConfiguration)(runtimeConfig), (0, httpAuthExtensionConfiguration_1.getHttpAuthExtensionConfiguration)(runtimeConfig));
    extensions2.forEach((extension) => extension.configure(extensionConfiguration));
    return Object.assign(runtimeConfig, (0, region_config_resolver_1.resolveAwsRegionExtensionConfiguration)(extensionConfiguration), (0, smithy_client_1.resolveDefaultRuntimeConfig)(extensionConfiguration), (0, protocol_http_1.resolveHttpHandlerRuntimeConfig)(extensionConfiguration), (0, httpAuthExtensionConfiguration_1.resolveHttpAuthRuntimeConfig)(extensionConfiguration));
  };
  exports.resolveRuntimeExtensions = resolveRuntimeExtensions2;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/STSClient.js
var require_STSClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.STSClient = exports.__Client = undefined;
  var middleware_host_header_1 = require_dist_cjs4();
  var middleware_logger_1 = require_dist_cjs5();
  var middleware_recursion_detection_1 = require_dist_cjs6();
  var middleware_user_agent_1 = require_dist_cjs31();
  var config_resolver_1 = require_dist_cjs33();
  var core_1 = require_dist_cjs19();
  var middleware_content_length_1 = require_dist_cjs34();
  var middleware_endpoint_1 = require_dist_cjs37();
  var middleware_retry_1 = require_dist_cjs40();
  var smithy_client_1 = require_dist_cjs28();
  Object.defineProperty(exports, "__Client", { enumerable: true, get: function() {
    return smithy_client_1.Client;
  } });
  var httpAuthSchemeProvider_1 = require_httpAuthSchemeProvider2();
  var EndpointParameters_1 = require_EndpointParameters();
  var runtimeConfig_1 = require_runtimeConfig2();
  var runtimeExtensions_1 = require_runtimeExtensions();

  class STSClient extends smithy_client_1.Client {
    config;
    constructor(...[configuration]) {
      const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration || {});
      super(_config_0);
      this.initConfig = _config_0;
      const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
      const _config_2 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_1);
      const _config_3 = (0, middleware_retry_1.resolveRetryConfig)(_config_2);
      const _config_4 = (0, config_resolver_1.resolveRegionConfig)(_config_3);
      const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
      const _config_6 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_5);
      const _config_7 = (0, httpAuthSchemeProvider_1.resolveHttpAuthSchemeConfig)(_config_6);
      const _config_8 = (0, runtimeExtensions_1.resolveRuntimeExtensions)(_config_7, configuration?.extensions || []);
      this.config = _config_8;
      this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
      this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
      this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
      this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
      this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
      this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
      this.middlewareStack.use((0, core_1.getHttpAuthSchemeEndpointRuleSetPlugin)(this.config, {
        httpAuthSchemeParametersProvider: httpAuthSchemeProvider_1.defaultSTSHttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (config) => new core_1.DefaultIdentityProviderConfig({
          "aws.auth#sigv4": config.credentials
        })
      }));
      this.middlewareStack.use((0, core_1.getHttpSigningPlugin)(this.config));
    }
    destroy() {
      super.destroy();
    }
  }
  exports.STSClient = STSClient;
});

// node_modules/@aws-sdk/nested-clients/dist-cjs/submodules/sts/index.js
var require_sts = __commonJS((exports) => {
  var STSClient = require_STSClient();
  var smithyClient = require_dist_cjs28();
  var middlewareEndpoint = require_dist_cjs37();
  var middlewareSerde = require_dist_cjs7();
  var EndpointParameters = require_EndpointParameters();
  var core2 = require_dist_cjs30();
  var protocolHttp = require_dist_cjs3();
  var client = require_client();

  class STSServiceException extends smithyClient.ServiceException {
    constructor(options) {
      super(options);
      Object.setPrototypeOf(this, STSServiceException.prototype);
    }
  }
  var CredentialsFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.SecretAccessKey && { SecretAccessKey: smithyClient.SENSITIVE_STRING }
  });
  var AssumeRoleResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }
  });

  class ExpiredTokenException extends STSServiceException {
    name = "ExpiredTokenException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "ExpiredTokenException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, ExpiredTokenException.prototype);
    }
  }

  class MalformedPolicyDocumentException extends STSServiceException {
    name = "MalformedPolicyDocumentException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "MalformedPolicyDocumentException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, MalformedPolicyDocumentException.prototype);
    }
  }

  class PackedPolicyTooLargeException extends STSServiceException {
    name = "PackedPolicyTooLargeException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "PackedPolicyTooLargeException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, PackedPolicyTooLargeException.prototype);
    }
  }

  class RegionDisabledException extends STSServiceException {
    name = "RegionDisabledException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "RegionDisabledException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, RegionDisabledException.prototype);
    }
  }

  class IDPRejectedClaimException extends STSServiceException {
    name = "IDPRejectedClaimException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "IDPRejectedClaimException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, IDPRejectedClaimException.prototype);
    }
  }

  class InvalidIdentityTokenException extends STSServiceException {
    name = "InvalidIdentityTokenException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "InvalidIdentityTokenException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, InvalidIdentityTokenException.prototype);
    }
  }
  var AssumeRoleWithWebIdentityRequestFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.WebIdentityToken && { WebIdentityToken: smithyClient.SENSITIVE_STRING }
  });
  var AssumeRoleWithWebIdentityResponseFilterSensitiveLog = (obj) => ({
    ...obj,
    ...obj.Credentials && { Credentials: CredentialsFilterSensitiveLog(obj.Credentials) }
  });

  class IDPCommunicationErrorException extends STSServiceException {
    name = "IDPCommunicationErrorException";
    $fault = "client";
    constructor(opts) {
      super({
        name: "IDPCommunicationErrorException",
        $fault: "client",
        ...opts
      });
      Object.setPrototypeOf(this, IDPCommunicationErrorException.prototype);
    }
  }
  var se_AssumeRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
      ...se_AssumeRoleRequest(input),
      [_A]: _AR,
      [_V]: _2
    });
    return buildHttpRpcRequest2(context, headers, "/", undefined, body);
  };
  var se_AssumeRoleWithWebIdentityCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
      ...se_AssumeRoleWithWebIdentityRequest(input),
      [_A]: _ARWWI,
      [_V]: _2
    });
    return buildHttpRpcRequest2(context, headers, "/", undefined, body);
  };
  var de_AssumeRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
      return de_CommandError3(output, context);
    }
    const data = await core2.parseXmlBody(output.body, context);
    let contents = {};
    contents = de_AssumeRoleResponse(data.AssumeRoleResult);
    const response = {
      $metadata: deserializeMetadata3(output),
      ...contents
    };
    return response;
  };
  var de_AssumeRoleWithWebIdentityCommand = async (output, context) => {
    if (output.statusCode >= 300) {
      return de_CommandError3(output, context);
    }
    const data = await core2.parseXmlBody(output.body, context);
    let contents = {};
    contents = de_AssumeRoleWithWebIdentityResponse(data.AssumeRoleWithWebIdentityResult);
    const response = {
      $metadata: deserializeMetadata3(output),
      ...contents
    };
    return response;
  };
  var de_CommandError3 = async (output, context) => {
    const parsedOutput = {
      ...output,
      body: await core2.parseXmlErrorBody(output.body, context)
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
      case "ExpiredTokenException":
      case "com.amazonaws.sts#ExpiredTokenException":
        throw await de_ExpiredTokenExceptionRes(parsedOutput);
      case "MalformedPolicyDocument":
      case "com.amazonaws.sts#MalformedPolicyDocumentException":
        throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput);
      case "PackedPolicyTooLarge":
      case "com.amazonaws.sts#PackedPolicyTooLargeException":
        throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput);
      case "RegionDisabledException":
      case "com.amazonaws.sts#RegionDisabledException":
        throw await de_RegionDisabledExceptionRes(parsedOutput);
      case "IDPCommunicationError":
      case "com.amazonaws.sts#IDPCommunicationErrorException":
        throw await de_IDPCommunicationErrorExceptionRes(parsedOutput);
      case "IDPRejectedClaim":
      case "com.amazonaws.sts#IDPRejectedClaimException":
        throw await de_IDPRejectedClaimExceptionRes(parsedOutput);
      case "InvalidIdentityToken":
      case "com.amazonaws.sts#InvalidIdentityTokenException":
        throw await de_InvalidIdentityTokenExceptionRes(parsedOutput);
      default:
        const parsedBody = parsedOutput.body;
        return throwDefaultError3({
          output,
          parsedBody: parsedBody.Error,
          errorCode
        });
    }
  };
  var de_ExpiredTokenExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ExpiredTokenException(body.Error);
    const exception = new ExpiredTokenException({
      $metadata: deserializeMetadata3(parsedOutput),
      ...deserialized
    });
    return smithyClient.decorateServiceException(exception, body);
  };
  var de_IDPCommunicationErrorExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IDPCommunicationErrorException(body.Error);
    const exception = new IDPCommunicationErrorException({
      $metadata: deserializeMetadata3(parsedOutput),
      ...deserialized
    });
    return smithyClient.decorateServiceException(exception, body);
  };
  var de_IDPRejectedClaimExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IDPRejectedClaimException(body.Error);
    const exception = new IDPRejectedClaimException({
      $metadata: deserializeMetadata3(parsedOutput),
      ...deserialized
    });
    return smithyClient.decorateServiceException(exception, body);
  };
  var de_InvalidIdentityTokenExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidIdentityTokenException(body.Error);
    const exception = new InvalidIdentityTokenException({
      $metadata: deserializeMetadata3(parsedOutput),
      ...deserialized
    });
    return smithyClient.decorateServiceException(exception, body);
  };
  var de_MalformedPolicyDocumentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_MalformedPolicyDocumentException(body.Error);
    const exception = new MalformedPolicyDocumentException({
      $metadata: deserializeMetadata3(parsedOutput),
      ...deserialized
    });
    return smithyClient.decorateServiceException(exception, body);
  };
  var de_PackedPolicyTooLargeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PackedPolicyTooLargeException(body.Error);
    const exception = new PackedPolicyTooLargeException({
      $metadata: deserializeMetadata3(parsedOutput),
      ...deserialized
    });
    return smithyClient.decorateServiceException(exception, body);
  };
  var de_RegionDisabledExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_RegionDisabledException(body.Error);
    const exception = new RegionDisabledException({
      $metadata: deserializeMetadata3(parsedOutput),
      ...deserialized
    });
    return smithyClient.decorateServiceException(exception, body);
  };
  var se_AssumeRoleRequest = (input, context) => {
    const entries = {};
    if (input[_RA] != null) {
      entries[_RA] = input[_RA];
    }
    if (input[_RSN] != null) {
      entries[_RSN] = input[_RSN];
    }
    if (input[_PA] != null) {
      const memberEntries = se_policyDescriptorListType(input[_PA]);
      if (input[_PA]?.length === 0) {
        entries.PolicyArns = [];
      }
      Object.entries(memberEntries).forEach(([key, value]) => {
        const loc = `PolicyArns.${key}`;
        entries[loc] = value;
      });
    }
    if (input[_P] != null) {
      entries[_P] = input[_P];
    }
    if (input[_DS] != null) {
      entries[_DS] = input[_DS];
    }
    if (input[_T] != null) {
      const memberEntries = se_tagListType(input[_T]);
      if (input[_T]?.length === 0) {
        entries.Tags = [];
      }
      Object.entries(memberEntries).forEach(([key, value]) => {
        const loc = `Tags.${key}`;
        entries[loc] = value;
      });
    }
    if (input[_TTK] != null) {
      const memberEntries = se_tagKeyListType(input[_TTK]);
      if (input[_TTK]?.length === 0) {
        entries.TransitiveTagKeys = [];
      }
      Object.entries(memberEntries).forEach(([key, value]) => {
        const loc = `TransitiveTagKeys.${key}`;
        entries[loc] = value;
      });
    }
    if (input[_EI] != null) {
      entries[_EI] = input[_EI];
    }
    if (input[_SN] != null) {
      entries[_SN] = input[_SN];
    }
    if (input[_TC] != null) {
      entries[_TC] = input[_TC];
    }
    if (input[_SI] != null) {
      entries[_SI] = input[_SI];
    }
    if (input[_PC] != null) {
      const memberEntries = se_ProvidedContextsListType(input[_PC]);
      if (input[_PC]?.length === 0) {
        entries.ProvidedContexts = [];
      }
      Object.entries(memberEntries).forEach(([key, value]) => {
        const loc = `ProvidedContexts.${key}`;
        entries[loc] = value;
      });
    }
    return entries;
  };
  var se_AssumeRoleWithWebIdentityRequest = (input, context) => {
    const entries = {};
    if (input[_RA] != null) {
      entries[_RA] = input[_RA];
    }
    if (input[_RSN] != null) {
      entries[_RSN] = input[_RSN];
    }
    if (input[_WIT] != null) {
      entries[_WIT] = input[_WIT];
    }
    if (input[_PI] != null) {
      entries[_PI] = input[_PI];
    }
    if (input[_PA] != null) {
      const memberEntries = se_policyDescriptorListType(input[_PA]);
      if (input[_PA]?.length === 0) {
        entries.PolicyArns = [];
      }
      Object.entries(memberEntries).forEach(([key, value]) => {
        const loc = `PolicyArns.${key}`;
        entries[loc] = value;
      });
    }
    if (input[_P] != null) {
      entries[_P] = input[_P];
    }
    if (input[_DS] != null) {
      entries[_DS] = input[_DS];
    }
    return entries;
  };
  var se_policyDescriptorListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
      if (entry === null) {
        continue;
      }
      const memberEntries = se_PolicyDescriptorType(entry);
      Object.entries(memberEntries).forEach(([key, value]) => {
        entries[`member.${counter}.${key}`] = value;
      });
      counter++;
    }
    return entries;
  };
  var se_PolicyDescriptorType = (input, context) => {
    const entries = {};
    if (input[_a2] != null) {
      entries[_a2] = input[_a2];
    }
    return entries;
  };
  var se_ProvidedContext = (input, context) => {
    const entries = {};
    if (input[_PAr] != null) {
      entries[_PAr] = input[_PAr];
    }
    if (input[_CA] != null) {
      entries[_CA] = input[_CA];
    }
    return entries;
  };
  var se_ProvidedContextsListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
      if (entry === null) {
        continue;
      }
      const memberEntries = se_ProvidedContext(entry);
      Object.entries(memberEntries).forEach(([key, value]) => {
        entries[`member.${counter}.${key}`] = value;
      });
      counter++;
    }
    return entries;
  };
  var se_Tag = (input, context) => {
    const entries = {};
    if (input[_K] != null) {
      entries[_K] = input[_K];
    }
    if (input[_Va] != null) {
      entries[_Va] = input[_Va];
    }
    return entries;
  };
  var se_tagKeyListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
      if (entry === null) {
        continue;
      }
      entries[`member.${counter}`] = entry;
      counter++;
    }
    return entries;
  };
  var se_tagListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
      if (entry === null) {
        continue;
      }
      const memberEntries = se_Tag(entry);
      Object.entries(memberEntries).forEach(([key, value]) => {
        entries[`member.${counter}.${key}`] = value;
      });
      counter++;
    }
    return entries;
  };
  var de_AssumedRoleUser = (output, context) => {
    const contents = {};
    if (output[_ARI] != null) {
      contents[_ARI] = smithyClient.expectString(output[_ARI]);
    }
    if (output[_Ar] != null) {
      contents[_Ar] = smithyClient.expectString(output[_Ar]);
    }
    return contents;
  };
  var de_AssumeRoleResponse = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
      contents[_C] = de_Credentials(output[_C]);
    }
    if (output[_ARU] != null) {
      contents[_ARU] = de_AssumedRoleUser(output[_ARU]);
    }
    if (output[_PPS] != null) {
      contents[_PPS] = smithyClient.strictParseInt32(output[_PPS]);
    }
    if (output[_SI] != null) {
      contents[_SI] = smithyClient.expectString(output[_SI]);
    }
    return contents;
  };
  var de_AssumeRoleWithWebIdentityResponse = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
      contents[_C] = de_Credentials(output[_C]);
    }
    if (output[_SFWIT] != null) {
      contents[_SFWIT] = smithyClient.expectString(output[_SFWIT]);
    }
    if (output[_ARU] != null) {
      contents[_ARU] = de_AssumedRoleUser(output[_ARU]);
    }
    if (output[_PPS] != null) {
      contents[_PPS] = smithyClient.strictParseInt32(output[_PPS]);
    }
    if (output[_Pr] != null) {
      contents[_Pr] = smithyClient.expectString(output[_Pr]);
    }
    if (output[_Au] != null) {
      contents[_Au] = smithyClient.expectString(output[_Au]);
    }
    if (output[_SI] != null) {
      contents[_SI] = smithyClient.expectString(output[_SI]);
    }
    return contents;
  };
  var de_Credentials = (output, context) => {
    const contents = {};
    if (output[_AKI] != null) {
      contents[_AKI] = smithyClient.expectString(output[_AKI]);
    }
    if (output[_SAK] != null) {
      contents[_SAK] = smithyClient.expectString(output[_SAK]);
    }
    if (output[_ST] != null) {
      contents[_ST] = smithyClient.expectString(output[_ST]);
    }
    if (output[_E] != null) {
      contents[_E] = smithyClient.expectNonNull(smithyClient.parseRfc3339DateTimeWithOffset(output[_E]));
    }
    return contents;
  };
  var de_ExpiredTokenException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
      contents[_m] = smithyClient.expectString(output[_m]);
    }
    return contents;
  };
  var de_IDPCommunicationErrorException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
      contents[_m] = smithyClient.expectString(output[_m]);
    }
    return contents;
  };
  var de_IDPRejectedClaimException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
      contents[_m] = smithyClient.expectString(output[_m]);
    }
    return contents;
  };
  var de_InvalidIdentityTokenException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
      contents[_m] = smithyClient.expectString(output[_m]);
    }
    return contents;
  };
  var de_MalformedPolicyDocumentException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
      contents[_m] = smithyClient.expectString(output[_m]);
    }
    return contents;
  };
  var de_PackedPolicyTooLargeException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
      contents[_m] = smithyClient.expectString(output[_m]);
    }
    return contents;
  };
  var de_RegionDisabledException = (output, context) => {
    const contents = {};
    if (output[_m] != null) {
      contents[_m] = smithyClient.expectString(output[_m]);
    }
    return contents;
  };
  var deserializeMetadata3 = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"]
  });
  var throwDefaultError3 = smithyClient.withBaseException(STSServiceException);
  var buildHttpRpcRequest2 = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
      protocol,
      hostname,
      port,
      method: "POST",
      path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
      headers
    };
    if (body !== undefined) {
      contents.body = body;
    }
    return new protocolHttp.HttpRequest(contents);
  };
  var SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded"
  };
  var _2 = "2011-06-15";
  var _A = "Action";
  var _AKI = "AccessKeyId";
  var _AR = "AssumeRole";
  var _ARI = "AssumedRoleId";
  var _ARU = "AssumedRoleUser";
  var _ARWWI = "AssumeRoleWithWebIdentity";
  var _Ar = "Arn";
  var _Au = "Audience";
  var _C = "Credentials";
  var _CA = "ContextAssertion";
  var _DS = "DurationSeconds";
  var _E = "Expiration";
  var _EI = "ExternalId";
  var _K = "Key";
  var _P = "Policy";
  var _PA = "PolicyArns";
  var _PAr = "ProviderArn";
  var _PC = "ProvidedContexts";
  var _PI = "ProviderId";
  var _PPS = "PackedPolicySize";
  var _Pr = "Provider";
  var _RA = "RoleArn";
  var _RSN = "RoleSessionName";
  var _SAK = "SecretAccessKey";
  var _SFWIT = "SubjectFromWebIdentityToken";
  var _SI = "SourceIdentity";
  var _SN = "SerialNumber";
  var _ST = "SessionToken";
  var _T = "Tags";
  var _TC = "TokenCode";
  var _TTK = "TransitiveTagKeys";
  var _V = "Version";
  var _Va = "Value";
  var _WIT = "WebIdentityToken";
  var _a2 = "arn";
  var _m = "message";
  var buildFormUrlencodedString = (formEntries) => Object.entries(formEntries).map(([key, value]) => smithyClient.extendedEncodeURIComponent(key) + "=" + smithyClient.extendedEncodeURIComponent(value)).join("&");
  var loadQueryErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
      return data.Error.Code;
    }
    if (output.statusCode == 404) {
      return "NotFound";
    }
  };

  class AssumeRoleCommand extends smithyClient.Command.classBuilder().ep(EndpointParameters.commonParams).m(function(Command, cs, config, o2) {
    return [
      middlewareSerde.getSerdePlugin(config, this.serialize, this.deserialize),
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("AWSSecurityTokenServiceV20110615", "AssumeRole", {}).n("STSClient", "AssumeRoleCommand").f(undefined, AssumeRoleResponseFilterSensitiveLog).ser(se_AssumeRoleCommand).de(de_AssumeRoleCommand).build() {
  }

  class AssumeRoleWithWebIdentityCommand extends smithyClient.Command.classBuilder().ep(EndpointParameters.commonParams).m(function(Command, cs, config, o2) {
    return [
      middlewareSerde.getSerdePlugin(config, this.serialize, this.deserialize),
      middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithWebIdentity", {}).n("STSClient", "AssumeRoleWithWebIdentityCommand").f(AssumeRoleWithWebIdentityRequestFilterSensitiveLog, AssumeRoleWithWebIdentityResponseFilterSensitiveLog).ser(se_AssumeRoleWithWebIdentityCommand).de(de_AssumeRoleWithWebIdentityCommand).build() {
  }
  var commands3 = {
    AssumeRoleCommand,
    AssumeRoleWithWebIdentityCommand
  };

  class STS extends STSClient.STSClient {
  }
  smithyClient.createAggregatedClient(commands3, STS);
  var ASSUME_ROLE_DEFAULT_REGION = "us-east-1";
  var getAccountIdFromAssumedRoleUser = (assumedRoleUser) => {
    if (typeof assumedRoleUser?.Arn === "string") {
      const arnComponents = assumedRoleUser.Arn.split(":");
      if (arnComponents.length > 4 && arnComponents[4] !== "") {
        return arnComponents[4];
      }
    }
    return;
  };
  var resolveRegion = async (_region, _parentRegion, credentialProviderLogger) => {
    const region = typeof _region === "function" ? await _region() : _region;
    const parentRegion = typeof _parentRegion === "function" ? await _parentRegion() : _parentRegion;
    credentialProviderLogger?.debug?.("@aws-sdk/client-sts::resolveRegion", "accepting first of:", `${region} (provider)`, `${parentRegion} (parent client)`, `${ASSUME_ROLE_DEFAULT_REGION} (STS default)`);
    return region ?? parentRegion ?? ASSUME_ROLE_DEFAULT_REGION;
  };
  var getDefaultRoleAssumer$1 = (stsOptions, STSClient2) => {
    let stsClient;
    let closureSourceCreds;
    return async (sourceCreds, params) => {
      closureSourceCreds = sourceCreds;
      if (!stsClient) {
        const { logger = stsOptions?.parentClientConfig?.logger, profile = stsOptions?.parentClientConfig?.profile, region, requestHandler = stsOptions?.parentClientConfig?.requestHandler, credentialProviderLogger } = stsOptions;
        const resolvedRegion = await resolveRegion(region, stsOptions?.parentClientConfig?.region, credentialProviderLogger);
        const isCompatibleRequestHandler = !isH2(requestHandler);
        stsClient = new STSClient2({
          ...stsOptions,
          profile,
          credentialDefaultProvider: () => async () => closureSourceCreds,
          region: resolvedRegion,
          requestHandler: isCompatibleRequestHandler ? requestHandler : undefined,
          logger
        });
      }
      const { Credentials, AssumedRoleUser } = await stsClient.send(new AssumeRoleCommand(params));
      if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
        throw new Error(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`);
      }
      const accountId = getAccountIdFromAssumedRoleUser(AssumedRoleUser);
      const credentials = {
        accessKeyId: Credentials.AccessKeyId,
        secretAccessKey: Credentials.SecretAccessKey,
        sessionToken: Credentials.SessionToken,
        expiration: Credentials.Expiration,
        ...Credentials.CredentialScope && { credentialScope: Credentials.CredentialScope },
        ...accountId && { accountId }
      };
      client.setCredentialFeature(credentials, "CREDENTIALS_STS_ASSUME_ROLE", "i");
      return credentials;
    };
  };
  var getDefaultRoleAssumerWithWebIdentity$1 = (stsOptions, STSClient2) => {
    let stsClient;
    return async (params) => {
      if (!stsClient) {
        const { logger = stsOptions?.parentClientConfig?.logger, profile = stsOptions?.parentClientConfig?.profile, region, requestHandler = stsOptions?.parentClientConfig?.requestHandler, credentialProviderLogger } = stsOptions;
        const resolvedRegion = await resolveRegion(region, stsOptions?.parentClientConfig?.region, credentialProviderLogger);
        const isCompatibleRequestHandler = !isH2(requestHandler);
        stsClient = new STSClient2({
          ...stsOptions,
          profile,
          region: resolvedRegion,
          requestHandler: isCompatibleRequestHandler ? requestHandler : undefined,
          logger
        });
      }
      const { Credentials, AssumedRoleUser } = await stsClient.send(new AssumeRoleWithWebIdentityCommand(params));
      if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
        throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${params.RoleArn}`);
      }
      const accountId = getAccountIdFromAssumedRoleUser(AssumedRoleUser);
      const credentials = {
        accessKeyId: Credentials.AccessKeyId,
        secretAccessKey: Credentials.SecretAccessKey,
        sessionToken: Credentials.SessionToken,
        expiration: Credentials.Expiration,
        ...Credentials.CredentialScope && { credentialScope: Credentials.CredentialScope },
        ...accountId && { accountId }
      };
      if (accountId) {
        client.setCredentialFeature(credentials, "RESOLVED_ACCOUNT_ID", "T");
      }
      client.setCredentialFeature(credentials, "CREDENTIALS_STS_ASSUME_ROLE_WEB_ID", "k");
      return credentials;
    };
  };
  var isH2 = (requestHandler) => {
    return requestHandler?.metadata?.handlerProtocol === "h2";
  };
  var getCustomizableStsClientCtor = (baseCtor, customizations) => {
    if (!customizations)
      return baseCtor;
    else
      return class CustomizableSTSClient extends baseCtor {
        constructor(config) {
          super(config);
          for (const customization of customizations) {
            this.middlewareStack.use(customization);
          }
        }
      };
  };
  var getDefaultRoleAssumer = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumer$1(stsOptions, getCustomizableStsClientCtor(STSClient.STSClient, stsPlugins));
  var getDefaultRoleAssumerWithWebIdentity = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumerWithWebIdentity$1(stsOptions, getCustomizableStsClientCtor(STSClient.STSClient, stsPlugins));
  var decorateDefaultCredentialProvider = (provider) => (input) => provider({
    roleAssumer: getDefaultRoleAssumer(input),
    roleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity(input),
    ...input
  });
  Object.defineProperty(exports, "$Command", {
    enumerable: true,
    get: function() {
      return smithyClient.Command;
    }
  });
  exports.AssumeRoleCommand = AssumeRoleCommand;
  exports.AssumeRoleResponseFilterSensitiveLog = AssumeRoleResponseFilterSensitiveLog;
  exports.AssumeRoleWithWebIdentityCommand = AssumeRoleWithWebIdentityCommand;
  exports.AssumeRoleWithWebIdentityRequestFilterSensitiveLog = AssumeRoleWithWebIdentityRequestFilterSensitiveLog;
  exports.AssumeRoleWithWebIdentityResponseFilterSensitiveLog = AssumeRoleWithWebIdentityResponseFilterSensitiveLog;
  exports.CredentialsFilterSensitiveLog = CredentialsFilterSensitiveLog;
  exports.ExpiredTokenException = ExpiredTokenException;
  exports.IDPCommunicationErrorException = IDPCommunicationErrorException;
  exports.IDPRejectedClaimException = IDPRejectedClaimException;
  exports.InvalidIdentityTokenException = InvalidIdentityTokenException;
  exports.MalformedPolicyDocumentException = MalformedPolicyDocumentException;
  exports.PackedPolicyTooLargeException = PackedPolicyTooLargeException;
  exports.RegionDisabledException = RegionDisabledException;
  exports.STS = STS;
  exports.STSServiceException = STSServiceException;
  exports.decorateDefaultCredentialProvider = decorateDefaultCredentialProvider;
  exports.getDefaultRoleAssumer = getDefaultRoleAssumer;
  exports.getDefaultRoleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity;
  Object.keys(STSClient).forEach(function(k3) {
    if (k3 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k3))
      Object.defineProperty(exports, k3, {
        enumerable: true,
        get: function() {
          return STSClient[k3];
        }
      });
  });
});

// node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveAssumeRoleCredentials.js
var import_client5, import_property_provider17, import_shared_ini_file_loader5, isAssumeRoleProfile = (arg, { profile = "default", logger } = {}) => {
  return Boolean(arg) && typeof arg === "object" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof arg.external_id) > -1 && ["undefined", "string"].indexOf(typeof arg.mfa_serial) > -1 && (isAssumeRoleWithSourceProfile(arg, { profile, logger }) || isCredentialSourceProfile(arg, { profile, logger }));
}, isAssumeRoleWithSourceProfile = (arg, { profile, logger }) => {
  const withSourceProfile = typeof arg.source_profile === "string" && typeof arg.credential_source === "undefined";
  if (withSourceProfile) {
    logger?.debug?.(`    ${profile} isAssumeRoleWithSourceProfile source_profile=${arg.source_profile}`);
  }
  return withSourceProfile;
}, isCredentialSourceProfile = (arg, { profile, logger }) => {
  const withProviderProfile = typeof arg.credential_source === "string" && typeof arg.source_profile === "undefined";
  if (withProviderProfile) {
    logger?.debug?.(`    ${profile} isCredentialSourceProfile credential_source=${arg.credential_source}`);
  }
  return withProviderProfile;
}, resolveAssumeRoleCredentials = async (profileName, profiles, options, visitedProfiles = {}, resolveProfileData) => {
  options.logger?.debug("@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)");
  const profileData = profiles[profileName];
  const { source_profile, region } = profileData;
  if (!options.roleAssumer) {
    const { getDefaultRoleAssumer } = await Promise.resolve().then(() => __toESM(require_sts(), 1));
    options.roleAssumer = getDefaultRoleAssumer({
      ...options.clientConfig,
      credentialProviderLogger: options.logger,
      parentClientConfig: {
        ...options?.parentClientConfig,
        region: region ?? options?.parentClientConfig?.region
      }
    }, options.clientPlugins);
  }
  if (source_profile && source_profile in visitedProfiles) {
    throw new import_property_provider17.CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile ${import_shared_ini_file_loader5.getProfileName(options)}. Profiles visited: ` + Object.keys(visitedProfiles).join(", "), { logger: options.logger });
  }
  options.logger?.debug(`@aws-sdk/credential-provider-ini - finding credential resolver using ${source_profile ? `source_profile=[${source_profile}]` : `profile=[${profileName}]`}`);
  const sourceCredsProvider = source_profile ? resolveProfileData(source_profile, profiles, options, {
    ...visitedProfiles,
    [source_profile]: true
  }, isCredentialSourceWithoutRoleArn(profiles[source_profile] ?? {})) : (await resolveCredentialSource(profileData.credential_source, profileName, options.logger)(options))();
  if (isCredentialSourceWithoutRoleArn(profileData)) {
    return sourceCredsProvider.then((creds) => import_client5.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"));
  } else {
    const params = {
      RoleArn: profileData.role_arn,
      RoleSessionName: profileData.role_session_name || `aws-sdk-js-${Date.now()}`,
      ExternalId: profileData.external_id,
      DurationSeconds: parseInt(profileData.duration_seconds || "3600", 10)
    };
    const { mfa_serial } = profileData;
    if (mfa_serial) {
      if (!options.mfaCodeProvider) {
        throw new import_property_provider17.CredentialsProviderError(`Profile ${profileName} requires multi-factor authentication, but no MFA code callback was provided.`, { logger: options.logger, tryNextLink: false });
      }
      params.SerialNumber = mfa_serial;
      params.TokenCode = await options.mfaCodeProvider(mfa_serial);
    }
    const sourceCreds = await sourceCredsProvider;
    return options.roleAssumer(sourceCreds, params).then((creds) => import_client5.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"));
  }
}, isCredentialSourceWithoutRoleArn = (section) => {
  return !section.role_arn && !!section.credential_source;
};
var init_resolveAssumeRoleCredentials = __esm(() => {
  init_resolveCredentialSource();
  import_client5 = __toESM(require_client(), 1);
  import_property_provider17 = __toESM(require_dist_cjs24(), 1);
  import_shared_ini_file_loader5 = __toESM(require_dist_cjs35(), 1);
});

// node_modules/@aws-sdk/credential-provider-process/dist-es/getValidatedProcessCredentials.js
var import_client6, getValidatedProcessCredentials = (profileName, data, profiles) => {
  if (data.Version !== 1) {
    throw Error(`Profile ${profileName} credential_process did not return Version 1.`);
  }
  if (data.AccessKeyId === undefined || data.SecretAccessKey === undefined) {
    throw Error(`Profile ${profileName} credential_process returned invalid credentials.`);
  }
  if (data.Expiration) {
    const currentTime = new Date;
    const expireTime = new Date(data.Expiration);
    if (expireTime < currentTime) {
      throw Error(`Profile ${profileName} credential_process returned expired credentials.`);
    }
  }
  let accountId = data.AccountId;
  if (!accountId && profiles?.[profileName]?.aws_account_id) {
    accountId = profiles[profileName].aws_account_id;
  }
  const credentials = {
    accessKeyId: data.AccessKeyId,
    secretAccessKey: data.SecretAccessKey,
    ...data.SessionToken && { sessionToken: data.SessionToken },
    ...data.Expiration && { expiration: new Date(data.Expiration) },
    ...data.CredentialScope && { credentialScope: data.CredentialScope },
    ...accountId && { accountId }
  };
  import_client6.setCredentialFeature(credentials, "CREDENTIALS_PROCESS", "w");
  return credentials;
};
var init_getValidatedProcessCredentials = __esm(() => {
  import_client6 = __toESM(require_client(), 1);
});

// node_modules/@aws-sdk/credential-provider-process/dist-es/resolveProcessCredentials.js
import { exec } from "child_process";
import { promisify } from "util";
var import_property_provider18, import_shared_ini_file_loader6, resolveProcessCredentials = async (profileName, profiles, logger) => {
  const profile = profiles[profileName];
  if (profiles[profileName]) {
    const credentialProcess = profile["credential_process"];
    if (credentialProcess !== undefined) {
      const execPromise = promisify(import_shared_ini_file_loader6.externalDataInterceptor?.getTokenRecord?.().exec ?? exec);
      try {
        const { stdout } = await execPromise(credentialProcess);
        let data;
        try {
          data = JSON.parse(stdout.trim());
        } catch {
          throw Error(`Profile ${profileName} credential_process returned invalid JSON.`);
        }
        return getValidatedProcessCredentials(profileName, data, profiles);
      } catch (error) {
        throw new import_property_provider18.CredentialsProviderError(error.message, { logger });
      }
    } else {
      throw new import_property_provider18.CredentialsProviderError(`Profile ${profileName} did not contain credential_process.`, { logger });
    }
  } else {
    throw new import_property_provider18.CredentialsProviderError(`Profile ${profileName} could not be found in shared credentials file.`, {
      logger
    });
  }
};
var init_resolveProcessCredentials = __esm(() => {
  init_getValidatedProcessCredentials();
  import_property_provider18 = __toESM(require_dist_cjs24(), 1);
  import_shared_ini_file_loader6 = __toESM(require_dist_cjs35(), 1);
});

// node_modules/@aws-sdk/credential-provider-process/dist-es/fromProcess.js
var import_shared_ini_file_loader7, fromProcess = (init = {}) => async ({ callerClientConfig } = {}) => {
  init.logger?.debug("@aws-sdk/credential-provider-process - fromProcess");
  const profiles = await import_shared_ini_file_loader7.parseKnownFiles(init);
  return resolveProcessCredentials(import_shared_ini_file_loader7.getProfileName({
    profile: init.profile ?? callerClientConfig?.profile
  }), profiles, init.logger);
};
var init_fromProcess = __esm(() => {
  init_resolveProcessCredentials();
  import_shared_ini_file_loader7 = __toESM(require_dist_cjs35(), 1);
});

// node_modules/@aws-sdk/credential-provider-process/dist-es/index.js
var exports_dist_es5 = {};
__export(exports_dist_es5, {
  fromProcess: () => fromProcess
});
var init_dist_es9 = __esm(() => {
  init_fromProcess();
});

// node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProcessCredentials.js
var import_client7, isProcessProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.credential_process === "string", resolveProcessCredentials2 = async (options, profile) => Promise.resolve().then(() => (init_dist_es9(), exports_dist_es5)).then(({ fromProcess: fromProcess3 }) => fromProcess3({
  ...options,
  profile
})().then((creds) => import_client7.setCredentialFeature(creds, "CREDENTIALS_PROFILE_PROCESS", "v")));
var init_resolveProcessCredentials2 = __esm(() => {
  import_client7 = __toESM(require_client(), 1);
});

// node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveSsoCredentials.js
var import_client8, resolveSsoCredentials = async (profile, profileData, options = {}) => {
  const { fromSSO: fromSSO3 } = await Promise.resolve().then(() => (init_dist_es8(), exports_dist_es4));
  return fromSSO3({
    profile,
    logger: options.logger,
    parentClientConfig: options.parentClientConfig,
    clientConfig: options.clientConfig
  })().then((creds) => {
    if (profileData.sso_session) {
      return import_client8.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SSO", "r");
    } else {
      return import_client8.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SSO_LEGACY", "t");
    }
  });
}, isSsoProfile3 = (arg) => arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string");
var init_resolveSsoCredentials = __esm(() => {
  import_client8 = __toESM(require_client(), 1);
});

// node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveStaticCredentials.js
var import_client9, isStaticCredsProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.aws_access_key_id === "string" && typeof arg.aws_secret_access_key === "string" && ["undefined", "string"].indexOf(typeof arg.aws_session_token) > -1 && ["undefined", "string"].indexOf(typeof arg.aws_account_id) > -1, resolveStaticCredentials = async (profile, options) => {
  options?.logger?.debug("@aws-sdk/credential-provider-ini - resolveStaticCredentials");
  const credentials = {
    accessKeyId: profile.aws_access_key_id,
    secretAccessKey: profile.aws_secret_access_key,
    sessionToken: profile.aws_session_token,
    ...profile.aws_credential_scope && { credentialScope: profile.aws_credential_scope },
    ...profile.aws_account_id && { accountId: profile.aws_account_id }
  };
  return import_client9.setCredentialFeature(credentials, "CREDENTIALS_PROFILE", "n");
};
var init_resolveStaticCredentials = __esm(() => {
  import_client9 = __toESM(require_client(), 1);
});

// node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromWebToken.js
var fromWebToken = (init) => async (awsIdentityProperties) => {
  init.logger?.debug("@aws-sdk/credential-provider-web-identity - fromWebToken");
  const { roleArn, roleSessionName, webIdentityToken, providerId, policyArns, policy, durationSeconds } = init;
  let { roleAssumerWithWebIdentity } = init;
  if (!roleAssumerWithWebIdentity) {
    const { getDefaultRoleAssumerWithWebIdentity } = await Promise.resolve().then(() => __toESM(require_sts(), 1));
    roleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity({
      ...init.clientConfig,
      credentialProviderLogger: init.logger,
      parentClientConfig: {
        ...awsIdentityProperties?.callerClientConfig,
        ...init.parentClientConfig
      }
    }, init.clientPlugins);
  }
  return roleAssumerWithWebIdentity({
    RoleArn: roleArn,
    RoleSessionName: roleSessionName ?? `aws-sdk-js-session-${Date.now()}`,
    WebIdentityToken: webIdentityToken,
    ProviderId: providerId,
    PolicyArns: policyArns,
    Policy: policy,
    DurationSeconds: durationSeconds
  });
};

// node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromTokenFile.js
import { readFileSync } from "fs";
var import_client10, import_property_provider19, import_shared_ini_file_loader8, ENV_TOKEN_FILE = "AWS_WEB_IDENTITY_TOKEN_FILE", ENV_ROLE_ARN = "AWS_ROLE_ARN", ENV_ROLE_SESSION_NAME = "AWS_ROLE_SESSION_NAME", fromTokenFile = (init = {}) => async () => {
  init.logger?.debug("@aws-sdk/credential-provider-web-identity - fromTokenFile");
  const webIdentityTokenFile = init?.webIdentityTokenFile ?? process.env[ENV_TOKEN_FILE];
  const roleArn = init?.roleArn ?? process.env[ENV_ROLE_ARN];
  const roleSessionName = init?.roleSessionName ?? process.env[ENV_ROLE_SESSION_NAME];
  if (!webIdentityTokenFile || !roleArn) {
    throw new import_property_provider19.CredentialsProviderError("Web identity configuration not specified", {
      logger: init.logger
    });
  }
  const credentials = await fromWebToken({
    ...init,
    webIdentityToken: import_shared_ini_file_loader8.externalDataInterceptor?.getTokenRecord?.()[webIdentityTokenFile] ?? readFileSync(webIdentityTokenFile, { encoding: "ascii" }),
    roleArn,
    roleSessionName
  })();
  if (webIdentityTokenFile === process.env[ENV_TOKEN_FILE]) {
    import_client10.setCredentialFeature(credentials, "CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN", "h");
  }
  return credentials;
};
var init_fromTokenFile = __esm(() => {
  import_client10 = __toESM(require_client(), 1);
  import_property_provider19 = __toESM(require_dist_cjs24(), 1);
  import_shared_ini_file_loader8 = __toESM(require_dist_cjs35(), 1);
});

// node_modules/@aws-sdk/credential-provider-web-identity/dist-es/index.js
var exports_dist_es6 = {};
__export(exports_dist_es6, {
  fromWebToken: () => fromWebToken,
  fromTokenFile: () => fromTokenFile
});
var init_dist_es10 = __esm(() => {
  init_fromTokenFile();
});

// node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveWebIdentityCredentials.js
var import_client11, isWebIdentityProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.web_identity_token_file === "string" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1, resolveWebIdentityCredentials = async (profile, options) => Promise.resolve().then(() => (init_dist_es10(), exports_dist_es6)).then(({ fromTokenFile: fromTokenFile3 }) => fromTokenFile3({
  webIdentityTokenFile: profile.web_identity_token_file,
  roleArn: profile.role_arn,
  roleSessionName: profile.role_session_name,
  roleAssumerWithWebIdentity: options.roleAssumerWithWebIdentity,
  logger: options.logger,
  parentClientConfig: options.parentClientConfig
})().then((creds) => import_client11.setCredentialFeature(creds, "CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN", "q")));
var init_resolveWebIdentityCredentials = __esm(() => {
  import_client11 = __toESM(require_client(), 1);
});

// node_modules/@aws-sdk/credential-provider-ini/dist-es/resolveProfileData.js
var import_property_provider20, resolveProfileData = async (profileName, profiles, options, visitedProfiles = {}, isAssumeRoleRecursiveCall = false) => {
  const data = profiles[profileName];
  if (Object.keys(visitedProfiles).length > 0 && isStaticCredsProfile(data)) {
    return resolveStaticCredentials(data, options);
  }
  if (isAssumeRoleRecursiveCall || isAssumeRoleProfile(data, { profile: profileName, logger: options.logger })) {
    return resolveAssumeRoleCredentials(profileName, profiles, options, visitedProfiles, resolveProfileData);
  }
  if (isStaticCredsProfile(data)) {
    return resolveStaticCredentials(data, options);
  }
  if (isWebIdentityProfile(data)) {
    return resolveWebIdentityCredentials(data, options);
  }
  if (isProcessProfile(data)) {
    return resolveProcessCredentials2(options, profileName);
  }
  if (isSsoProfile3(data)) {
    return await resolveSsoCredentials(profileName, data, options);
  }
  throw new import_property_provider20.CredentialsProviderError(`Could not resolve credentials using profile: [${profileName}] in configuration/credentials file(s).`, { logger: options.logger });
};
var init_resolveProfileData = __esm(() => {
  init_resolveAssumeRoleCredentials();
  init_resolveProcessCredentials2();
  init_resolveSsoCredentials();
  init_resolveStaticCredentials();
  init_resolveWebIdentityCredentials();
  import_property_provider20 = __toESM(require_dist_cjs24(), 1);
});

// node_modules/@aws-sdk/credential-provider-ini/dist-es/fromIni.js
var import_shared_ini_file_loader9, fromIni = (_init = {}) => async ({ callerClientConfig } = {}) => {
  const init = {
    ..._init,
    parentClientConfig: {
      ...callerClientConfig,
      ..._init.parentClientConfig
    }
  };
  init.logger?.debug("@aws-sdk/credential-provider-ini - fromIni");
  const profiles = await import_shared_ini_file_loader9.parseKnownFiles(init);
  return resolveProfileData(import_shared_ini_file_loader9.getProfileName({
    profile: _init.profile ?? callerClientConfig?.profile
  }), profiles, init);
};
var init_fromIni = __esm(() => {
  init_resolveProfileData();
  import_shared_ini_file_loader9 = __toESM(require_dist_cjs35(), 1);
});

// node_modules/@aws-sdk/credential-provider-ini/dist-es/index.js
var exports_dist_es7 = {};
__export(exports_dist_es7, {
  fromIni: () => fromIni
});
var init_dist_es11 = __esm(() => {
  init_fromIni();
});

// node_modules/@aws-sdk/credential-provider-node/dist-es/defaultProvider.js
var import_property_provider21, import_shared_ini_file_loader10, multipleCredentialSourceWarningEmitted = false, defaultProvider = (init = {}) => import_property_provider21.memoize(import_property_provider21.chain(async () => {
  const profile = init.profile ?? process.env[import_shared_ini_file_loader10.ENV_PROFILE];
  if (profile) {
    const envStaticCredentialsAreSet = process.env[ENV_KEY] && process.env[ENV_SECRET];
    if (envStaticCredentialsAreSet) {
      if (!multipleCredentialSourceWarningEmitted) {
        const warnFn = init.logger?.warn && init.logger?.constructor?.name !== "NoOpLogger" ? init.logger.warn.bind(init.logger) : console.warn;
        warnFn(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`);
        multipleCredentialSourceWarningEmitted = true;
      }
    }
    throw new import_property_provider21.CredentialsProviderError("AWS_PROFILE is set, skipping fromEnv provider.", {
      logger: init.logger,
      tryNextLink: true
    });
  }
  init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromEnv");
  return fromEnv(init)();
}, async () => {
  init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromSSO");
  const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoSession } = init;
  if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
    throw new import_property_provider21.CredentialsProviderError("Skipping SSO provider in default chain (inputs do not include SSO fields).", { logger: init.logger });
  }
  const { fromSSO: fromSSO3 } = await Promise.resolve().then(() => (init_dist_es8(), exports_dist_es4));
  return fromSSO3(init)();
}, async () => {
  init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromIni");
  const { fromIni: fromIni3 } = await Promise.resolve().then(() => (init_dist_es11(), exports_dist_es7));
  return fromIni3(init)();
}, async () => {
  init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromProcess");
  const { fromProcess: fromProcess3 } = await Promise.resolve().then(() => (init_dist_es9(), exports_dist_es5));
  return fromProcess3(init)();
}, async () => {
  init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile");
  const { fromTokenFile: fromTokenFile3 } = await Promise.resolve().then(() => (init_dist_es10(), exports_dist_es6));
  return fromTokenFile3(init)();
}, async () => {
  init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::remoteProvider");
  return (await remoteProvider(init))();
}, async () => {
  throw new import_property_provider21.CredentialsProviderError("Could not load credentials from any providers", {
    tryNextLink: false,
    logger: init.logger
  });
}), credentialsTreatedAsExpired, credentialsWillNeedRefresh), credentialsWillNeedRefresh = (credentials) => credentials?.expiration !== undefined, credentialsTreatedAsExpired = (credentials) => credentials?.expiration !== undefined && credentials.expiration.getTime() - Date.now() < 300000;
var init_defaultProvider = __esm(() => {
  init_dist_es3();
  init_remoteProvider();
  import_property_provider21 = __toESM(require_dist_cjs24(), 1);
  import_shared_ini_file_loader10 = __toESM(require_dist_cjs35(), 1);
});

// node_modules/@aws-sdk/credential-provider-node/dist-es/index.js
var init_dist_es12 = __esm(() => {
  init_defaultProvider();
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/endpoint/ruleset.js
var K = "required", L = "type", M = "rules", N = "conditions", O = "fn", P = "argv", Q = "ref", R = "assign", S = "url", T2 = "properties", U = "headers", V = "metricValues", a2 = false, b2 = "error", c2 = "stringEquals", d2 = "https://dynamodb.{Region}.{PartitionResult#dualStackDnsSuffix}", e2 = "endpoint", f2 = "tree", g2 = "dynamodb", h2, i3, j2, k3, l2, m2, n2, o2, p2, q2, r2, s2, t3, u2, v2, w2, x3, y, z, A, B, C, D, E, F, G, H, I, J, _data2, ruleSet2;
var init_ruleset2 = __esm(() => {
  h2 = { [K]: false, [L]: "string" };
  i3 = { [K]: true, default: false, [L]: "boolean" };
  j2 = { [O]: "isSet", [P]: [{ [Q]: "Endpoint" }] };
  k3 = { [Q]: "Endpoint" };
  l2 = { [O]: "isSet", [P]: [{ [Q]: "Region" }] };
  m2 = { [Q]: "Region" };
  n2 = { [O]: "aws.partition", [P]: [m2], [R]: "PartitionResult" };
  o2 = { [N]: [{ [O]: "booleanEquals", [P]: [{ [Q]: "UseFIPS" }, true] }], [b2]: "Invalid Configuration: FIPS and custom endpoint are not supported", [L]: b2 };
  p2 = { [O]: "booleanEquals", [P]: [{ [Q]: "UseFIPS" }, true] };
  q2 = { [N]: [{ [O]: "booleanEquals", [P]: [{ [Q]: "UseDualStack" }, true] }], [b2]: "Invalid Configuration: Dualstack and custom endpoint are not supported", [L]: b2 };
  r2 = { [O]: "booleanEquals", [P]: [{ [Q]: "UseDualStack" }, true] };
  s2 = { [e2]: { [S]: "{Endpoint}", [T2]: {}, [U]: {} }, [L]: e2 };
  t3 = {};
  u2 = { [O]: "booleanEquals", [P]: [{ [O]: "getAttr", [P]: [{ [Q]: "PartitionResult" }, "supportsFIPS"] }, true] };
  v2 = { [O]: "booleanEquals", [P]: [{ [O]: "getAttr", [P]: [{ [Q]: "PartitionResult" }, "supportsDualStack"] }, true] };
  w2 = { [N]: [{ [O]: "isSet", [P]: [{ [Q]: "AccountIdEndpointMode" }] }, { [O]: c2, [P]: [{ [Q]: "AccountIdEndpointMode" }, "required"] }], [M]: [{ [b2]: "Invalid Configuration: AccountIdEndpointMode is required and FIPS is enabled, but FIPS account endpoints are not supported", [L]: b2 }], [L]: f2 };
  x3 = { [O]: "getAttr", [P]: [{ [Q]: "PartitionResult" }, "name"] };
  y = { [e2]: { [S]: "https://dynamodb.{Region}.{PartitionResult#dnsSuffix}", [T2]: {}, [U]: {} }, [L]: e2 };
  z = { [S]: "https://{ParsedArn#accountId}.ddb.{Region}.{PartitionResult#dualStackDnsSuffix}", [T2]: { [V]: ["O"] }, [U]: {} };
  A = { [V]: ["O"] };
  B = { [b2]: "Credentials-sourced account ID parameter is invalid", [L]: b2 };
  C = { [N]: [{ [O]: "isSet", [P]: [{ [Q]: "AccountIdEndpointMode" }] }, { [O]: c2, [P]: [{ [Q]: "AccountIdEndpointMode" }, "required"] }], [M]: [{ [N]: [{ [O]: "not", [P]: [p2] }], [M]: [{ [N]: [{ [O]: c2, [P]: [x3, "aws"] }], [M]: [{ [b2]: "AccountIdEndpointMode is required but no AccountID was provided or able to be loaded", [L]: b2 }], [L]: f2 }, { [b2]: "Invalid Configuration: AccountIdEndpointMode is required but account endpoints are not supported in this partition", [L]: b2 }], [L]: f2 }, { [b2]: "Invalid Configuration: AccountIdEndpointMode is required and FIPS is enabled, but FIPS account endpoints are not supported", [L]: b2 }], [L]: f2 };
  D = { [S]: "https://{ParsedArn#accountId}.ddb.{Region}.{PartitionResult#dnsSuffix}", [T2]: A, [U]: {} };
  E = [p2];
  F = [r2];
  G = [{ [O]: "isSet", [P]: [{ [Q]: "AccountIdEndpointMode" }] }, { [O]: "not", [P]: [{ [O]: c2, [P]: [{ [Q]: "AccountIdEndpointMode" }, "disabled"] }] }, { [O]: c2, [P]: [x3, "aws"] }, { [O]: "not", [P]: [p2] }, { [O]: "isSet", [P]: [{ [Q]: "ResourceArn" }] }, { [O]: "aws.parseArn", [P]: [{ [Q]: "ResourceArn" }], [R]: "ParsedArn" }, { [O]: c2, [P]: [{ [O]: "getAttr", [P]: [{ [Q]: "ParsedArn" }, "service"] }, g2] }, { [O]: "isValidHostLabel", [P]: [{ [O]: "getAttr", [P]: [{ [Q]: "ParsedArn" }, "region"] }, false] }, { [O]: c2, [P]: [{ [O]: "getAttr", [P]: [{ [Q]: "ParsedArn" }, "region"] }, "{Region}"] }, { [O]: "isValidHostLabel", [P]: [{ [O]: "getAttr", [P]: [{ [Q]: "ParsedArn" }, "accountId"] }, false] }];
  H = [{ [O]: "isSet", [P]: [{ [Q]: "AccountIdEndpointMode" }] }, { [O]: "not", [P]: [{ [O]: c2, [P]: [{ [Q]: "AccountIdEndpointMode" }, "disabled"] }] }, { [O]: c2, [P]: [x3, "aws"] }, { [O]: "not", [P]: [p2] }, { [O]: "isSet", [P]: [{ [Q]: "ResourceArnList" }] }, { [O]: "getAttr", [P]: [{ [Q]: "ResourceArnList" }, "[0]"], [R]: "FirstArn" }, { [O]: "aws.parseArn", [P]: [{ [Q]: "FirstArn" }], [R]: "ParsedArn" }, { [O]: c2, [P]: [{ [O]: "getAttr", [P]: [{ [Q]: "ParsedArn" }, "service"] }, g2] }, { [O]: "isValidHostLabel", [P]: [{ [O]: "getAttr", [P]: [{ [Q]: "ParsedArn" }, "region"] }, false] }, { [O]: c2, [P]: [{ [O]: "getAttr", [P]: [{ [Q]: "ParsedArn" }, "region"] }, "{Region}"] }, { [O]: "isValidHostLabel", [P]: [{ [O]: "getAttr", [P]: [{ [Q]: "ParsedArn" }, "accountId"] }, false] }];
  I = [{ [O]: "isSet", [P]: [{ [Q]: "AccountIdEndpointMode" }] }, { [O]: "not", [P]: [{ [O]: c2, [P]: [{ [Q]: "AccountIdEndpointMode" }, "disabled"] }] }, { [O]: c2, [P]: [x3, "aws"] }, { [O]: "not", [P]: [p2] }, { [O]: "isSet", [P]: [{ [Q]: "AccountId" }] }];
  J = [{ [O]: "isValidHostLabel", [P]: [{ [Q]: "AccountId" }, false] }];
  _data2 = { version: "1.0", parameters: { Region: h2, UseDualStack: i3, UseFIPS: i3, Endpoint: h2, AccountId: h2, AccountIdEndpointMode: h2, ResourceArn: h2, ResourceArnList: { [K]: a2, [L]: "stringArray" } }, [M]: [{ [N]: [j2, l2, n2], [M]: [o2, q2, { [N]: [{ [O]: c2, [P]: [k3, d2] }], error: "Endpoint override is not supported for dual-stack endpoints. Please enable dual-stack functionality by enabling the configuration. For more details, see: https://docs.aws.amazon.com/sdkref/latest/guide/feature-endpoints.html", [L]: b2 }, s2], [L]: f2 }, { [N]: [j2], [M]: [o2, q2, s2], [L]: f2 }, { [N]: [l2], [M]: [{ [N]: [n2], [M]: [{ [N]: [{ [O]: c2, [P]: [m2, "local"] }], [M]: [{ [N]: E, error: "Invalid Configuration: FIPS and local endpoint are not supported", [L]: b2 }, { [N]: F, error: "Invalid Configuration: Dualstack and local endpoint are not supported", [L]: b2 }, { endpoint: { [S]: "http://localhost:8000", [T2]: { authSchemes: [{ name: "sigv4", signingName: g2, signingRegion: "us-east-1" }] }, [U]: t3 }, [L]: e2 }], [L]: f2 }, { [N]: [p2, r2], [M]: [{ [N]: [u2, v2], [M]: [w2, { endpoint: { [S]: "https://dynamodb-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", [T2]: t3, [U]: t3 }, [L]: e2 }], [L]: f2 }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", [L]: b2 }], [L]: f2 }, { [N]: E, [M]: [{ [N]: [u2], [M]: [{ [N]: [{ [O]: c2, [P]: [x3, "aws-us-gov"] }], [M]: [w2, y], [L]: f2 }, w2, { endpoint: { [S]: "https://dynamodb-fips.{Region}.{PartitionResult#dnsSuffix}", [T2]: t3, [U]: t3 }, [L]: e2 }], [L]: f2 }, { error: "FIPS is enabled but this partition does not support FIPS", [L]: b2 }], [L]: f2 }, { [N]: F, [M]: [{ [N]: [v2], [M]: [{ [N]: G, endpoint: z, [L]: e2 }, { [N]: H, endpoint: z, [L]: e2 }, { [N]: I, [M]: [{ [N]: J, [M]: [{ endpoint: { [S]: "https://{AccountId}.ddb.{Region}.{PartitionResult#dualStackDnsSuffix}", [T2]: A, [U]: t3 }, [L]: e2 }], [L]: f2 }, B], [L]: f2 }, C, { endpoint: { [S]: d2, [T2]: t3, [U]: t3 }, [L]: e2 }], [L]: f2 }, { error: "DualStack is enabled but this partition does not support DualStack", [L]: b2 }], [L]: f2 }, { [N]: G, endpoint: D, [L]: e2 }, { [N]: H, endpoint: D, [L]: e2 }, { [N]: I, [M]: [{ [N]: J, [M]: [{ endpoint: { [S]: "https://{AccountId}.ddb.{Region}.{PartitionResult#dnsSuffix}", [T2]: A, [U]: t3 }, [L]: e2 }], [L]: f2 }, B], [L]: f2 }, C, y], [L]: f2 }], [L]: f2 }, { error: "Invalid Configuration: Missing Region", [L]: b2 }] };
  ruleSet2 = _data2;
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/endpoint/endpointResolver.js
var import_util_endpoints3, import_util_endpoints4, cache2, defaultEndpointResolver2 = (endpointParams, context = {}) => {
  return cache2.get(endpointParams, () => import_util_endpoints4.resolveEndpoint(ruleSet2, {
    endpointParams,
    logger: context.logger
  }));
};
var init_endpointResolver2 = __esm(() => {
  init_ruleset2();
  import_util_endpoints3 = __toESM(require_dist_cjs23(), 1);
  import_util_endpoints4 = __toESM(require_dist_cjs20(), 1);
  cache2 = new import_util_endpoints4.EndpointCache({
    size: 50,
    params: [
      "AccountId",
      "AccountIdEndpointMode",
      "Endpoint",
      "Region",
      "ResourceArn",
      "ResourceArnList",
      "UseDualStack",
      "UseFIPS"
    ]
  });
  import_util_endpoints4.customEndpointFunctions.aws = import_util_endpoints3.awsEndpointFunctions;
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/runtimeConfig.shared.js
var import_core15, import_smithy_client18, import_url_parser3, import_util_base642, import_util_utf82, getRuntimeConfig3 = (config) => {
  return {
    apiVersion: "2012-08-10",
    base64Decoder: config?.base64Decoder ?? import_util_base642.fromBase64,
    base64Encoder: config?.base64Encoder ?? import_util_base642.toBase64,
    disableHostPrefix: config?.disableHostPrefix ?? false,
    endpointProvider: config?.endpointProvider ?? defaultEndpointResolver2,
    extensions: config?.extensions ?? [],
    httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultDynamoDBHttpAuthSchemeProvider,
    httpAuthSchemes: config?.httpAuthSchemes ?? [
      {
        schemeId: "aws.auth#sigv4",
        identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
        signer: new import_core15.AwsSdkSigV4Signer
      }
    ],
    logger: config?.logger ?? new import_smithy_client18.NoOpLogger,
    serviceId: config?.serviceId ?? "DynamoDB",
    urlParser: config?.urlParser ?? import_url_parser3.parseUrl,
    utf8Decoder: config?.utf8Decoder ?? import_util_utf82.fromUtf8,
    utf8Encoder: config?.utf8Encoder ?? import_util_utf82.toUtf8
  };
};
var init_runtimeConfig_shared2 = __esm(() => {
  init_httpAuthSchemeProvider();
  init_endpointResolver2();
  import_core15 = __toESM(require_dist_cjs30(), 1);
  import_smithy_client18 = __toESM(require_dist_cjs28(), 1);
  import_url_parser3 = __toESM(require_dist_cjs22(), 1);
  import_util_base642 = __toESM(require_dist_cjs11(), 1);
  import_util_utf82 = __toESM(require_dist_cjs10(), 1);
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/runtimeConfig.js
var import_core16, import_util_user_agent_node2, import_config_resolver3, import_hash_node2, import_middleware_retry3, import_node_config_provider4, import_node_http_handler3, import_util_body_length_node2, import_util_retry2, import_smithy_client19, import_util_defaults_mode_node2, import_smithy_client20, getRuntimeConfig4 = (config) => {
  import_smithy_client20.emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = import_util_defaults_mode_node2.resolveDefaultsModeConfig(config);
  const defaultConfigProvider = () => defaultsMode().then(import_smithy_client19.loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig3(config);
  import_core16.emitWarningIfUnsupportedVersion(process.version);
  const loaderConfig = {
    profile: config?.profile,
    logger: clientSharedValues.logger
  };
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    accountIdEndpointMode: config?.accountIdEndpointMode ?? import_node_config_provider4.loadConfig($NODE_ACCOUNT_ID_ENDPOINT_MODE_CONFIG_OPTIONS, loaderConfig),
    authSchemePreference: config?.authSchemePreference ?? import_node_config_provider4.loadConfig(import_core16.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
    bodyLengthChecker: config?.bodyLengthChecker ?? import_util_body_length_node2.calculateBodyLength,
    credentialDefaultProvider: config?.credentialDefaultProvider ?? defaultProvider,
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? import_util_user_agent_node2.createDefaultUserAgentProvider({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
    endpointDiscoveryEnabledProvider: config?.endpointDiscoveryEnabledProvider ?? import_node_config_provider4.loadConfig(NODE_ENDPOINT_DISCOVERY_CONFIG_OPTIONS, loaderConfig),
    maxAttempts: config?.maxAttempts ?? import_node_config_provider4.loadConfig(import_middleware_retry3.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
    region: config?.region ?? import_node_config_provider4.loadConfig(import_config_resolver3.NODE_REGION_CONFIG_OPTIONS, { ...import_config_resolver3.NODE_REGION_CONFIG_FILE_OPTIONS, ...loaderConfig }),
    requestHandler: import_node_http_handler3.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
    retryMode: config?.retryMode ?? import_node_config_provider4.loadConfig({
      ...import_middleware_retry3.NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || import_util_retry2.DEFAULT_RETRY_MODE
    }, config),
    sha256: config?.sha256 ?? import_hash_node2.Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? import_node_http_handler3.streamCollector,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? import_node_config_provider4.loadConfig(import_config_resolver3.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
    useFipsEndpoint: config?.useFipsEndpoint ?? import_node_config_provider4.loadConfig(import_config_resolver3.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
    userAgentAppId: config?.userAgentAppId ?? import_node_config_provider4.loadConfig(import_util_user_agent_node2.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
  };
};
var init_runtimeConfig2 = __esm(() => {
  init_package();
  init_account_id_endpoint();
  init_dist_es12();
  init_dist_es2();
  init_runtimeConfig_shared2();
  import_core16 = __toESM(require_dist_cjs30(), 1);
  import_util_user_agent_node2 = __toESM(require_dist_cjs41(), 1);
  import_config_resolver3 = __toESM(require_dist_cjs33(), 1);
  import_hash_node2 = __toESM(require_dist_cjs42(), 1);
  import_middleware_retry3 = __toESM(require_dist_cjs40(), 1);
  import_node_config_provider4 = __toESM(require_dist_cjs36(), 1);
  import_node_http_handler3 = __toESM(require_dist_cjs14(), 1);
  import_util_body_length_node2 = __toESM(require_dist_cjs43(), 1);
  import_util_retry2 = __toESM(require_dist_cjs39(), 1);
  import_smithy_client19 = __toESM(require_dist_cjs28(), 1);
  import_util_defaults_mode_node2 = __toESM(require_dist_cjs44(), 1);
  import_smithy_client20 = __toESM(require_dist_cjs28(), 1);
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/auth/httpAuthExtensionConfiguration.js
var getHttpAuthExtensionConfiguration2 = (runtimeConfig) => {
  const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
  let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
  let _credentials = runtimeConfig.credentials;
  return {
    setHttpAuthScheme(httpAuthScheme) {
      const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
      if (index === -1) {
        _httpAuthSchemes.push(httpAuthScheme);
      } else {
        _httpAuthSchemes.splice(index, 1, httpAuthScheme);
      }
    },
    httpAuthSchemes() {
      return _httpAuthSchemes;
    },
    setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
      _httpAuthSchemeProvider = httpAuthSchemeProvider;
    },
    httpAuthSchemeProvider() {
      return _httpAuthSchemeProvider;
    },
    setCredentials(credentials) {
      _credentials = credentials;
    },
    credentials() {
      return _credentials;
    }
  };
}, resolveHttpAuthRuntimeConfig2 = (config) => {
  return {
    httpAuthSchemes: config.httpAuthSchemes(),
    httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
    credentials: config.credentials()
  };
};

// node_modules/@aws-sdk/client-dynamodb/dist-es/runtimeExtensions.js
var import_region_config_resolver2, import_protocol_http4, import_smithy_client21, resolveRuntimeExtensions2 = (runtimeConfig, extensions2) => {
  const extensionConfiguration = Object.assign(import_region_config_resolver2.getAwsRegionExtensionConfiguration(runtimeConfig), import_smithy_client21.getDefaultExtensionConfiguration(runtimeConfig), import_protocol_http4.getHttpHandlerExtensionConfiguration(runtimeConfig), getHttpAuthExtensionConfiguration2(runtimeConfig));
  extensions2.forEach((extension) => extension.configure(extensionConfiguration));
  return Object.assign(runtimeConfig, import_region_config_resolver2.resolveAwsRegionExtensionConfiguration(extensionConfiguration), import_smithy_client21.resolveDefaultRuntimeConfig(extensionConfiguration), import_protocol_http4.resolveHttpHandlerRuntimeConfig(extensionConfiguration), resolveHttpAuthRuntimeConfig2(extensionConfiguration));
};
var init_runtimeExtensions2 = __esm(() => {
  import_region_config_resolver2 = __toESM(require_dist_cjs45(), 1);
  import_protocol_http4 = __toESM(require_dist_cjs3(), 1);
  import_smithy_client21 = __toESM(require_dist_cjs28(), 1);
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/DynamoDBClient.js
var import_middleware_host_header2, import_middleware_logger2, import_middleware_recursion_detection2, import_middleware_user_agent2, import_config_resolver4, import_core17, import_middleware_content_length2, import_middleware_endpoint7, import_middleware_retry4, import_smithy_client22, DynamoDBClient;
var init_DynamoDBClient = __esm(() => {
  init_account_id_endpoint();
  init_dist_es2();
  init_httpAuthSchemeProvider();
  init_DescribeEndpointsCommand();
  init_EndpointParameters();
  init_runtimeConfig2();
  init_runtimeExtensions2();
  import_middleware_host_header2 = __toESM(require_dist_cjs4(), 1);
  import_middleware_logger2 = __toESM(require_dist_cjs5(), 1);
  import_middleware_recursion_detection2 = __toESM(require_dist_cjs6(), 1);
  import_middleware_user_agent2 = __toESM(require_dist_cjs31(), 1);
  import_config_resolver4 = __toESM(require_dist_cjs33(), 1);
  import_core17 = __toESM(require_dist_cjs19(), 1);
  import_middleware_content_length2 = __toESM(require_dist_cjs34(), 1);
  import_middleware_endpoint7 = __toESM(require_dist_cjs37(), 1);
  import_middleware_retry4 = __toESM(require_dist_cjs40(), 1);
  import_smithy_client22 = __toESM(require_dist_cjs28(), 1);
  DynamoDBClient = class DynamoDBClient extends import_smithy_client22.Client {
    config;
    constructor(...[configuration]) {
      const _config_0 = getRuntimeConfig4(configuration || {});
      super(_config_0);
      this.initConfig = _config_0;
      const _config_1 = resolveClientEndpointParameters(_config_0);
      const _config_2 = $resolveAccountIdEndpointModeConfig(_config_1);
      const _config_3 = import_middleware_user_agent2.resolveUserAgentConfig(_config_2);
      const _config_4 = import_middleware_retry4.resolveRetryConfig(_config_3);
      const _config_5 = import_config_resolver4.resolveRegionConfig(_config_4);
      const _config_6 = import_middleware_host_header2.resolveHostHeaderConfig(_config_5);
      const _config_7 = import_middleware_endpoint7.resolveEndpointConfig(_config_6);
      const _config_8 = resolveHttpAuthSchemeConfig(_config_7);
      const _config_9 = resolveEndpointDiscoveryConfig(_config_8, {
        endpointDiscoveryCommandCtor: DescribeEndpointsCommand
      });
      const _config_10 = resolveRuntimeExtensions2(_config_9, configuration?.extensions || []);
      this.config = _config_10;
      this.middlewareStack.use(import_middleware_user_agent2.getUserAgentPlugin(this.config));
      this.middlewareStack.use(import_middleware_retry4.getRetryPlugin(this.config));
      this.middlewareStack.use(import_middleware_content_length2.getContentLengthPlugin(this.config));
      this.middlewareStack.use(import_middleware_host_header2.getHostHeaderPlugin(this.config));
      this.middlewareStack.use(import_middleware_logger2.getLoggerPlugin(this.config));
      this.middlewareStack.use(import_middleware_recursion_detection2.getRecursionDetectionPlugin(this.config));
      this.middlewareStack.use(import_core17.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
        httpAuthSchemeParametersProvider: defaultDynamoDBHttpAuthSchemeParametersProvider,
        identityProviderConfigProvider: async (config) => new import_core17.DefaultIdentityProviderConfig({
          "aws.auth#sigv4": config.credentials
        })
      }));
      this.middlewareStack.use(import_core17.getHttpSigningPlugin(this.config));
    }
    destroy() {
      super.destroy();
    }
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/BatchExecuteStatementCommand.js
var import_middleware_endpoint8, import_middleware_serde6, import_smithy_client23, BatchExecuteStatementCommand;
var init_BatchExecuteStatementCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint8 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde6 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client23 = __toESM(require_dist_cjs28(), 1);
  BatchExecuteStatementCommand = class BatchExecuteStatementCommand extends import_smithy_client23.Command.classBuilder().ep(commonParams).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde6.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint8.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "BatchExecuteStatement", {}).n("DynamoDBClient", "BatchExecuteStatementCommand").f(undefined, undefined).ser(se_BatchExecuteStatementCommand).de(de_BatchExecuteStatementCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/BatchGetItemCommand.js
var import_middleware_endpoint9, import_middleware_serde7, import_smithy_client24, BatchGetItemCommand;
var init_BatchGetItemCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint9 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde7 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client24 = __toESM(require_dist_cjs28(), 1);
  BatchGetItemCommand = class BatchGetItemCommand extends import_smithy_client24.Command.classBuilder().ep({
    ...commonParams,
    ResourceArnList: { type: "operationContextParams", get: (input) => Object.keys(input?.RequestItems ?? {}) }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde7.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint9.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "BatchGetItem", {}).n("DynamoDBClient", "BatchGetItemCommand").f(undefined, undefined).ser(se_BatchGetItemCommand).de(de_BatchGetItemCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/BatchWriteItemCommand.js
var import_middleware_endpoint10, import_middleware_serde8, import_smithy_client25, BatchWriteItemCommand;
var init_BatchWriteItemCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint10 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde8 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client25 = __toESM(require_dist_cjs28(), 1);
  BatchWriteItemCommand = class BatchWriteItemCommand extends import_smithy_client25.Command.classBuilder().ep({
    ...commonParams,
    ResourceArnList: { type: "operationContextParams", get: (input) => Object.keys(input?.RequestItems ?? {}) }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde8.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint10.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "BatchWriteItem", {}).n("DynamoDBClient", "BatchWriteItemCommand").f(undefined, undefined).ser(se_BatchWriteItemCommand).de(de_BatchWriteItemCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/CreateBackupCommand.js
var import_middleware_endpoint11, import_middleware_serde9, import_smithy_client26, CreateBackupCommand;
var init_CreateBackupCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint11 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde9 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client26 = __toESM(require_dist_cjs28(), 1);
  CreateBackupCommand = class CreateBackupCommand extends import_smithy_client26.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde9.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint11.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "CreateBackup", {}).n("DynamoDBClient", "CreateBackupCommand").f(undefined, undefined).ser(se_CreateBackupCommand).de(de_CreateBackupCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/CreateGlobalTableCommand.js
var import_middleware_endpoint12, import_middleware_serde10, import_smithy_client27, CreateGlobalTableCommand;
var init_CreateGlobalTableCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint12 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde10 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client27 = __toESM(require_dist_cjs28(), 1);
  CreateGlobalTableCommand = class CreateGlobalTableCommand extends import_smithy_client27.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "GlobalTableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde10.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint12.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "CreateGlobalTable", {}).n("DynamoDBClient", "CreateGlobalTableCommand").f(undefined, undefined).ser(se_CreateGlobalTableCommand).de(de_CreateGlobalTableCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/CreateTableCommand.js
var import_middleware_endpoint13, import_middleware_serde11, import_smithy_client28, CreateTableCommand;
var init_CreateTableCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint13 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde11 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client28 = __toESM(require_dist_cjs28(), 1);
  CreateTableCommand = class CreateTableCommand extends import_smithy_client28.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde11.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint13.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "CreateTable", {}).n("DynamoDBClient", "CreateTableCommand").f(undefined, undefined).ser(se_CreateTableCommand).de(de_CreateTableCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DeleteBackupCommand.js
var import_middleware_endpoint14, import_middleware_serde12, import_smithy_client29, DeleteBackupCommand;
var init_DeleteBackupCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint14 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde12 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client29 = __toESM(require_dist_cjs28(), 1);
  DeleteBackupCommand = class DeleteBackupCommand extends import_smithy_client29.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "BackupArn" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde12.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint14.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "DeleteBackup", {}).n("DynamoDBClient", "DeleteBackupCommand").f(undefined, undefined).ser(se_DeleteBackupCommand).de(de_DeleteBackupCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DeleteItemCommand.js
var import_middleware_endpoint15, import_middleware_serde13, import_smithy_client30, DeleteItemCommand;
var init_DeleteItemCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint15 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde13 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client30 = __toESM(require_dist_cjs28(), 1);
  DeleteItemCommand = class DeleteItemCommand extends import_smithy_client30.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde13.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint15.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "DeleteItem", {}).n("DynamoDBClient", "DeleteItemCommand").f(undefined, undefined).ser(se_DeleteItemCommand).de(de_DeleteItemCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DeleteResourcePolicyCommand.js
var import_middleware_endpoint16, import_middleware_serde14, import_smithy_client31, DeleteResourcePolicyCommand;
var init_DeleteResourcePolicyCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint16 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde14 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client31 = __toESM(require_dist_cjs28(), 1);
  DeleteResourcePolicyCommand = class DeleteResourcePolicyCommand extends import_smithy_client31.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "ResourceArn" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde14.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint16.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "DeleteResourcePolicy", {}).n("DynamoDBClient", "DeleteResourcePolicyCommand").f(undefined, undefined).ser(se_DeleteResourcePolicyCommand).de(de_DeleteResourcePolicyCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DeleteTableCommand.js
var import_middleware_endpoint17, import_middleware_serde15, import_smithy_client32, DeleteTableCommand;
var init_DeleteTableCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint17 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde15 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client32 = __toESM(require_dist_cjs28(), 1);
  DeleteTableCommand = class DeleteTableCommand extends import_smithy_client32.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde15.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint17.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "DeleteTable", {}).n("DynamoDBClient", "DeleteTableCommand").f(undefined, undefined).ser(se_DeleteTableCommand).de(de_DeleteTableCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DescribeBackupCommand.js
var import_middleware_endpoint18, import_middleware_serde16, import_smithy_client33, DescribeBackupCommand;
var init_DescribeBackupCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint18 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde16 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client33 = __toESM(require_dist_cjs28(), 1);
  DescribeBackupCommand = class DescribeBackupCommand extends import_smithy_client33.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "BackupArn" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde16.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint18.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "DescribeBackup", {}).n("DynamoDBClient", "DescribeBackupCommand").f(undefined, undefined).ser(se_DescribeBackupCommand).de(de_DescribeBackupCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DescribeContinuousBackupsCommand.js
var import_middleware_endpoint19, import_middleware_serde17, import_smithy_client34, DescribeContinuousBackupsCommand;
var init_DescribeContinuousBackupsCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint19 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde17 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client34 = __toESM(require_dist_cjs28(), 1);
  DescribeContinuousBackupsCommand = class DescribeContinuousBackupsCommand extends import_smithy_client34.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde17.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint19.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "DescribeContinuousBackups", {}).n("DynamoDBClient", "DescribeContinuousBackupsCommand").f(undefined, undefined).ser(se_DescribeContinuousBackupsCommand).de(de_DescribeContinuousBackupsCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DescribeContributorInsightsCommand.js
var import_middleware_endpoint20, import_middleware_serde18, import_smithy_client35, DescribeContributorInsightsCommand;
var init_DescribeContributorInsightsCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint20 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde18 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client35 = __toESM(require_dist_cjs28(), 1);
  DescribeContributorInsightsCommand = class DescribeContributorInsightsCommand extends import_smithy_client35.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde18.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint20.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "DescribeContributorInsights", {}).n("DynamoDBClient", "DescribeContributorInsightsCommand").f(undefined, undefined).ser(se_DescribeContributorInsightsCommand).de(de_DescribeContributorInsightsCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DescribeExportCommand.js
var import_middleware_endpoint21, import_middleware_serde19, import_smithy_client36, DescribeExportCommand;
var init_DescribeExportCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint21 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde19 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client36 = __toESM(require_dist_cjs28(), 1);
  DescribeExportCommand = class DescribeExportCommand extends import_smithy_client36.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "ExportArn" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde19.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint21.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "DescribeExport", {}).n("DynamoDBClient", "DescribeExportCommand").f(undefined, undefined).ser(se_DescribeExportCommand).de(de_DescribeExportCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DescribeGlobalTableCommand.js
var import_middleware_endpoint22, import_middleware_serde20, import_smithy_client37, DescribeGlobalTableCommand;
var init_DescribeGlobalTableCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint22 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde20 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client37 = __toESM(require_dist_cjs28(), 1);
  DescribeGlobalTableCommand = class DescribeGlobalTableCommand extends import_smithy_client37.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "GlobalTableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde20.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint22.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "DescribeGlobalTable", {}).n("DynamoDBClient", "DescribeGlobalTableCommand").f(undefined, undefined).ser(se_DescribeGlobalTableCommand).de(de_DescribeGlobalTableCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DescribeGlobalTableSettingsCommand.js
var import_middleware_endpoint23, import_middleware_serde21, import_smithy_client38, DescribeGlobalTableSettingsCommand;
var init_DescribeGlobalTableSettingsCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint23 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde21 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client38 = __toESM(require_dist_cjs28(), 1);
  DescribeGlobalTableSettingsCommand = class DescribeGlobalTableSettingsCommand extends import_smithy_client38.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "GlobalTableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde21.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint23.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "DescribeGlobalTableSettings", {}).n("DynamoDBClient", "DescribeGlobalTableSettingsCommand").f(undefined, undefined).ser(se_DescribeGlobalTableSettingsCommand).de(de_DescribeGlobalTableSettingsCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DescribeImportCommand.js
var import_middleware_endpoint24, import_middleware_serde22, import_smithy_client39, DescribeImportCommand;
var init_DescribeImportCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint24 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde22 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client39 = __toESM(require_dist_cjs28(), 1);
  DescribeImportCommand = class DescribeImportCommand extends import_smithy_client39.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "ImportArn" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde22.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint24.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "DescribeImport", {}).n("DynamoDBClient", "DescribeImportCommand").f(undefined, undefined).ser(se_DescribeImportCommand).de(de_DescribeImportCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DescribeKinesisStreamingDestinationCommand.js
var import_middleware_endpoint25, import_middleware_serde23, import_smithy_client40, DescribeKinesisStreamingDestinationCommand;
var init_DescribeKinesisStreamingDestinationCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint25 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde23 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client40 = __toESM(require_dist_cjs28(), 1);
  DescribeKinesisStreamingDestinationCommand = class DescribeKinesisStreamingDestinationCommand extends import_smithy_client40.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde23.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint25.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "DescribeKinesisStreamingDestination", {}).n("DynamoDBClient", "DescribeKinesisStreamingDestinationCommand").f(undefined, undefined).ser(se_DescribeKinesisStreamingDestinationCommand).de(de_DescribeKinesisStreamingDestinationCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DescribeLimitsCommand.js
var import_middleware_endpoint26, import_middleware_serde24, import_smithy_client41, DescribeLimitsCommand;
var init_DescribeLimitsCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint26 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde24 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client41 = __toESM(require_dist_cjs28(), 1);
  DescribeLimitsCommand = class DescribeLimitsCommand extends import_smithy_client41.Command.classBuilder().ep(commonParams).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde24.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint26.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "DescribeLimits", {}).n("DynamoDBClient", "DescribeLimitsCommand").f(undefined, undefined).ser(se_DescribeLimitsCommand).de(de_DescribeLimitsCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DescribeTableCommand.js
var import_middleware_endpoint27, import_middleware_serde25, import_smithy_client42, DescribeTableCommand;
var init_DescribeTableCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint27 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde25 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client42 = __toESM(require_dist_cjs28(), 1);
  DescribeTableCommand = class DescribeTableCommand extends import_smithy_client42.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde25.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint27.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "DescribeTable", {}).n("DynamoDBClient", "DescribeTableCommand").f(undefined, undefined).ser(se_DescribeTableCommand).de(de_DescribeTableCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DescribeTableReplicaAutoScalingCommand.js
var import_middleware_endpoint28, import_middleware_serde26, import_smithy_client43, DescribeTableReplicaAutoScalingCommand;
var init_DescribeTableReplicaAutoScalingCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint28 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde26 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client43 = __toESM(require_dist_cjs28(), 1);
  DescribeTableReplicaAutoScalingCommand = class DescribeTableReplicaAutoScalingCommand extends import_smithy_client43.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde26.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint28.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "DescribeTableReplicaAutoScaling", {}).n("DynamoDBClient", "DescribeTableReplicaAutoScalingCommand").f(undefined, undefined).ser(se_DescribeTableReplicaAutoScalingCommand).de(de_DescribeTableReplicaAutoScalingCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DescribeTimeToLiveCommand.js
var import_middleware_endpoint29, import_middleware_serde27, import_smithy_client44, DescribeTimeToLiveCommand;
var init_DescribeTimeToLiveCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint29 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde27 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client44 = __toESM(require_dist_cjs28(), 1);
  DescribeTimeToLiveCommand = class DescribeTimeToLiveCommand extends import_smithy_client44.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde27.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint29.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "DescribeTimeToLive", {}).n("DynamoDBClient", "DescribeTimeToLiveCommand").f(undefined, undefined).ser(se_DescribeTimeToLiveCommand).de(de_DescribeTimeToLiveCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/DisableKinesisStreamingDestinationCommand.js
var import_middleware_endpoint30, import_middleware_serde28, import_smithy_client45, DisableKinesisStreamingDestinationCommand;
var init_DisableKinesisStreamingDestinationCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint30 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde28 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client45 = __toESM(require_dist_cjs28(), 1);
  DisableKinesisStreamingDestinationCommand = class DisableKinesisStreamingDestinationCommand extends import_smithy_client45.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde28.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint30.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "DisableKinesisStreamingDestination", {}).n("DynamoDBClient", "DisableKinesisStreamingDestinationCommand").f(undefined, undefined).ser(se_DisableKinesisStreamingDestinationCommand).de(de_DisableKinesisStreamingDestinationCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/EnableKinesisStreamingDestinationCommand.js
var import_middleware_endpoint31, import_middleware_serde29, import_smithy_client46, EnableKinesisStreamingDestinationCommand;
var init_EnableKinesisStreamingDestinationCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint31 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde29 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client46 = __toESM(require_dist_cjs28(), 1);
  EnableKinesisStreamingDestinationCommand = class EnableKinesisStreamingDestinationCommand extends import_smithy_client46.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde29.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint31.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "EnableKinesisStreamingDestination", {}).n("DynamoDBClient", "EnableKinesisStreamingDestinationCommand").f(undefined, undefined).ser(se_EnableKinesisStreamingDestinationCommand).de(de_EnableKinesisStreamingDestinationCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/ExecuteStatementCommand.js
var import_middleware_endpoint32, import_middleware_serde30, import_smithy_client47, ExecuteStatementCommand;
var init_ExecuteStatementCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint32 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde30 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client47 = __toESM(require_dist_cjs28(), 1);
  ExecuteStatementCommand = class ExecuteStatementCommand extends import_smithy_client47.Command.classBuilder().ep(commonParams).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde30.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint32.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "ExecuteStatement", {}).n("DynamoDBClient", "ExecuteStatementCommand").f(undefined, undefined).ser(se_ExecuteStatementCommand).de(de_ExecuteStatementCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/ExecuteTransactionCommand.js
var import_middleware_endpoint33, import_middleware_serde31, import_smithy_client48, ExecuteTransactionCommand;
var init_ExecuteTransactionCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint33 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde31 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client48 = __toESM(require_dist_cjs28(), 1);
  ExecuteTransactionCommand = class ExecuteTransactionCommand extends import_smithy_client48.Command.classBuilder().ep(commonParams).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde31.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint33.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "ExecuteTransaction", {}).n("DynamoDBClient", "ExecuteTransactionCommand").f(undefined, undefined).ser(se_ExecuteTransactionCommand).de(de_ExecuteTransactionCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/ExportTableToPointInTimeCommand.js
var import_middleware_endpoint34, import_middleware_serde32, import_smithy_client49, ExportTableToPointInTimeCommand;
var init_ExportTableToPointInTimeCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint34 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde32 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client49 = __toESM(require_dist_cjs28(), 1);
  ExportTableToPointInTimeCommand = class ExportTableToPointInTimeCommand extends import_smithy_client49.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableArn" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde32.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint34.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "ExportTableToPointInTime", {}).n("DynamoDBClient", "ExportTableToPointInTimeCommand").f(undefined, undefined).ser(se_ExportTableToPointInTimeCommand).de(de_ExportTableToPointInTimeCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/GetItemCommand.js
var import_middleware_endpoint35, import_middleware_serde33, import_smithy_client50, GetItemCommand;
var init_GetItemCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint35 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde33 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client50 = __toESM(require_dist_cjs28(), 1);
  GetItemCommand = class GetItemCommand extends import_smithy_client50.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde33.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint35.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "GetItem", {}).n("DynamoDBClient", "GetItemCommand").f(undefined, undefined).ser(se_GetItemCommand).de(de_GetItemCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/GetResourcePolicyCommand.js
var import_middleware_endpoint36, import_middleware_serde34, import_smithy_client51, GetResourcePolicyCommand;
var init_GetResourcePolicyCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint36 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde34 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client51 = __toESM(require_dist_cjs28(), 1);
  GetResourcePolicyCommand = class GetResourcePolicyCommand extends import_smithy_client51.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "ResourceArn" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde34.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint36.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "GetResourcePolicy", {}).n("DynamoDBClient", "GetResourcePolicyCommand").f(undefined, undefined).ser(se_GetResourcePolicyCommand).de(de_GetResourcePolicyCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/ImportTableCommand.js
var import_middleware_endpoint37, import_middleware_serde35, import_smithy_client52, ImportTableCommand;
var init_ImportTableCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint37 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde35 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client52 = __toESM(require_dist_cjs28(), 1);
  ImportTableCommand = class ImportTableCommand extends import_smithy_client52.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "operationContextParams", get: (input) => input?.TableCreationParameters?.TableName }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde35.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint37.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "ImportTable", {}).n("DynamoDBClient", "ImportTableCommand").f(undefined, undefined).ser(se_ImportTableCommand).de(de_ImportTableCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/ListBackupsCommand.js
var import_middleware_endpoint38, import_middleware_serde36, import_smithy_client53, ListBackupsCommand;
var init_ListBackupsCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint38 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde36 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client53 = __toESM(require_dist_cjs28(), 1);
  ListBackupsCommand = class ListBackupsCommand extends import_smithy_client53.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde36.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint38.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "ListBackups", {}).n("DynamoDBClient", "ListBackupsCommand").f(undefined, undefined).ser(se_ListBackupsCommand).de(de_ListBackupsCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/ListContributorInsightsCommand.js
var import_middleware_endpoint39, import_middleware_serde37, import_smithy_client54, ListContributorInsightsCommand;
var init_ListContributorInsightsCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint39 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde37 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client54 = __toESM(require_dist_cjs28(), 1);
  ListContributorInsightsCommand = class ListContributorInsightsCommand extends import_smithy_client54.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde37.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint39.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "ListContributorInsights", {}).n("DynamoDBClient", "ListContributorInsightsCommand").f(undefined, undefined).ser(se_ListContributorInsightsCommand).de(de_ListContributorInsightsCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/ListExportsCommand.js
var import_middleware_endpoint40, import_middleware_serde38, import_smithy_client55, ListExportsCommand;
var init_ListExportsCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint40 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde38 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client55 = __toESM(require_dist_cjs28(), 1);
  ListExportsCommand = class ListExportsCommand extends import_smithy_client55.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableArn" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde38.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint40.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "ListExports", {}).n("DynamoDBClient", "ListExportsCommand").f(undefined, undefined).ser(se_ListExportsCommand).de(de_ListExportsCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/ListGlobalTablesCommand.js
var import_middleware_endpoint41, import_middleware_serde39, import_smithy_client56, ListGlobalTablesCommand;
var init_ListGlobalTablesCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint41 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde39 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client56 = __toESM(require_dist_cjs28(), 1);
  ListGlobalTablesCommand = class ListGlobalTablesCommand extends import_smithy_client56.Command.classBuilder().ep(commonParams).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde39.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint41.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "ListGlobalTables", {}).n("DynamoDBClient", "ListGlobalTablesCommand").f(undefined, undefined).ser(se_ListGlobalTablesCommand).de(de_ListGlobalTablesCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/ListImportsCommand.js
var import_middleware_endpoint42, import_middleware_serde40, import_smithy_client57, ListImportsCommand;
var init_ListImportsCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint42 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde40 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client57 = __toESM(require_dist_cjs28(), 1);
  ListImportsCommand = class ListImportsCommand extends import_smithy_client57.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableArn" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde40.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint42.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "ListImports", {}).n("DynamoDBClient", "ListImportsCommand").f(undefined, undefined).ser(se_ListImportsCommand).de(de_ListImportsCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/ListTablesCommand.js
var import_middleware_endpoint43, import_middleware_serde41, import_smithy_client58, ListTablesCommand;
var init_ListTablesCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint43 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde41 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client58 = __toESM(require_dist_cjs28(), 1);
  ListTablesCommand = class ListTablesCommand extends import_smithy_client58.Command.classBuilder().ep(commonParams).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde41.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint43.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "ListTables", {}).n("DynamoDBClient", "ListTablesCommand").f(undefined, undefined).ser(se_ListTablesCommand).de(de_ListTablesCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/ListTagsOfResourceCommand.js
var import_middleware_endpoint44, import_middleware_serde42, import_smithy_client59, ListTagsOfResourceCommand;
var init_ListTagsOfResourceCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint44 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde42 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client59 = __toESM(require_dist_cjs28(), 1);
  ListTagsOfResourceCommand = class ListTagsOfResourceCommand extends import_smithy_client59.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "ResourceArn" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde42.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint44.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "ListTagsOfResource", {}).n("DynamoDBClient", "ListTagsOfResourceCommand").f(undefined, undefined).ser(se_ListTagsOfResourceCommand).de(de_ListTagsOfResourceCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/PutItemCommand.js
var import_middleware_endpoint45, import_middleware_serde43, import_smithy_client60, PutItemCommand;
var init_PutItemCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint45 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde43 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client60 = __toESM(require_dist_cjs28(), 1);
  PutItemCommand = class PutItemCommand extends import_smithy_client60.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde43.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint45.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "PutItem", {}).n("DynamoDBClient", "PutItemCommand").f(undefined, undefined).ser(se_PutItemCommand).de(de_PutItemCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/PutResourcePolicyCommand.js
var import_middleware_endpoint46, import_middleware_serde44, import_smithy_client61, PutResourcePolicyCommand;
var init_PutResourcePolicyCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint46 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde44 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client61 = __toESM(require_dist_cjs28(), 1);
  PutResourcePolicyCommand = class PutResourcePolicyCommand extends import_smithy_client61.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "ResourceArn" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde44.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint46.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "PutResourcePolicy", {}).n("DynamoDBClient", "PutResourcePolicyCommand").f(undefined, undefined).ser(se_PutResourcePolicyCommand).de(de_PutResourcePolicyCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/QueryCommand.js
var import_middleware_endpoint47, import_middleware_serde45, import_smithy_client62, QueryCommand;
var init_QueryCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint47 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde45 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client62 = __toESM(require_dist_cjs28(), 1);
  QueryCommand = class QueryCommand extends import_smithy_client62.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde45.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint47.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "Query", {}).n("DynamoDBClient", "QueryCommand").f(undefined, undefined).ser(se_QueryCommand).de(de_QueryCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/RestoreTableFromBackupCommand.js
var import_middleware_endpoint48, import_middleware_serde46, import_smithy_client63, RestoreTableFromBackupCommand;
var init_RestoreTableFromBackupCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint48 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde46 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client63 = __toESM(require_dist_cjs28(), 1);
  RestoreTableFromBackupCommand = class RestoreTableFromBackupCommand extends import_smithy_client63.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TargetTableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde46.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint48.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "RestoreTableFromBackup", {}).n("DynamoDBClient", "RestoreTableFromBackupCommand").f(undefined, undefined).ser(se_RestoreTableFromBackupCommand).de(de_RestoreTableFromBackupCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/RestoreTableToPointInTimeCommand.js
var import_middleware_endpoint49, import_middleware_serde47, import_smithy_client64, RestoreTableToPointInTimeCommand;
var init_RestoreTableToPointInTimeCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint49 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde47 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client64 = __toESM(require_dist_cjs28(), 1);
  RestoreTableToPointInTimeCommand = class RestoreTableToPointInTimeCommand extends import_smithy_client64.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TargetTableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde47.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint49.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "RestoreTableToPointInTime", {}).n("DynamoDBClient", "RestoreTableToPointInTimeCommand").f(undefined, undefined).ser(se_RestoreTableToPointInTimeCommand).de(de_RestoreTableToPointInTimeCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/ScanCommand.js
var import_middleware_endpoint50, import_middleware_serde48, import_smithy_client65, ScanCommand;
var init_ScanCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint50 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde48 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client65 = __toESM(require_dist_cjs28(), 1);
  ScanCommand = class ScanCommand extends import_smithy_client65.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde48.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint50.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "Scan", {}).n("DynamoDBClient", "ScanCommand").f(undefined, undefined).ser(se_ScanCommand).de(de_ScanCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/TagResourceCommand.js
var import_middleware_endpoint51, import_middleware_serde49, import_smithy_client66, TagResourceCommand;
var init_TagResourceCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint51 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde49 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client66 = __toESM(require_dist_cjs28(), 1);
  TagResourceCommand = class TagResourceCommand extends import_smithy_client66.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "ResourceArn" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde49.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint51.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "TagResource", {}).n("DynamoDBClient", "TagResourceCommand").f(undefined, undefined).ser(se_TagResourceCommand).de(de_TagResourceCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/TransactGetItemsCommand.js
var import_middleware_endpoint52, import_middleware_serde50, import_smithy_client67, TransactGetItemsCommand;
var init_TransactGetItemsCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint52 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde50 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client67 = __toESM(require_dist_cjs28(), 1);
  TransactGetItemsCommand = class TransactGetItemsCommand extends import_smithy_client67.Command.classBuilder().ep({
    ...commonParams,
    ResourceArnList: {
      type: "operationContextParams",
      get: (input) => input?.TransactItems?.map((obj) => obj?.Get?.TableName)
    }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde50.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint52.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "TransactGetItems", {}).n("DynamoDBClient", "TransactGetItemsCommand").f(undefined, undefined).ser(se_TransactGetItemsCommand).de(de_TransactGetItemsCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/TransactWriteItemsCommand.js
var import_middleware_endpoint53, import_middleware_serde51, import_smithy_client68, TransactWriteItemsCommand;
var init_TransactWriteItemsCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint53 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde51 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client68 = __toESM(require_dist_cjs28(), 1);
  TransactWriteItemsCommand = class TransactWriteItemsCommand extends import_smithy_client68.Command.classBuilder().ep({
    ...commonParams,
    ResourceArnList: {
      type: "operationContextParams",
      get: (input) => input?.TransactItems?.map((obj) => [obj?.ConditionCheck?.TableName, obj?.Put?.TableName, obj?.Delete?.TableName, obj?.Update?.TableName].filter((i4) => i4)).flat()
    }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde51.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint53.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "TransactWriteItems", {}).n("DynamoDBClient", "TransactWriteItemsCommand").f(undefined, undefined).ser(se_TransactWriteItemsCommand).de(de_TransactWriteItemsCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/UntagResourceCommand.js
var import_middleware_endpoint54, import_middleware_serde52, import_smithy_client69, UntagResourceCommand;
var init_UntagResourceCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint54 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde52 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client69 = __toESM(require_dist_cjs28(), 1);
  UntagResourceCommand = class UntagResourceCommand extends import_smithy_client69.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "ResourceArn" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde52.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint54.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "UntagResource", {}).n("DynamoDBClient", "UntagResourceCommand").f(undefined, undefined).ser(se_UntagResourceCommand).de(de_UntagResourceCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/UpdateContinuousBackupsCommand.js
var import_middleware_endpoint55, import_middleware_serde53, import_smithy_client70, UpdateContinuousBackupsCommand;
var init_UpdateContinuousBackupsCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint55 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde53 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client70 = __toESM(require_dist_cjs28(), 1);
  UpdateContinuousBackupsCommand = class UpdateContinuousBackupsCommand extends import_smithy_client70.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde53.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint55.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "UpdateContinuousBackups", {}).n("DynamoDBClient", "UpdateContinuousBackupsCommand").f(undefined, undefined).ser(se_UpdateContinuousBackupsCommand).de(de_UpdateContinuousBackupsCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/UpdateContributorInsightsCommand.js
var import_middleware_endpoint56, import_middleware_serde54, import_smithy_client71, UpdateContributorInsightsCommand;
var init_UpdateContributorInsightsCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint56 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde54 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client71 = __toESM(require_dist_cjs28(), 1);
  UpdateContributorInsightsCommand = class UpdateContributorInsightsCommand extends import_smithy_client71.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde54.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint56.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "UpdateContributorInsights", {}).n("DynamoDBClient", "UpdateContributorInsightsCommand").f(undefined, undefined).ser(se_UpdateContributorInsightsCommand).de(de_UpdateContributorInsightsCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/UpdateGlobalTableCommand.js
var import_middleware_endpoint57, import_middleware_serde55, import_smithy_client72, UpdateGlobalTableCommand;
var init_UpdateGlobalTableCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint57 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde55 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client72 = __toESM(require_dist_cjs28(), 1);
  UpdateGlobalTableCommand = class UpdateGlobalTableCommand extends import_smithy_client72.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "GlobalTableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde55.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint57.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "UpdateGlobalTable", {}).n("DynamoDBClient", "UpdateGlobalTableCommand").f(undefined, undefined).ser(se_UpdateGlobalTableCommand).de(de_UpdateGlobalTableCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/UpdateGlobalTableSettingsCommand.js
var import_middleware_endpoint58, import_middleware_serde56, import_smithy_client73, UpdateGlobalTableSettingsCommand;
var init_UpdateGlobalTableSettingsCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint58 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde56 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client73 = __toESM(require_dist_cjs28(), 1);
  UpdateGlobalTableSettingsCommand = class UpdateGlobalTableSettingsCommand extends import_smithy_client73.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "GlobalTableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde56.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint58.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "UpdateGlobalTableSettings", {}).n("DynamoDBClient", "UpdateGlobalTableSettingsCommand").f(undefined, undefined).ser(se_UpdateGlobalTableSettingsCommand).de(de_UpdateGlobalTableSettingsCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/UpdateItemCommand.js
var import_middleware_endpoint59, import_middleware_serde57, import_smithy_client74, UpdateItemCommand;
var init_UpdateItemCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint59 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde57 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client74 = __toESM(require_dist_cjs28(), 1);
  UpdateItemCommand = class UpdateItemCommand extends import_smithy_client74.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde57.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint59.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "UpdateItem", {}).n("DynamoDBClient", "UpdateItemCommand").f(undefined, undefined).ser(se_UpdateItemCommand).de(de_UpdateItemCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/UpdateKinesisStreamingDestinationCommand.js
var import_middleware_endpoint60, import_middleware_serde58, import_smithy_client75, UpdateKinesisStreamingDestinationCommand;
var init_UpdateKinesisStreamingDestinationCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint60 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde58 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client75 = __toESM(require_dist_cjs28(), 1);
  UpdateKinesisStreamingDestinationCommand = class UpdateKinesisStreamingDestinationCommand extends import_smithy_client75.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde58.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint60.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "UpdateKinesisStreamingDestination", {}).n("DynamoDBClient", "UpdateKinesisStreamingDestinationCommand").f(undefined, undefined).ser(se_UpdateKinesisStreamingDestinationCommand).de(de_UpdateKinesisStreamingDestinationCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/UpdateTableCommand.js
var import_middleware_endpoint61, import_middleware_serde59, import_smithy_client76, UpdateTableCommand;
var init_UpdateTableCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint61 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde59 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client76 = __toESM(require_dist_cjs28(), 1);
  UpdateTableCommand = class UpdateTableCommand extends import_smithy_client76.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde59.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint61.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "UpdateTable", {}).n("DynamoDBClient", "UpdateTableCommand").f(undefined, undefined).ser(se_UpdateTableCommand).de(de_UpdateTableCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/UpdateTableReplicaAutoScalingCommand.js
var import_middleware_endpoint62, import_middleware_serde60, import_smithy_client77, UpdateTableReplicaAutoScalingCommand;
var init_UpdateTableReplicaAutoScalingCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint62 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde60 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client77 = __toESM(require_dist_cjs28(), 1);
  UpdateTableReplicaAutoScalingCommand = class UpdateTableReplicaAutoScalingCommand extends import_smithy_client77.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde60.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint62.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "UpdateTableReplicaAutoScaling", {}).n("DynamoDBClient", "UpdateTableReplicaAutoScalingCommand").f(undefined, undefined).ser(se_UpdateTableReplicaAutoScalingCommand).de(de_UpdateTableReplicaAutoScalingCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/UpdateTimeToLiveCommand.js
var import_middleware_endpoint63, import_middleware_serde61, import_smithy_client78, UpdateTimeToLiveCommand;
var init_UpdateTimeToLiveCommand = __esm(() => {
  init_EndpointParameters();
  init_Aws_json1_0();
  import_middleware_endpoint63 = __toESM(require_dist_cjs37(), 1);
  import_middleware_serde61 = __toESM(require_dist_cjs7(), 1);
  import_smithy_client78 = __toESM(require_dist_cjs28(), 1);
  UpdateTimeToLiveCommand = class UpdateTimeToLiveCommand extends import_smithy_client78.Command.classBuilder().ep({
    ...commonParams,
    ResourceArn: { type: "contextParams", name: "TableName" }
  }).m(function(Command, cs, config, o3) {
    return [
      import_middleware_serde61.getSerdePlugin(config, this.serialize, this.deserialize),
      import_middleware_endpoint63.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
    ];
  }).s("DynamoDB_20120810", "UpdateTimeToLive", {}).n("DynamoDBClient", "UpdateTimeToLiveCommand").f(undefined, undefined).ser(se_UpdateTimeToLiveCommand).de(de_UpdateTimeToLiveCommand).build() {
  };
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/DynamoDB.js
var import_smithy_client79, commands3, DynamoDB;
var init_DynamoDB = __esm(() => {
  init_BatchExecuteStatementCommand();
  init_BatchGetItemCommand();
  init_BatchWriteItemCommand();
  init_CreateBackupCommand();
  init_CreateGlobalTableCommand();
  init_CreateTableCommand();
  init_DeleteBackupCommand();
  init_DeleteItemCommand();
  init_DeleteResourcePolicyCommand();
  init_DeleteTableCommand();
  init_DescribeBackupCommand();
  init_DescribeContinuousBackupsCommand();
  init_DescribeContributorInsightsCommand();
  init_DescribeEndpointsCommand();
  init_DescribeExportCommand();
  init_DescribeGlobalTableCommand();
  init_DescribeGlobalTableSettingsCommand();
  init_DescribeImportCommand();
  init_DescribeKinesisStreamingDestinationCommand();
  init_DescribeLimitsCommand();
  init_DescribeTableCommand();
  init_DescribeTableReplicaAutoScalingCommand();
  init_DescribeTimeToLiveCommand();
  init_DisableKinesisStreamingDestinationCommand();
  init_EnableKinesisStreamingDestinationCommand();
  init_ExecuteStatementCommand();
  init_ExecuteTransactionCommand();
  init_ExportTableToPointInTimeCommand();
  init_GetItemCommand();
  init_GetResourcePolicyCommand();
  init_ImportTableCommand();
  init_ListBackupsCommand();
  init_ListContributorInsightsCommand();
  init_ListExportsCommand();
  init_ListGlobalTablesCommand();
  init_ListImportsCommand();
  init_ListTablesCommand();
  init_ListTagsOfResourceCommand();
  init_PutItemCommand();
  init_PutResourcePolicyCommand();
  init_QueryCommand();
  init_RestoreTableFromBackupCommand();
  init_RestoreTableToPointInTimeCommand();
  init_ScanCommand();
  init_TagResourceCommand();
  init_TransactGetItemsCommand();
  init_TransactWriteItemsCommand();
  init_UntagResourceCommand();
  init_UpdateContinuousBackupsCommand();
  init_UpdateContributorInsightsCommand();
  init_UpdateGlobalTableCommand();
  init_UpdateGlobalTableSettingsCommand();
  init_UpdateItemCommand();
  init_UpdateKinesisStreamingDestinationCommand();
  init_UpdateTableCommand();
  init_UpdateTableReplicaAutoScalingCommand();
  init_UpdateTimeToLiveCommand();
  init_DynamoDBClient();
  import_smithy_client79 = __toESM(require_dist_cjs28(), 1);
  commands3 = {
    BatchExecuteStatementCommand,
    BatchGetItemCommand,
    BatchWriteItemCommand,
    CreateBackupCommand,
    CreateGlobalTableCommand,
    CreateTableCommand,
    DeleteBackupCommand,
    DeleteItemCommand,
    DeleteResourcePolicyCommand,
    DeleteTableCommand,
    DescribeBackupCommand,
    DescribeContinuousBackupsCommand,
    DescribeContributorInsightsCommand,
    DescribeEndpointsCommand,
    DescribeExportCommand,
    DescribeGlobalTableCommand,
    DescribeGlobalTableSettingsCommand,
    DescribeImportCommand,
    DescribeKinesisStreamingDestinationCommand,
    DescribeLimitsCommand,
    DescribeTableCommand,
    DescribeTableReplicaAutoScalingCommand,
    DescribeTimeToLiveCommand,
    DisableKinesisStreamingDestinationCommand,
    EnableKinesisStreamingDestinationCommand,
    ExecuteStatementCommand,
    ExecuteTransactionCommand,
    ExportTableToPointInTimeCommand,
    GetItemCommand,
    GetResourcePolicyCommand,
    ImportTableCommand,
    ListBackupsCommand,
    ListContributorInsightsCommand,
    ListExportsCommand,
    ListGlobalTablesCommand,
    ListImportsCommand,
    ListTablesCommand,
    ListTagsOfResourceCommand,
    PutItemCommand,
    PutResourcePolicyCommand,
    QueryCommand,
    RestoreTableFromBackupCommand,
    RestoreTableToPointInTimeCommand,
    ScanCommand,
    TagResourceCommand,
    TransactGetItemsCommand,
    TransactWriteItemsCommand,
    UntagResourceCommand,
    UpdateContinuousBackupsCommand,
    UpdateContributorInsightsCommand,
    UpdateGlobalTableCommand,
    UpdateGlobalTableSettingsCommand,
    UpdateItemCommand,
    UpdateKinesisStreamingDestinationCommand,
    UpdateTableCommand,
    UpdateTableReplicaAutoScalingCommand,
    UpdateTimeToLiveCommand
  };
  DynamoDB = class DynamoDB extends DynamoDBClient {
  };
  import_smithy_client79.createAggregatedClient(commands3, DynamoDB);
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/commands/index.js
var init_commands2 = __esm(() => {
  init_BatchExecuteStatementCommand();
  init_BatchGetItemCommand();
  init_BatchWriteItemCommand();
  init_CreateBackupCommand();
  init_CreateGlobalTableCommand();
  init_CreateTableCommand();
  init_DeleteBackupCommand();
  init_DeleteItemCommand();
  init_DeleteResourcePolicyCommand();
  init_DeleteTableCommand();
  init_DescribeBackupCommand();
  init_DescribeContinuousBackupsCommand();
  init_DescribeContributorInsightsCommand();
  init_DescribeEndpointsCommand();
  init_DescribeExportCommand();
  init_DescribeGlobalTableCommand();
  init_DescribeGlobalTableSettingsCommand();
  init_DescribeImportCommand();
  init_DescribeKinesisStreamingDestinationCommand();
  init_DescribeLimitsCommand();
  init_DescribeTableCommand();
  init_DescribeTableReplicaAutoScalingCommand();
  init_DescribeTimeToLiveCommand();
  init_DisableKinesisStreamingDestinationCommand();
  init_EnableKinesisStreamingDestinationCommand();
  init_ExecuteStatementCommand();
  init_ExecuteTransactionCommand();
  init_ExportTableToPointInTimeCommand();
  init_GetItemCommand();
  init_GetResourcePolicyCommand();
  init_ImportTableCommand();
  init_ListBackupsCommand();
  init_ListContributorInsightsCommand();
  init_ListExportsCommand();
  init_ListGlobalTablesCommand();
  init_ListImportsCommand();
  init_ListTablesCommand();
  init_ListTagsOfResourceCommand();
  init_PutItemCommand();
  init_PutResourcePolicyCommand();
  init_QueryCommand();
  init_RestoreTableFromBackupCommand();
  init_RestoreTableToPointInTimeCommand();
  init_ScanCommand();
  init_TagResourceCommand();
  init_TransactGetItemsCommand();
  init_TransactWriteItemsCommand();
  init_UntagResourceCommand();
  init_UpdateContinuousBackupsCommand();
  init_UpdateContributorInsightsCommand();
  init_UpdateGlobalTableCommand();
  init_UpdateGlobalTableSettingsCommand();
  init_UpdateItemCommand();
  init_UpdateKinesisStreamingDestinationCommand();
  init_UpdateTableCommand();
  init_UpdateTableReplicaAutoScalingCommand();
  init_UpdateTimeToLiveCommand();
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/pagination/Interfaces.js
var init_Interfaces2 = () => {};

// node_modules/@aws-sdk/client-dynamodb/dist-es/pagination/ListContributorInsightsPaginator.js
var import_core18, paginateListContributorInsights;
var init_ListContributorInsightsPaginator = __esm(() => {
  init_ListContributorInsightsCommand();
  init_DynamoDBClient();
  import_core18 = __toESM(require_dist_cjs19(), 1);
  paginateListContributorInsights = import_core18.createPaginator(DynamoDBClient, ListContributorInsightsCommand, "NextToken", "NextToken", "MaxResults");
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/pagination/ListExportsPaginator.js
var import_core19, paginateListExports;
var init_ListExportsPaginator = __esm(() => {
  init_ListExportsCommand();
  init_DynamoDBClient();
  import_core19 = __toESM(require_dist_cjs19(), 1);
  paginateListExports = import_core19.createPaginator(DynamoDBClient, ListExportsCommand, "NextToken", "NextToken", "MaxResults");
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/pagination/ListImportsPaginator.js
var import_core20, paginateListImports;
var init_ListImportsPaginator = __esm(() => {
  init_ListImportsCommand();
  init_DynamoDBClient();
  import_core20 = __toESM(require_dist_cjs19(), 1);
  paginateListImports = import_core20.createPaginator(DynamoDBClient, ListImportsCommand, "NextToken", "NextToken", "PageSize");
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/pagination/ListTablesPaginator.js
var import_core21, paginateListTables;
var init_ListTablesPaginator = __esm(() => {
  init_ListTablesCommand();
  init_DynamoDBClient();
  import_core21 = __toESM(require_dist_cjs19(), 1);
  paginateListTables = import_core21.createPaginator(DynamoDBClient, ListTablesCommand, "ExclusiveStartTableName", "LastEvaluatedTableName", "Limit");
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/pagination/QueryPaginator.js
var import_core22, paginateQuery;
var init_QueryPaginator = __esm(() => {
  init_QueryCommand();
  init_DynamoDBClient();
  import_core22 = __toESM(require_dist_cjs19(), 1);
  paginateQuery = import_core22.createPaginator(DynamoDBClient, QueryCommand, "ExclusiveStartKey", "LastEvaluatedKey", "Limit");
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/pagination/ScanPaginator.js
var import_core23, paginateScan;
var init_ScanPaginator = __esm(() => {
  init_ScanCommand();
  init_DynamoDBClient();
  import_core23 = __toESM(require_dist_cjs19(), 1);
  paginateScan = import_core23.createPaginator(DynamoDBClient, ScanCommand, "ExclusiveStartKey", "LastEvaluatedKey", "Limit");
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/pagination/index.js
var init_pagination2 = __esm(() => {
  init_Interfaces2();
  init_ListContributorInsightsPaginator();
  init_ListExportsPaginator();
  init_ListImportsPaginator();
  init_ListTablesPaginator();
  init_QueryPaginator();
  init_ScanPaginator();
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/waiters/waitForTableExists.js
var init_waitForTableExists = () => {};

// node_modules/@aws-sdk/client-dynamodb/dist-es/waiters/waitForTableNotExists.js
var init_waitForTableNotExists = () => {};

// node_modules/@aws-sdk/client-dynamodb/dist-es/waiters/index.js
var init_waiters = __esm(() => {
  init_waitForTableExists();
  init_waitForTableNotExists();
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/models/models_1.js
var init_models_1 = () => {};

// node_modules/@aws-sdk/client-dynamodb/dist-es/models/index.js
var init_models2 = __esm(() => {
  init_models_0();
  init_models_1();
});

// node_modules/@aws-sdk/client-dynamodb/dist-es/index.js
var init_dist_es13 = __esm(() => {
  init_DynamoDBClient();
  init_DynamoDB();
  init_commands2();
  init_pagination2();
  init_waiters();
  init_models2();
});

// node_modules/@aws-sdk/util-dynamodb/dist-es/NumberValue.js
class NumberValue {
  value;
  constructor(value) {
    if (typeof value === "object" && "N" in value) {
      this.value = String(value.N);
    } else {
      this.value = String(value);
    }
    const valueOf = typeof value.valueOf() === "number" ? value.valueOf() : 0;
    const imprecise = valueOf > Number.MAX_SAFE_INTEGER || valueOf < Number.MIN_SAFE_INTEGER || Math.abs(valueOf) === Infinity || Number.isNaN(valueOf);
    if (imprecise) {
      throw new Error(`NumberValue should not be initialized with an imprecise number=${valueOf}. Use a string instead.`);
    }
  }
  static from(value) {
    return new NumberValue(value);
  }
  toAttributeValue() {
    return {
      N: this.toString()
    };
  }
  toBigInt() {
    const stringValue = this.toString();
    return BigInt(stringValue);
  }
  toString() {
    return String(this.value);
  }
  valueOf() {
    return this.toString();
  }
}

// node_modules/@aws-sdk/util-dynamodb/dist-es/convertToAttr.js
var convertToAttr = (data, options) => {
  if (data === undefined) {
    throw new Error(`Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.`);
  } else if (data === null && typeof data === "object") {
    return convertToNullAttr();
  } else if (Array.isArray(data)) {
    return convertToListAttr(data, options);
  } else if (data?.constructor?.name === "Set") {
    return convertToSetAttr(data, options);
  } else if (data?.constructor?.name === "Map") {
    return convertToMapAttrFromIterable(data, options);
  } else if (data?.constructor?.name === "Object" || !data.constructor && typeof data === "object") {
    return convertToMapAttrFromEnumerableProps(data, options);
  } else if (isBinary(data)) {
    if (data.length === 0 && options?.convertEmptyValues) {
      return convertToNullAttr();
    }
    return convertToBinaryAttr(data);
  } else if (typeof data === "boolean" || data?.constructor?.name === "Boolean") {
    return { BOOL: data.valueOf() };
  } else if (typeof data === "number" || data?.constructor?.name === "Number") {
    return convertToNumberAttr(data, options);
  } else if (data instanceof NumberValue) {
    return data.toAttributeValue();
  } else if (typeof data === "bigint") {
    return convertToBigIntAttr(data);
  } else if (typeof data === "string" || data?.constructor?.name === "String") {
    if (data.length === 0 && options?.convertEmptyValues) {
      return convertToNullAttr();
    }
    return convertToStringAttr(data);
  } else if (options?.convertClassInstanceToMap && typeof data === "object") {
    return convertToMapAttrFromEnumerableProps(data, options);
  }
  throw new Error(`Unsupported type passed: ${data}. Pass options.convertClassInstanceToMap=true to marshall typeof object as map attribute.`);
}, convertToListAttr = (data, options) => ({
  L: data.filter((item) => typeof item !== "function" && (!options?.removeUndefinedValues || options?.removeUndefinedValues && item !== undefined)).map((item) => convertToAttr(item, options))
}), convertToSetAttr = (set2, options) => {
  const setToOperate = options?.removeUndefinedValues ? new Set([...set2].filter((value) => value !== undefined)) : set2;
  if (!options?.removeUndefinedValues && setToOperate.has(undefined)) {
    throw new Error(`Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.`);
  }
  if (setToOperate.size === 0) {
    if (options?.convertEmptyValues) {
      return convertToNullAttr();
    }
    throw new Error(`Pass a non-empty set, or options.convertEmptyValues=true.`);
  }
  const item = setToOperate.values().next().value;
  if (item instanceof NumberValue) {
    return {
      NS: Array.from(setToOperate).map((_2) => _2.toString())
    };
  } else if (typeof item === "number") {
    return {
      NS: Array.from(setToOperate).map((num) => convertToNumberAttr(num, options)).map((item2) => item2.N)
    };
  } else if (typeof item === "bigint") {
    return {
      NS: Array.from(setToOperate).map(convertToBigIntAttr).map((item2) => item2.N)
    };
  } else if (typeof item === "string") {
    return {
      SS: Array.from(setToOperate).map(convertToStringAttr).map((item2) => item2.S)
    };
  } else if (isBinary(item)) {
    return {
      BS: Array.from(setToOperate).map(convertToBinaryAttr).map((item2) => item2.B)
    };
  } else {
    throw new Error(`Only Number Set (NS), Binary Set (BS) or String Set (SS) are allowed.`);
  }
}, convertToMapAttrFromIterable = (data, options) => ({
  M: ((data2) => {
    const map4 = {};
    for (const [key, value] of data2) {
      if (typeof value !== "function" && (value !== undefined || !options?.removeUndefinedValues)) {
        map4[key] = convertToAttr(value, options);
      }
    }
    return map4;
  })(data)
}), convertToMapAttrFromEnumerableProps = (data, options) => ({
  M: ((data2) => {
    const map4 = {};
    for (const key in data2) {
      const value = data2[key];
      if (typeof value !== "function" && (value !== undefined || !options?.removeUndefinedValues)) {
        map4[key] = convertToAttr(value, options);
      }
    }
    return map4;
  })(data)
}), convertToNullAttr = () => ({ NULL: true }), convertToBinaryAttr = (data) => ({ B: data }), convertToStringAttr = (data) => ({ S: data.toString() }), convertToBigIntAttr = (data) => ({ N: data.toString() }), validateBigIntAndThrow = (errorPrefix) => {
  throw new Error(`${errorPrefix} Use NumberValue from @aws-sdk/lib-dynamodb.`);
}, convertToNumberAttr = (num, options) => {
  if ([Number.NaN, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY].map((val) => val.toString()).includes(num.toString())) {
    throw new Error(`Special numeric value ${num.toString()} is not allowed`);
  } else if (!options?.allowImpreciseNumbers) {
    if (Number(num) > Number.MAX_SAFE_INTEGER) {
      validateBigIntAndThrow(`Number ${num.toString()} is greater than Number.MAX_SAFE_INTEGER.`);
    } else if (Number(num) < Number.MIN_SAFE_INTEGER) {
      validateBigIntAndThrow(`Number ${num.toString()} is lesser than Number.MIN_SAFE_INTEGER.`);
    }
  }
  return { N: num.toString() };
}, isBinary = (data) => {
  const binaryTypes = [
    "ArrayBuffer",
    "Blob",
    "Buffer",
    "DataView",
    "File",
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Uint16Array",
    "Int32Array",
    "Uint32Array",
    "Float32Array",
    "Float64Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  if (data?.constructor) {
    return binaryTypes.includes(data.constructor.name);
  }
  return false;
};
var init_convertToAttr = () => {};

// node_modules/@aws-sdk/util-dynamodb/dist-es/convertToNative.js
var convertToNative = (data, options) => {
  for (const [key, value] of Object.entries(data)) {
    if (value !== undefined) {
      switch (key) {
        case "NULL":
          return null;
        case "BOOL":
          return Boolean(value);
        case "N":
          return convertNumber(value, options);
        case "B":
          return convertBinary(value);
        case "S":
          return convertString(value);
        case "L":
          return convertList(value, options);
        case "M":
          return convertMap(value, options);
        case "NS":
          return new Set(value.map((item) => convertNumber(item, options)));
        case "BS":
          return new Set(value.map(convertBinary));
        case "SS":
          return new Set(value.map(convertString));
        default:
          throw new Error(`Unsupported type passed: ${key}`);
      }
    }
  }
  throw new Error(`No value defined: ${JSON.stringify(data)}`);
}, convertNumber = (numString, options) => {
  if (typeof options?.wrapNumbers === "function") {
    return options?.wrapNumbers(numString);
  }
  if (options?.wrapNumbers) {
    return NumberValue.from(numString);
  }
  const num = Number(numString);
  const infinityValues = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
  const isLargeFiniteNumber = (num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) && !infinityValues.includes(num);
  if (isLargeFiniteNumber) {
    if (typeof BigInt === "function") {
      try {
        return BigInt(numString);
      } catch (error) {
        throw new Error(`${numString} can't be converted to BigInt. Set options.wrapNumbers to get string value.`);
      }
    } else {
      throw new Error(`${numString} is outside SAFE_INTEGER bounds. Set options.wrapNumbers to get string value.`);
    }
  }
  return num;
}, convertString = (stringValue) => stringValue, convertBinary = (binaryValue) => binaryValue, convertList = (list, options) => list.map((item) => convertToNative(item, options)), convertMap = (map4, options) => Object.entries(map4).reduce((acc, [key, value]) => (acc[key] = convertToNative(value, options), acc), {});
var init_convertToNative = () => {};

// node_modules/@aws-sdk/util-dynamodb/dist-es/marshall.js
function marshall(data, options) {
  const attributeValue = convertToAttr(data, options);
  const [key, value] = Object.entries(attributeValue)[0];
  switch (key) {
    case "M":
    case "L":
      return options?.convertTopLevelContainer ? attributeValue : value;
    case "SS":
    case "NS":
    case "BS":
    case "S":
    case "N":
    case "B":
    case "NULL":
    case "BOOL":
    case "$unknown":
    default:
      return attributeValue;
  }
}
var init_marshall = __esm(() => {
  init_convertToAttr();
});

// node_modules/@aws-sdk/util-dynamodb/dist-es/models.js
var init_models3 = () => {};

// node_modules/@aws-sdk/util-dynamodb/dist-es/unmarshall.js
var unmarshall = (data, options) => {
  if (options?.convertWithoutMapWrapper) {
    return convertToNative(data, options);
  }
  return convertToNative({ M: data }, options);
};
var init_unmarshall = __esm(() => {
  init_convertToNative();
});

// node_modules/@aws-sdk/util-dynamodb/dist-es/index.js
var init_dist_es14 = __esm(() => {
  init_convertToAttr();
  init_convertToNative();
  init_marshall();
  init_models3();
  init_unmarshall();
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/utils.js
var SELF = null, ALL_VALUES, ALL_MEMBERS, NEXT_LEVEL = "*", processObj = (obj, processFunc, keyNodes) => {
  if (obj !== undefined) {
    if (keyNodes == null) {
      return processFunc(obj);
    } else {
      const keys = Object.keys(keyNodes);
      const goToNextLevel = keys.length === 1 && keys[0] === NEXT_LEVEL;
      const someChildren = keys.length >= 1 && !goToNextLevel;
      const allChildren = keys.length === 0;
      if (someChildren) {
        return processKeysInObj(obj, processFunc, keyNodes);
      } else if (allChildren) {
        return processAllKeysInObj(obj, processFunc, SELF);
      } else if (goToNextLevel) {
        return Object.entries(obj ?? {}).reduce((acc, [k4, v3]) => {
          if (typeof v3 !== "function") {
            acc[k4] = processObj(v3, processFunc, keyNodes[NEXT_LEVEL]);
          }
          return acc;
        }, Array.isArray(obj) ? [] : {});
      }
    }
  }
  return;
}, processKeysInObj = (obj, processFunc, keyNodes) => {
  let accumulator;
  if (Array.isArray(obj)) {
    accumulator = obj.filter((item) => typeof item !== "function");
  } else {
    accumulator = {};
    for (const [k4, v3] of Object.entries(obj)) {
      if (typeof v3 !== "function") {
        accumulator[k4] = v3;
      }
    }
  }
  for (const [nodeKey, nodes] of Object.entries(keyNodes)) {
    if (typeof obj[nodeKey] === "function") {
      continue;
    }
    const processedValue = processObj(obj[nodeKey], processFunc, nodes);
    if (processedValue !== undefined && typeof processedValue !== "function") {
      accumulator[nodeKey] = processedValue;
    }
  }
  return accumulator;
}, processAllKeysInObj = (obj, processFunc, keyNodes) => {
  if (Array.isArray(obj)) {
    return obj.filter((item) => typeof item !== "function").map((item) => processObj(item, processFunc, keyNodes));
  }
  return Object.entries(obj).reduce((acc, [key, value]) => {
    if (typeof value === "function") {
      return acc;
    }
    const processedValue = processObj(value, processFunc, keyNodes);
    if (processedValue !== undefined && typeof processedValue !== "function") {
      acc[key] = processedValue;
    }
    return acc;
  }, {});
}, marshallInput = (obj, keyNodes, options) => {
  const marshallFunc = (toMarshall) => marshall(toMarshall, options);
  return processKeysInObj(obj, marshallFunc, keyNodes);
}, unmarshallOutput = (obj, keyNodes, options) => {
  const unmarshallFunc = (toMarshall) => unmarshall(toMarshall, options);
  return processKeysInObj(obj, unmarshallFunc, keyNodes);
};
var init_utils = __esm(() => {
  init_dist_es14();
  ALL_VALUES = {};
  ALL_MEMBERS = [];
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/baseCommand/DynamoDBDocumentClientCommand.js
var import_core24, import_smithy_client80, DynamoDBDocumentClientCommand;
var init_DynamoDBDocumentClientCommand = __esm(() => {
  init_utils();
  import_core24 = __toESM(require_dist_cjs30(), 1);
  import_smithy_client80 = __toESM(require_dist_cjs28(), 1);
  DynamoDBDocumentClientCommand = class DynamoDBDocumentClientCommand extends import_smithy_client80.Command {
    addMarshallingMiddleware(configuration) {
      const { marshallOptions = {}, unmarshallOptions = {} } = configuration.translateConfig || {};
      marshallOptions.convertTopLevelContainer = marshallOptions.convertTopLevelContainer ?? true;
      unmarshallOptions.convertWithoutMapWrapper = unmarshallOptions.convertWithoutMapWrapper ?? true;
      this.clientCommand.middlewareStack.addRelativeTo((next, context) => async (args) => {
        import_core24.setFeature(context, "DDB_MAPPER", "d");
        return next({
          ...args,
          input: marshallInput(args.input, this.inputKeyNodes, marshallOptions)
        });
      }, {
        name: "DocumentMarshall",
        relation: "before",
        toMiddleware: "serializerMiddleware",
        override: true
      });
      this.clientCommand.middlewareStack.addRelativeTo((next, context) => async (args) => {
        const deserialized = await next(args);
        deserialized.output = unmarshallOutput(deserialized.output, this.outputKeyNodes, unmarshallOptions);
        return deserialized;
      }, {
        name: "DocumentUnmarshall",
        relation: "before",
        toMiddleware: "deserializerMiddleware",
        override: true
      });
    }
  };
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/BatchExecuteStatementCommand.js
var BatchExecuteStatementCommand3;
var init_BatchExecuteStatementCommand2 = __esm(() => {
  init_dist_es13();
  init_DynamoDBDocumentClientCommand();
  init_utils();
  BatchExecuteStatementCommand3 = class BatchExecuteStatementCommand3 extends DynamoDBDocumentClientCommand {
    input;
    inputKeyNodes = {
      Statements: {
        "*": {
          Parameters: ALL_MEMBERS
        }
      }
    };
    outputKeyNodes = {
      Responses: {
        "*": {
          Error: {
            Item: ALL_VALUES
          },
          Item: ALL_VALUES
        }
      }
    };
    clientCommand;
    middlewareStack;
    constructor(input) {
      super();
      this.input = input;
      this.clientCommand = new BatchExecuteStatementCommand(this.input);
      this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
      this.addMarshallingMiddleware(configuration);
      const stack = clientStack.concat(this.middlewareStack);
      const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
      return async () => handler(this.clientCommand);
    }
  };
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/BatchGetCommand.js
var BatchGetCommand;
var init_BatchGetCommand = __esm(() => {
  init_dist_es13();
  init_DynamoDBDocumentClientCommand();
  init_utils();
  BatchGetCommand = class BatchGetCommand extends DynamoDBDocumentClientCommand {
    input;
    inputKeyNodes = {
      RequestItems: {
        "*": {
          Keys: {
            "*": ALL_VALUES
          }
        }
      }
    };
    outputKeyNodes = {
      Responses: {
        "*": {
          "*": ALL_VALUES
        }
      },
      UnprocessedKeys: {
        "*": {
          Keys: {
            "*": ALL_VALUES
          }
        }
      }
    };
    clientCommand;
    middlewareStack;
    constructor(input) {
      super();
      this.input = input;
      this.clientCommand = new BatchGetItemCommand(this.input);
      this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
      this.addMarshallingMiddleware(configuration);
      const stack = clientStack.concat(this.middlewareStack);
      const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
      return async () => handler(this.clientCommand);
    }
  };
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/BatchWriteCommand.js
var BatchWriteCommand;
var init_BatchWriteCommand = __esm(() => {
  init_dist_es13();
  init_DynamoDBDocumentClientCommand();
  init_utils();
  BatchWriteCommand = class BatchWriteCommand extends DynamoDBDocumentClientCommand {
    input;
    inputKeyNodes = {
      RequestItems: {
        "*": {
          "*": {
            PutRequest: {
              Item: ALL_VALUES
            },
            DeleteRequest: {
              Key: ALL_VALUES
            }
          }
        }
      }
    };
    outputKeyNodes = {
      UnprocessedItems: {
        "*": {
          "*": {
            PutRequest: {
              Item: ALL_VALUES
            },
            DeleteRequest: {
              Key: ALL_VALUES
            }
          }
        }
      },
      ItemCollectionMetrics: {
        "*": {
          "*": {
            ItemCollectionKey: ALL_VALUES
          }
        }
      }
    };
    clientCommand;
    middlewareStack;
    constructor(input) {
      super();
      this.input = input;
      this.clientCommand = new BatchWriteItemCommand(this.input);
      this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
      this.addMarshallingMiddleware(configuration);
      const stack = clientStack.concat(this.middlewareStack);
      const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
      return async () => handler(this.clientCommand);
    }
  };
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/DeleteCommand.js
var DeleteCommand;
var init_DeleteCommand = __esm(() => {
  init_dist_es13();
  init_DynamoDBDocumentClientCommand();
  init_utils();
  DeleteCommand = class DeleteCommand extends DynamoDBDocumentClientCommand {
    input;
    inputKeyNodes = {
      Key: ALL_VALUES,
      Expected: {
        "*": {
          Value: SELF,
          AttributeValueList: ALL_MEMBERS
        }
      },
      ExpressionAttributeValues: ALL_VALUES
    };
    outputKeyNodes = {
      Attributes: ALL_VALUES,
      ItemCollectionMetrics: {
        ItemCollectionKey: ALL_VALUES
      }
    };
    clientCommand;
    middlewareStack;
    constructor(input) {
      super();
      this.input = input;
      this.clientCommand = new DeleteItemCommand(this.input);
      this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
      this.addMarshallingMiddleware(configuration);
      const stack = clientStack.concat(this.middlewareStack);
      const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
      return async () => handler(this.clientCommand);
    }
  };
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/ExecuteStatementCommand.js
var ExecuteStatementCommand3;
var init_ExecuteStatementCommand2 = __esm(() => {
  init_dist_es13();
  init_DynamoDBDocumentClientCommand();
  init_utils();
  ExecuteStatementCommand3 = class ExecuteStatementCommand3 extends DynamoDBDocumentClientCommand {
    input;
    inputKeyNodes = {
      Parameters: ALL_MEMBERS
    };
    outputKeyNodes = {
      Items: {
        "*": ALL_VALUES
      },
      LastEvaluatedKey: ALL_VALUES
    };
    clientCommand;
    middlewareStack;
    constructor(input) {
      super();
      this.input = input;
      this.clientCommand = new ExecuteStatementCommand(this.input);
      this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
      this.addMarshallingMiddleware(configuration);
      const stack = clientStack.concat(this.middlewareStack);
      const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
      return async () => handler(this.clientCommand);
    }
  };
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/ExecuteTransactionCommand.js
var ExecuteTransactionCommand3;
var init_ExecuteTransactionCommand2 = __esm(() => {
  init_dist_es13();
  init_DynamoDBDocumentClientCommand();
  init_utils();
  ExecuteTransactionCommand3 = class ExecuteTransactionCommand3 extends DynamoDBDocumentClientCommand {
    input;
    inputKeyNodes = {
      TransactStatements: {
        "*": {
          Parameters: ALL_MEMBERS
        }
      }
    };
    outputKeyNodes = {
      Responses: {
        "*": {
          Item: ALL_VALUES
        }
      }
    };
    clientCommand;
    middlewareStack;
    constructor(input) {
      super();
      this.input = input;
      this.clientCommand = new ExecuteTransactionCommand(this.input);
      this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
      this.addMarshallingMiddleware(configuration);
      const stack = clientStack.concat(this.middlewareStack);
      const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
      return async () => handler(this.clientCommand);
    }
  };
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/GetCommand.js
var GetCommand;
var init_GetCommand = __esm(() => {
  init_dist_es13();
  init_DynamoDBDocumentClientCommand();
  init_utils();
  GetCommand = class GetCommand extends DynamoDBDocumentClientCommand {
    input;
    inputKeyNodes = {
      Key: ALL_VALUES
    };
    outputKeyNodes = {
      Item: ALL_VALUES
    };
    clientCommand;
    middlewareStack;
    constructor(input) {
      super();
      this.input = input;
      this.clientCommand = new GetItemCommand(this.input);
      this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
      this.addMarshallingMiddleware(configuration);
      const stack = clientStack.concat(this.middlewareStack);
      const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
      return async () => handler(this.clientCommand);
    }
  };
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/PutCommand.js
var PutCommand;
var init_PutCommand = __esm(() => {
  init_dist_es13();
  init_DynamoDBDocumentClientCommand();
  init_utils();
  PutCommand = class PutCommand extends DynamoDBDocumentClientCommand {
    input;
    inputKeyNodes = {
      Item: ALL_VALUES,
      Expected: {
        "*": {
          Value: SELF,
          AttributeValueList: ALL_MEMBERS
        }
      },
      ExpressionAttributeValues: ALL_VALUES
    };
    outputKeyNodes = {
      Attributes: ALL_VALUES,
      ItemCollectionMetrics: {
        ItemCollectionKey: ALL_VALUES
      }
    };
    clientCommand;
    middlewareStack;
    constructor(input) {
      super();
      this.input = input;
      this.clientCommand = new PutItemCommand(this.input);
      this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
      this.addMarshallingMiddleware(configuration);
      const stack = clientStack.concat(this.middlewareStack);
      const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
      return async () => handler(this.clientCommand);
    }
  };
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/QueryCommand.js
var QueryCommand3;
var init_QueryCommand2 = __esm(() => {
  init_dist_es13();
  init_DynamoDBDocumentClientCommand();
  init_utils();
  QueryCommand3 = class QueryCommand3 extends DynamoDBDocumentClientCommand {
    input;
    inputKeyNodes = {
      KeyConditions: {
        "*": {
          AttributeValueList: ALL_MEMBERS
        }
      },
      QueryFilter: {
        "*": {
          AttributeValueList: ALL_MEMBERS
        }
      },
      ExclusiveStartKey: ALL_VALUES,
      ExpressionAttributeValues: ALL_VALUES
    };
    outputKeyNodes = {
      Items: {
        "*": ALL_VALUES
      },
      LastEvaluatedKey: ALL_VALUES
    };
    clientCommand;
    middlewareStack;
    constructor(input) {
      super();
      this.input = input;
      this.clientCommand = new QueryCommand(this.input);
      this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
      this.addMarshallingMiddleware(configuration);
      const stack = clientStack.concat(this.middlewareStack);
      const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
      return async () => handler(this.clientCommand);
    }
  };
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/ScanCommand.js
var ScanCommand3;
var init_ScanCommand2 = __esm(() => {
  init_dist_es13();
  init_DynamoDBDocumentClientCommand();
  init_utils();
  ScanCommand3 = class ScanCommand3 extends DynamoDBDocumentClientCommand {
    input;
    inputKeyNodes = {
      ScanFilter: {
        "*": {
          AttributeValueList: ALL_MEMBERS
        }
      },
      ExclusiveStartKey: ALL_VALUES,
      ExpressionAttributeValues: ALL_VALUES
    };
    outputKeyNodes = {
      Items: {
        "*": ALL_VALUES
      },
      LastEvaluatedKey: ALL_VALUES
    };
    clientCommand;
    middlewareStack;
    constructor(input) {
      super();
      this.input = input;
      this.clientCommand = new ScanCommand(this.input);
      this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
      this.addMarshallingMiddleware(configuration);
      const stack = clientStack.concat(this.middlewareStack);
      const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
      return async () => handler(this.clientCommand);
    }
  };
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/TransactGetCommand.js
var TransactGetCommand;
var init_TransactGetCommand = __esm(() => {
  init_dist_es13();
  init_DynamoDBDocumentClientCommand();
  init_utils();
  TransactGetCommand = class TransactGetCommand extends DynamoDBDocumentClientCommand {
    input;
    inputKeyNodes = {
      TransactItems: {
        "*": {
          Get: {
            Key: ALL_VALUES
          }
        }
      }
    };
    outputKeyNodes = {
      Responses: {
        "*": {
          Item: ALL_VALUES
        }
      }
    };
    clientCommand;
    middlewareStack;
    constructor(input) {
      super();
      this.input = input;
      this.clientCommand = new TransactGetItemsCommand(this.input);
      this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
      this.addMarshallingMiddleware(configuration);
      const stack = clientStack.concat(this.middlewareStack);
      const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
      return async () => handler(this.clientCommand);
    }
  };
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/TransactWriteCommand.js
var TransactWriteCommand;
var init_TransactWriteCommand = __esm(() => {
  init_dist_es13();
  init_DynamoDBDocumentClientCommand();
  init_utils();
  TransactWriteCommand = class TransactWriteCommand extends DynamoDBDocumentClientCommand {
    input;
    inputKeyNodes = {
      TransactItems: {
        "*": {
          ConditionCheck: {
            Key: ALL_VALUES,
            ExpressionAttributeValues: ALL_VALUES
          },
          Put: {
            Item: ALL_VALUES,
            ExpressionAttributeValues: ALL_VALUES
          },
          Delete: {
            Key: ALL_VALUES,
            ExpressionAttributeValues: ALL_VALUES
          },
          Update: {
            Key: ALL_VALUES,
            ExpressionAttributeValues: ALL_VALUES
          }
        }
      }
    };
    outputKeyNodes = {
      ItemCollectionMetrics: {
        "*": {
          "*": {
            ItemCollectionKey: ALL_VALUES
          }
        }
      }
    };
    clientCommand;
    middlewareStack;
    constructor(input) {
      super();
      this.input = input;
      this.clientCommand = new TransactWriteItemsCommand(this.input);
      this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
      this.addMarshallingMiddleware(configuration);
      const stack = clientStack.concat(this.middlewareStack);
      const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
      return async () => handler(this.clientCommand);
    }
  };
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/UpdateCommand.js
var UpdateCommand;
var init_UpdateCommand = __esm(() => {
  init_dist_es13();
  init_DynamoDBDocumentClientCommand();
  init_utils();
  UpdateCommand = class UpdateCommand extends DynamoDBDocumentClientCommand {
    input;
    inputKeyNodes = {
      Key: ALL_VALUES,
      AttributeUpdates: {
        "*": {
          Value: SELF
        }
      },
      Expected: {
        "*": {
          Value: SELF,
          AttributeValueList: ALL_MEMBERS
        }
      },
      ExpressionAttributeValues: ALL_VALUES
    };
    outputKeyNodes = {
      Attributes: ALL_VALUES,
      ItemCollectionMetrics: {
        ItemCollectionKey: ALL_VALUES
      }
    };
    clientCommand;
    middlewareStack;
    constructor(input) {
      super();
      this.input = input;
      this.clientCommand = new UpdateItemCommand(this.input);
      this.middlewareStack = this.clientCommand.middlewareStack;
    }
    resolveMiddleware(clientStack, configuration, options) {
      this.addMarshallingMiddleware(configuration);
      const stack = clientStack.concat(this.middlewareStack);
      const handler = this.clientCommand.resolveMiddleware(stack, configuration, options);
      return async () => handler(this.clientCommand);
    }
  };
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/DynamoDBDocumentClient.js
var import_smithy_client81, DynamoDBDocumentClient;
var init_DynamoDBDocumentClient = __esm(() => {
  import_smithy_client81 = __toESM(require_dist_cjs28(), 1);
  DynamoDBDocumentClient = class DynamoDBDocumentClient extends import_smithy_client81.Client {
    config;
    constructor(client, translateConfig) {
      super(client.config);
      this.config = client.config;
      this.config.translateConfig = translateConfig;
      this.middlewareStack = client.middlewareStack;
      if (this.config?.cacheMiddleware) {
        throw new Error("@aws-sdk/lib-dynamodb - cacheMiddleware=true is not compatible with the" + " DynamoDBDocumentClient. This option must be set to false.");
      }
    }
    static from(client, translateConfig) {
      return new DynamoDBDocumentClient(client, translateConfig);
    }
    destroy() {}
  };
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/DynamoDBDocument.js
var DynamoDBDocument;
var init_DynamoDBDocument = __esm(() => {
  init_BatchExecuteStatementCommand2();
  init_BatchGetCommand();
  init_BatchWriteCommand();
  init_DeleteCommand();
  init_ExecuteStatementCommand2();
  init_ExecuteTransactionCommand2();
  init_GetCommand();
  init_PutCommand();
  init_QueryCommand2();
  init_ScanCommand2();
  init_TransactGetCommand();
  init_TransactWriteCommand();
  init_UpdateCommand();
  init_DynamoDBDocumentClient();
  DynamoDBDocument = class DynamoDBDocument extends DynamoDBDocumentClient {
    static from(client, translateConfig) {
      return new DynamoDBDocument(client, translateConfig);
    }
    batchExecuteStatement(args, optionsOrCb, cb) {
      const command = new BatchExecuteStatementCommand3(args);
      if (typeof optionsOrCb === "function") {
        this.send(command, optionsOrCb);
      } else if (typeof cb === "function") {
        if (typeof optionsOrCb !== "object") {
          throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
        }
        this.send(command, optionsOrCb || {}, cb);
      } else {
        return this.send(command, optionsOrCb);
      }
    }
    batchGet(args, optionsOrCb, cb) {
      const command = new BatchGetCommand(args);
      if (typeof optionsOrCb === "function") {
        this.send(command, optionsOrCb);
      } else if (typeof cb === "function") {
        if (typeof optionsOrCb !== "object") {
          throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
        }
        this.send(command, optionsOrCb || {}, cb);
      } else {
        return this.send(command, optionsOrCb);
      }
    }
    batchWrite(args, optionsOrCb, cb) {
      const command = new BatchWriteCommand(args);
      if (typeof optionsOrCb === "function") {
        this.send(command, optionsOrCb);
      } else if (typeof cb === "function") {
        if (typeof optionsOrCb !== "object") {
          throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
        }
        this.send(command, optionsOrCb || {}, cb);
      } else {
        return this.send(command, optionsOrCb);
      }
    }
    delete(args, optionsOrCb, cb) {
      const command = new DeleteCommand(args);
      if (typeof optionsOrCb === "function") {
        this.send(command, optionsOrCb);
      } else if (typeof cb === "function") {
        if (typeof optionsOrCb !== "object") {
          throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
        }
        this.send(command, optionsOrCb || {}, cb);
      } else {
        return this.send(command, optionsOrCb);
      }
    }
    executeStatement(args, optionsOrCb, cb) {
      const command = new ExecuteStatementCommand3(args);
      if (typeof optionsOrCb === "function") {
        this.send(command, optionsOrCb);
      } else if (typeof cb === "function") {
        if (typeof optionsOrCb !== "object") {
          throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
        }
        this.send(command, optionsOrCb || {}, cb);
      } else {
        return this.send(command, optionsOrCb);
      }
    }
    executeTransaction(args, optionsOrCb, cb) {
      const command = new ExecuteTransactionCommand3(args);
      if (typeof optionsOrCb === "function") {
        this.send(command, optionsOrCb);
      } else if (typeof cb === "function") {
        if (typeof optionsOrCb !== "object") {
          throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
        }
        this.send(command, optionsOrCb || {}, cb);
      } else {
        return this.send(command, optionsOrCb);
      }
    }
    get(args, optionsOrCb, cb) {
      const command = new GetCommand(args);
      if (typeof optionsOrCb === "function") {
        this.send(command, optionsOrCb);
      } else if (typeof cb === "function") {
        if (typeof optionsOrCb !== "object") {
          throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
        }
        this.send(command, optionsOrCb || {}, cb);
      } else {
        return this.send(command, optionsOrCb);
      }
    }
    put(args, optionsOrCb, cb) {
      const command = new PutCommand(args);
      if (typeof optionsOrCb === "function") {
        this.send(command, optionsOrCb);
      } else if (typeof cb === "function") {
        if (typeof optionsOrCb !== "object") {
          throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
        }
        this.send(command, optionsOrCb || {}, cb);
      } else {
        return this.send(command, optionsOrCb);
      }
    }
    query(args, optionsOrCb, cb) {
      const command = new QueryCommand3(args);
      if (typeof optionsOrCb === "function") {
        this.send(command, optionsOrCb);
      } else if (typeof cb === "function") {
        if (typeof optionsOrCb !== "object") {
          throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
        }
        this.send(command, optionsOrCb || {}, cb);
      } else {
        return this.send(command, optionsOrCb);
      }
    }
    scan(args, optionsOrCb, cb) {
      const command = new ScanCommand3(args);
      if (typeof optionsOrCb === "function") {
        this.send(command, optionsOrCb);
      } else if (typeof cb === "function") {
        if (typeof optionsOrCb !== "object") {
          throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
        }
        this.send(command, optionsOrCb || {}, cb);
      } else {
        return this.send(command, optionsOrCb);
      }
    }
    transactGet(args, optionsOrCb, cb) {
      const command = new TransactGetCommand(args);
      if (typeof optionsOrCb === "function") {
        this.send(command, optionsOrCb);
      } else if (typeof cb === "function") {
        if (typeof optionsOrCb !== "object") {
          throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
        }
        this.send(command, optionsOrCb || {}, cb);
      } else {
        return this.send(command, optionsOrCb);
      }
    }
    transactWrite(args, optionsOrCb, cb) {
      const command = new TransactWriteCommand(args);
      if (typeof optionsOrCb === "function") {
        this.send(command, optionsOrCb);
      } else if (typeof cb === "function") {
        if (typeof optionsOrCb !== "object") {
          throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
        }
        this.send(command, optionsOrCb || {}, cb);
      } else {
        return this.send(command, optionsOrCb);
      }
    }
    update(args, optionsOrCb, cb) {
      const command = new UpdateCommand(args);
      if (typeof optionsOrCb === "function") {
        this.send(command, optionsOrCb);
      } else if (typeof cb === "function") {
        if (typeof optionsOrCb !== "object") {
          throw new Error(`Expect http options but get ${typeof optionsOrCb}`);
        }
        this.send(command, optionsOrCb || {}, cb);
      } else {
        return this.send(command, optionsOrCb);
      }
    }
  };
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/commands/index.js
var init_commands3 = __esm(() => {
  init_BatchExecuteStatementCommand2();
  init_BatchGetCommand();
  init_BatchWriteCommand();
  init_DeleteCommand();
  init_ExecuteStatementCommand2();
  init_ExecuteTransactionCommand2();
  init_GetCommand();
  init_PutCommand();
  init_QueryCommand2();
  init_ScanCommand2();
  init_TransactGetCommand();
  init_TransactWriteCommand();
  init_UpdateCommand();
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/pagination/Interfaces.js
var init_Interfaces3 = () => {};

// node_modules/@aws-sdk/lib-dynamodb/dist-es/pagination/QueryPaginator.js
var import_core25, paginateQuery2;
var init_QueryPaginator2 = __esm(() => {
  init_QueryCommand2();
  init_DynamoDBDocumentClient();
  import_core25 = __toESM(require_dist_cjs19(), 1);
  paginateQuery2 = import_core25.createPaginator(DynamoDBDocumentClient, QueryCommand3, "ExclusiveStartKey", "LastEvaluatedKey", "Limit");
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/pagination/ScanPaginator.js
var import_core26, paginateScan2;
var init_ScanPaginator2 = __esm(() => {
  init_ScanCommand2();
  init_DynamoDBDocumentClient();
  import_core26 = __toESM(require_dist_cjs19(), 1);
  paginateScan2 = import_core26.createPaginator(DynamoDBDocumentClient, ScanCommand3, "ExclusiveStartKey", "LastEvaluatedKey", "Limit");
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/pagination/index.js
var init_pagination3 = __esm(() => {
  init_Interfaces3();
  init_QueryPaginator2();
  init_ScanPaginator2();
});

// node_modules/@aws-sdk/lib-dynamodb/dist-es/index.js
var exports_dist_es8 = {};
__export(exports_dist_es8, {
  paginateScan: () => paginateScan2,
  paginateQuery: () => paginateQuery2,
  __Client: () => import_smithy_client81.Client,
  UpdateCommand: () => UpdateCommand,
  TransactWriteCommand: () => TransactWriteCommand,
  TransactGetCommand: () => TransactGetCommand,
  ScanCommand: () => ScanCommand3,
  QueryCommand: () => QueryCommand3,
  PutCommand: () => PutCommand,
  NumberValue: () => NumberValue,
  GetCommand: () => GetCommand,
  ExecuteTransactionCommand: () => ExecuteTransactionCommand3,
  ExecuteStatementCommand: () => ExecuteStatementCommand3,
  DynamoDBDocumentClientCommand: () => DynamoDBDocumentClientCommand,
  DynamoDBDocumentClient: () => DynamoDBDocumentClient,
  DynamoDBDocument: () => DynamoDBDocument,
  DeleteCommand: () => DeleteCommand,
  BatchWriteCommand: () => BatchWriteCommand,
  BatchGetCommand: () => BatchGetCommand,
  BatchExecuteStatementCommand: () => BatchExecuteStatementCommand3
});
var init_dist_es15 = __esm(() => {
  init_dist_es14();
  init_DynamoDBDocument();
  init_DynamoDBDocumentClient();
  init_commands3();
  init_pagination3();
});

// node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var exports_value = {};
__export(exports_value, {
  IsUndefined: () => IsUndefined,
  IsUint8Array: () => IsUint8Array,
  IsSymbol: () => IsSymbol,
  IsString: () => IsString,
  IsRegExp: () => IsRegExp,
  IsObject: () => IsObject,
  IsNumber: () => IsNumber,
  IsNull: () => IsNull,
  IsIterator: () => IsIterator,
  IsFunction: () => IsFunction,
  IsDate: () => IsDate,
  IsBoolean: () => IsBoolean,
  IsBigInt: () => IsBigInt,
  IsAsyncIterator: () => IsAsyncIterator,
  IsArray: () => IsArray,
  HasPropertyKey: () => HasPropertyKey
});
function HasPropertyKey(value, key) {
  return key in value;
}
function IsAsyncIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.asyncIterator in value;
}
function IsArray(value) {
  return Array.isArray(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsDate(value) {
  return value instanceof globalThis.Date;
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.iterator in value;
}
function IsNull(value) {
  return value === null;
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsObject(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString(value) {
  return typeof value === "string";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined(value) {
  return value === undefined;
}

// node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType(value) {
  return value.map((value2) => Visit(value2));
}
function DateType(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType(value) {
  return new Uint8Array(value);
}
function RegExpType(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit(value[key]);
  }
  return result;
}
function Visit(value) {
  return IsArray(value) ? ArrayType(value) : IsDate(value) ? DateType(value) : IsUint8Array(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject(value) ? ObjectType(value) : value;
}
function Clone(value) {
  return Visit(value);
}

// node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneType(schema, options) {
  return options === undefined ? Clone(schema) : Clone({ ...options, ...schema });
}

// node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
function IsAsyncIterator2(value) {
  return IsObject2(value) && globalThis.Symbol.asyncIterator in value;
}
function IsIterator2(value) {
  return IsObject2(value) && globalThis.Symbol.iterator in value;
}
function IsStandardObject(value) {
  return IsObject2(value) && (globalThis.Object.getPrototypeOf(value) === Object.prototype || globalThis.Object.getPrototypeOf(value) === null);
}
function IsPromise(value) {
  return value instanceof globalThis.Promise;
}
function IsDate2(value) {
  return value instanceof Date && globalThis.Number.isFinite(value.getTime());
}
function IsMap(value) {
  return value instanceof globalThis.Map;
}
function IsSet(value) {
  return value instanceof globalThis.Set;
}
function IsTypedArray(value) {
  return globalThis.ArrayBuffer.isView(value);
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey2(value, key) {
  return key in value;
}
function IsObject2(value) {
  return value !== null && typeof value === "object";
}
function IsArray2(value) {
  return globalThis.Array.isArray(value) && !globalThis.ArrayBuffer.isView(value);
}
function IsUndefined2(value) {
  return value === undefined;
}
function IsNull2(value) {
  return value === null;
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return globalThis.Number.isInteger(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsString2(value) {
  return typeof value === "string";
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt2(value) || IsBoolean2(value) || IsNull2(value) || IsNumber2(value) || IsString2(value) || IsSymbol2(value) || IsUndefined2(value);
}

// node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.InstanceMode = "default";
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject = IsObject2(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !IsArray2(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy2.AllowNaN ? IsNumber2(value) : Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined2(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));

// node_modules/@sinclair/typebox/build/esm/type/create/immutable.mjs
function ImmutableArray(value) {
  return globalThis.Object.freeze(value).map((value2) => Immutable(value2));
}
function ImmutableDate(value) {
  return value;
}
function ImmutableUint8Array(value) {
  return value;
}
function ImmutableRegExp(value) {
  return value;
}
function ImmutableObject(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Immutable(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Immutable(value[key]);
  }
  return globalThis.Object.freeze(result);
}
function Immutable(value) {
  return IsArray(value) ? ImmutableArray(value) : IsDate(value) ? ImmutableDate(value) : IsUint8Array(value) ? ImmutableUint8Array(value) : IsRegExp(value) ? ImmutableRegExp(value) : IsObject(value) ? ImmutableObject(value) : value;
}

// node_modules/@sinclair/typebox/build/esm/type/create/type.mjs
function CreateType(schema, options) {
  const result = options !== undefined ? { ...options, ...schema } : schema;
  switch (TypeSystemPolicy.InstanceMode) {
    case "freeze":
      return Immutable(result);
    case "clone":
      return Clone(result);
    default:
      return result;
  }
}

// node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
class TypeBoxError extends Error {
  constructor(message) {
    super(message);
  }
}

// node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");

// node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly(value) {
  return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional(value) {
  return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny(value) {
  return IsKindOf(value, "Any");
}
function IsArgument(value) {
  return IsKindOf(value, "Argument");
}
function IsArray3(value) {
  return IsKindOf(value, "Array");
}
function IsAsyncIterator3(value) {
  return IsKindOf(value, "AsyncIterator");
}
function IsBigInt3(value) {
  return IsKindOf(value, "BigInt");
}
function IsBoolean3(value) {
  return IsKindOf(value, "Boolean");
}
function IsComputed(value) {
  return IsKindOf(value, "Computed");
}
function IsConstructor(value) {
  return IsKindOf(value, "Constructor");
}
function IsDate3(value) {
  return IsKindOf(value, "Date");
}
function IsFunction3(value) {
  return IsKindOf(value, "Function");
}
function IsInteger2(value) {
  return IsKindOf(value, "Integer");
}
function IsIntersect(value) {
  return IsKindOf(value, "Intersect");
}
function IsIterator3(value) {
  return IsKindOf(value, "Iterator");
}
function IsKindOf(value, kind) {
  return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralValue(value) {
  return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsLiteral(value) {
  return IsKindOf(value, "Literal");
}
function IsMappedKey(value) {
  return IsKindOf(value, "MappedKey");
}
function IsMappedResult(value) {
  return IsKindOf(value, "MappedResult");
}
function IsNever(value) {
  return IsKindOf(value, "Never");
}
function IsNot(value) {
  return IsKindOf(value, "Not");
}
function IsNull3(value) {
  return IsKindOf(value, "Null");
}
function IsNumber3(value) {
  return IsKindOf(value, "Number");
}
function IsObject3(value) {
  return IsKindOf(value, "Object");
}
function IsPromise2(value) {
  return IsKindOf(value, "Promise");
}
function IsRecord(value) {
  return IsKindOf(value, "Record");
}
function IsRef(value) {
  return IsKindOf(value, "Ref");
}
function IsRegExp2(value) {
  return IsKindOf(value, "RegExp");
}
function IsString3(value) {
  return IsKindOf(value, "String");
}
function IsSymbol3(value) {
  return IsKindOf(value, "Symbol");
}
function IsTemplateLiteral(value) {
  return IsKindOf(value, "TemplateLiteral");
}
function IsThis(value) {
  return IsKindOf(value, "This");
}
function IsTransform(value) {
  return IsObject(value) && TransformKind in value;
}
function IsTuple(value) {
  return IsKindOf(value, "Tuple");
}
function IsUndefined3(value) {
  return IsKindOf(value, "Undefined");
}
function IsUnion(value) {
  return IsKindOf(value, "Union");
}
function IsUint8Array3(value) {
  return IsKindOf(value, "Uint8Array");
}
function IsUnknown(value) {
  return IsKindOf(value, "Unknown");
}
function IsUnsafe(value) {
  return IsKindOf(value, "Unsafe");
}
function IsVoid(value) {
  return IsKindOf(value, "Void");
}
function IsKind(value) {
  return IsObject(value) && Kind in value && IsString(value[Kind]);
}
function IsSchema(value) {
  return IsAny(value) || IsArgument(value) || IsArray3(value) || IsBoolean3(value) || IsBigInt3(value) || IsAsyncIterator3(value) || IsComputed(value) || IsConstructor(value) || IsDate3(value) || IsFunction3(value) || IsInteger2(value) || IsIntersect(value) || IsIterator3(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull3(value) || IsNumber3(value) || IsObject3(value) || IsPromise2(value) || IsRecord(value) || IsRef(value) || IsRegExp2(value) || IsString3(value) || IsSymbol3(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined3(value) || IsUnion(value) || IsUint8Array3(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value);
}
// node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var exports_type = {};
__export(exports_type, {
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError,
  IsVoid: () => IsVoid2,
  IsUnsafe: () => IsUnsafe2,
  IsUnknown: () => IsUnknown2,
  IsUnionLiteral: () => IsUnionLiteral,
  IsUnion: () => IsUnion2,
  IsUndefined: () => IsUndefined4,
  IsUint8Array: () => IsUint8Array4,
  IsTuple: () => IsTuple2,
  IsTransform: () => IsTransform2,
  IsThis: () => IsThis2,
  IsTemplateLiteral: () => IsTemplateLiteral2,
  IsSymbol: () => IsSymbol4,
  IsString: () => IsString4,
  IsSchema: () => IsSchema2,
  IsRegExp: () => IsRegExp3,
  IsRef: () => IsRef2,
  IsRecursive: () => IsRecursive,
  IsRecord: () => IsRecord2,
  IsReadonly: () => IsReadonly2,
  IsProperties: () => IsProperties,
  IsPromise: () => IsPromise3,
  IsOptional: () => IsOptional2,
  IsObject: () => IsObject4,
  IsNumber: () => IsNumber4,
  IsNull: () => IsNull4,
  IsNot: () => IsNot2,
  IsNever: () => IsNever2,
  IsMappedResult: () => IsMappedResult2,
  IsMappedKey: () => IsMappedKey2,
  IsLiteralValue: () => IsLiteralValue2,
  IsLiteralString: () => IsLiteralString,
  IsLiteralNumber: () => IsLiteralNumber,
  IsLiteralBoolean: () => IsLiteralBoolean,
  IsLiteral: () => IsLiteral2,
  IsKindOf: () => IsKindOf2,
  IsKind: () => IsKind2,
  IsIterator: () => IsIterator4,
  IsIntersect: () => IsIntersect2,
  IsInteger: () => IsInteger3,
  IsImport: () => IsImport,
  IsFunction: () => IsFunction4,
  IsDate: () => IsDate4,
  IsConstructor: () => IsConstructor2,
  IsComputed: () => IsComputed2,
  IsBoolean: () => IsBoolean4,
  IsBigInt: () => IsBigInt4,
  IsAsyncIterator: () => IsAsyncIterator4,
  IsArray: () => IsArray4,
  IsArgument: () => IsArgument2,
  IsAny: () => IsAny2
});
class TypeGuardUnknownTypeError extends TypeBoxError {
}
var KnownTypes = [
  "Argument",
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Computed",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern(value) {
  try {
    new RegExp(value);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree(value) {
  if (!IsString(value))
    return false;
  for (let i = 0;i < value.length; i++) {
    const code = value.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties(value) {
  return IsOptionalBoolean(value) || IsSchema2(value);
}
function IsOptionalBigInt(value) {
  return IsUndefined(value) || IsBigInt(value);
}
function IsOptionalNumber(value) {
  return IsUndefined(value) || IsNumber(value);
}
function IsOptionalBoolean(value) {
  return IsUndefined(value) || IsBoolean(value);
}
function IsOptionalString(value) {
  return IsUndefined(value) || IsString(value);
}
function IsOptionalPattern(value) {
  return IsUndefined(value) || IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
}
function IsOptionalFormat(value) {
  return IsUndefined(value) || IsString(value) && IsControlCharacterFree(value);
}
function IsOptionalSchema(value) {
  return IsUndefined(value) || IsSchema2(value);
}
function IsReadonly2(value) {
  return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional2(value) {
  return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny2(value) {
  return IsKindOf2(value, "Any") && IsOptionalString(value.$id);
}
function IsArgument2(value) {
  return IsKindOf2(value, "Argument") && IsNumber(value.index);
}
function IsArray4(value) {
  return IsKindOf2(value, "Array") && value.type === "array" && IsOptionalString(value.$id) && IsSchema2(value.items) && IsOptionalNumber(value.minItems) && IsOptionalNumber(value.maxItems) && IsOptionalBoolean(value.uniqueItems) && IsOptionalSchema(value.contains) && IsOptionalNumber(value.minContains) && IsOptionalNumber(value.maxContains);
}
function IsAsyncIterator4(value) {
  return IsKindOf2(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsBigInt4(value) {
  return IsKindOf2(value, "BigInt") && value.type === "bigint" && IsOptionalString(value.$id) && IsOptionalBigInt(value.exclusiveMaximum) && IsOptionalBigInt(value.exclusiveMinimum) && IsOptionalBigInt(value.maximum) && IsOptionalBigInt(value.minimum) && IsOptionalBigInt(value.multipleOf);
}
function IsBoolean4(value) {
  return IsKindOf2(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
}
function IsComputed2(value) {
  return IsKindOf2(value, "Computed") && IsString(value.target) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema));
}
function IsConstructor2(value) {
  return IsKindOf2(value, "Constructor") && value.type === "Constructor" && IsOptionalString(value.$id) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsDate4(value) {
  return IsKindOf2(value, "Date") && value.type === "Date" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximumTimestamp) && IsOptionalNumber(value.exclusiveMinimumTimestamp) && IsOptionalNumber(value.maximumTimestamp) && IsOptionalNumber(value.minimumTimestamp) && IsOptionalNumber(value.multipleOfTimestamp);
}
function IsFunction4(value) {
  return IsKindOf2(value, "Function") && value.type === "Function" && IsOptionalString(value.$id) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsImport(value) {
  return IsKindOf2(value, "Import") && HasPropertyKey(value, "$defs") && IsObject(value.$defs) && IsProperties(value.$defs) && HasPropertyKey(value, "$ref") && IsString(value.$ref) && value.$ref in value.$defs;
}
function IsInteger3(value) {
  return IsKindOf2(value, "Integer") && value.type === "integer" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsProperties(value) {
  return IsObject(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema2(schema));
}
function IsIntersect2(value) {
  return IsKindOf2(value, "Intersect") && (IsString(value.type) && value.type !== "object" ? false : true) && IsArray(value.allOf) && value.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) && IsOptionalString(value.type) && (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) && IsOptionalString(value.$id);
}
function IsIterator4(value) {
  return IsKindOf2(value, "Iterator") && value.type === "Iterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsKindOf2(value, kind) {
  return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralString(value) {
  return IsLiteral2(value) && IsString(value.const);
}
function IsLiteralNumber(value) {
  return IsLiteral2(value) && IsNumber(value.const);
}
function IsLiteralBoolean(value) {
  return IsLiteral2(value) && IsBoolean(value.const);
}
function IsLiteral2(value) {
  return IsKindOf2(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue2(value.const);
}
function IsLiteralValue2(value) {
  return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsMappedKey2(value) {
  return IsKindOf2(value, "MappedKey") && IsArray(value.keys) && value.keys.every((key) => IsNumber(key) || IsString(key));
}
function IsMappedResult2(value) {
  return IsKindOf2(value, "MappedResult") && IsProperties(value.properties);
}
function IsNever2(value) {
  return IsKindOf2(value, "Never") && IsObject(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
}
function IsNot2(value) {
  return IsKindOf2(value, "Not") && IsSchema2(value.not);
}
function IsNull4(value) {
  return IsKindOf2(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
}
function IsNumber4(value) {
  return IsKindOf2(value, "Number") && value.type === "number" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsObject4(value) {
  return IsKindOf2(value, "Object") && value.type === "object" && IsOptionalString(value.$id) && IsProperties(value.properties) && IsAdditionalProperties(value.additionalProperties) && IsOptionalNumber(value.minProperties) && IsOptionalNumber(value.maxProperties);
}
function IsPromise3(value) {
  return IsKindOf2(value, "Promise") && value.type === "Promise" && IsOptionalString(value.$id) && IsSchema2(value.item);
}
function IsRecord2(value) {
  return IsKindOf2(value, "Record") && value.type === "object" && IsOptionalString(value.$id) && IsAdditionalProperties(value.additionalProperties) && IsObject(value.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject(schema.patternProperties) && IsSchema2(schema.patternProperties[keys[0]]);
  })(value);
}
function IsRecursive(value) {
  return IsObject(value) && Hint in value && value[Hint] === "Recursive";
}
function IsRef2(value) {
  return IsKindOf2(value, "Ref") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsRegExp3(value) {
  return IsKindOf2(value, "RegExp") && IsOptionalString(value.$id) && IsString(value.source) && IsString(value.flags) && IsOptionalNumber(value.maxLength) && IsOptionalNumber(value.minLength);
}
function IsString4(value) {
  return IsKindOf2(value, "String") && value.type === "string" && IsOptionalString(value.$id) && IsOptionalNumber(value.minLength) && IsOptionalNumber(value.maxLength) && IsOptionalPattern(value.pattern) && IsOptionalFormat(value.format);
}
function IsSymbol4(value) {
  return IsKindOf2(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
}
function IsTemplateLiteral2(value) {
  return IsKindOf2(value, "TemplateLiteral") && value.type === "string" && IsString(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
}
function IsThis2(value) {
  return IsKindOf2(value, "This") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsTransform2(value) {
  return IsObject(value) && TransformKind in value;
}
function IsTuple2(value) {
  return IsKindOf2(value, "Tuple") && value.type === "array" && IsOptionalString(value.$id) && IsNumber(value.minItems) && IsNumber(value.maxItems) && value.minItems === value.maxItems && (IsUndefined(value.items) && IsUndefined(value.additionalItems) && value.minItems === 0 || IsArray(value.items) && value.items.every((schema) => IsSchema2(schema)));
}
function IsUndefined4(value) {
  return IsKindOf2(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
}
function IsUnionLiteral(value) {
  return IsUnion2(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion2(value) {
  return IsKindOf2(value, "Union") && IsOptionalString(value.$id) && IsObject(value) && IsArray(value.anyOf) && value.anyOf.every((schema) => IsSchema2(schema));
}
function IsUint8Array4(value) {
  return IsKindOf2(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString(value.$id) && IsOptionalNumber(value.minByteLength) && IsOptionalNumber(value.maxByteLength);
}
function IsUnknown2(value) {
  return IsKindOf2(value, "Unknown") && IsOptionalString(value.$id);
}
function IsUnsafe2(value) {
  return IsKindOf2(value, "Unsafe");
}
function IsVoid2(value) {
  return IsKindOf2(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
}
function IsKind2(value) {
  return IsObject(value) && Kind in value && IsString(value[Kind]) && !KnownTypes.includes(value[Kind]);
}
function IsSchema2(value) {
  return IsObject(value) && (IsAny2(value) || IsArgument2(value) || IsArray4(value) || IsBoolean4(value) || IsBigInt4(value) || IsAsyncIterator4(value) || IsComputed2(value) || IsConstructor2(value) || IsDate4(value) || IsFunction4(value) || IsInteger3(value) || IsIntersect2(value) || IsIterator4(value) || IsLiteral2(value) || IsMappedKey2(value) || IsMappedResult2(value) || IsNever2(value) || IsNot2(value) || IsNull4(value) || IsNumber4(value) || IsObject4(value) || IsPromise3(value) || IsRecord2(value) || IsRef2(value) || IsRegExp3(value) || IsString4(value) || IsSymbol4(value) || IsTemplateLiteral2(value) || IsThis2(value) || IsTuple2(value) || IsUndefined4(value) || IsUnion2(value) || IsUint8Array4(value) || IsUnknown2(value) || IsUnsafe2(value) || IsVoid2(value) || IsKind2(value));
}
// node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternNever = "(?!.*)";
var PatternBooleanExact = `^${PatternBoolean}$`;
var PatternNumberExact = `^${PatternNumber}$`;
var PatternStringExact = `^${PatternString}$`;
var PatternNeverExact = `^${PatternNever}$`;

// node_modules/@sinclair/typebox/build/esm/type/registry/format.mjs
var exports_format = {};
__export(exports_format, {
  Set: () => Set2,
  Has: () => Has,
  Get: () => Get,
  Entries: () => Entries,
  Delete: () => Delete,
  Clear: () => Clear
});
var map = new Map;
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format) {
  return map.delete(format);
}
function Has(format) {
  return map.has(format);
}
function Set2(format, func) {
  map.set(format, func);
}
function Get(format) {
  return map.get(format);
}
// node_modules/@sinclair/typebox/build/esm/type/registry/type.mjs
var exports_type2 = {};
__export(exports_type2, {
  Set: () => Set3,
  Has: () => Has2,
  Get: () => Get2,
  Entries: () => Entries2,
  Delete: () => Delete2,
  Clear: () => Clear2
});
var map2 = new Map;
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}
// node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
}
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}

// node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
function Any(options) {
  return CreateType({ [Kind]: "Any" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
function Array2(items, options) {
  return CreateType({ [Kind]: "Array", type: "array", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/argument/argument.mjs
function Argument(index) {
  return CreateType({ [Kind]: "Argument", index });
}

// node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
function AsyncIterator2(items, options) {
  return CreateType({ [Kind]: "AsyncIterator", type: "AsyncIterator", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/computed/computed.mjs
function Computed(target, parameters, options) {
  return CreateType({ [Kind]: "Computed", target, parameters }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
function DiscardKey(value, key) {
  const { [key]: _, ...rest } = value;
  return rest;
}
function Discard(value, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value);
}

// node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
function Never(options) {
  return CreateType({ [Kind]: "Never", not: {} }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return CreateType({
    [Kind]: "MappedResult",
    properties
  });
}

// node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return CreateType({ [Kind]: "Constructor", type: "Constructor", parameters, returns }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
function Function2(parameters, returns, options) {
  return CreateType({ [Kind]: "Function", type: "Function", parameters, returns }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
function UnionCreate(T, options) {
  return CreateType({ [Kind]: "Union", anyOf: T }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional(types) {
  return types.some((type) => IsOptional(type));
}
function RemoveOptionalFromRest(types) {
  return types.map((left) => IsOptional(left) ? RemoveOptionalFromType(left) : left);
}
function RemoveOptionalFromType(T) {
  return Discard(T, [OptionalKind]);
}
function ResolveUnion(types, options) {
  const isOptional = IsUnionOptional(types);
  return isOptional ? Optional(UnionCreate(RemoveOptionalFromRest(types), options)) : UnionCreate(RemoveOptionalFromRest(types), options);
}
function UnionEvaluated(T, options) {
  return T.length === 1 ? CreateType(T[0], options) : T.length === 0 ? Never(options) : ResolveUnion(T, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
function Union(types, options) {
  return types.length === 0 ? Never(options) : types.length === 1 ? CreateType(types[0], options) : UnionCreate(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
class TemplateLiteralParserError extends TypeBoxError {
}
function Unescape(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
}
function IsCloseParen(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
}
function IsSeparator(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
}
function IsGroup(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
}
function Or(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And(pattern) {
  function Group(value, index) {
    if (!IsOpenParen(value, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value.length; scan++) {
      if (IsOpenParen(value, scan))
        count += 1;
      if (IsCloseParen(value, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
class TemplateLiteralFiniteError extends TypeBoxError {
}
function IsNumberExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
class TemplateLiteralGenerateError extends TypeBoxError {
}
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}

// node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
function Literal(value, options) {
  return CreateType({
    [Kind]: "Literal",
    const: value,
    type: typeof value
  }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
function Boolean2(options) {
  return CreateType({ [Kind]: "Boolean", type: "boolean" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
function BigInt2(options) {
  return CreateType({ [Kind]: "BigInt", type: "bigint" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
function Number2(options) {
  return CreateType({ [Kind]: "Number", type: "number" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
function String2(options) {
  return CreateType({ [Kind]: "String", type: "string" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal) => Literal(literal.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
class TemplateLiteralPatternError extends TypeBoxError {
}
function Escape(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit2(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
}
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options) {
  const pattern = IsString(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return CreateType({ [Kind]: "TemplateLiteral", type: "string", pattern }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral(templateLiteral) {
  const keys = TemplateLiteralGenerate(templateLiteral);
  return keys.map((key) => key.toString());
}
function FromUnion2(types) {
  const result = [];
  for (const type of types)
    result.push(...IndexPropertyKeys(type));
  return result;
}
function FromLiteral(literalValue) {
  return [literalValue.toString()];
}
function IndexPropertyKeys(type) {
  return [...new Set(IsTemplateLiteral(type) ? FromTemplateLiteral(type) : IsUnion(type) ? FromUnion2(type.anyOf) : IsLiteral(type) ? FromLiteral(type.const) : IsNumber3(type) ? ["[number]"] : IsInteger2(type) ? ["[number]"] : [])];
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
function FromProperties(type, properties, options) {
  const result = {};
  for (const K2 of Object.getOwnPropertyNames(properties)) {
    result[K2] = Index(type, IndexPropertyKeys(properties[K2]), options);
  }
  return result;
}
function FromMappedResult(type, mappedResult, options) {
  return FromProperties(type, mappedResult.properties, options);
}
function IndexFromMappedResult(type, mappedResult, options) {
  const properties = FromMappedResult(type, mappedResult, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest(types, key) {
  return types.map((type) => IndexFromPropertyKey(type, key));
}
function FromIntersectRest(types) {
  return types.filter((type) => !IsNever(type));
}
function FromIntersect(types, key) {
  return IntersectEvaluated(FromIntersectRest(FromRest(types, key)));
}
function FromUnionRest(types) {
  return types.some((L) => IsNever(L)) ? [] : types;
}
function FromUnion3(types, key) {
  return UnionEvaluated(FromUnionRest(FromRest(types, key)));
}
function FromTuple(types, key) {
  return key in types ? types[key] : key === "[number]" ? UnionEvaluated(types) : Never();
}
function FromArray(type, key) {
  return key === "[number]" ? type : Never();
}
function FromProperty(properties, propertyKey) {
  return propertyKey in properties ? properties[propertyKey] : Never();
}
function IndexFromPropertyKey(type, propertyKey) {
  return IsIntersect(type) ? FromIntersect(type.allOf, propertyKey) : IsUnion(type) ? FromUnion3(type.anyOf, propertyKey) : IsTuple(type) ? FromTuple(type.items ?? [], propertyKey) : IsArray3(type) ? FromArray(type.items, propertyKey) : IsObject3(type) ? FromProperty(type.properties, propertyKey) : Never();
}
function IndexFromPropertyKeys(type, propertyKeys) {
  return propertyKeys.map((propertyKey) => IndexFromPropertyKey(type, propertyKey));
}
function FromSchema(type, propertyKeys) {
  return UnionEvaluated(IndexFromPropertyKeys(type, propertyKeys));
}
function Index(type, key, options) {
  if (IsRef(type) || IsRef(key)) {
    const error = `Index types using Ref parameters require both Type and Key to be of TSchema`;
    if (!IsSchema(type) || !IsSchema(key))
      throw new TypeBoxError(error);
    return Computed("Index", [type, key]);
  }
  if (IsMappedResult(key))
    return IndexFromMappedResult(type, key, options);
  if (IsMappedKey(key))
    return IndexFromMappedKey(type, key, options);
  return CreateType(IsSchema(key) ? FromSchema(type, IndexPropertyKeys(key)) : FromSchema(type, key), options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey(type, key, options) {
  return { [key]: Index(type, [key], Clone(options)) };
}
function MappedIndexPropertyKeys(type, propertyKeys, options) {
  return propertyKeys.reduce((result, left) => {
    return { ...result, ...MappedIndexPropertyKey(type, left, options) };
  }, {});
}
function MappedIndexProperties(type, mappedKey, options) {
  return MappedIndexPropertyKeys(type, mappedKey.keys, options);
}
function IndexFromMappedKey(type, mappedKey, options) {
  const properties = MappedIndexProperties(type, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
function Iterator2(items, options) {
  return CreateType({ [Kind]: "Iterator", type: "Iterator", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
function RequiredKeys(properties) {
  const keys = [];
  for (let key in properties) {
    if (!IsOptional(properties[key]))
      keys.push(key);
  }
  return keys;
}
function _Object(properties, options) {
  const required = RequiredKeys(properties);
  const schematic = required.length > 0 ? { [Kind]: "Object", type: "object", properties, required } : { [Kind]: "Object", type: "object", properties };
  return CreateType(schematic, options);
}
var Object2 = _Object;

// node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
function Promise2(item, options) {
  return CreateType({ [Kind]: "Promise", type: "Promise", item }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
function RemoveReadonly(schema) {
  return CreateType(Discard(schema, [ReadonlyKind]));
}
function AddReadonly(schema) {
  return CreateType({ ...schema, [ReadonlyKind]: "Readonly" });
}
function ReadonlyWithFlag(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
}
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties2(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly(K[K2], F);
  return Acc;
}
function FromMappedResult2(R, F) {
  return FromProperties2(R.properties, F);
}
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult2(R, F);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
function Tuple(types, options) {
  return CreateType(types.length > 0 ? { [Kind]: "Tuple", type: "array", items: types, additionalItems: false, minItems: types.length, maxItems: types.length } : { [Kind]: "Tuple", type: "array", minItems: types.length, maxItems: types.length }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult3(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
}
function MappedKeyToKnownMappedResultProperties(K) {
  return { [K]: Literal(K) };
}
function MappedKeyToUnknownMappedResultProperties(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal(L);
  return Acc;
}
function MappedKeyToMappedResultProperties(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
}
function FromMappedKey(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult3(K, R);
}
function FromRest2(K, T) {
  return T.map((L) => FromSchemaType(K, L));
}
function FromProperties3(K, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K2] = FromSchemaType(K, T[K2]);
  return Acc;
}
function FromSchemaType(K, T) {
  const options = { ...T };
  return IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : IsMappedResult(T) ? FromMappedResult3(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options) : IsAsyncIterator3(T) ? AsyncIterator2(FromSchemaType(K, T.items), options) : IsIterator3(T) ? Iterator2(FromSchemaType(K, T.items), options) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf), options) : IsUnion(T) ? Union(FromRest2(K, T.anyOf), options) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? []), options) : IsObject3(T) ? Object2(FromProperties3(K, T.properties), options) : IsArray3(T) ? Array2(FromSchemaType(K, T.items), options) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item), options) : T;
}
function MappedFunctionReturnType(K, T) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType(L, T);
  return Acc;
}
function Mapped(key, map3, options) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return Object2(R, options);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
function RemoveOptional(schema) {
  return CreateType(Discard(schema, [OptionalKind]));
}
function AddOptional(schema) {
  return CreateType({ ...schema, [OptionalKind]: "Optional" });
}
function OptionalWithFlag(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
}
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties4(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional(P[K2], F);
  return Acc;
}
function FromMappedResult4(R, F) {
  return FromProperties4(R.properties, F);
}
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult4(R, F);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
function IntersectCreate(T, options = {}) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: options.unevaluatedProperties } : {};
  return CreateType(options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: T } : { ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: T }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional(types) {
  return types.every((left) => IsOptional(left));
}
function RemoveOptionalFromType2(type) {
  return Discard(type, [OptionalKind]);
}
function RemoveOptionalFromRest2(types) {
  return types.map((left) => IsOptional(left) ? RemoveOptionalFromType2(left) : left);
}
function ResolveIntersect(types, options) {
  return IsIntersectOptional(types) ? Optional(IntersectCreate(RemoveOptionalFromRest2(types), options)) : IntersectCreate(RemoveOptionalFromRest2(types), options);
}
function IntersectEvaluated(types, options = {}) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
function Intersect(types, options) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
function Ref(...args) {
  const [$ref, options] = typeof args[0] === "string" ? [args[0], args[1]] : [args[0].$id, args[1]];
  if (typeof $ref !== "string")
    throw new TypeBoxError("Ref: $ref must be a string");
  return CreateType({ [Kind]: "Ref", $ref }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
function FromComputed(target, parameters) {
  return Computed("Awaited", [Computed(target, parameters)]);
}
function FromRef($ref) {
  return Computed("Awaited", [Ref($ref)]);
}
function FromIntersect2(types) {
  return Intersect(FromRest3(types));
}
function FromUnion4(types) {
  return Union(FromRest3(types));
}
function FromPromise(type) {
  return Awaited(type);
}
function FromRest3(types) {
  return types.map((type) => Awaited(type));
}
function Awaited(type, options) {
  return CreateType(IsComputed(type) ? FromComputed(type.target, type.parameters) : IsIntersect(type) ? FromIntersect2(type.allOf) : IsUnion(type) ? FromUnion4(type.anyOf) : IsPromise2(type) ? FromPromise(type.item) : IsRef(type) ? FromRef(type.$ref) : type, options);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
function FromRest4(types) {
  const result = [];
  for (const L of types)
    result.push(KeyOfPropertyKeys(L));
  return result;
}
function FromIntersect3(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetUnionMany(propertyKeysArray);
  return propertyKeys;
}
function FromUnion5(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetIntersectMany(propertyKeysArray);
  return propertyKeys;
}
function FromTuple2(types) {
  return types.map((_, indexer) => indexer.toString());
}
function FromArray2(_) {
  return ["[number]"];
}
function FromProperties5(T) {
  return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys(type) {
  return IsIntersect(type) ? FromIntersect3(type.allOf) : IsUnion(type) ? FromUnion5(type.anyOf) : IsTuple(type) ? FromTuple2(type.items ?? []) : IsArray3(type) ? FromArray2(type.items) : IsObject3(type) ? FromProperties5(type.properties) : IsRecord(type) ? FromPatternProperties(type.patternProperties) : [];
}
var includePatternProperties = false;
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern = keys.map((key) => `(${key})`);
  return `^(${pattern.join("|")})$`;
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function FromComputed2(target, parameters) {
  return Computed("KeyOf", [Computed(target, parameters)]);
}
function FromRef2($ref) {
  return Computed("KeyOf", [Ref($ref)]);
}
function KeyOfFromType(type, options) {
  const propertyKeys = KeyOfPropertyKeys(type);
  const propertyKeyTypes = KeyOfPropertyKeysToRest(propertyKeys);
  const result = UnionEvaluated(propertyKeyTypes);
  return CreateType(result, options);
}
function KeyOfPropertyKeysToRest(propertyKeys) {
  return propertyKeys.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(type, options) {
  return IsComputed(type) ? FromComputed2(type.target, type.parameters) : IsRef(type) ? FromRef2(type.$ref) : IsMappedResult(type) ? KeyOfFromMappedResult(type, options) : KeyOfFromType(type, options);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties6(properties, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = KeyOf(properties[K2], Clone(options));
  return result;
}
function FromMappedResult5(mappedResult, options) {
  return FromProperties6(mappedResult.properties, options);
}
function KeyOfFromMappedResult(mappedResult, options) {
  const properties = FromMappedResult5(mappedResult, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs
function KeyOfPropertyEntries(schema) {
  const keys = KeyOfPropertyKeys(schema);
  const schemas = IndexFromPropertyKeys(schema, keys);
  return keys.map((_, index) => [keys[index], schemas[index]]);
}

// node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
function CompositeKeys(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys(L));
  return SetDistinct(Acc);
}
function FilterNever(T) {
  return T.filter((L) => !IsNever(L));
}
function CompositeProperty(T, K) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys(L, [K]));
  return FilterNever(Acc);
}
function CompositeProperties(T, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
  }
  return Acc;
}
function Composite(T, options) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}

// node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
function Date2(options) {
  return CreateType({ [Kind]: "Date", type: "Date" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
function Null(options) {
  return CreateType({ [Kind]: "Null", type: "null" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
function Symbol2(options) {
  return CreateType({ [Kind]: "Symbol", type: "symbol" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
function Undefined(options) {
  return CreateType({ [Kind]: "Undefined", type: "undefined" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
function Uint8Array2(options) {
  return CreateType({ [Kind]: "Uint8Array", type: "Uint8Array" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
function Unknown(options) {
  return CreateType({ [Kind]: "Unknown" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray3(T) {
  return T.map((L) => FromValue(L, false));
}
function FromProperties7(value) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value))
    Acc[K] = Readonly(FromValue(value[K], false));
  return Acc;
}
function ConditionalReadonly(T, root) {
  return root === true ? T : Readonly(T);
}
function FromValue(value, root) {
  return IsAsyncIterator(value) ? ConditionalReadonly(Any(), root) : IsIterator(value) ? ConditionalReadonly(Any(), root) : IsArray(value) ? Readonly(Tuple(FromArray3(value))) : IsUint8Array(value) ? Uint8Array2() : IsDate(value) ? Date2() : IsObject(value) ? ConditionalReadonly(Object2(FromProperties7(value)), root) : IsFunction(value) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined(value) ? Undefined() : IsNull(value) ? Null() : IsSymbol(value) ? Symbol2() : IsBigInt(value) ? BigInt2() : IsNumber(value) ? Literal(value) : IsBoolean(value) ? Literal(value) : IsString(value) ? Literal(value) : Object2({});
}
function Const(T, options) {
  return CreateType(FromValue(T, true), options);
}

// node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options) {
  return IsConstructor(schema) ? Tuple(schema.parameters, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
function Enum(item, options) {
  if (IsUndefined(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value) => Literal(value));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
class ExtendsResolverError extends TypeBoxError {
}
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
function IntoBooleanResult(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
}
function Throw(message) {
  throw new ExtendsResolverError(message);
}
function IsStructuralRight(right) {
  return exports_type.IsNever(right) || exports_type.IsIntersect(right) || exports_type.IsUnion(right) || exports_type.IsUnknown(right) || exports_type.IsAny(right);
}
function StructuralRight(left, right) {
  return exports_type.IsNever(right) ? FromNeverRight(left, right) : exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) ? FromUnionRight(left, right) : exports_type.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
}
function FromAnyRight(left, right) {
  return ExtendsResult.True;
}
function FromAny(left, right) {
  return exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) && right.anyOf.some((schema) => exports_type.IsAny(schema) || exports_type.IsUnknown(schema)) ? ExtendsResult.True : exports_type.IsUnion(right) ? ExtendsResult.Union : exports_type.IsUnknown(right) ? ExtendsResult.True : exports_type.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
}
function FromArrayRight(left, right) {
  return exports_type.IsUnknown(left) ? ExtendsResult.False : exports_type.IsAny(left) ? ExtendsResult.Union : exports_type.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromArray4(left, right) {
  return exports_type.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromAsyncIterator(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromBigInt(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBooleanRight(left, right) {
  return exports_type.IsLiteralBoolean(left) ? ExtendsResult.True : exports_type.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBoolean(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromConstructor(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : !exports_type.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromDate(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromFunction(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : !exports_type.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromIntegerRight(left, right) {
  return exports_type.IsLiteral(left) && exports_value.IsNumber(left.const) ? ExtendsResult.True : exports_type.IsNumber(left) || exports_type.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromInteger(left, right) {
  return exports_type.IsInteger(right) || exports_type.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
}
function FromIntersectRight(left, right) {
  return right.allOf.every((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIntersect4(left, right) {
  return left.allOf.some((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIterator(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromLiteral2(left, right) {
  return exports_type.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsString(right) ? FromStringRight(left, right) : exports_type.IsNumber(right) ? FromNumberRight(left, right) : exports_type.IsInteger(right) ? FromIntegerRight(left, right) : exports_type.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
}
function FromNeverRight(left, right) {
  return ExtendsResult.False;
}
function FromNever(left, right) {
  return ExtendsResult.True;
}
function UnwrapTNot(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!exports_type.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
}
function FromNot(left, right) {
  return exports_type.IsNot(left) ? Visit3(UnwrapTNot(left), right) : exports_type.IsNot(right) ? Visit3(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
}
function FromNull(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumberRight(left, right) {
  return exports_type.IsLiteralNumber(left) ? ExtendsResult.True : exports_type.IsNumber(left) || exports_type.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumber(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsInteger(right) || exports_type.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
}
function IsObjectPropertyCount(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectSymbolLike(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && exports_type.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type.IsString(schema.properties.description.anyOf[0]) && exports_type.IsUndefined(schema.properties.description.anyOf[1]) || exports_type.IsString(schema.properties.description.anyOf[1]) && exports_type.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBooleanLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBigIntLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectDateLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectUint8ArrayLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectFunctionLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectConstructorLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectArrayLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectPromiseLike(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit3(schema.properties["then"], then)) === ExtendsResult.True;
}
function Property(left, right) {
  return Visit3(left, right) === ExtendsResult.False ? ExtendsResult.False : exports_type.IsOptional(left) && !exports_type.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
}
function FromObjectRight(left, right) {
  return exports_type.IsUnknown(left) ? ExtendsResult.False : exports_type.IsAny(left) ? ExtendsResult.Union : exports_type.IsNever(left) || exports_type.IsLiteralString(left) && IsObjectStringLike(right) || exports_type.IsLiteralNumber(left) && IsObjectNumberLike(right) || exports_type.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || exports_type.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type.IsBigInt(left) && IsObjectBigIntLike(right) || exports_type.IsString(left) && IsObjectStringLike(right) || exports_type.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type.IsNumber(left) && IsObjectNumberLike(right) || exports_type.IsInteger(left) && IsObjectNumberLike(right) || exports_type.IsBoolean(left) && IsObjectBooleanLike(right) || exports_type.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || exports_type.IsDate(left) && IsObjectDateLike(right) || exports_type.IsConstructor(left) && IsObjectConstructorLike(right) || exports_type.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : exports_type.IsRecord(left) && exports_type.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : exports_type.IsRecord(left) && exports_type.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
}
function FromObject(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : !exports_type.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !exports_type.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (exports_type.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
}
function FromPromise2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !exports_type.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.item, right.item));
}
function RecordKey(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : (PatternStringExact in schema.patternProperties) ? String2() : Throw("Unknown record key pattern");
}
function RecordValue(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : (PatternStringExact in schema.patternProperties) ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
}
function FromRecordRight(left, right) {
  const [Key, Value] = [RecordKey(right), RecordValue(right)];
  return exports_type.IsLiteralString(left) && exports_type.IsNumber(Key) && IntoBooleanResult(Visit3(left, Value)) === ExtendsResult.True ? ExtendsResult.True : exports_type.IsUint8Array(left) && exports_type.IsNumber(Key) ? Visit3(left, Value) : exports_type.IsString(left) && exports_type.IsNumber(Key) ? Visit3(left, Value) : exports_type.IsArray(left) && exports_type.IsNumber(Key) ? Visit3(left, Value) : exports_type.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
}
function FromRecord(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : !exports_type.IsRecord(right) ? ExtendsResult.False : Visit3(RecordValue(left), RecordValue(right));
}
function FromRegExp(left, right) {
  const L = exports_type.IsRegExp(left) ? String2() : left;
  const R = exports_type.IsRegExp(right) ? String2() : right;
  return Visit3(L, R);
}
function FromStringRight(left, right) {
  return exports_type.IsLiteral(left) && exports_value.IsString(left.const) ? ExtendsResult.True : exports_type.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromString(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromSymbol(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromTemplateLiteral2(left, right) {
  return exports_type.IsTemplateLiteral(left) ? Visit3(TemplateLiteralToUnion(left), right) : exports_type.IsTemplateLiteral(right) ? Visit3(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(left, right) {
  return exports_type.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit3(schema, right.items) === ExtendsResult.True);
}
function FromTupleRight(left, right) {
  return exports_type.IsNever(left) ? ExtendsResult.True : exports_type.IsUnknown(left) ? ExtendsResult.False : exports_type.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
}
function FromTuple3(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : exports_type.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !exports_type.IsTuple(right) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) || !exports_value.IsUndefined(left.items) && exports_value.IsUndefined(right.items) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit3(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUint8Array(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUndefined(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsVoid(right) ? FromVoidRight(left, right) : exports_type.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnionRight(left, right) {
  return right.anyOf.some((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnion6(left, right) {
  return left.anyOf.every((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnknownRight(left, right) {
  return ExtendsResult.True;
}
function FromUnknown(left, right) {
  return exports_type.IsNever(right) ? FromNeverRight(left, right) : exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) ? FromUnionRight(left, right) : exports_type.IsAny(right) ? FromAnyRight(left, right) : exports_type.IsString(right) ? FromStringRight(left, right) : exports_type.IsNumber(right) ? FromNumberRight(left, right) : exports_type.IsInteger(right) ? FromIntegerRight(left, right) : exports_type.IsBoolean(right) ? FromBooleanRight(left, right) : exports_type.IsArray(right) ? FromArrayRight(left, right) : exports_type.IsTuple(right) ? FromTupleRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoidRight(left, right) {
  return exports_type.IsUndefined(left) ? ExtendsResult.True : exports_type.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoid(left, right) {
  return exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) ? FromUnionRight(left, right) : exports_type.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type.IsAny(right) ? FromAnyRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
}
function Visit3(left, right) {
  return exports_type.IsTemplateLiteral(left) || exports_type.IsTemplateLiteral(right) ? FromTemplateLiteral2(left, right) : exports_type.IsRegExp(left) || exports_type.IsRegExp(right) ? FromRegExp(left, right) : exports_type.IsNot(left) || exports_type.IsNot(right) ? FromNot(left, right) : exports_type.IsAny(left) ? FromAny(left, right) : exports_type.IsArray(left) ? FromArray4(left, right) : exports_type.IsBigInt(left) ? FromBigInt(left, right) : exports_type.IsBoolean(left) ? FromBoolean(left, right) : exports_type.IsAsyncIterator(left) ? FromAsyncIterator(left, right) : exports_type.IsConstructor(left) ? FromConstructor(left, right) : exports_type.IsDate(left) ? FromDate(left, right) : exports_type.IsFunction(left) ? FromFunction(left, right) : exports_type.IsInteger(left) ? FromInteger(left, right) : exports_type.IsIntersect(left) ? FromIntersect4(left, right) : exports_type.IsIterator(left) ? FromIterator(left, right) : exports_type.IsLiteral(left) ? FromLiteral2(left, right) : exports_type.IsNever(left) ? FromNever(left, right) : exports_type.IsNull(left) ? FromNull(left, right) : exports_type.IsNumber(left) ? FromNumber(left, right) : exports_type.IsObject(left) ? FromObject(left, right) : exports_type.IsRecord(left) ? FromRecord(left, right) : exports_type.IsString(left) ? FromString(left, right) : exports_type.IsSymbol(left) ? FromSymbol(left, right) : exports_type.IsTuple(left) ? FromTuple3(left, right) : exports_type.IsPromise(left) ? FromPromise2(left, right) : exports_type.IsUint8Array(left) ? FromUint8Array(left, right) : exports_type.IsUndefined(left) ? FromUndefined(left, right) : exports_type.IsUnion(left) ? FromUnion6(left, right) : exports_type.IsUnknown(left) ? FromUnknown(left, right) : exports_type.IsVoid(left) ? FromVoid(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`);
}
function ExtendsCheck(left, right) {
  return Visit3(left, right);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
function FromProperties8(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends(P[K2], Right, True, False, Clone(options));
  return Acc;
}
function FromMappedResult6(Left, Right, True, False, options) {
  return FromProperties8(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
}
function Extends(L, R, T, F, options) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CreateType(ExtendsFromMappedKey(L, R, T, F, options)) : CreateType(ExtendsResolve(L, R, T, F), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, Clone(options))
  };
}
function FromPropertyKeys(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
}
function FromMappedKey2(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
}
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-undefined.mjs
function Intersect2(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
}
function Union2(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
}
function Not(schema) {
  return !ExtendsUndefinedCheck(schema.not);
}
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
}
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CreateType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CreateType(ExcludeFromMappedResult(L, R), options);
  return CreateType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties9(P, U) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude(P[K2], U);
  return Acc;
}
function FromMappedResult7(R, T) {
  return FromProperties9(R.properties, T);
}
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
}
function Extract(L, R, options) {
  if (IsTemplateLiteral(L))
    return CreateType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CreateType(ExtractFromMappedResult(L, R), options);
  return CreateType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties10(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract(P[K2], T);
  return Acc;
}
function FromMappedResult8(R, T) {
  return FromProperties10(R.properties, T);
}
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
function InstanceType(schema, options) {
  return IsConstructor(schema) ? CreateType(schema.returns, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}

// node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
function RecordCreateFromPattern(pattern, T, options) {
  return CreateType({ [Kind]: "Record", type: "object", patternProperties: { [pattern]: T } }, options);
}
function RecordCreateFromKeys(K, T, options) {
  const result = {};
  for (const K2 of K)
    result[K2] = T;
  return Object2(result, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
}
function FromUnionKey(key, type, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(key)), type, options);
}
function FromLiteralKey(key, type, options) {
  return RecordCreateFromKeys([key.toString()], type, options);
}
function FromRegExpKey(key, type, options) {
  return RecordCreateFromPattern(key.source, type, options);
}
function FromStringKey(key, type, options) {
  const pattern = IsUndefined(key.pattern) ? PatternStringExact : key.pattern;
  return RecordCreateFromPattern(pattern, type, options);
}
function FromAnyKey(_, type, options) {
  return RecordCreateFromPattern(PatternStringExact, type, options);
}
function FromNeverKey(_key, type, options) {
  return RecordCreateFromPattern(PatternNeverExact, type, options);
}
function FromBooleanKey(_key, type, options) {
  return Object2({ true: type, false: type }, options);
}
function FromIntegerKey(_key, type, options) {
  return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function FromNumberKey(_, type, options) {
  return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function Record(key, type, options = {}) {
  return IsUnion(key) ? FromUnionKey(key.anyOf, type, options) : IsTemplateLiteral(key) ? FromTemplateLiteralKey(key, type, options) : IsLiteral(key) ? FromLiteralKey(key.const, type, options) : IsBoolean3(key) ? FromBooleanKey(key, type, options) : IsInteger2(key) ? FromIntegerKey(key, type, options) : IsNumber3(key) ? FromNumberKey(key, type, options) : IsRegExp2(key) ? FromRegExpKey(key, type, options) : IsString3(key) ? FromStringKey(key, type, options) : IsAny(key) ? FromAnyKey(key, type, options) : IsNever(key) ? FromNeverKey(key, type, options) : Never(options);
}
function RecordPattern(record) {
  return globalThis.Object.getOwnPropertyNames(record.patternProperties)[0];
}
function RecordKey2(type) {
  const pattern = RecordPattern(type);
  return pattern === PatternStringExact ? String2() : pattern === PatternNumberExact ? Number2() : String2({ pattern });
}
function RecordValue2(type) {
  return type.patternProperties[RecordPattern(type)];
}

// node_modules/@sinclair/typebox/build/esm/type/instantiate/instantiate.mjs
function FromConstructor2(args, type) {
  type.parameters = FromTypes(args, type.parameters);
  type.returns = FromType(args, type.returns);
  return type;
}
function FromFunction2(args, type) {
  type.parameters = FromTypes(args, type.parameters);
  type.returns = FromType(args, type.returns);
  return type;
}
function FromIntersect5(args, type) {
  type.allOf = FromTypes(args, type.allOf);
  return type;
}
function FromUnion7(args, type) {
  type.anyOf = FromTypes(args, type.anyOf);
  return type;
}
function FromTuple4(args, type) {
  if (IsUndefined(type.items))
    return type;
  type.items = FromTypes(args, type.items);
  return type;
}
function FromArray5(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromAsyncIterator2(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromIterator2(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromPromise3(args, type) {
  type.item = FromType(args, type.item);
  return type;
}
function FromObject2(args, type) {
  const mappedProperties = FromProperties11(args, type.properties);
  return { ...type, ...Object2(mappedProperties) };
}
function FromRecord2(args, type) {
  const mappedKey = FromType(args, RecordKey2(type));
  const mappedValue = FromType(args, RecordValue2(type));
  const result = Record(mappedKey, mappedValue);
  return { ...type, ...result };
}
function FromArgument(args, argument) {
  return argument.index in args ? args[argument.index] : Unknown();
}
function FromProperty2(args, type) {
  const isReadonly = IsReadonly(type);
  const isOptional = IsOptional(type);
  const mapped = FromType(args, type);
  return isReadonly && isOptional ? ReadonlyOptional(mapped) : isReadonly && !isOptional ? Readonly(mapped) : !isReadonly && isOptional ? Optional(mapped) : mapped;
}
function FromProperties11(args, properties) {
  return globalThis.Object.getOwnPropertyNames(properties).reduce((result, key) => {
    return { ...result, [key]: FromProperty2(args, properties[key]) };
  }, {});
}
function FromTypes(args, types) {
  return types.map((type) => FromType(args, type));
}
function FromType(args, type) {
  return IsConstructor(type) ? FromConstructor2(args, type) : IsFunction3(type) ? FromFunction2(args, type) : IsIntersect(type) ? FromIntersect5(args, type) : IsUnion(type) ? FromUnion7(args, type) : IsTuple(type) ? FromTuple4(args, type) : IsArray3(type) ? FromArray5(args, type) : IsAsyncIterator3(type) ? FromAsyncIterator2(args, type) : IsIterator3(type) ? FromIterator2(args, type) : IsPromise2(type) ? FromPromise3(args, type) : IsObject3(type) ? FromObject2(args, type) : IsRecord(type) ? FromRecord2(args, type) : IsArgument(type) ? FromArgument(args, type) : type;
}
function Instantiate(type, args) {
  return FromType(args, CloneType(type));
}

// node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
function Integer(options) {
  return CreateType({ [Kind]: "Integer", type: "integer" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
function MappedIntrinsicPropertyKey(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, Clone(options))
  };
}
function MappedIntrinsicPropertyKeys(K, M, options) {
  const result = K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
  return result;
}
function MappedIntrinsicProperties(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
}
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase(value) {
  return value.toUpperCase();
}
function ApplyLowercase(value) {
  return value.toLowerCase();
}
function FromTemplateLiteral3(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite = IsTemplateLiteralExpressionFinite(expression);
  if (!finite)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value) => Literal(value));
  const mapped = FromRest5(literals, mode);
  const union = Union(mapped);
  return TemplateLiteral([union], options);
}
function FromLiteralValue(value, mode) {
  return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value) : mode === "Capitalize" ? ApplyCapitalize(value) : mode === "Uppercase" ? ApplyUppercase(value) : mode === "Lowercase" ? ApplyLowercase(value) : value : value.toString();
}
function FromRest5(T, M) {
  return T.map((L) => Intrinsic(L, M));
}
function Intrinsic(schema, mode, options = {}) {
  return IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : IsTemplateLiteral(schema) ? FromTemplateLiteral3(schema, mode, options) : IsUnion(schema) ? Union(FromRest5(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : CreateType(schema, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
function FromProperties12(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Omit(properties[K2], propertyKeys, Clone(options));
  return result;
}
function FromMappedResult9(mappedResult, propertyKeys, options) {
  return FromProperties12(mappedResult.properties, propertyKeys, options);
}
function OmitFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult9(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect6(types, propertyKeys) {
  return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromUnion8(types, propertyKeys) {
  return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromProperty3(properties, key) {
  const { [key]: _, ...R } = properties;
  return R;
}
function FromProperties13(properties, propertyKeys) {
  return propertyKeys.reduce((T, K2) => FromProperty3(T, K2), properties);
}
function FromObject3(properties, propertyKeys) {
  const options = Discard(properties, [TransformKind, "$id", "required", "properties"]);
  const omittedProperties = FromProperties13(properties["properties"], propertyKeys);
  return Object2(omittedProperties, options);
}
function UnionFromPropertyKeys(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal(key)] : result2, []);
  return Union(result);
}
function OmitResolve(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect6(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union(FromUnion8(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject3(properties, propertyKeys) : Object2({});
}
function Omit(type, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type) ? OmitFromMappedResult(type, propertyKeys, options) : IsMappedKey(key) ? OmitFromMappedKey(type, key, options) : isTypeRef && isKeyRef ? Computed("Omit", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Omit", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Omit", [type, typeKey], options) : CreateType({ ...OmitResolve(type, propertyKeys), ...options });
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey2(type, key, options) {
  return { [key]: Omit(type, [key], Clone(options)) };
}
function FromPropertyKeys2(type, propertyKeys, options) {
  return propertyKeys.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(type, LK, options) };
  }, {});
}
function FromMappedKey3(type, mappedKey, options) {
  return FromPropertyKeys2(type, mappedKey.keys, options);
}
function OmitFromMappedKey(type, mappedKey, options) {
  const properties = FromMappedKey3(type, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
function FromProperties14(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Pick(properties[K2], propertyKeys, Clone(options));
  return result;
}
function FromMappedResult10(mappedResult, propertyKeys, options) {
  return FromProperties14(mappedResult.properties, propertyKeys, options);
}
function PickFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult10(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect7(types, propertyKeys) {
  return types.map((type) => PickResolve(type, propertyKeys));
}
function FromUnion9(types, propertyKeys) {
  return types.map((type) => PickResolve(type, propertyKeys));
}
function FromProperties15(properties, propertyKeys) {
  const result = {};
  for (const K2 of propertyKeys)
    if (K2 in properties)
      result[K2] = properties[K2];
  return result;
}
function FromObject4(T, K) {
  const options = Discard(T, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties15(T["properties"], K);
  return Object2(properties, options);
}
function UnionFromPropertyKeys2(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal(key)] : result2, []);
  return Union(result);
}
function PickResolve(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect7(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union(FromUnion9(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject4(properties, propertyKeys) : Object2({});
}
function Pick(type, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys2(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type) ? PickFromMappedResult(type, propertyKeys, options) : IsMappedKey(key) ? PickFromMappedKey(type, key, options) : isTypeRef && isKeyRef ? Computed("Pick", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Pick", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Pick", [type, typeKey], options) : CreateType({ ...PickResolve(type, propertyKeys), ...options });
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey3(type, key, options) {
  return {
    [key]: Pick(type, [key], Clone(options))
  };
}
function FromPropertyKeys3(type, propertyKeys, options) {
  return propertyKeys.reduce((result, leftKey) => {
    return { ...result, ...FromPropertyKey3(type, leftKey, options) };
  }, {});
}
function FromMappedKey4(type, mappedKey, options) {
  return FromPropertyKeys3(type, mappedKey.keys, options);
}
function PickFromMappedKey(type, mappedKey, options) {
  const properties = FromMappedKey4(type, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
function FromComputed3(target, parameters) {
  return Computed("Partial", [Computed(target, parameters)]);
}
function FromRef3($ref) {
  return Computed("Partial", [Ref($ref)]);
}
function FromProperties16(properties) {
  const partialProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    partialProperties[K] = Optional(properties[K]);
  return partialProperties;
}
function FromObject5(type) {
  const options = Discard(type, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties16(type["properties"]);
  return Object2(properties, options);
}
function FromRest6(types) {
  return types.map((type) => PartialResolve(type));
}
function PartialResolve(type) {
  return IsComputed(type) ? FromComputed3(type.target, type.parameters) : IsRef(type) ? FromRef3(type.$ref) : IsIntersect(type) ? Intersect(FromRest6(type.allOf)) : IsUnion(type) ? Union(FromRest6(type.anyOf)) : IsObject3(type) ? FromObject5(type) : IsBigInt3(type) ? type : IsBoolean3(type) ? type : IsInteger2(type) ? type : IsLiteral(type) ? type : IsNull3(type) ? type : IsNumber3(type) ? type : IsString3(type) ? type : IsSymbol3(type) ? type : IsUndefined3(type) ? type : Object2({});
}
function Partial(type, options) {
  if (IsMappedResult(type)) {
    return PartialFromMappedResult(type, options);
  } else {
    return CreateType({ ...PartialResolve(type), ...options });
  }
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties17(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial(K[K2], Clone(options));
  return Acc;
}
function FromMappedResult11(R, options) {
  return FromProperties17(R.properties, options);
}
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult11(R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
function FromComputed4(target, parameters) {
  return Computed("Required", [Computed(target, parameters)]);
}
function FromRef4($ref) {
  return Computed("Required", [Ref($ref)]);
}
function FromProperties18(properties) {
  const requiredProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    requiredProperties[K] = Discard(properties[K], [OptionalKind]);
  return requiredProperties;
}
function FromObject6(type) {
  const options = Discard(type, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties18(type["properties"]);
  return Object2(properties, options);
}
function FromRest7(types) {
  return types.map((type) => RequiredResolve(type));
}
function RequiredResolve(type) {
  return IsComputed(type) ? FromComputed4(type.target, type.parameters) : IsRef(type) ? FromRef4(type.$ref) : IsIntersect(type) ? Intersect(FromRest7(type.allOf)) : IsUnion(type) ? Union(FromRest7(type.anyOf)) : IsObject3(type) ? FromObject6(type) : IsBigInt3(type) ? type : IsBoolean3(type) ? type : IsInteger2(type) ? type : IsLiteral(type) ? type : IsNull3(type) ? type : IsNumber3(type) ? type : IsString3(type) ? type : IsSymbol3(type) ? type : IsUndefined3(type) ? type : Object2({});
}
function Required(type, options) {
  if (IsMappedResult(type)) {
    return RequiredFromMappedResult(type, options);
  } else {
    return CreateType({ ...RequiredResolve(type), ...options });
  }
}

// node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties19(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required(P[K2], options);
  return Acc;
}
function FromMappedResult12(R, options) {
  return FromProperties19(R.properties, options);
}
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/module/compute.mjs
function DereferenceParameters(moduleProperties, types) {
  return types.map((type) => {
    return IsRef(type) ? Dereference(moduleProperties, type.$ref) : FromType2(moduleProperties, type);
  });
}
function Dereference(moduleProperties, ref) {
  return ref in moduleProperties ? IsRef(moduleProperties[ref]) ? Dereference(moduleProperties, moduleProperties[ref].$ref) : FromType2(moduleProperties, moduleProperties[ref]) : Never();
}
function FromAwaited(parameters) {
  return Awaited(parameters[0]);
}
function FromIndex(parameters) {
  return Index(parameters[0], parameters[1]);
}
function FromKeyOf(parameters) {
  return KeyOf(parameters[0]);
}
function FromPartial(parameters) {
  return Partial(parameters[0]);
}
function FromOmit(parameters) {
  return Omit(parameters[0], parameters[1]);
}
function FromPick(parameters) {
  return Pick(parameters[0], parameters[1]);
}
function FromRequired(parameters) {
  return Required(parameters[0]);
}
function FromComputed5(moduleProperties, target, parameters) {
  const dereferenced = DereferenceParameters(moduleProperties, parameters);
  return target === "Awaited" ? FromAwaited(dereferenced) : target === "Index" ? FromIndex(dereferenced) : target === "KeyOf" ? FromKeyOf(dereferenced) : target === "Partial" ? FromPartial(dereferenced) : target === "Omit" ? FromOmit(dereferenced) : target === "Pick" ? FromPick(dereferenced) : target === "Required" ? FromRequired(dereferenced) : Never();
}
function FromArray6(moduleProperties, type) {
  return Array2(FromType2(moduleProperties, type));
}
function FromAsyncIterator3(moduleProperties, type) {
  return AsyncIterator2(FromType2(moduleProperties, type));
}
function FromConstructor3(moduleProperties, parameters, instanceType) {
  return Constructor(FromTypes2(moduleProperties, parameters), FromType2(moduleProperties, instanceType));
}
function FromFunction3(moduleProperties, parameters, returnType) {
  return Function2(FromTypes2(moduleProperties, parameters), FromType2(moduleProperties, returnType));
}
function FromIntersect8(moduleProperties, types) {
  return Intersect(FromTypes2(moduleProperties, types));
}
function FromIterator3(moduleProperties, type) {
  return Iterator2(FromType2(moduleProperties, type));
}
function FromObject7(moduleProperties, properties) {
  return Object2(globalThis.Object.keys(properties).reduce((result, key) => {
    return { ...result, [key]: FromType2(moduleProperties, properties[key]) };
  }, {}));
}
function FromRecord3(moduleProperties, type) {
  const [value, pattern] = [FromType2(moduleProperties, RecordValue2(type)), RecordPattern(type)];
  const result = CloneType(type);
  result.patternProperties[pattern] = value;
  return result;
}
function FromTransform(moduleProperties, transform) {
  return IsRef(transform) ? { ...Dereference(moduleProperties, transform.$ref), [TransformKind]: transform[TransformKind] } : transform;
}
function FromTuple5(moduleProperties, types) {
  return Tuple(FromTypes2(moduleProperties, types));
}
function FromUnion10(moduleProperties, types) {
  return Union(FromTypes2(moduleProperties, types));
}
function FromTypes2(moduleProperties, types) {
  return types.map((type) => FromType2(moduleProperties, type));
}
function FromType2(moduleProperties, type) {
  return IsOptional(type) ? CreateType(FromType2(moduleProperties, Discard(type, [OptionalKind])), type) : IsReadonly(type) ? CreateType(FromType2(moduleProperties, Discard(type, [ReadonlyKind])), type) : IsTransform(type) ? CreateType(FromTransform(moduleProperties, type), type) : IsArray3(type) ? CreateType(FromArray6(moduleProperties, type.items), type) : IsAsyncIterator3(type) ? CreateType(FromAsyncIterator3(moduleProperties, type.items), type) : IsComputed(type) ? CreateType(FromComputed5(moduleProperties, type.target, type.parameters)) : IsConstructor(type) ? CreateType(FromConstructor3(moduleProperties, type.parameters, type.returns), type) : IsFunction3(type) ? CreateType(FromFunction3(moduleProperties, type.parameters, type.returns), type) : IsIntersect(type) ? CreateType(FromIntersect8(moduleProperties, type.allOf), type) : IsIterator3(type) ? CreateType(FromIterator3(moduleProperties, type.items), type) : IsObject3(type) ? CreateType(FromObject7(moduleProperties, type.properties), type) : IsRecord(type) ? CreateType(FromRecord3(moduleProperties, type)) : IsTuple(type) ? CreateType(FromTuple5(moduleProperties, type.items || []), type) : IsUnion(type) ? CreateType(FromUnion10(moduleProperties, type.anyOf), type) : type;
}
function ComputeType(moduleProperties, key) {
  return key in moduleProperties ? FromType2(moduleProperties, moduleProperties[key]) : Never();
}
function ComputeModuleProperties(moduleProperties) {
  return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => {
    return { ...result, [key]: ComputeType(moduleProperties, key) };
  }, {});
}

// node_modules/@sinclair/typebox/build/esm/type/module/module.mjs
class TModule {
  constructor($defs) {
    const computed = ComputeModuleProperties($defs);
    const identified = this.WithIdentifiers(computed);
    this.$defs = identified;
  }
  Import(key, options) {
    const $defs = { ...this.$defs, [key]: CreateType(this.$defs[key], options) };
    return CreateType({ [Kind]: "Import", $defs, $ref: key });
  }
  WithIdentifiers($defs) {
    return globalThis.Object.getOwnPropertyNames($defs).reduce((result, key) => {
      return { ...result, [key]: { ...$defs[key], $id: key } };
    }, {});
  }
}
function Module(properties) {
  return new TModule(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
function Not2(type, options) {
  return CreateType({ [Kind]: "Not", not: type }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
function Parameters(schema, options) {
  return IsFunction3(schema) ? Tuple(schema.parameters, options) : Never();
}

// node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
var Ordinal = 0;
function Recursive(callback, options = {}) {
  if (IsUndefined(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = CloneType(callback({ [Kind]: "This", $ref: `${options.$id}` }));
  thisType.$id = options.$id;
  return CreateType({ [Hint]: "Recursive", ...thisType }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
function RegExp2(unresolved, options) {
  const expr = IsString(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return CreateType({ [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
function RestResolve(T) {
  return IsIntersect(T) ? T.allOf : IsUnion(T) ? T.anyOf : IsTuple(T) ? T.items ?? [] : [];
}
function Rest(T) {
  return RestResolve(T);
}

// node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
function ReturnType(schema, options) {
  return IsFunction3(schema) ? CreateType(schema.returns, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
class TransformDecodeBuilder {
  constructor(schema) {
    this.schema = schema;
  }
  Decode(decode) {
    return new TransformEncodeBuilder(this.schema, decode);
  }
}

class TransformEncodeBuilder {
  constructor(schema, decode) {
    this.schema = schema;
    this.decode = decode;
  }
  EncodeTransform(encode, schema) {
    const Encode = (value) => schema[TransformKind].Encode(encode(value));
    const Decode = (value) => this.decode(schema[TransformKind].Decode(value));
    const Codec = { Encode, Decode };
    return { ...schema, [TransformKind]: Codec };
  }
  EncodeSchema(encode, schema) {
    const Codec = { Decode: this.decode, Encode: encode };
    return { ...schema, [TransformKind]: Codec };
  }
  Encode(encode) {
    return IsTransform(this.schema) ? this.EncodeTransform(encode, this.schema) : this.EncodeSchema(encode, this.schema);
  }
}
function Transform(schema) {
  return new TransformDecodeBuilder(schema);
}

// node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return CreateType({ [Kind]: options[Kind] ?? "Unsafe" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
function Void(options) {
  return CreateType({ [Kind]: "Void", type: "void" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var exports_type3 = {};
__export(exports_type3, {
  Void: () => Void,
  Uppercase: () => Uppercase,
  Unsafe: () => Unsafe,
  Unknown: () => Unknown,
  Union: () => Union,
  Undefined: () => Undefined,
  Uncapitalize: () => Uncapitalize,
  Uint8Array: () => Uint8Array2,
  Tuple: () => Tuple,
  Transform: () => Transform,
  TemplateLiteral: () => TemplateLiteral,
  Symbol: () => Symbol2,
  String: () => String2,
  ReturnType: () => ReturnType,
  Rest: () => Rest,
  Required: () => Required,
  RegExp: () => RegExp2,
  Ref: () => Ref,
  Recursive: () => Recursive,
  Record: () => Record,
  ReadonlyOptional: () => ReadonlyOptional,
  Readonly: () => Readonly,
  Promise: () => Promise2,
  Pick: () => Pick,
  Partial: () => Partial,
  Parameters: () => Parameters,
  Optional: () => Optional,
  Omit: () => Omit,
  Object: () => Object2,
  Number: () => Number2,
  Null: () => Null,
  Not: () => Not2,
  Never: () => Never,
  Module: () => Module,
  Mapped: () => Mapped,
  Lowercase: () => Lowercase,
  Literal: () => Literal,
  KeyOf: () => KeyOf,
  Iterator: () => Iterator2,
  Intersect: () => Intersect,
  Integer: () => Integer,
  Instantiate: () => Instantiate,
  InstanceType: () => InstanceType,
  Index: () => Index,
  Function: () => Function2,
  Extract: () => Extract,
  Extends: () => Extends,
  Exclude: () => Exclude,
  Enum: () => Enum,
  Date: () => Date2,
  ConstructorParameters: () => ConstructorParameters,
  Constructor: () => Constructor,
  Const: () => Const,
  Composite: () => Composite,
  Capitalize: () => Capitalize,
  Boolean: () => Boolean2,
  BigInt: () => BigInt2,
  Awaited: () => Awaited,
  AsyncIterator: () => AsyncIterator2,
  Array: () => Array2,
  Argument: () => Argument,
  Any: () => Any
});

// node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type = exports_type3;

// node_modules/@sinclair/typebox/build/esm/errors/function.mjs
function DefaultErrorFunction(error) {
  switch (error.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error.schema.const === "string" ? `'${error.schema.const}'` : error.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Expected required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
var errorFunction = DefaultErrorFunction;
function GetErrorFunction() {
  return errorFunction;
}

// node_modules/@sinclair/typebox/build/esm/value/deref/deref.mjs
class TypeDereferenceError extends TypeBoxError {
  constructor(schema) {
    super(`Unable to dereference schema with $id '${schema.$ref}'`);
    this.schema = schema;
  }
}
function Resolve(schema, references) {
  const target = references.find((target2) => target2.$id === schema.$ref);
  if (target === undefined)
    throw new TypeDereferenceError(schema);
  return Deref(target, references);
}
function Pushref(schema, references) {
  if (!IsString2(schema.$id) || references.some((target) => target.$id === schema.$id))
    return references;
  references.push(schema);
  return references;
}
function Deref(schema, references) {
  return schema[Kind] === "This" || schema[Kind] === "Ref" ? Resolve(schema, references) : schema;
}

// node_modules/@sinclair/typebox/build/esm/value/hash/hash.mjs
class ValueHashError extends TypeBoxError {
  constructor(value) {
    super(`Unable to hash value`);
    this.value = value;
  }
}
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("18446744073709551616")];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
function* NumberToBytes(value) {
  const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value >> 8 * (byteCount - 1 - i) & 255;
  }
}
function ArrayType2(value) {
  FNV1A64(ByteMarker.Array);
  for (const item of value) {
    Visit4(item);
  }
}
function BooleanType(value) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value ? 1 : 0);
}
function BigIntType(value) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function DateType2(value) {
  FNV1A64(ByteMarker.Date);
  Visit4(value.getTime());
}
function NullType(value) {
  FNV1A64(ByteMarker.Null);
}
function NumberType(value) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function ObjectType2(value) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
    Visit4(key);
    Visit4(value[key]);
  }
}
function StringType(value) {
  FNV1A64(ByteMarker.String);
  for (let i = 0;i < value.length; i++) {
    for (const byte of NumberToBytes(value.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
}
function SymbolType(value) {
  FNV1A64(ByteMarker.Symbol);
  Visit4(value.description);
}
function Uint8ArrayType2(value) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0;i < value.length; i++) {
    FNV1A64(value[i]);
  }
}
function UndefinedType(value) {
  return FNV1A64(ByteMarker.Undefined);
}
function Visit4(value) {
  if (IsArray2(value))
    return ArrayType2(value);
  if (IsBoolean2(value))
    return BooleanType(value);
  if (IsBigInt2(value))
    return BigIntType(value);
  if (IsDate2(value))
    return DateType2(value);
  if (IsNull2(value))
    return NullType(value);
  if (IsNumber2(value))
    return NumberType(value);
  if (IsObject2(value))
    return ObjectType2(value);
  if (IsString2(value))
    return StringType(value);
  if (IsSymbol2(value))
    return SymbolType(value);
  if (IsUint8Array2(value))
    return Uint8ArrayType2(value);
  if (IsUndefined2(value))
    return UndefinedType(value);
  throw new ValueHashError(value);
}
function FNV1A64(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
}
function Hash(value) {
  Accumulator = BigInt("14695981039346656037");
  Visit4(value);
  return Accumulator;
}

// node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
class ValueCheckUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
function IsAnyOrUnknown(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
}
function IsDefined(value) {
  return value !== undefined;
}
function FromAny2(schema, references, value) {
  return true;
}
function FromArgument2(schema, references, value) {
  return true;
}
function FromArray7(schema, references, value) {
  if (!IsArray2(value))
    return false;
  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
    return false;
  }
  if (!value.every((value2) => Visit5(schema.items, references, value2))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined(schema.contains) || IsNumber2(schema.minContains) || IsNumber2(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2) => Visit5(containsSchema, references, value2) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
}
function FromAsyncIterator4(schema, references, value) {
  return IsAsyncIterator2(value);
}
function FromBigInt2(schema, references, value) {
  if (!IsBigInt2(value))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function FromBoolean2(schema, references, value) {
  return IsBoolean2(value);
}
function FromConstructor4(schema, references, value) {
  return Visit5(schema.returns, references, value.prototype);
}
function FromDate2(schema, references, value) {
  if (!IsDate2(value))
    return false;
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function FromFunction4(schema, references, value) {
  return IsFunction2(value);
}
function FromImport(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit5(target, [...references, ...definitions], value);
}
function FromInteger2(schema, references, value) {
  if (!IsInteger(value)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromIntersect9(schema, references, value) {
  const check1 = schema.allOf.every((schema2) => Visit5(schema2, references, value));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit5(schema.unevaluatedProperties, references, value[key]));
    return check1 && check2;
  } else {
    return check1;
  }
}
function FromIterator4(schema, references, value) {
  return IsIterator2(value);
}
function FromLiteral3(schema, references, value) {
  return value === schema.const;
}
function FromNever2(schema, references, value) {
  return false;
}
function FromNot2(schema, references, value) {
  return !Visit5(schema.not, references, value);
}
function FromNull2(schema, references, value) {
  return IsNull2(value);
}
function FromNumber2(schema, references, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromObject8(schema, references, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return false;
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit5(property, references, value[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit5(property, references, value[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit5(schema.additionalProperties, references, value[key]));
  } else {
    return true;
  }
}
function FromPromise4(schema, references, value) {
  return IsPromise(value);
}
function FromRecord4(schema, references, value) {
  if (!TypeSystemPolicy.IsRecordLike(value)) {
    return false;
  }
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value).every(([key, value2]) => {
    return regex.test(key) ? Visit5(patternSchema, references, value2) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
    return !regex.test(key) ? Visit5(schema.additionalProperties, references, value2) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
}
function FromRef5(schema, references, value) {
  return Visit5(Deref(schema, references), references, value);
}
function FromRegExp2(schema, references, value) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  return regex.test(value);
}
function FromString2(schema, references, value) {
  if (!IsString2(value)) {
    return false;
  }
  if (IsDefined(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  if (IsDefined(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value))
      return false;
  }
  if (IsDefined(schema.format)) {
    if (!exports_format.Has(schema.format))
      return false;
    const func = exports_format.Get(schema.format);
    return func(value);
  }
  return true;
}
function FromSymbol2(schema, references, value) {
  return IsSymbol2(value);
}
function FromTemplateLiteral4(schema, references, value) {
  return IsString2(value) && new RegExp(schema.pattern).test(value);
}
function FromThis(schema, references, value) {
  return Visit5(Deref(schema, references), references, value);
}
function FromTuple6(schema, references, value) {
  if (!IsArray2(value)) {
    return false;
  }
  if (schema.items === undefined && !(value.length === 0)) {
    return false;
  }
  if (!(value.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit5(schema.items[i], references, value[i]))
      return false;
  }
  return true;
}
function FromUndefined2(schema, references, value) {
  return IsUndefined2(value);
}
function FromUnion11(schema, references, value) {
  return schema.anyOf.some((inner) => Visit5(inner, references, value));
}
function FromUint8Array2(schema, references, value) {
  if (!IsUint8Array2(value)) {
    return false;
  }
  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    return false;
  }
  return true;
}
function FromUnknown2(schema, references, value) {
  return true;
}
function FromVoid2(schema, references, value) {
  return TypeSystemPolicy.IsVoidLike(value);
}
function FromKind(schema, references, value) {
  if (!exports_type2.Has(schema[Kind]))
    return false;
  const func = exports_type2.Get(schema[Kind]);
  return func(schema, value);
}
function Visit5(schema, references, value) {
  const references_ = IsDefined(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny2(schema_, references_, value);
    case "Argument":
      return FromArgument2(schema_, references_, value);
    case "Array":
      return FromArray7(schema_, references_, value);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_, value);
    case "BigInt":
      return FromBigInt2(schema_, references_, value);
    case "Boolean":
      return FromBoolean2(schema_, references_, value);
    case "Constructor":
      return FromConstructor4(schema_, references_, value);
    case "Date":
      return FromDate2(schema_, references_, value);
    case "Function":
      return FromFunction4(schema_, references_, value);
    case "Import":
      return FromImport(schema_, references_, value);
    case "Integer":
      return FromInteger2(schema_, references_, value);
    case "Intersect":
      return FromIntersect9(schema_, references_, value);
    case "Iterator":
      return FromIterator4(schema_, references_, value);
    case "Literal":
      return FromLiteral3(schema_, references_, value);
    case "Never":
      return FromNever2(schema_, references_, value);
    case "Not":
      return FromNot2(schema_, references_, value);
    case "Null":
      return FromNull2(schema_, references_, value);
    case "Number":
      return FromNumber2(schema_, references_, value);
    case "Object":
      return FromObject8(schema_, references_, value);
    case "Promise":
      return FromPromise4(schema_, references_, value);
    case "Record":
      return FromRecord4(schema_, references_, value);
    case "Ref":
      return FromRef5(schema_, references_, value);
    case "RegExp":
      return FromRegExp2(schema_, references_, value);
    case "String":
      return FromString2(schema_, references_, value);
    case "Symbol":
      return FromSymbol2(schema_, references_, value);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value);
    case "This":
      return FromThis(schema_, references_, value);
    case "Tuple":
      return FromTuple6(schema_, references_, value);
    case "Undefined":
      return FromUndefined2(schema_, references_, value);
    case "Union":
      return FromUnion11(schema_, references_, value);
    case "Uint8Array":
      return FromUint8Array2(schema_, references_, value);
    case "Unknown":
      return FromUnknown2(schema_, references_, value);
    case "Void":
      return FromVoid2(schema_, references_, value);
    default:
      if (!exports_type2.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind(schema_, references_, value);
  }
}
function Check(...args) {
  return args.length === 3 ? Visit5(args[0], args[1], args[2]) : Visit5(args[0], [], args[1]);
}

// node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));

class ValueErrorsUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}
function EscapeKey(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined2(value) {
  return value !== undefined;
}

class ValueErrorIterator {
  constructor(iterator) {
    this.iterator = iterator;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
function Create(errorType, schema, path, value, errors = []) {
  return {
    type: errorType,
    schema,
    path,
    value,
    message: GetErrorFunction()({ errorType, path, schema, value, errors }),
    errors
  };
}
function* FromAny3(schema, references, path, value) {}
function* FromArgument3(schema, references, path, value) {}
function* FromArray8(schema, references, path, value) {
  if (!IsArray2(value)) {
    return yield Create(ValueErrorType.Array, schema, path, value);
  }
  if (IsDefined2(schema.minItems) && !(value.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
  }
  if (IsDefined2(schema.maxItems) && !(value.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
  }
  for (let i = 0;i < value.length; i++) {
    yield* Visit6(schema.items, references, `${path}/${i}`, value[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
  }
  if (!(IsDefined2(schema.contains) || IsDefined2(schema.minContains) || IsDefined2(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2, index) => Visit6(containsSchema, references, `${path}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path, value);
  }
  if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
  }
  if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
  }
}
function* FromAsyncIterator5(schema, references, path, value) {
  if (!IsAsyncIterator2(value))
    yield Create(ValueErrorType.AsyncIterator, schema, path, value);
}
function* FromBigInt3(schema, references, path, value) {
  if (!IsBigInt2(value))
    return yield Create(ValueErrorType.BigInt, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
  }
}
function* FromBoolean3(schema, references, path, value) {
  if (!IsBoolean2(value))
    yield Create(ValueErrorType.Boolean, schema, path, value);
}
function* FromConstructor5(schema, references, path, value) {
  yield* Visit6(schema.returns, references, path, value.prototype);
}
function* FromDate3(schema, references, path, value) {
  if (!IsDate2(value))
    return yield Create(ValueErrorType.Date, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
  }
}
function* FromFunction5(schema, references, path, value) {
  if (!IsFunction2(value))
    yield Create(ValueErrorType.Function, schema, path, value);
}
function* FromImport2(schema, references, path, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  yield* Visit6(target, [...references, ...definitions], path, value);
}
function* FromInteger3(schema, references, path, value) {
  if (!IsInteger(value))
    return yield Create(ValueErrorType.Integer, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
  }
}
function* FromIntersect10(schema, references, path, value) {
  let hasError = false;
  for (const inner of schema.allOf) {
    for (const error of Visit6(inner, references, path, value)) {
      hasError = true;
      yield error;
    }
  }
  if (hasError) {
    return yield Create(ValueErrorType.Intersect, schema, path, value);
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit6(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator5(schema, references, path, value) {
  if (!IsIterator2(value))
    yield Create(ValueErrorType.Iterator, schema, path, value);
}
function* FromLiteral4(schema, references, path, value) {
  if (!(value === schema.const))
    yield Create(ValueErrorType.Literal, schema, path, value);
}
function* FromNever3(schema, references, path, value) {
  yield Create(ValueErrorType.Never, schema, path, value);
}
function* FromNot3(schema, references, path, value) {
  if (Visit6(schema.not, references, path, value).next().done === true)
    yield Create(ValueErrorType.Not, schema, path, value);
}
function* FromNull3(schema, references, path, value) {
  if (!IsNull2(value))
    yield Create(ValueErrorType.Null, schema, path, value);
}
function* FromNumber3(schema, references, path, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return yield Create(ValueErrorType.Number, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
  }
}
function* FromObject9(schema, references, path, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit6(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit6(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
        yield* Visit6(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      }
    }
  }
}
function* FromPromise5(schema, references, path, value) {
  if (!IsPromise(value))
    yield Create(ValueErrorType.Promise, schema, path, value);
}
function* FromRecord5(schema, references, path, value) {
  if (!TypeSystemPolicy.IsRecordLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value)) {
    if (regex.test(propertyKey))
      yield* Visit6(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (!regex.test(propertyKey))
        yield* Visit6(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef6(schema, references, path, value) {
  yield* Visit6(Deref(schema, references), references, path, value);
}
function* FromRegExp3(schema, references, path, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined2(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined2(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value)) {
    return yield Create(ValueErrorType.RegExp, schema, path, value);
  }
}
function* FromString3(schema, references, path, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined2(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined2(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  if (IsString2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value);
    }
  }
  if (IsString2(schema.format)) {
    if (!exports_format.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
    } else {
      const format = exports_format.Get(schema.format);
      if (!format(value)) {
        yield Create(ValueErrorType.StringFormat, schema, path, value);
      }
    }
  }
}
function* FromSymbol3(schema, references, path, value) {
  if (!IsSymbol2(value))
    yield Create(ValueErrorType.Symbol, schema, path, value);
}
function* FromTemplateLiteral5(schema, references, path, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value)) {
    yield Create(ValueErrorType.StringPattern, schema, path, value);
  }
}
function* FromThis2(schema, references, path, value) {
  yield* Visit6(Deref(schema, references), references, path, value);
}
function* FromTuple7(schema, references, path, value) {
  if (!IsArray2(value))
    return yield Create(ValueErrorType.Tuple, schema, path, value);
  if (schema.items === undefined && !(value.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!(value.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit6(schema.items[i], references, `${path}/${i}`, value[i]);
  }
}
function* FromUndefined3(schema, references, path, value) {
  if (!IsUndefined2(value))
    yield Create(ValueErrorType.Undefined, schema, path, value);
}
function* FromUnion12(schema, references, path, value) {
  if (Check(schema, references, value))
    return;
  const errors = schema.anyOf.map((variant) => new ValueErrorIterator(Visit6(variant, references, path, value)));
  yield Create(ValueErrorType.Union, schema, path, value, errors);
}
function* FromUint8Array3(schema, references, path, value) {
  if (!IsUint8Array2(value))
    return yield Create(ValueErrorType.Uint8Array, schema, path, value);
  if (IsDefined2(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
  }
  if (IsDefined2(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
  }
}
function* FromUnknown3(schema, references, path, value) {}
function* FromVoid3(schema, references, path, value) {
  if (!TypeSystemPolicy.IsVoidLike(value))
    yield Create(ValueErrorType.Void, schema, path, value);
}
function* FromKind2(schema, references, path, value) {
  const check = exports_type2.Get(schema[Kind]);
  if (!check(schema, value))
    yield Create(ValueErrorType.Kind, schema, path, value);
}
function* Visit6(schema, references, path, value) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny3(schema_, references_, path, value);
    case "Argument":
      return yield* FromArgument3(schema_, references_, path, value);
    case "Array":
      return yield* FromArray8(schema_, references_, path, value);
    case "AsyncIterator":
      return yield* FromAsyncIterator5(schema_, references_, path, value);
    case "BigInt":
      return yield* FromBigInt3(schema_, references_, path, value);
    case "Boolean":
      return yield* FromBoolean3(schema_, references_, path, value);
    case "Constructor":
      return yield* FromConstructor5(schema_, references_, path, value);
    case "Date":
      return yield* FromDate3(schema_, references_, path, value);
    case "Function":
      return yield* FromFunction5(schema_, references_, path, value);
    case "Import":
      return yield* FromImport2(schema_, references_, path, value);
    case "Integer":
      return yield* FromInteger3(schema_, references_, path, value);
    case "Intersect":
      return yield* FromIntersect10(schema_, references_, path, value);
    case "Iterator":
      return yield* FromIterator5(schema_, references_, path, value);
    case "Literal":
      return yield* FromLiteral4(schema_, references_, path, value);
    case "Never":
      return yield* FromNever3(schema_, references_, path, value);
    case "Not":
      return yield* FromNot3(schema_, references_, path, value);
    case "Null":
      return yield* FromNull3(schema_, references_, path, value);
    case "Number":
      return yield* FromNumber3(schema_, references_, path, value);
    case "Object":
      return yield* FromObject9(schema_, references_, path, value);
    case "Promise":
      return yield* FromPromise5(schema_, references_, path, value);
    case "Record":
      return yield* FromRecord5(schema_, references_, path, value);
    case "Ref":
      return yield* FromRef6(schema_, references_, path, value);
    case "RegExp":
      return yield* FromRegExp3(schema_, references_, path, value);
    case "String":
      return yield* FromString3(schema_, references_, path, value);
    case "Symbol":
      return yield* FromSymbol3(schema_, references_, path, value);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral5(schema_, references_, path, value);
    case "This":
      return yield* FromThis2(schema_, references_, path, value);
    case "Tuple":
      return yield* FromTuple7(schema_, references_, path, value);
    case "Undefined":
      return yield* FromUndefined3(schema_, references_, path, value);
    case "Union":
      return yield* FromUnion12(schema_, references_, path, value);
    case "Uint8Array":
      return yield* FromUint8Array3(schema_, references_, path, value);
    case "Unknown":
      return yield* FromUnknown3(schema_, references_, path, value);
    case "Void":
      return yield* FromVoid3(schema_, references_, path, value);
    default:
      if (!exports_type2.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind2(schema_, references_, path, value);
  }
}
function Errors(...args) {
  const iterator = args.length === 3 ? Visit6(args[0], args[1], "", args[2]) : Visit6(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator);
}
// node_modules/@sinclair/typebox/build/esm/value/assert/assert.mjs
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AssertError_instances;
var _AssertError_iterator;
var _AssertError_Iterator;

class AssertError extends TypeBoxError {
  constructor(iterator) {
    const error = iterator.First();
    super(error === undefined ? "Invalid Value" : error.message);
    _AssertError_instances.add(this);
    _AssertError_iterator.set(this, undefined);
    __classPrivateFieldSet(this, _AssertError_iterator, iterator, "f");
    this.error = error;
  }
  Errors() {
    return new ValueErrorIterator(__classPrivateFieldGet(this, _AssertError_instances, "m", _AssertError_Iterator).call(this));
  }
}
_AssertError_iterator = new WeakMap, _AssertError_instances = new WeakSet, _AssertError_Iterator = function* _AssertError_Iterator2() {
  if (this.error)
    yield this.error;
  yield* __classPrivateFieldGet(this, _AssertError_iterator, "f");
};
function AssertValue(schema, references, value) {
  if (Check(schema, references, value))
    return;
  throw new AssertError(Errors(schema, references, value));
}
function Assert(...args) {
  return args.length === 3 ? AssertValue(args[0], args[1], args[2]) : AssertValue(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/clone/clone.mjs
function FromObject10(value) {
  const Acc = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    Acc[key] = Clone2(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    Acc[key] = Clone2(value[key]);
  }
  return Acc;
}
function FromArray9(value) {
  return value.map((element) => Clone2(element));
}
function FromTypedArray(value) {
  return value.slice();
}
function FromMap(value) {
  return new Map(Clone2([...value.entries()]));
}
function FromSet(value) {
  return new Set(Clone2([...value.entries()]));
}
function FromDate4(value) {
  return new Date(value.toISOString());
}
function FromValue2(value) {
  return value;
}
function Clone2(value) {
  if (IsArray2(value))
    return FromArray9(value);
  if (IsDate2(value))
    return FromDate4(value);
  if (IsTypedArray(value))
    return FromTypedArray(value);
  if (IsMap(value))
    return FromMap(value);
  if (IsSet(value))
    return FromSet(value);
  if (IsObject2(value))
    return FromObject10(value);
  if (IsValueType(value))
    return FromValue2(value);
  throw new Error("ValueClone: Unable to clone value");
}

// node_modules/@sinclair/typebox/build/esm/value/create/create.mjs
class ValueCreateError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function FromDefault(value) {
  return IsFunction2(value) ? value() : Clone2(value);
}
function FromAny4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromArgument4(schema, references) {
  return {};
}
function FromArray10(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey2(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey2(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit7(schema.items, references);
    });
  } else {
    return [];
  }
}
function FromAsyncIterator6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {}();
  }
}
function FromBigInt4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
}
function FromBoolean4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
}
function FromConstructor6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = Visit7(schema.returns, references);
    if (typeof value === "object" && !Array.isArray(value)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value)) {
            const self2 = this;
            self2[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
}
function FromDate5(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
}
function FromFunction6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit7(schema.returns, references);
  }
}
function FromImport3(schema, references) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit7(target, [...references, ...definitions]);
}
function FromInteger4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromIntersect11(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = schema.allOf.reduce((acc, schema2) => {
      const next = Visit7(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value;
  }
}
function FromIterator6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {}();
  }
}
function FromLiteral5(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
}
function FromNever4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
}
function FromNot4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
}
function FromNull4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
}
function FromNumber4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromObject11(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required = new Set(schema.required);
    const Acc = {};
    for (const [key, subschema] of Object.entries(schema.properties)) {
      if (!required.has(key))
        continue;
      Acc[key] = Visit7(subschema, references);
    }
    return Acc;
  }
}
function FromPromise6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit7(schema.item, references));
  }
}
function FromRecord6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromRef7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromRegExp4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
}
function FromString4(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey2(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey2(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey2(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
}
function FromSymbol4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
}
function FromTemplateLiteral6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
}
function FromThis3(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromTuple8(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit7(schema.items[index], references));
  }
}
function FromUndefined4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromUnion13(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit7(schema.anyOf[0], references);
  }
}
function FromUint8Array4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
}
function FromUnknown4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromVoid4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromKind3(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
}
function Visit7(schema, references) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Argument":
      return FromArgument4(schema_, references_);
    case "Array":
      return FromArray10(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator6(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Date":
      return FromDate5(schema_, references_);
    case "Function":
      return FromFunction6(schema_, references_);
    case "Import":
      return FromImport3(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect11(schema_, references_);
    case "Iterator":
      return FromIterator6(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot4(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject11(schema_, references_);
    case "Promise":
      return FromPromise6(schema_, references_);
    case "Record":
      return FromRecord6(schema_, references_);
    case "Ref":
      return FromRef7(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral6(schema_, references_);
    case "This":
      return FromThis3(schema_, references_);
    case "Tuple":
      return FromTuple8(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion13(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!exports_type2.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit7(args[0], args[1]) : Visit7(args[0], []);
}

// node_modules/@sinclair/typebox/build/esm/value/cast/cast.mjs
class ValueCastError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function ScoreUnion(schema, references, value) {
  if (schema[Kind] === "Object" && typeof value === "object" && !IsNull2(value)) {
    const object = schema;
    const keys = Object.getOwnPropertyNames(value);
    const entries = Object.entries(object.properties);
    return entries.reduce((acc, [key, schema2]) => {
      const literal = schema2[Kind] === "Literal" && schema2.const === value[key] ? 100 : 0;
      const checks = Check(schema2, references, value[key]) ? 10 : 0;
      const exists = keys.includes(key) ? 1 : 0;
      return acc + (literal + checks + exists);
    }, 0);
  } else if (schema[Kind] === "Union") {
    const schemas = schema.anyOf.map((schema2) => Deref(schema2, references));
    const scores = schemas.map((schema2) => ScoreUnion(schema2, references, value));
    return Math.max(...scores);
  } else {
    return Check(schema, references, value) ? 1 : 0;
  }
}
function SelectUnion(union, references, value) {
  const schemas = union.anyOf.map((schema) => Deref(schema, references));
  let [select, best] = [schemas[0], 0];
  for (const schema of schemas) {
    const score = ScoreUnion(schema, references, value);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
}
function CastUnion(union, references, value) {
  if ("default" in union) {
    return typeof value === "function" ? union.default : Clone2(union.default);
  } else {
    const schema = SelectUnion(union, references, value);
    return Cast(schema, references, value);
  }
}
function DefaultClone(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : Create2(schema, references);
}
function Default(schema, references, value) {
  return Check(schema, references, value) ? value : Create2(schema, references);
}
function FromArray11(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  const created = IsArray2(value) ? Clone2(value) : Create2(schema, references);
  const minimum = IsNumber2(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber2(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value2) => Visit8(schema.items, references, value2));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
}
function FromConstructor7(schema, references, value) {
  if (Check(schema, references, value))
    return Create2(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {};
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit8(property, references, value.prototype[key]);
  }
  return result;
}
function FromImport4(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit8(target, [...references, ...definitions], value);
}
function IntersectAssign(correct, value) {
  if (IsObject2(correct) && !IsObject2(value) || !IsObject2(correct) && IsObject2(value))
    return correct;
  if (!IsObject2(correct) || !IsObject2(value))
    return value;
  return globalThis.Object.getOwnPropertyNames(correct).reduce((result, key) => {
    const property = key in value ? IntersectAssign(correct[key], value[key]) : correct[key];
    return { ...result, [key]: property };
  }, {});
}
function FromIntersect12(schema, references, value) {
  if (Check(schema, references, value))
    return value;
  const correct = Create2(schema, references);
  const assigned = IntersectAssign(correct, value);
  return Check(schema, references, assigned) ? assigned : correct;
}
function FromNever5(schema, references, value) {
  throw new ValueCastError(schema, "Never types cannot be cast");
}
function FromObject12(schema, references, value) {
  if (Check(schema, references, value))
    return value;
  if (value === null || typeof value !== "object")
    return Create2(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value[key] === undefined)
      continue;
    result[key] = Visit8(property, references, value[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit8(schema.additionalProperties, references, value[propertyName]);
    }
  }
  return result;
}
function FromRecord7(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit8(subschema, references, propValue);
  }
  return result;
}
function FromRef8(schema, references, value) {
  return Visit8(Deref(schema, references), references, value);
}
function FromThis4(schema, references, value) {
  return Visit8(Deref(schema, references), references, value);
}
function FromTuple9(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (!IsArray2(value))
    return Create2(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit8(schema2, references, value[index]));
}
function FromUnion14(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : CastUnion(schema, references, value);
}
function Visit8(schema, references, value) {
  const references_ = IsString2(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_, value);
    case "Constructor":
      return FromConstructor7(schema_, references_, value);
    case "Import":
      return FromImport4(schema_, references_, value);
    case "Intersect":
      return FromIntersect12(schema_, references_, value);
    case "Never":
      return FromNever5(schema_, references_, value);
    case "Object":
      return FromObject12(schema_, references_, value);
    case "Record":
      return FromRecord7(schema_, references_, value);
    case "Ref":
      return FromRef8(schema_, references_, value);
    case "This":
      return FromThis4(schema_, references_, value);
    case "Tuple":
      return FromTuple9(schema_, references_, value);
    case "Union":
      return FromUnion14(schema_, references_, value);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value);
    default:
      return Default(schema_, references_, value);
  }
}
function Cast(...args) {
  return args.length === 3 ? Visit8(args[0], args[1], args[2]) : Visit8(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/clean/clean.mjs
function IsCheckable(schema) {
  return IsKind(schema) && schema[Kind] !== "Unsafe";
}
function FromArray12(schema, references, value) {
  if (!IsArray2(value))
    return value;
  return value.map((value2) => Visit9(schema.items, references, value2));
}
function FromImport5(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit9(target, [...references, ...definitions], value);
}
function FromIntersect13(schema, references, value) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit9(schema2, references, Clone2(value)));
  const composite = intersections.reduce((acc, value2) => IsObject2(value2) ? { ...acc, ...value2 } : value2, {});
  if (!IsObject2(value) || !IsObject2(composite) || !IsKind(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value[key])) {
      composite[key] = Visit9(unevaluatedProperties, references, value[key]);
    }
  }
  return composite;
}
function FromObject13(schema, references, value) {
  if (!IsObject2(value) || IsArray2(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value)) {
    if (HasPropertyKey2(schema.properties, key)) {
      value[key] = Visit9(schema.properties[key], references, value[key]);
      continue;
    }
    if (IsKind(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit9(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRecord8(schema, references, value) {
  if (!IsObject2(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.getOwnPropertyNames(value);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value[key] = Visit9(propertySchema, references, value[key]);
      continue;
    }
    if (IsKind(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit9(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRef9(schema, references, value) {
  return Visit9(Deref(schema, references), references, value);
}
function FromThis5(schema, references, value) {
  return Visit9(Deref(schema, references), references, value);
}
function FromTuple10(schema, references, value) {
  if (!IsArray2(value))
    return value;
  if (IsUndefined2(schema.items))
    return [];
  const length = Math.min(value.length, schema.items.length);
  for (let i = 0;i < length; i++) {
    value[i] = Visit9(schema.items[i], references, value[i]);
  }
  return value.length > length ? value.slice(0, length) : value;
}
function FromUnion15(schema, references, value) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, references, value)) {
      return Visit9(inner, references, value);
    }
  }
  return value;
}
function Visit9(schema, references, value) {
  const references_ = IsString2(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray12(schema_, references_, value);
    case "Import":
      return FromImport5(schema_, references_, value);
    case "Intersect":
      return FromIntersect13(schema_, references_, value);
    case "Object":
      return FromObject13(schema_, references_, value);
    case "Record":
      return FromRecord8(schema_, references_, value);
    case "Ref":
      return FromRef9(schema_, references_, value);
    case "This":
      return FromThis5(schema_, references_, value);
    case "Tuple":
      return FromTuple10(schema_, references_, value);
    case "Union":
      return FromUnion15(schema_, references_, value);
    default:
      return value;
  }
}
function Clean(...args) {
  return args.length === 3 ? Visit9(args[0], args[1], args[2]) : Visit9(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/convert/convert.mjs
function IsStringNumeric(value) {
  return IsString2(value) && !isNaN(value) && !isNaN(parseFloat(value));
}
function IsValueToString(value) {
  return IsBigInt2(value) || IsBoolean2(value) || IsNumber2(value);
}
function IsValueTrue(value) {
  return value === true || IsNumber2(value) && value === 1 || IsBigInt2(value) && value === BigInt("1") || IsString2(value) && (value.toLowerCase() === "true" || value === "1");
}
function IsValueFalse(value) {
  return value === false || IsNumber2(value) && (value === 0 || Object.is(value, -0)) || IsBigInt2(value) && value === BigInt("0") || IsString2(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
}
function IsTimeStringWithTimeZone(value) {
  return IsString2(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsTimeStringWithoutTimeZone(value) {
  return IsString2(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateTimeStringWithTimeZone(value) {
  return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsDateTimeStringWithoutTimeZone(value) {
  return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateString(value) {
  return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
}
function TryConvertLiteralString(value, target) {
  const conversion = TryConvertString(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralNumber(value, target) {
  const conversion = TryConvertNumber(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralBoolean(value, target) {
  const conversion = TryConvertBoolean(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteral(schema, value) {
  return IsString2(schema.const) ? TryConvertLiteralString(value, schema.const) : IsNumber2(schema.const) ? TryConvertLiteralNumber(value, schema.const) : IsBoolean2(schema.const) ? TryConvertLiteralBoolean(value, schema.const) : value;
}
function TryConvertBoolean(value) {
  return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
}
function TryConvertBigInt(value) {
  const truncateInteger = (value2) => value2.split(".")[0];
  return IsStringNumeric(value) ? BigInt(truncateInteger(value)) : IsNumber2(value) ? BigInt(Math.trunc(value)) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
}
function TryConvertString(value) {
  return IsSymbol2(value) && value.description !== undefined ? value.description.toString() : IsValueToString(value) ? value.toString() : value;
}
function TryConvertNumber(value) {
  return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertInteger(value) {
  return IsStringNumeric(value) ? parseInt(value) : IsNumber2(value) ? Math.trunc(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertNull(value) {
  return IsString2(value) && value.toLowerCase() === "null" ? null : value;
}
function TryConvertUndefined(value) {
  return IsString2(value) && value === "undefined" ? undefined : value;
}
function TryConvertDate(value) {
  return IsDate2(value) ? value : IsNumber2(value) ? new Date(value) : IsValueTrue(value) ? new Date(1) : IsValueFalse(value) ? new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? new Date(`${value}T00:00:00.000Z`) : value;
}
function Default2(value) {
  return value;
}
function FromArray13(schema, references, value) {
  const elements = IsArray2(value) ? value : [value];
  return elements.map((element) => Visit10(schema.items, references, element));
}
function FromBigInt5(schema, references, value) {
  return TryConvertBigInt(value);
}
function FromBoolean5(schema, references, value) {
  return TryConvertBoolean(value);
}
function FromDate6(schema, references, value) {
  return TryConvertDate(value);
}
function FromImport6(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit10(target, [...references, ...definitions], value);
}
function FromInteger5(schema, references, value) {
  return TryConvertInteger(value);
}
function FromIntersect14(schema, references, value) {
  return schema.allOf.reduce((value2, schema2) => Visit10(schema2, references, value2), value);
}
function FromLiteral6(schema, references, value) {
  return TryConvertLiteral(schema, value);
}
function FromNull5(schema, references, value) {
  return TryConvertNull(value);
}
function FromNumber5(schema, references, value) {
  return TryConvertNumber(value);
}
function FromObject14(schema, references, value) {
  if (!IsObject2(value) || IsArray2(value))
    return value;
  for (const propertyKey of Object.getOwnPropertyNames(schema.properties)) {
    if (!HasPropertyKey2(value, propertyKey))
      continue;
    value[propertyKey] = Visit10(schema.properties[propertyKey], references, value[propertyKey]);
  }
  return value;
}
function FromRecord9(schema, references, value) {
  const isConvertable = IsObject2(value) && !IsArray2(value);
  if (!isConvertable)
    return value;
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  for (const [propKey, propValue] of Object.entries(value)) {
    value[propKey] = Visit10(property, references, propValue);
  }
  return value;
}
function FromRef10(schema, references, value) {
  return Visit10(Deref(schema, references), references, value);
}
function FromString5(schema, references, value) {
  return TryConvertString(value);
}
function FromSymbol5(schema, references, value) {
  return IsString2(value) || IsNumber2(value) ? Symbol(value) : value;
}
function FromThis6(schema, references, value) {
  return Visit10(Deref(schema, references), references, value);
}
function FromTuple11(schema, references, value) {
  const isConvertable = IsArray2(value) && !IsUndefined2(schema.items);
  if (!isConvertable)
    return value;
  return value.map((value2, index) => {
    return index < schema.items.length ? Visit10(schema.items[index], references, value2) : value2;
  });
}
function FromUndefined5(schema, references, value) {
  return TryConvertUndefined(value);
}
function FromUnion16(schema, references, value) {
  for (const subschema of schema.anyOf) {
    if (Check(subschema, references, value)) {
      return value;
    }
  }
  for (const subschema of schema.anyOf) {
    const converted = Visit10(subschema, references, Clone2(value));
    if (!Check(subschema, references, converted))
      continue;
    return converted;
  }
  return value;
}
function Visit10(schema, references, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray13(schema_, references_, value);
    case "BigInt":
      return FromBigInt5(schema_, references_, value);
    case "Boolean":
      return FromBoolean5(schema_, references_, value);
    case "Date":
      return FromDate6(schema_, references_, value);
    case "Import":
      return FromImport6(schema_, references_, value);
    case "Integer":
      return FromInteger5(schema_, references_, value);
    case "Intersect":
      return FromIntersect14(schema_, references_, value);
    case "Literal":
      return FromLiteral6(schema_, references_, value);
    case "Null":
      return FromNull5(schema_, references_, value);
    case "Number":
      return FromNumber5(schema_, references_, value);
    case "Object":
      return FromObject14(schema_, references_, value);
    case "Record":
      return FromRecord9(schema_, references_, value);
    case "Ref":
      return FromRef10(schema_, references_, value);
    case "String":
      return FromString5(schema_, references_, value);
    case "Symbol":
      return FromSymbol5(schema_, references_, value);
    case "This":
      return FromThis6(schema_, references_, value);
    case "Tuple":
      return FromTuple11(schema_, references_, value);
    case "Undefined":
      return FromUndefined5(schema_, references_, value);
    case "Union":
      return FromUnion16(schema_, references_, value);
    default:
      return Default2(value);
  }
}
function Convert(...args) {
  return args.length === 3 ? Visit10(args[0], args[1], args[2]) : Visit10(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/transform/decode.mjs
class TransformDecodeCheckError extends TypeBoxError {
  constructor(schema, value, error) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error;
  }
}

class TransformDecodeError extends TypeBoxError {
  constructor(schema, path, value, error) {
    super(error instanceof Error ? error.message : "Unknown error");
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error;
  }
}
function Default3(schema, path, value) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Decode(value) : value;
  } catch (error) {
    throw new TransformDecodeError(schema, path, value, error);
  }
}
function FromArray14(schema, references, path, value) {
  return IsArray2(value) ? Default3(schema, path, value.map((value2, index) => Visit11(schema.items, references, `${path}/${index}`, value2))) : Default3(schema, path, value);
}
function FromIntersect15(schema, references, path, value) {
  if (!IsObject2(value) || IsValueType(value))
    return Default3(schema, path, value);
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...value };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit11(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default3(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default3(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default3(schema, path, unknownProperties);
}
function FromImport7(schema, references, path, value) {
  const additional = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const result = Visit11(target, [...references, ...additional], path, value);
  return Default3(schema, path, result);
}
function FromNot5(schema, references, path, value) {
  return Default3(schema, path, Visit11(schema.not, references, path, value));
}
function FromObject15(schema, references, path, value) {
  if (!IsObject2(value))
    return Default3(schema, path, value);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...value };
  for (const key of knownKeys) {
    if (!HasPropertyKey2(knownProperties, key))
      continue;
    if (IsUndefined2(knownProperties[key]) && (!IsUndefined3(schema.properties[key]) || TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit11(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
  }
  if (!IsSchema(schema.additionalProperties)) {
    return Default3(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default3(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default3(schema, path, unknownProperties);
}
function FromRecord10(schema, references, path, value) {
  if (!IsObject2(value))
    return Default3(schema, path, value);
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern);
  const knownProperties = { ...value };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit11(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema(schema.additionalProperties)) {
    return Default3(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      unknownProperties[key] = Default3(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default3(schema, path, unknownProperties);
}
function FromRef11(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default3(schema, path, Visit11(target, references, path, value));
}
function FromThis7(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default3(schema, path, Visit11(target, references, path, value));
}
function FromTuple12(schema, references, path, value) {
  return IsArray2(value) && IsArray2(schema.items) ? Default3(schema, path, schema.items.map((schema2, index) => Visit11(schema2, references, `${path}/${index}`, value[index]))) : Default3(schema, path, value);
}
function FromUnion17(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const decoded = Visit11(subschema, references, path, value);
    return Default3(schema, path, decoded);
  }
  return Default3(schema, path, value);
}
function Visit11(schema, references, path, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray14(schema_, references_, path, value);
    case "Import":
      return FromImport7(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect15(schema_, references_, path, value);
    case "Not":
      return FromNot5(schema_, references_, path, value);
    case "Object":
      return FromObject15(schema_, references_, path, value);
    case "Record":
      return FromRecord10(schema_, references_, path, value);
    case "Ref":
      return FromRef11(schema_, references_, path, value);
    case "Symbol":
      return Default3(schema_, path, value);
    case "This":
      return FromThis7(schema_, references_, path, value);
    case "Tuple":
      return FromTuple12(schema_, references_, path, value);
    case "Union":
      return FromUnion17(schema_, references_, path, value);
    default:
      return Default3(schema_, path, value);
  }
}
function TransformDecode(schema, references, value) {
  return Visit11(schema, references, "", value);
}

// node_modules/@sinclair/typebox/build/esm/value/transform/encode.mjs
class TransformEncodeCheckError extends TypeBoxError {
  constructor(schema, value, error) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error;
  }
}

class TransformEncodeError extends TypeBoxError {
  constructor(schema, path, value, error) {
    super(`${error instanceof Error ? error.message : "Unknown error"}`);
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error;
  }
}
function Default4(schema, path, value) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Encode(value) : value;
  } catch (error) {
    throw new TransformEncodeError(schema, path, value, error);
  }
}
function FromArray15(schema, references, path, value) {
  const defaulted = Default4(schema, path, value);
  return IsArray2(defaulted) ? defaulted.map((value2, index) => Visit12(schema.items, references, `${path}/${index}`, value2)) : defaulted;
}
function FromImport8(schema, references, path, value) {
  const additional = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const result = Default4(schema, path, value);
  return Visit12(target, [...references, ...additional], path, result);
}
function FromIntersect16(schema, references, path, value) {
  const defaulted = Default4(schema, path, value);
  if (!IsObject2(value) || IsValueType(value))
    return defaulted;
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...defaulted };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit12(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform(schema.unevaluatedProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default4(unevaluatedProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromNot6(schema, references, path, value) {
  return Default4(schema.not, path, Default4(schema, path, value));
}
function FromObject16(schema, references, path, value) {
  const defaulted = Default4(schema, path, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...defaulted };
  for (const key of knownKeys) {
    if (!HasPropertyKey2(knownProperties, key))
      continue;
    if (IsUndefined2(knownProperties[key]) && (!IsUndefined3(schema.properties[key]) || TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit12(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
  }
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default4(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRecord11(schema, references, path, value) {
  const defaulted = Default4(schema, path, value);
  if (!IsObject2(value))
    return defaulted;
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern);
  const knownProperties = { ...defaulted };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit12(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      properties[key] = Default4(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRef12(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit12(target, references, path, value);
  return Default4(schema, path, resolved);
}
function FromThis8(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit12(target, references, path, value);
  return Default4(schema, path, resolved);
}
function FromTuple13(schema, references, path, value) {
  const value1 = Default4(schema, path, value);
  return IsArray2(schema.items) ? schema.items.map((schema2, index) => Visit12(schema2, references, `${path}/${index}`, value1[index])) : [];
}
function FromUnion18(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const value1 = Visit12(subschema, references, path, value);
    return Default4(schema, path, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit12(subschema, references, path, value);
    if (!Check(schema, references, value1))
      continue;
    return Default4(schema, path, value1);
  }
  return Default4(schema, path, value);
}
function Visit12(schema, references, path, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray15(schema_, references_, path, value);
    case "Import":
      return FromImport8(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect16(schema_, references_, path, value);
    case "Not":
      return FromNot6(schema_, references_, path, value);
    case "Object":
      return FromObject16(schema_, references_, path, value);
    case "Record":
      return FromRecord11(schema_, references_, path, value);
    case "Ref":
      return FromRef12(schema_, references_, path, value);
    case "This":
      return FromThis8(schema_, references_, path, value);
    case "Tuple":
      return FromTuple13(schema_, references_, path, value);
    case "Union":
      return FromUnion18(schema_, references_, path, value);
    default:
      return Default4(schema_, path, value);
  }
}
function TransformEncode(schema, references, value) {
  return Visit12(schema, references, "", value);
}

// node_modules/@sinclair/typebox/build/esm/value/transform/has.mjs
function FromArray16(schema, references) {
  return IsTransform(schema) || Visit13(schema.items, references);
}
function FromAsyncIterator7(schema, references) {
  return IsTransform(schema) || Visit13(schema.items, references);
}
function FromConstructor8(schema, references) {
  return IsTransform(schema) || Visit13(schema.returns, references) || schema.parameters.some((schema2) => Visit13(schema2, references));
}
function FromFunction7(schema, references) {
  return IsTransform(schema) || Visit13(schema.returns, references) || schema.parameters.some((schema2) => Visit13(schema2, references));
}
function FromIntersect17(schema, references) {
  return IsTransform(schema) || IsTransform(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit13(schema2, references));
}
function FromImport9(schema, references) {
  const additional = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => [...result, schema.$defs[key]], []);
  const target = schema.$defs[schema.$ref];
  return IsTransform(schema) || Visit13(target, [...additional, ...references]);
}
function FromIterator7(schema, references) {
  return IsTransform(schema) || Visit13(schema.items, references);
}
function FromNot7(schema, references) {
  return IsTransform(schema) || Visit13(schema.not, references);
}
function FromObject17(schema, references) {
  return IsTransform(schema) || Object.values(schema.properties).some((schema2) => Visit13(schema2, references)) || IsSchema(schema.additionalProperties) && Visit13(schema.additionalProperties, references);
}
function FromPromise7(schema, references) {
  return IsTransform(schema) || Visit13(schema.item, references);
}
function FromRecord12(schema, references) {
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern];
  return IsTransform(schema) || Visit13(property, references) || IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties);
}
function FromRef13(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit13(Deref(schema, references), references);
}
function FromThis9(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit13(Deref(schema, references), references);
}
function FromTuple14(schema, references) {
  return IsTransform(schema) || !IsUndefined2(schema.items) && schema.items.some((schema2) => Visit13(schema2, references));
}
function FromUnion19(schema, references) {
  return IsTransform(schema) || schema.anyOf.some((schema2) => Visit13(schema2, references));
}
function Visit13(schema, references) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray16(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator7(schema_, references_);
    case "Constructor":
      return FromConstructor8(schema_, references_);
    case "Function":
      return FromFunction7(schema_, references_);
    case "Import":
      return FromImport9(schema_, references_);
    case "Intersect":
      return FromIntersect17(schema_, references_);
    case "Iterator":
      return FromIterator7(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Object":
      return FromObject17(schema_, references_);
    case "Promise":
      return FromPromise7(schema_, references_);
    case "Record":
      return FromRecord12(schema_, references_);
    case "Ref":
      return FromRef13(schema_, references_);
    case "This":
      return FromThis9(schema_, references_);
    case "Tuple":
      return FromTuple14(schema_, references_);
    case "Union":
      return FromUnion19(schema_, references_);
    default:
      return IsTransform(schema);
  }
}
var visited = new Set;
function HasTransform(schema, references) {
  visited.clear();
  return Visit13(schema, references);
}

// node_modules/@sinclair/typebox/build/esm/value/decode/decode.mjs
function Decode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check(schema, references, value))
    throw new TransformDecodeCheckError(schema, value, Errors(schema, references, value).First());
  return HasTransform(schema, references) ? TransformDecode(schema, references, value) : value;
}
// node_modules/@sinclair/typebox/build/esm/value/default/default.mjs
function ValueOrDefault(schema, value) {
  const defaultValue = HasPropertyKey2(schema, "default") ? schema.default : undefined;
  const clone = IsFunction2(defaultValue) ? defaultValue() : Clone2(defaultValue);
  return IsUndefined2(value) ? clone : IsObject2(value) && IsObject2(clone) ? Object.assign(clone, value) : value;
}
function HasDefaultProperty(schema) {
  return IsKind(schema) && "default" in schema;
}
function FromArray17(schema, references, value) {
  if (IsArray2(value)) {
    for (let i = 0;i < value.length; i++) {
      value[i] = Visit14(schema.items, references, value[i]);
    }
    return value;
  }
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray2(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit14(schema.items, references, defaulted[i]);
  }
  return defaulted;
}
function FromDate7(schema, references, value) {
  return IsDate2(value) ? value : ValueOrDefault(schema, value);
}
function FromImport10(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit14(target, [...references, ...definitions], value);
}
function FromIntersect18(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit14(schema2, references, defaulted);
    return IsObject2(next) ? { ...acc, ...next } : next;
  }, {});
}
function FromObject18(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    const propertyValue = Visit14(schema.properties[key], references, defaulted[key]);
    if (IsUndefined2(propertyValue))
      continue;
    defaulted[key] = Visit14(schema.properties[key], references, defaulted[key]);
  }
  if (!HasDefaultProperty(schema.additionalProperties))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit14(schema.additionalProperties, references, defaulted[key]);
  }
  return defaulted;
}
function FromRecord13(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && HasDefaultProperty(propertySchema)))
      continue;
    defaulted[key] = Visit14(propertySchema, references, defaulted[key]);
  }
  if (!HasDefaultProperty(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit14(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRef14(schema, references, value) {
  return Visit14(Deref(schema, references), references, ValueOrDefault(schema, value));
}
function FromThis10(schema, references, value) {
  return Visit14(Deref(schema, references), references, value);
}
function FromTuple15(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray2(defaulted) || IsUndefined2(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit14(items[i], references, defaulted[i]);
  }
  return defaulted;
}
function FromUnion20(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  for (const inner of schema.anyOf) {
    const result = Visit14(inner, references, Clone2(defaulted));
    if (Check(inner, references, result)) {
      return result;
    }
  }
  return defaulted;
}
function Visit14(schema, references, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray17(schema_, references_, value);
    case "Date":
      return FromDate7(schema_, references_, value);
    case "Import":
      return FromImport10(schema_, references_, value);
    case "Intersect":
      return FromIntersect18(schema_, references_, value);
    case "Object":
      return FromObject18(schema_, references_, value);
    case "Record":
      return FromRecord13(schema_, references_, value);
    case "Ref":
      return FromRef14(schema_, references_, value);
    case "This":
      return FromThis10(schema_, references_, value);
    case "Tuple":
      return FromTuple15(schema_, references_, value);
    case "Union":
      return FromUnion20(schema_, references_, value);
    default:
      return ValueOrDefault(schema_, value);
  }
}
function Default5(...args) {
  return args.length === 3 ? Visit14(args[0], args[1], args[2]) : Visit14(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/pointer/pointer.mjs
var exports_pointer = {};
__export(exports_pointer, {
  ValuePointerRootSetError: () => ValuePointerRootSetError,
  ValuePointerRootDeleteError: () => ValuePointerRootDeleteError,
  Set: () => Set4,
  Has: () => Has3,
  Get: () => Get3,
  Format: () => Format,
  Delete: () => Delete3
});
class ValuePointerRootSetError extends TypeBoxError {
  constructor(value, path, update) {
    super("Cannot set root value");
    this.value = value;
    this.path = path;
    this.update = update;
  }
}

class ValuePointerRootDeleteError extends TypeBoxError {
  constructor(value, path) {
    super("Cannot delete root value");
    this.value = value;
    this.path = path;
  }
}
function Escape2(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
}
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0;i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape2(pointer.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value, pointer, update);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete3(value, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value, pointer);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value, pointer) {
  if (pointer === "")
    return value;
  let current = value;
  for (const component of Format(pointer)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}
// node_modules/@sinclair/typebox/build/esm/value/equal/equal.mjs
function ObjectType3(left, right) {
  if (!IsObject2(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
}
function DateType3(left, right) {
  return IsDate2(right) && left.getTime() === right.getTime();
}
function ArrayType3(left, right) {
  if (!IsArray2(right) || left.length !== right.length)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function TypedArrayType(left, right) {
  if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function ValueType(left, right) {
  return left === right;
}
function Equal(left, right) {
  if (IsDate2(left))
    return DateType3(left, right);
  if (IsTypedArray(left))
    return TypedArrayType(left, right);
  if (IsArray2(left))
    return ArrayType3(left, right);
  if (IsObject2(left))
    return ObjectType3(left, right);
  if (IsValueType(left))
    return ValueType(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}

// node_modules/@sinclair/typebox/build/esm/value/delta/delta.mjs
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);

class ValueDiffError extends TypeBoxError {
  constructor(value, message) {
    super(message);
    this.value = value;
  }
}
function CreateUpdate(path, value) {
  return { type: "update", path, value };
}
function CreateInsert(path, value) {
  return { type: "insert", path, value };
}
function CreateDelete(path) {
  return { type: "delete", path };
}
function AssertDiffable(value) {
  if (globalThis.Object.getOwnPropertySymbols(value).length > 0)
    throw new ValueDiffError(value, "Cannot diff objects with symbols");
}
function* ObjectType4(path, current, next) {
  AssertDiffable(current);
  AssertDiffable(next);
  if (!IsStandardObject(next))
    return yield CreateUpdate(path, next);
  const currentKeys = globalThis.Object.getOwnPropertyNames(current);
  const nextKeys = globalThis.Object.getOwnPropertyNames(next);
  for (const key of nextKeys) {
    if (HasPropertyKey2(current, key))
      continue;
    yield CreateInsert(`${path}/${key}`, next[key]);
  }
  for (const key of currentKeys) {
    if (!HasPropertyKey2(next, key))
      continue;
    if (Equal(current, next))
      continue;
    yield* Visit15(`${path}/${key}`, current[key], next[key]);
  }
  for (const key of currentKeys) {
    if (HasPropertyKey2(next, key))
      continue;
    yield CreateDelete(`${path}/${key}`);
  }
}
function* ArrayType4(path, current, next) {
  if (!IsArray2(next))
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit15(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0;i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1;i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete(`${path}/${i}`);
  }
}
function* TypedArrayType2(path, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit15(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType2(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path, next);
}
function* Visit15(path, current, next) {
  if (IsStandardObject(current))
    return yield* ObjectType4(path, current, next);
  if (IsArray2(current))
    return yield* ArrayType4(path, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path, current, next);
  throw new ValueDiffError(current, "Unable to diff value");
}
function Diff(current, next) {
  return [...Visit15("", current, next)];
}
function IsRootUpdate(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
}
function IsIdentity(edits) {
  return edits.length === 0;
}
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer.Set(clone, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer.Set(clone, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer.Delete(clone, edit.path);
        break;
      }
    }
  }
  return clone;
}
// node_modules/@sinclair/typebox/build/esm/value/encode/encode.mjs
function Encode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = HasTransform(schema, references) ? TransformEncode(schema, references, value) : value;
  if (!Check(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, encoded, Errors(schema, references, encoded).First());
  return encoded;
}
// node_modules/@sinclair/typebox/build/esm/value/mutate/mutate.mjs
function IsStandardObject2(value) {
  return IsObject2(value) && !IsArray2(value);
}

class ValueMutateError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
function ObjectType5(root, path, current, next) {
  if (!IsStandardObject2(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    const currentKeys = Object.getOwnPropertyNames(current);
    const nextKeys = Object.getOwnPropertyNames(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit16(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
}
function ArrayType5(root, path, current, next) {
  if (!IsArray2(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    for (let index = 0;index < next.length; index++) {
      Visit16(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
}
function TypedArrayType3(root, path, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i = 0;i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    exports_pointer.Set(root, path, Clone2(next));
  }
}
function ValueType3(root, path, current, next) {
  if (current === next)
    return;
  exports_pointer.Set(root, path, next);
}
function Visit16(root, path, current, next) {
  if (IsArray2(next))
    return ArrayType5(root, path, current, next);
  if (IsTypedArray(next))
    return TypedArrayType3(root, path, current, next);
  if (IsStandardObject2(next))
    return ObjectType5(root, path, current, next);
  if (IsValueType(next))
    return ValueType3(root, path, current, next);
}
function IsNonMutableValue(value) {
  return IsTypedArray(value) || IsValueType(value);
}
function IsMismatchedValue(current, next) {
  return IsStandardObject2(current) && IsArray2(next) || IsArray2(current) && IsStandardObject2(next);
}
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit16(current, "", current, next);
}
// node_modules/@sinclair/typebox/build/esm/value/parse/parse.mjs
class ParseError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
var ParseRegistry;
(function(ParseRegistry2) {
  const registry = new Map([
    ["Assert", (type, references, value) => {
      Assert(type, references, value);
      return value;
    }],
    ["Cast", (type, references, value) => Cast(type, references, value)],
    ["Clean", (type, references, value) => Clean(type, references, value)],
    ["Clone", (_type, _references, value) => Clone2(value)],
    ["Convert", (type, references, value) => Convert(type, references, value)],
    ["Decode", (type, references, value) => HasTransform(type, references) ? TransformDecode(type, references, value) : value],
    ["Default", (type, references, value) => Default5(type, references, value)],
    ["Encode", (type, references, value) => HasTransform(type, references) ? TransformEncode(type, references, value) : value]
  ]);
  function Delete5(key) {
    registry.delete(key);
  }
  ParseRegistry2.Delete = Delete5;
  function Set5(key, callback) {
    registry.set(key, callback);
  }
  ParseRegistry2.Set = Set5;
  function Get4(key) {
    return registry.get(key);
  }
  ParseRegistry2.Get = Get4;
})(ParseRegistry || (ParseRegistry = {}));
var ParseDefault = [
  "Clone",
  "Clean",
  "Default",
  "Convert",
  "Assert",
  "Decode"
];
function ParseValue(operations, type, references, value) {
  return operations.reduce((value2, operationKey) => {
    const operation = ParseRegistry.Get(operationKey);
    if (IsUndefined2(operation))
      throw new ParseError(`Unable to find Parse operation '${operationKey}'`);
    return operation(type, references, value2);
  }, value);
}
function Parse(...args) {
  const [operations, schema, references, value] = args.length === 4 ? [args[0], args[1], args[2], args[3]] : args.length === 3 ? IsArray2(args[0]) ? [args[0], args[1], [], args[2]] : [ParseDefault, args[0], args[1], args[2]] : args.length === 2 ? [ParseDefault, args[0], [], args[1]] : (() => {
    throw new ParseError("Invalid Arguments");
  })();
  return ParseValue(operations, schema, references, value);
}
// node_modules/@sinclair/typebox/build/esm/value/value/value.mjs
var exports_value2 = {};
__export(exports_value2, {
  ValueErrorIterator: () => ValueErrorIterator,
  Patch: () => Patch,
  Parse: () => Parse,
  Mutate: () => Mutate,
  Hash: () => Hash,
  Errors: () => Errors,
  Equal: () => Equal,
  Encode: () => Encode,
  Edit: () => Edit,
  Diff: () => Diff,
  Default: () => Default5,
  Decode: () => Decode,
  Create: () => Create2,
  Convert: () => Convert,
  Clone: () => Clone2,
  Clean: () => Clean,
  Check: () => Check,
  Cast: () => Cast,
  Assert: () => Assert
});
// node_modules/@sinclair/typebox/build/esm/compiler/compiler.mjs
class TypeCheck {
  constructor(schema, references, checkFunc, code) {
    this.schema = schema;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema, references);
  }
  Code() {
    return this.code;
  }
  Schema() {
    return this.schema;
  }
  References() {
    return this.references;
  }
  Errors(value) {
    return Errors(this.schema, this.references, value);
  }
  Check(value) {
    return this.checkFunc(value);
  }
  Decode(value) {
    if (!this.checkFunc(value))
      throw new TransformDecodeCheckError(this.schema, value, this.Errors(value).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value) : value;
  }
  Encode(value) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value) : value;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value, this.Errors(value).First());
    return encoded;
  }
}
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value) {
    if (value.length === 0)
      return false;
    return Character.IsNumeric(value.charCodeAt(0));
  }
  function IsAccessor(value) {
    if (IsFirstCharacterNumeric(value))
      return false;
    for (let i = 0;i < value.length; i++) {
      const code = value.charCodeAt(i);
      const check2 = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check2)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode2(object, key) {
    return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode2($id) {
    const buffer = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape3(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));

class TypeCompilerUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class TypeCompilerTypeGuardError extends TypeBoxError {
  constructor(schema) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema;
  }
}
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))` : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy.AllowNaN ? `typeof ${value} === 'number'` : `Number.isFinite(${value})`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema) {
    return schema[Kind] === "Any" || schema[Kind] === "Unknown";
  }
  function* FromAny5(schema, references, value) {
    yield "true";
  }
  function* FromArgument5(schema, references, value) {
    yield "true";
  }
  function* FromArray18(schema, references, value) {
    yield `Array.isArray(${value})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber2(schema.maxItems))
      yield `${value}.length <= ${schema.maxItems}`;
    if (IsNumber2(schema.minItems))
      yield `${value}.length >= ${schema.minItems}`;
    const elementExpression = CreateExpression(schema.items, references, "value");
    yield `${value}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema2(schema.contains) || IsNumber2(schema.minContains) || IsNumber2(schema.maxContains)) {
      const containsSchema = IsSchema2(schema.contains) ? schema.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber2(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
      const checkMaxContains = IsNumber2(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check2 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check2}})(${value})`;
    }
    if (schema.uniqueItems === true) {
      const check2 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check2} }`;
      yield `((${parameter}) => { ${block} )(${value})`;
    }
  }
  function* FromAsyncIterator8(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
  }
  function* FromBigInt6(schema, references, value) {
    yield `(typeof ${value} === 'bigint')`;
    if (IsBigInt2(schema.exclusiveMaximum))
      yield `${value} < BigInt(${schema.exclusiveMaximum})`;
    if (IsBigInt2(schema.exclusiveMinimum))
      yield `${value} > BigInt(${schema.exclusiveMinimum})`;
    if (IsBigInt2(schema.maximum))
      yield `${value} <= BigInt(${schema.maximum})`;
    if (IsBigInt2(schema.minimum))
      yield `${value} >= BigInt(${schema.minimum})`;
    if (IsBigInt2(schema.multipleOf))
      yield `(${value} % BigInt(${schema.multipleOf})) === 0`;
  }
  function* FromBoolean6(schema, references, value) {
    yield `(typeof ${value} === 'boolean')`;
  }
  function* FromConstructor9(schema, references, value) {
    yield* Visit17(schema.returns, references, `${value}.prototype`);
  }
  function* FromDate8(schema, references, value) {
    yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;
    if (IsNumber2(schema.exclusiveMaximumTimestamp))
      yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
    if (IsNumber2(schema.exclusiveMinimumTimestamp))
      yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
    if (IsNumber2(schema.maximumTimestamp))
      yield `${value}.getTime() <= ${schema.maximumTimestamp}`;
    if (IsNumber2(schema.minimumTimestamp))
      yield `${value}.getTime() >= ${schema.minimumTimestamp}`;
    if (IsNumber2(schema.multipleOfTimestamp))
      yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction8(schema, references, value) {
    yield `(typeof ${value} === 'function')`;
  }
  function* FromImport11(schema, references, value) {
    const members = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => {
      return [...result, schema.$defs[key]];
    }, []);
    yield* Visit17(Ref(schema.$ref), [...references, ...members], value);
  }
  function* FromInteger6(schema, references, value) {
    yield `Number.isInteger(${value})`;
    if (IsNumber2(schema.exclusiveMaximum))
      yield `${value} < ${schema.exclusiveMaximum}`;
    if (IsNumber2(schema.exclusiveMinimum))
      yield `${value} > ${schema.exclusiveMinimum}`;
    if (IsNumber2(schema.maximum))
      yield `${value} <= ${schema.maximum}`;
    if (IsNumber2(schema.minimum))
      yield `${value} >= ${schema.minimum}`;
    if (IsNumber2(schema.multipleOf))
      yield `(${value} % ${schema.multipleOf}) === 0`;
  }
  function* FromIntersect19(schema, references, value) {
    const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value)).join(" && ");
    if (schema.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check2})`;
    } else if (IsSchema2(schema.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;
      yield `(${check1} && ${check2})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator8(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
  }
  function* FromLiteral7(schema, references, value) {
    if (typeof schema.const === "number" || typeof schema.const === "boolean") {
      yield `(${value} === ${schema.const})`;
    } else {
      yield `(${value} === '${LiteralString.Escape(schema.const)}')`;
    }
  }
  function* FromNever6(schema, references, value) {
    yield `false`;
  }
  function* FromNot8(schema, references, value) {
    const expression = CreateExpression(schema.not, references, value);
    yield `(!${expression})`;
  }
  function* FromNull6(schema, references, value) {
    yield `(${value} === null)`;
  }
  function* FromNumber6(schema, references, value) {
    yield Policy.IsNumberLike(value);
    if (IsNumber2(schema.exclusiveMaximum))
      yield `${value} < ${schema.exclusiveMaximum}`;
    if (IsNumber2(schema.exclusiveMinimum))
      yield `${value} > ${schema.exclusiveMinimum}`;
    if (IsNumber2(schema.maximum))
      yield `${value} <= ${schema.maximum}`;
    if (IsNumber2(schema.minimum))
      yield `${value} >= ${schema.minimum}`;
    if (IsNumber2(schema.multipleOf))
      yield `(${value} % ${schema.multipleOf}) === 0`;
  }
  function* FromObject19(schema, references, value) {
    yield Policy.IsObjectLike(value);
    if (IsNumber2(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
    if (IsNumber2(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value, knownKey);
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit17(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value, knownKey, expression);
      }
    }
    if (schema.additionalProperties === false) {
      if (schema.required && schema.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema.additionalProperties === "object") {
      const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise8(schema, references, value) {
    yield `${value} instanceof Promise`;
  }
  function* FromRecord14(schema, references, value) {
    yield Policy.IsRecordLike(value);
    if (IsNumber2(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
    if (IsNumber2(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check2 = IsSchema2(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
    yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef15(schema, references, value) {
    const target = Deref(schema, references);
    if (state.functions.has(schema.$ref))
      return yield `${CreateFunctionName(schema.$ref)}(${value})`;
    yield* Visit17(target, references, value);
  }
  function* FromRegExp5(schema, references, value) {
    const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
    yield `(typeof ${value} === 'string')`;
    if (IsNumber2(schema.maxLength))
      yield `${value}.length <= ${schema.maxLength}`;
    if (IsNumber2(schema.minLength))
      yield `${value}.length >= ${schema.minLength}`;
    yield `${variable}.test(${value})`;
  }
  function* FromString6(schema, references, value) {
    yield `(typeof ${value} === 'string')`;
    if (IsNumber2(schema.maxLength))
      yield `${value}.length <= ${schema.maxLength}`;
    if (IsNumber2(schema.minLength))
      yield `${value}.length >= ${schema.minLength}`;
    if (schema.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value})`;
    }
    if (schema.format !== undefined) {
      yield `format('${schema.format}', ${value})`;
    }
  }
  function* FromSymbol6(schema, references, value) {
    yield `(typeof ${value} === 'symbol')`;
  }
  function* FromTemplateLiteral7(schema, references, value) {
    yield `(typeof ${value} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
    yield `${variable}.test(${value})`;
  }
  function* FromThis11(schema, references, value) {
    yield `${CreateFunctionName(schema.$ref)}(${value})`;
  }
  function* FromTuple16(schema, references, value) {
    yield `Array.isArray(${value})`;
    if (schema.items === undefined)
      return yield `${value}.length === 0`;
    yield `(${value}.length === ${schema.maxItems})`;
    for (let i = 0;i < schema.items.length; i++) {
      const expression = CreateExpression(schema.items[i], references, `${value}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined6(schema, references, value) {
    yield `${value} === undefined`;
  }
  function* FromUnion21(schema, references, value) {
    const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array5(schema, references, value) {
    yield `${value} instanceof Uint8Array`;
    if (IsNumber2(schema.maxByteLength))
      yield `(${value}.length <= ${schema.maxByteLength})`;
    if (IsNumber2(schema.minByteLength))
      yield `(${value}.length >= ${schema.minByteLength})`;
  }
  function* FromUnknown5(schema, references, value) {
    yield "true";
  }
  function* FromVoid5(schema, references, value) {
    yield Policy.IsVoidLike(value);
  }
  function* FromKind4(schema, references, value) {
    const instance = state.instances.size;
    state.instances.set(instance, schema);
    yield `kind('${schema[Kind]}', ${instance}, ${value})`;
  }
  function* Visit17(schema, references, value, useHoisting = true) {
    const references_ = IsString2(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (useHoisting && IsString2(schema.$id)) {
      const functionName = CreateFunctionName(schema.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value})`;
      } else {
        state.functions.set(functionName, "<deferred>");
        const functionCode = CreateFunction(functionName, schema, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, value);
      case "Argument":
        return yield* FromArgument5(schema_, references_, value);
      case "Array":
        return yield* FromArray18(schema_, references_, value);
      case "AsyncIterator":
        return yield* FromAsyncIterator8(schema_, references_, value);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, value);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, value);
      case "Constructor":
        return yield* FromConstructor9(schema_, references_, value);
      case "Date":
        return yield* FromDate8(schema_, references_, value);
      case "Function":
        return yield* FromFunction8(schema_, references_, value);
      case "Import":
        return yield* FromImport11(schema_, references_, value);
      case "Integer":
        return yield* FromInteger6(schema_, references_, value);
      case "Intersect":
        return yield* FromIntersect19(schema_, references_, value);
      case "Iterator":
        return yield* FromIterator8(schema_, references_, value);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, value);
      case "Never":
        return yield* FromNever6(schema_, references_, value);
      case "Not":
        return yield* FromNot8(schema_, references_, value);
      case "Null":
        return yield* FromNull6(schema_, references_, value);
      case "Number":
        return yield* FromNumber6(schema_, references_, value);
      case "Object":
        return yield* FromObject19(schema_, references_, value);
      case "Promise":
        return yield* FromPromise8(schema_, references_, value);
      case "Record":
        return yield* FromRecord14(schema_, references_, value);
      case "Ref":
        return yield* FromRef15(schema_, references_, value);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, value);
      case "String":
        return yield* FromString6(schema_, references_, value);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, value);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, value);
      case "This":
        return yield* FromThis11(schema_, references_, value);
      case "Tuple":
        return yield* FromTuple16(schema_, references_, value);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, value);
      case "Union":
        return yield* FromUnion21(schema_, references_, value);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, value);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, value);
      case "Void":
        return yield* FromVoid5(schema_, references_, value);
      default:
        if (!exports_type2.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema);
        return yield* FromKind4(schema_, references_, value);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema, references, value, useHoisting = true) {
    return `(${[...Visit17(schema, references, value, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema, references, value, useHoisting = true) {
    const [newline, pad] = [`
`, (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit17(schema, references, value, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
  }
  function CreateParameter(name, type) {
    const annotation = state.language === "typescript" ? `: ${type}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type) {
    return state.language === "typescript" ? `: ${type}` : "";
  }
  function Build(schema, references, options) {
    const functionCode = CreateFunction("check", schema, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString2(schema.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema.$id)}(value)
}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join(`
`);
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema, references, options] = args.length === 2 && IsArray2(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray2(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema2(schema))
      throw new TypeCompilerTypeGuardError(schema);
    for (const schema2 of references)
      if (!IsSchema2(schema2))
        throw new TypeCompilerTypeGuardError(schema2);
    return Build(schema, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema, references = []) {
    const generatedCode = Code(schema, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value) {
      if (!exports_type2.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = exports_type2.Get(kind);
      const schema2 = instances.get(instance);
      return checkFunc(schema2, value);
    }
    function formatRegistryFunction(format, value) {
      if (!exports_format.Has(format))
        return false;
      const checkFunc = exports_format.Get(format);
      return checkFunc(value);
    }
    function hashFunction(value) {
      return Hash(value);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));

// node_modules/elysia/dist/bun/index.js
var __create2 = Object.create;
var { getPrototypeOf: __getProtoOf2, defineProperty: __defProp2, getOwnPropertyNames: __getOwnPropNames2 } = Object;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __toESM2 = (mod, isNodeMode, target) => {
  target = mod != null ? __create2(__getProtoOf2(mod)) : {};
  let to = isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames2(mod))
    if (!__hasOwnProp2.call(to, key))
      __defProp2(to, key, { get: () => mod[key], enumerable: true });
  return to;
};
var __commonJS2 = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var require_fast_decode_uri_component = __commonJS2((exports, module) => {
  var UTF8_ACCEPT = 12, UTF8_REJECT = 0, UTF8_DATA = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7];
  function decodeURIComponent2(uri) {
    var percentPosition = uri.indexOf("%");
    if (percentPosition === -1)
      return uri;
    var length = uri.length, decoded = "", last = 0, codepoint = 0, startOfOctets = percentPosition, state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length) {
      var high = hexCodeToInt(uri[percentPosition + 1], 4), low = hexCodeToInt(uri[percentPosition + 2], 0), byte = high | low, type = UTF8_DATA[byte];
      if (state = UTF8_DATA[256 + state + type], codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type], state === UTF8_ACCEPT)
        decoded += uri.slice(last, startOfOctets), decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023)), codepoint = 0, last = percentPosition + 3, percentPosition = startOfOctets = uri.indexOf("%", last);
      else if (state === UTF8_REJECT)
        return null;
      else {
        if (percentPosition += 3, percentPosition < length && uri.charCodeAt(percentPosition) === 37)
          continue;
        return null;
      }
    }
    return decoded + uri.slice(last);
  }
  var HEX = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  function hexCodeToInt(c, shift) {
    var i2 = HEX[c];
    return i2 === undefined ? 255 : i2 << shift;
  }
  module.exports = decodeURIComponent2;
});
var require_dist = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parse = parse2;
  exports.serialize = serialize;
  var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/, cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/, domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/, __toString = Object.prototype.toString, NullObject = (() => {
    let C = function() {};
    return C.prototype = Object.create(null), C;
  })();
  function parse2(str, options) {
    let obj = new NullObject, len = str.length;
    if (len < 2)
      return obj;
    let dec = options?.decode || decode2, index = 0;
    do {
      let eqIdx = str.indexOf("=", index);
      if (eqIdx === -1)
        break;
      let colonIdx = str.indexOf(";", index), endIdx = colonIdx === -1 ? len : colonIdx;
      if (eqIdx > endIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      let keyStartIdx = startIndex(str, index, eqIdx), keyEndIdx = endIndex(str, eqIdx, keyStartIdx), key = str.slice(keyStartIdx, keyEndIdx);
      if (obj[key] === undefined) {
        let valStartIdx = startIndex(str, eqIdx + 1, endIdx), valEndIdx = endIndex(str, endIdx, valStartIdx), value = dec(str.slice(valStartIdx, valEndIdx));
        obj[key] = value;
      }
      index = endIdx + 1;
    } while (index < len);
    return obj;
  }
  function startIndex(str, index, max2) {
    do {
      let code = str.charCodeAt(index);
      if (code !== 32 && code !== 9)
        return index;
    } while (++index < max2);
    return max2;
  }
  function endIndex(str, index, min) {
    while (index > min) {
      let code = str.charCodeAt(--index);
      if (code !== 32 && code !== 9)
        return index + 1;
    }
    return min;
  }
  function serialize(name, val, options) {
    let enc = options?.encode || encodeURIComponent;
    if (!cookieNameRegExp.test(name))
      throw TypeError(`argument name is invalid: ${name}`);
    let value = enc(val);
    if (!cookieValueRegExp.test(value))
      throw TypeError(`argument val is invalid: ${val}`);
    let str = name + "=" + value;
    if (!options)
      return str;
    if (options.maxAge !== undefined) {
      if (!Number.isInteger(options.maxAge))
        throw TypeError(`option maxAge is invalid: ${options.maxAge}`);
      str += "; Max-Age=" + options.maxAge;
    }
    if (options.domain) {
      if (!domainValueRegExp.test(options.domain))
        throw TypeError(`option domain is invalid: ${options.domain}`);
      str += "; Domain=" + options.domain;
    }
    if (options.path) {
      if (!pathValueRegExp.test(options.path))
        throw TypeError(`option path is invalid: ${options.path}`);
      str += "; Path=" + options.path;
    }
    if (options.expires) {
      if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf()))
        throw TypeError(`option expires is invalid: ${options.expires}`);
      str += "; Expires=" + options.expires.toUTCString();
    }
    if (options.httpOnly)
      str += "; HttpOnly";
    if (options.secure)
      str += "; Secure";
    if (options.partitioned)
      str += "; Partitioned";
    if (options.priority)
      switch (typeof options.priority === "string" ? options.priority.toLowerCase() : undefined) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw TypeError(`option priority is invalid: ${options.priority}`);
      }
    if (options.sameSite)
      switch (typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite) {
        case true:
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw TypeError(`option sameSite is invalid: ${options.sameSite}`);
      }
    return str;
  }
  function decode2(str) {
    if (str.indexOf("%") === -1)
      return str;
    try {
      return decodeURIComponent(str);
    } catch (e) {
      return str;
    }
  }
  function isDate(val) {
    return __toString.call(val) === "[object Date]";
  }
});
var Y = (v, b) => {
  let A = b?.length ? {} : null;
  if (A)
    for (let Q of b)
      A[Q.part.charCodeAt(0)] = Q;
  return { part: v, store: null, inert: A, params: null, wildcardStore: null };
};
var k = (v, b) => ({ ...v, part: b });
var T = (v) => ({ name: v, store: null, inert: null });

class _ {
  config;
  root = {};
  history = [];
  deferred = [];
  constructor(v = {}) {
    if (this.config = v, v.lazy)
      this.find = this.lazyFind;
    if (v.onParam && !Array.isArray(v.onParam))
      this.config.onParam = [this.config.onParam];
  }
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g, optionalParams: /(\/:\w+\?)/g };
  lazyFind = (v, b) => {
    if (!this.config.lazy)
      return this.find;
    return this.build(), this.find(v, b);
  };
  build() {
    if (!this.config.lazy)
      return;
    for (let [v, b, A] of this.deferred)
      this.add(v, b, A, { lazy: false, ignoreHistory: true });
    this.deferred = [], this.find = (v, b) => {
      let A = this.root[v];
      if (!A)
        return null;
      return $(b, b.length, A, 0, this.config.onParam);
    };
  }
  add(v, b, A, { ignoreError: Q = false, ignoreHistory: O = false, lazy: V = this.config.lazy } = {}) {
    if (V)
      return this.find = this.lazyFind, this.deferred.push([v, b, A]), A;
    if (typeof b !== "string")
      throw TypeError("Route path must be a string");
    if (b === "")
      b = "/";
    else if (b[0] !== "/")
      b = `/${b}`;
    let X = b[b.length - 1] === "*", J = b.match(_.regex.optionalParams);
    if (J) {
      let F = b.replaceAll("?", "");
      this.add(v, F, A, { ignoreError: Q, ignoreHistory: O, lazy: V });
      for (let B = 0;B < J.length; B++) {
        let D = b.replace(J[B], "");
        this.add(v, D, A, { ignoreError: true, ignoreHistory: O, lazy: V });
      }
      return A;
    }
    if (J)
      b = b.replaceAll("?", "");
    if (this.history.find(([F, B, D]) => F === v && B === b))
      return A;
    if (X || J && b.charCodeAt(b.length - 1) === 63)
      b = b.slice(0, -1);
    if (!O)
      this.history.push([v, b, A]);
    let K = b.split(_.regex.static), G = b.match(_.regex.params) || [];
    if (K[K.length - 1] === "")
      K.pop();
    let q;
    if (!this.root[v])
      q = this.root[v] = Y("/");
    else
      q = this.root[v];
    let U = 0;
    for (let F = 0;F < K.length; ++F) {
      let B = K[F];
      if (F > 0) {
        let D = G[U++].slice(1);
        if (q.params === null)
          q.params = T(D);
        else if (q.params.name !== D)
          if (Q)
            return A;
          else
            throw Error(`Cannot create route "${b}" with parameter "${D}" because a route already exists with a different parameter name ("${q.params.name}") in the same location`);
        let S = q.params;
        if (S.inert === null) {
          q = S.inert = Y(B);
          continue;
        }
        q = S.inert;
      }
      for (let D = 0;; ) {
        if (D === B.length) {
          if (D < q.part.length) {
            let S = k(q, q.part.slice(D));
            Object.assign(q, Y(B, [S]));
          }
          break;
        }
        if (D === q.part.length) {
          if (q.inert === null)
            q.inert = {};
          let S = q.inert[B.charCodeAt(D)];
          if (S) {
            q = S, B = B.slice(D), D = 0;
            continue;
          }
          let Z = Y(B.slice(D));
          q.inert[B.charCodeAt(D)] = Z, q = Z;
          break;
        }
        if (B[D] !== q.part[D]) {
          let S = k(q, q.part.slice(D)), Z = Y(B.slice(D));
          Object.assign(q, Y(q.part.slice(0, D), [S, Z])), q = Z;
          break;
        }
        ++D;
      }
    }
    if (U < G.length) {
      let B = G[U].slice(1);
      if (q.params === null)
        q.params = T(B);
      else if (q.params.name !== B)
        if (Q)
          return A;
        else
          throw Error(`Cannot create route "${b}" with parameter "${B}" because a route already exists with a different parameter name ("${q.params.name}") in the same location`);
      if (q.params.store === null)
        q.params.store = A;
      return q.params.store;
    }
    if (X) {
      if (q.wildcardStore === null)
        q.wildcardStore = A;
      return q.wildcardStore;
    }
    if (q.store === null)
      q.store = A;
    return q.store;
  }
  find(v, b) {
    let A = this.root[v];
    if (!A)
      return null;
    return $(b, b.length, A, 0, this.config.onParam);
  }
}
var $ = (v, b, A, Q, O) => {
  let V = A.part, X = V.length, J = Q + X;
  if (X > 1) {
    if (J > b)
      return null;
    if (X < 15) {
      for (let K = 1, G = Q + 1;K < X; ++K, ++G)
        if (V.charCodeAt(K) !== v.charCodeAt(G))
          return null;
    } else if (v.slice(Q, J) !== V)
      return null;
  }
  if (J === b) {
    if (A.store !== null)
      return { store: A.store, params: {} };
    if (A.wildcardStore !== null)
      return { store: A.wildcardStore, params: { "*": "" } };
    return null;
  }
  if (A.inert !== null) {
    let K = A.inert[v.charCodeAt(J)];
    if (K !== undefined) {
      let G = $(v, b, K, J, O);
      if (G !== null)
        return G;
    }
  }
  if (A.params !== null) {
    let { store: K, name: G, inert: q } = A.params, U = v.indexOf("/", J);
    if (U !== J) {
      if (U === -1 || U >= b) {
        if (K !== null) {
          let F = {};
          if (F[G] = v.substring(J, b), O)
            for (let B = 0;B < O.length; B++) {
              let D = O[B](F[G], G);
              if (D !== undefined)
                F[G] = D;
            }
          return { store: K, params: F };
        }
      } else if (q !== null) {
        let F = $(v, b, q, U, O);
        if (F !== null) {
          if (F.params[G] = v.substring(J, U), O)
            for (let B = 0;B < O.length; B++) {
              let D = O[B](F.params[G], G);
              if (D !== undefined)
                F.params[G] = D;
            }
          return F;
        }
      }
    }
  }
  if (A.wildcardStore !== null)
    return { store: A.wildcardStore, params: { "*": v.substring(J, b) } };
  return null;
};
var import_fast_decode_uri_component4 = __toESM2(require_fast_decode_uri_component(), 1);
var isBun = typeof Bun < "u";
var mime = { aac: "audio/aac", abw: "application/x-abiword", ai: "application/postscript", arc: "application/octet-stream", avi: "video/x-msvideo", azw: "application/vnd.amazon.ebook", bin: "application/octet-stream", bz: "application/x-bzip", bz2: "application/x-bzip2", csh: "application/x-csh", css: "text/css", csv: "text/csv", doc: "application/msword", dll: "application/octet-stream", eot: "application/vnd.ms-fontobject", epub: "application/epub+zip", gif: "image/gif", htm: "text/html", html: "text/html", ico: "image/x-icon", ics: "text/calendar", jar: "application/java-archive", jpeg: "image/jpeg", jpg: "image/jpeg", js: "application/javascript", json: "application/json", mid: "audio/midi", midi: "audio/midi", mp2: "audio/mpeg", mp3: "audio/mpeg", mp4: "video/mp4", mpa: "video/mpeg", mpe: "video/mpeg", mpeg: "video/mpeg", mpkg: "application/vnd.apple.installer+xml", odp: "application/vnd.oasis.opendocument.presentation", ods: "application/vnd.oasis.opendocument.spreadsheet", odt: "application/vnd.oasis.opendocument.text", oga: "audio/ogg", ogv: "video/ogg", ogx: "application/ogg", otf: "font/otf", png: "image/png", pdf: "application/pdf", ppt: "application/vnd.ms-powerpoint", rar: "application/x-rar-compressed", rtf: "application/rtf", sh: "application/x-sh", svg: "image/svg+xml", swf: "application/x-shockwave-flash", tar: "application/x-tar", tif: "image/tiff", tiff: "image/tiff", ts: "application/typescript", ttf: "font/ttf", txt: "text/plain", vsd: "application/vnd.visio", wav: "audio/x-wav", weba: "audio/webm", webm: "video/webm", webp: "image/webp", woff: "font/woff", woff2: "font/woff2", xhtml: "application/xhtml+xml", xls: "application/vnd.ms-excel", xlsx: "application/vnd.ms-excel", xlsx_OLD: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", xml: "application/xml", xul: "application/vnd.mozilla.xul+xml", zip: "application/zip", "3gp": "video/3gpp", "3gp_DOES_NOT_CONTAIN_VIDEO": "audio/3gpp", "3gp2": "video/3gpp2", "3gp2_DOES_NOT_CONTAIN_VIDEO": "audio/3gpp2", "7z": "application/x-7z-compressed" };
var getFileExtension = (path) => {
  let index = path.lastIndexOf(".");
  if (index === -1)
    return "";
  return path.slice(index + 1);
};
var createReadStream;
var stat;

class ElysiaFile {
  path;
  value;
  stats;
  constructor(path) {
    this.path = path;
    if (isBun)
      this.value = Bun.file(path);
    else {
      if (!createReadStream || !stat) {
        if (typeof window < "u") {
          console.warn("Browser environment does not support file");
          return;
        }
        let warnMissing = (name) => console.warn(Error(`[elysia] \`file\` require \`fs${name ? "." + name : ""}\` ${name?.includes(".") ? "module " : ""}which is not available in this environment`));
        if (typeof process > "u" || typeof process.getBuiltinModule !== "function") {
          warnMissing();
          return;
        }
        let fs = process.getBuiltinModule("fs");
        if (!fs) {
          warnMissing();
          return;
        }
        if (typeof fs.createReadStream !== "function") {
          warnMissing();
          return;
        }
        if (typeof fs.promises?.stat !== "function") {
          warnMissing();
          return;
        }
        createReadStream = fs.createReadStream, stat = fs.promises.stat;
      }
      this.value = (() => createReadStream(path))(), this.stats = stat(path);
    }
  }
  get type() {
    return mime[getFileExtension(this.path)] || "application/octet-stream";
  }
  get length() {
    if (isBun)
      return this.value.size;
    return this.stats?.then((x2) => x2.size) ?? 0;
  }
}
var hasHeaderShorthand = "toJSON" in new Headers;
var replaceUrlPath = (url, pathname) => {
  let urlObject = new URL(url);
  return urlObject.pathname = pathname, urlObject.toString();
};
var isClass = (v) => typeof v === "function" && /^\s*class\s+/.test(v.toString()) || v.toString && v.toString().startsWith("[object ") && v.toString() !== "[object Object]" || isNotEmpty(Object.getPrototypeOf(v));
var isObject = (item) => item && typeof item === "object" && !Array.isArray(item);
var mergeDeep = (target, source, options) => {
  let skipKeys = options?.skipKeys, override = options?.override ?? true, mergeArray = options?.mergeArray ?? false;
  if (!isObject(target) || !isObject(source))
    return target;
  for (let [key, value] of Object.entries(source)) {
    if (skipKeys?.includes(key))
      continue;
    if (mergeArray && Array.isArray(value)) {
      target[key] = Array.isArray(target[key]) ? [...target[key], ...value] : target[key] = value;
      continue;
    }
    if (!isObject(value) || !(key in target) || isClass(value)) {
      if ((override || !(key in target)) && !Object.isFrozen(target))
        try {
          target[key] = value;
        } catch {}
      continue;
    }
    if (!Object.isFrozen(target[key]))
      try {
        target[key] = mergeDeep(target[key], value, { skipKeys, override, mergeArray });
      } catch {}
  }
  return target;
};
var mergeCookie = (a, b) => {
  let v = mergeDeep(Object.assign({}, a), b, { skipKeys: ["properties"], mergeArray: false });
  if (v.properties)
    delete v.properties;
  return v;
};
var mergeObjectArray = (a, b) => {
  if (!b)
    return a;
  let array = [], checksums = [];
  if (a) {
    if (!Array.isArray(a))
      a = [a];
    for (let item of a)
      if (array.push(item), item.checksum)
        checksums.push(item.checksum);
  }
  if (b) {
    if (!Array.isArray(b))
      b = [b];
    for (let item of b)
      if (!checksums.includes(item.checksum))
        array.push(item);
  }
  return array;
};
var primitiveHooks = ["start", "request", "parse", "transform", "resolve", "beforeHandle", "afterHandle", "mapResponse", "afterResponse", "trace", "error", "stop", "body", "headers", "params", "query", "response", "type", "detail"];
var primitiveHookMap = primitiveHooks.reduce((acc, x2) => (acc[x2] = true, acc), {});
var isRecordNumber = (x2) => typeof x2 === "object" && Object.keys(x2).every((x22) => !isNaN(+x22));
var mergeResponse = (a, b) => {
  if (isRecordNumber(a) && isRecordNumber(b))
    return Object.assign({}, a, b);
  else if (a && !isRecordNumber(a) && isRecordNumber(b))
    return Object.assign({ 200: a }, b);
  return b ?? a;
};
var mergeSchemaValidator = (a, b) => {
  if (!a && !b)
    return { body: undefined, headers: undefined, params: undefined, query: undefined, cookie: undefined, response: undefined };
  return { body: b?.body ?? a?.body, headers: b?.headers ?? a?.headers, params: b?.params ?? a?.params, query: b?.query ?? a?.query, cookie: b?.cookie ?? a?.cookie, response: mergeResponse(a?.response, b?.response) };
};
var mergeHook = (a, b) => {
  if (!b)
    return a ?? {};
  if (!a)
    return b ?? {};
  if (!Object.values(b).find((x2) => x2 !== undefined && x2 !== null))
    return { ...a };
  let hook = { ...a, ...b, body: b.body ?? a.body, headers: b.headers ?? a.headers, params: b.params ?? a.params, query: b.query ?? a.query, cookie: b.cookie ?? a.cookie, response: mergeResponse(a.response, b.response), type: a.type || b.type, detail: mergeDeep(b.detail ?? {}, a.detail ?? {}), parse: mergeObjectArray(a.parse, b.parse), transform: mergeObjectArray(a.transform, b.transform), beforeHandle: mergeObjectArray(mergeObjectArray(fnToContainer(a.resolve, "resolve"), a.beforeHandle), mergeObjectArray(fnToContainer(b.resolve, "resolve"), b.beforeHandle)), afterHandle: mergeObjectArray(a.afterHandle, b.afterHandle), mapResponse: mergeObjectArray(a.mapResponse, b.mapResponse), afterResponse: mergeObjectArray(a.afterResponse, b.afterResponse), trace: mergeObjectArray(a.trace, b.trace), error: mergeObjectArray(a.error, b.error), standaloneSchema: a.standaloneSchema || b.standaloneSchema ? a.standaloneSchema && !b.standaloneSchema ? a.standaloneSchema : b.standaloneSchema && !a.standaloneSchema ? b.standaloneSchema : [...a.standaloneSchema ?? [], ...b.standaloneSchema ?? []] : undefined };
  if (hook.resolve)
    delete hook.resolve;
  return hook;
};
var lifeCycleToArray = (a) => {
  if (a.parse && !Array.isArray(a.parse))
    a.parse = [a.parse];
  if (a.transform && !Array.isArray(a.transform))
    a.transform = [a.transform];
  if (a.afterHandle && !Array.isArray(a.afterHandle))
    a.afterHandle = [a.afterHandle];
  if (a.mapResponse && !Array.isArray(a.mapResponse))
    a.mapResponse = [a.mapResponse];
  if (a.afterResponse && !Array.isArray(a.afterResponse))
    a.afterResponse = [a.afterResponse];
  if (a.trace && !Array.isArray(a.trace))
    a.trace = [a.trace];
  if (a.error && !Array.isArray(a.error))
    a.error = [a.error];
  let beforeHandle = [];
  if (a.resolve)
    beforeHandle = fnToContainer(Array.isArray(a.resolve) ? a.resolve : [a.resolve], "resolve"), delete a.resolve;
  if (a.beforeHandle)
    if (beforeHandle.length)
      beforeHandle = beforeHandle.concat(Array.isArray(a.beforeHandle) ? a.beforeHandle : [a.beforeHandle]);
    else
      beforeHandle = Array.isArray(a.beforeHandle) ? a.beforeHandle : [a.beforeHandle];
  if (beforeHandle.length)
    a.beforeHandle = beforeHandle;
  return a;
};
var isBun2 = typeof Bun < "u";
var hasBunHash = isBun2 && typeof Bun.hash === "function";
var checksum = (s) => {
  let h = 9;
  for (let i2 = 0;i2 < s.length; )
    h = Math.imul(h ^ s.charCodeAt(i2++), 387420489);
  return h = h ^ h >>> 9;
};
var injectChecksum = (checksum2, x2) => {
  if (!x2)
    return;
  if (!Array.isArray(x2)) {
    let fn = x2;
    if (checksum2 && !fn.checksum)
      fn.checksum = checksum2;
    if (fn.scope === "scoped")
      fn.scope = "local";
    return fn;
  }
  let fns = [...x2];
  for (let fn of fns) {
    if (checksum2 && !fn.checksum)
      fn.checksum = checksum2;
    if (fn.scope === "scoped")
      fn.scope = "local";
  }
  return fns;
};
var mergeLifeCycle = (a, b, checksum2) => {
  return { start: mergeObjectArray(a.start, injectChecksum(checksum2, b?.start)), request: mergeObjectArray(a.request, injectChecksum(checksum2, b?.request)), parse: mergeObjectArray(a.parse, injectChecksum(checksum2, b?.parse)), transform: mergeObjectArray(a.transform, injectChecksum(checksum2, b?.transform)), beforeHandle: mergeObjectArray(mergeObjectArray(fnToContainer(a.resolve, "resolve"), a.beforeHandle), injectChecksum(checksum2, mergeObjectArray(fnToContainer(b?.resolve, "resolve"), b?.beforeHandle))), afterHandle: mergeObjectArray(a.afterHandle, injectChecksum(checksum2, b?.afterHandle)), mapResponse: mergeObjectArray(a.mapResponse, injectChecksum(checksum2, b?.mapResponse)), afterResponse: mergeObjectArray(a.afterResponse, injectChecksum(checksum2, b?.afterResponse)), trace: mergeObjectArray(a.trace, injectChecksum(checksum2, b?.trace)), error: mergeObjectArray(a.error, injectChecksum(checksum2, b?.error)), stop: mergeObjectArray(a.stop, injectChecksum(checksum2, b?.stop)) };
};
var asHookType = (fn, inject, { skipIfHasType = false }) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn)) {
    if (skipIfHasType)
      fn.scope ??= inject;
    else
      fn.scope = inject;
    return fn;
  }
  for (let x2 of fn)
    if (skipIfHasType)
      x2.scope ??= inject;
    else
      x2.scope = inject;
  return fn;
};
var filterGlobal = (fn) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn))
    switch (fn.scope) {
      case "global":
      case "scoped":
        return { ...fn };
      default:
        return { fn };
    }
  let array = [];
  for (let x2 of fn)
    switch (x2.scope) {
      case "global":
      case "scoped":
        array.push({ ...x2 });
        break;
    }
  return array;
};
var filterGlobalHook = (hook) => {
  return { ...hook, type: hook?.type, detail: hook?.detail, parse: filterGlobal(hook?.parse), transform: filterGlobal(hook?.transform), beforeHandle: filterGlobal(hook?.beforeHandle), afterHandle: filterGlobal(hook?.afterHandle), mapResponse: filterGlobal(hook?.mapResponse), afterResponse: filterGlobal(hook?.afterResponse), error: filterGlobal(hook?.error), trace: filterGlobal(hook?.trace) };
};
var StatusMap = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Enhance Your Calm": 420, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var InvertedStatusMap = Object.fromEntries(Object.entries(StatusMap).map(([k2, v]) => [v, k2]));
function removeTrailingEquals(digest) {
  let trimmedDigest = digest;
  while (trimmedDigest.endsWith("="))
    trimmedDigest = trimmedDigest.slice(0, -1);
  return trimmedDigest;
}
var encoder = new TextEncoder;
var signCookie = async (val, secret) => {
  if (typeof val === "object")
    val = JSON.stringify(val);
  else if (typeof val !== "string")
    val = val + "";
  if (secret === null)
    throw TypeError("Secret key must be provided.");
  let secretKey = await crypto.subtle.importKey("raw", encoder.encode(secret), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]), hmacBuffer = await crypto.subtle.sign("HMAC", secretKey, encoder.encode(val));
  return val + "." + removeTrailingEquals(Buffer.from(hmacBuffer).toString("base64"));
};
var unsignCookie = async (input, secret) => {
  if (typeof input !== "string")
    throw TypeError("Signed cookie string must be provided.");
  if (secret === null)
    throw TypeError("Secret key must be provided.");
  let tentativeValue = input.slice(0, input.lastIndexOf("."));
  return await signCookie(tentativeValue, secret) === input ? tentativeValue : false;
};
var insertStandaloneValidator = (hook, name, value) => {
  if (!hook.standaloneValidator?.length || !Array.isArray(hook.standaloneValidator)) {
    hook.standaloneValidator = [{ [name]: value }];
    return;
  }
  let last = hook.standaloneValidator[hook.standaloneValidator.length - 1];
  if (name in last)
    hook.standaloneValidator.push({ [name]: value });
  else
    last[name] = value;
};
var parseNumericString = (message) => {
  if (typeof message === "number")
    return message;
  if (message.length < 16) {
    if (message.trim().length === 0)
      return null;
    let length = Number(message);
    if (Number.isNaN(length))
      return null;
    return length;
  }
  if (message.length === 16) {
    if (message.trim().length === 0)
      return null;
    let number = Number(message);
    if (Number.isNaN(number) || number.toString() !== message)
      return null;
    return number;
  }
  return null;
};
var isNumericString = (message) => parseNumericString(message) !== null;

class PromiseGroup {
  onError;
  onFinally;
  root = null;
  promises = [];
  constructor(onError = console.error, onFinally = () => {}) {
    this.onError = onError;
    this.onFinally = onFinally;
  }
  get size() {
    return this.promises.length;
  }
  add(promise) {
    if (this.promises.push(promise), this.root ||= this.drain(), this.promises.length === 1)
      this.then(this.onFinally);
    return promise;
  }
  async drain() {
    while (this.promises.length > 0) {
      try {
        await this.promises[0];
      } catch (error) {
        this.onError(error);
      }
      this.promises.shift();
    }
    this.root = null;
  }
  then(onfulfilled, onrejected) {
    return (this.root ?? Promise.resolve()).then(onfulfilled, onrejected);
  }
}
var fnToContainer = (fn, subType) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn)) {
    if (typeof fn === "function" || typeof fn === "string")
      return subType ? { fn, subType } : { fn };
    else if ("fn" in fn)
      return fn;
  }
  let fns = [];
  for (let x2 of fn)
    if (typeof x2 === "function" || typeof x2 === "string")
      fns.push(subType ? { fn: x2, subType } : { fn: x2 });
    else if ("fn" in x2)
      fns.push(x2);
  return fns;
};
var localHookToLifeCycleStore = (a) => {
  if (a.start)
    a.start = fnToContainer(a.start);
  if (a.request)
    a.request = fnToContainer(a.request);
  if (a.parse)
    a.parse = fnToContainer(a.parse);
  if (a.transform)
    a.transform = fnToContainer(a.transform);
  if (a.beforeHandle)
    a.beforeHandle = fnToContainer(a.beforeHandle);
  if (a.afterHandle)
    a.afterHandle = fnToContainer(a.afterHandle);
  if (a.mapResponse)
    a.mapResponse = fnToContainer(a.mapResponse);
  if (a.afterResponse)
    a.afterResponse = fnToContainer(a.afterResponse);
  if (a.trace)
    a.trace = fnToContainer(a.trace);
  if (a.error)
    a.error = fnToContainer(a.error);
  if (a.stop)
    a.stop = fnToContainer(a.stop);
  return a;
};
var lifeCycleToFn = (a) => {
  let lifecycle = Object.create(null);
  if (a.start?.map)
    lifecycle.start = a.start.map((x2) => x2.fn);
  if (a.request?.map)
    lifecycle.request = a.request.map((x2) => x2.fn);
  if (a.parse?.map)
    lifecycle.parse = a.parse.map((x2) => x2.fn);
  if (a.transform?.map)
    lifecycle.transform = a.transform.map((x2) => x2.fn);
  if (a.beforeHandle?.map)
    lifecycle.beforeHandle = a.beforeHandle.map((x2) => x2.fn);
  if (a.afterHandle?.map)
    lifecycle.afterHandle = a.afterHandle.map((x2) => x2.fn);
  if (a.mapResponse?.map)
    lifecycle.mapResponse = a.mapResponse.map((x2) => x2.fn);
  if (a.afterResponse?.map)
    lifecycle.afterResponse = a.afterResponse.map((x2) => x2.fn);
  if (a.error?.map)
    lifecycle.error = a.error.map((x2) => x2.fn);
  if (a.stop?.map)
    lifecycle.stop = a.stop.map((x2) => x2.fn);
  if (a.trace?.map)
    lifecycle.trace = a.trace.map((x2) => x2.fn);
  else
    lifecycle.trace = [];
  return lifecycle;
};
var cloneInference = (inference) => ({ body: inference.body, cookie: inference.cookie, headers: inference.headers, query: inference.query, set: inference.set, server: inference.server, path: inference.path, route: inference.route, url: inference.url });
var redirect = (url, status = 302) => Response.redirect(url, status);
var ELYSIA_FORM_DATA = Symbol("ElysiaFormData");
var ELYSIA_REQUEST_ID = Symbol("ElysiaRequestId");
var form = (items) => {
  let formData = new FormData;
  if (formData[ELYSIA_FORM_DATA] = {}, items)
    for (let [key, value] of Object.entries(items)) {
      if (Array.isArray(value)) {
        formData[ELYSIA_FORM_DATA][key] = [];
        for (let v of value) {
          if (value instanceof File)
            formData.append(key, value, value.name);
          else if (value instanceof ElysiaFile)
            formData.append(key, value.value, value.value?.name);
          else
            formData.append(key, value);
          formData[ELYSIA_FORM_DATA][key].push(value);
        }
        continue;
      }
      if (value instanceof File)
        formData.append(key, value, value.name);
      else if (value instanceof ElysiaFile)
        formData.append(key, value.value, value.value?.name);
      else
        formData.append(key, value);
      formData[ELYSIA_FORM_DATA][key] = value;
    }
  return formData;
};
var randomId = typeof crypto > "u" ? () => {
  let result = "", characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", charactersLength = characters.length;
  for (let i2 = 0;i2 < 16; i2++)
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  return result;
} : () => {
  let uuid = crypto.randomUUID();
  return uuid.slice(0, 8) + uuid.slice(24, 32);
};
var deduplicateChecksum = (array) => {
  if (!array.length)
    return [];
  let hashes = [];
  for (let i2 = 0;i2 < array.length; i2++) {
    let item = array[i2];
    if (item.checksum) {
      if (hashes.includes(item.checksum))
        array.splice(i2, 1), i2--;
      hashes.push(item.checksum);
    }
  }
  return array;
};
var promoteEvent = (events, as = "scoped") => {
  if (!events)
    return;
  if (as === "scoped") {
    for (let event of events)
      if ("scope" in event && event.scope === "local")
        event.scope = "scoped";
    return;
  }
  for (let event of events)
    if ("scope" in event)
      event.scope = "global";
};
var getLoosePath = (path) => {
  if (path.charCodeAt(path.length - 1) === 47)
    return path.slice(0, path.length - 1);
  return path + "/";
};
var isNotEmpty = (obj) => {
  if (!obj)
    return false;
  for (let _2 in obj)
    return true;
  return false;
};
var encodePath = (path, { dynamic = false } = {}) => {
  let encoded = encodeURIComponent(path).replace(/%2F/g, "/");
  if (dynamic)
    encoded = encoded.replace(/%3A/g, ":").replace(/%3F/g, "?");
  return encoded;
};
var supportPerMethodInlineHandler = (() => {
  if (typeof Bun > "u")
    return true;
  if (Bun.semver?.satisfies?.(Bun.version, ">=1.2.14"))
    return true;
  return false;
})();
async function getResponseLength(response) {
  if (response.bodyUsed || !response.body)
    return 0;
  let length = 0, reader = response.body.getReader();
  while (true) {
    let { done, value } = await reader.read();
    if (done)
      break;
    length += value.byteLength;
  }
  return length;
}
var emptySchema = { headers: true, cookie: true, query: true, params: true, body: true, response: true };
var env = typeof Bun < "u" ? Bun.env : typeof process < "u" ? process?.env : undefined;
var ERROR_CODE = Symbol("ElysiaErrorCode");
var isProduction = (env?.NODE_ENV ?? env?.ENV) === "production";
var emptyHttpStatus = { 101: undefined, 204: undefined, 205: undefined, 304: undefined, 307: undefined, 308: undefined };

class ElysiaCustomStatusResponse {
  code;
  response;
  constructor(code, response) {
    let res = response ?? (code in InvertedStatusMap ? InvertedStatusMap[code] : code);
    if (this.code = StatusMap[code] ?? code, code in emptyHttpStatus)
      this.response = undefined;
    else
      this.response = res;
  }
}
var status = (code, response) => new ElysiaCustomStatusResponse(code, response);
class NotFoundError extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor(message) {
    super(message ?? "NOT_FOUND");
  }
}

class ParseError2 extends Error {
  code = "PARSE";
  status = 400;
  constructor(cause) {
    super("Bad Request", { cause });
  }
}

class InvalidCookieSignature extends Error {
  key;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor(key, message) {
    super(message ?? `"${key}" has invalid cookie signature`);
    this.key = key;
  }
}
var mapValueError = (error) => {
  if (!error)
    return { summary: undefined };
  let { message, path, value, type } = error, property = path.slice(1).replaceAll("/", "."), isRoot = path === "";
  switch (type) {
    case 42:
      return { ...error, summary: isRoot ? "Value should not be provided" : `Property '${property}' should not be provided` };
    case 45:
      return { ...error, summary: isRoot ? "Value is missing" : `Property '${property}' is missing` };
    case 50:
      let quoteIndex = message.indexOf("'"), format = message.slice(quoteIndex + 1, message.indexOf("'", quoteIndex + 1));
      return { ...error, summary: isRoot ? "Value should be an email" : `Property '${property}' should be ${format}` };
    case 54:
      return { ...error, summary: `${message.slice(0, 9).trim()} property '${property}' to be ${message.slice(8).trim()} but found: ${value}` };
    case 62:
      let union = error.schema.anyOf.map((x2) => `'${x2?.format ?? x2.type}'`).join(", ");
      return { ...error, summary: isRoot ? `Value should be one of ${union}` : `Property '${property}' should be one of: ${union}` };
    default:
      return { summary: message, ...error };
  }
};

class InvalidFileType extends Error {
  property;
  expected;
  message;
  code = "INVALID_FILE_TYPE";
  status = 422;
  constructor(property, expected, message = `"${property}" has invalid file type`) {
    super(message);
    this.property = property;
    this.expected = expected;
    this.message = message;
    Object.setPrototypeOf(this, InvalidFileType.prototype);
  }
  toResponse(headers) {
    if (isProduction)
      return new Response(JSON.stringify({ type: "validation", on: "body" }), { status: 422, headers: { ...headers, "content-type": "application/json" } });
    return new Response(JSON.stringify({ type: "validation", on: "body", summary: "Invalid file type", message: this.message, property: this.property, expected: this.expected }), { status: 422, headers: { ...headers, "content-type": "application/json" } });
  }
}

class ValidationError extends Error {
  type;
  validator;
  value;
  allowUnsafeValidationDetails;
  code = "VALIDATION";
  status = 422;
  valueError;
  expected;
  customError;
  constructor(type, validator, value, allowUnsafeValidationDetails = false, errors) {
    let message = "", error, expected, customError;
    if (validator?.provider === "standard" || "~standard" in validator || validator.schema && "~standard" in validator.schema) {
      let standard = ("~standard" in validator ? validator : validator.schema)["~standard"];
      if (error = (errors ?? standard.validate(value).issues)?.[0], isProduction)
        message = JSON.stringify({ type: "validation", on: type, found: value });
      else
        message = JSON.stringify({ type: "validation", on: type, property: error.path?.[0] || "root", message: error?.message, summary: error?.problem, expected, found: value, errors }, null, 2);
      customError = error?.message;
    } else {
      if (value && typeof value === "object" && value instanceof ElysiaCustomStatusResponse)
        value = value.response;
      error = errors?.First() ?? ("Errors" in validator ? validator.Errors(value).First() : exports_value2.Errors(validator, value).First());
      let accessor = error?.path || "root", schema = validator?.schema ?? validator;
      if (!isProduction && !allowUnsafeValidationDetails)
        try {
          expected = exports_value2.Create(schema);
        } catch (error2) {
          expected = { type: "Could not create expected value", message: error2?.message, error: error2 };
        }
      if (customError = error?.schema?.message || error?.schema?.error !== undefined ? typeof error.schema.error === "function" ? error.schema.error(isProduction && !allowUnsafeValidationDetails ? { type: "validation", on: type, found: value } : { type: "validation", on: type, value, property: accessor, message: error?.message, summary: mapValueError(error).summary, found: value, expected, errors: "Errors" in validator ? [...validator.Errors(value)].map(mapValueError) : [...exports_value2.Errors(validator, value)].map(mapValueError) }, validator) : error.schema.error : undefined, customError !== undefined)
        message = typeof customError === "object" ? JSON.stringify(customError) : customError + "";
      else if (isProduction && !allowUnsafeValidationDetails)
        message = JSON.stringify({ type: "validation", on: type, found: value });
      else
        message = JSON.stringify({ type: "validation", on: type, property: accessor, message: error?.message, summary: mapValueError(error).summary, expected, found: value, errors: "Errors" in validator ? [...validator.Errors(value)].map(mapValueError) : [...exports_value2.Errors(validator, value)].map(mapValueError) }, null, 2);
    }
    super(message);
    this.type = type;
    this.validator = validator;
    this.value = value;
    this.allowUnsafeValidationDetails = allowUnsafeValidationDetails;
    this.valueError = error, this.expected = expected, this.customError = customError, Object.setPrototypeOf(this, ValidationError.prototype);
  }
  get all() {
    if (this.validator?.provider === "standard" || "~standard" in this.validator || "schema" in this.validator && this.validator.schema && "~standard" in this.validator.schema)
      return ("~standard" in this.validator ? this.validator : this.validator.schema)["~standard"].validate(this.value).issues?.map((issue) => ({ summary: issue.message, path: issue.path?.join(".") || "root", message: issue.message, value: this.value })) || [];
    return "Errors" in this.validator ? [...this.validator.Errors(this.value)].map(mapValueError) : [...exports_value2.Errors(this.validator, this.value)].map(mapValueError);
  }
  static simplifyModel(validator) {
    let model = "schema" in validator ? validator.schema : validator;
    try {
      return exports_value2.Create(model);
    } catch {
      return model;
    }
  }
  get model() {
    if ("~standard" in this.validator)
      return this.validator;
    return ValidationError.simplifyModel(this.validator);
  }
  toResponse(headers) {
    return new Response(this.message, { status: 400, headers: { ...headers, "content-type": "application/json" } });
  }
  detail(message) {
    if (!this.customError)
      return this.message;
    let validator = this.validator, value = this.value, expected = this.expected, errors = this.all;
    return isProduction && !this.allowUnsafeValidationDetails ? { type: "validation", on: this.type, found: value, message } : { type: "validation", on: this.type, property: this.valueError?.path || "root", message, summary: mapValueError(this.valueError).summary, found: value, expected, errors };
  }
}
var tryParse = (v, schema) => {
  try {
    return JSON.parse(v);
  } catch {
    throw new ValidationError("property", schema, v);
  }
};
function createType(kind, func) {
  if (!exports_type2.Has(kind))
    exports_type2.Set(kind, func);
  return (options = {}) => Unsafe({ ...options, [Kind]: kind });
}
var compile = (schema) => {
  try {
    let compiler = TypeCompiler.Compile(schema);
    return compiler.Create = () => exports_value2.Create(schema), compiler.Error = (v) => new ValidationError("property", schema, v, compiler.Errors(v)), compiler;
  } catch {
    return { Check: (v) => exports_value2.Check(schema, v), CheckThrow: (v) => {
      if (!exports_value2.Check(schema, v))
        throw new ValidationError("property", schema, v, exports_value2.Errors(schema, v));
    }, Decode: (v) => exports_value2.Decode(schema, v), Create: () => exports_value2.Create(schema), Error: (v) => new ValidationError("property", schema, v, exports_value2.Errors(schema, v)) };
  }
};
var parseFileUnit = (size) => {
  if (typeof size === "string")
    switch (size.slice(-1)) {
      case "k":
        return +size.slice(0, size.length - 1) * 1024;
      case "m":
        return +size.slice(0, size.length - 1) * 1048576;
      default:
        return +size;
    }
  return size;
};
var checkFileExtension = (type, extension) => {
  if (type.startsWith(extension))
    return true;
  return extension.charCodeAt(extension.length - 1) === 42 && extension.charCodeAt(extension.length - 2) === 47 && type.startsWith(extension.slice(0, -1));
};
var _fileTypeFromBlobWarn = false;
var warnIfFileTypeIsNotInstalled = () => {
  if (!_fileTypeFromBlobWarn)
    console.warn("[Elysia] Attempt to validate file type without 'file-type'. This may lead to security risks. We recommend installing 'file-type' to properly validate file extension."), _fileTypeFromBlobWarn = true;
};
var loadFileType = async () => Promise.resolve().then(() => (init_file_type(), exports_file_type)).then((x2) => {
  return _fileTypeFromBlob = x2.fileTypeFromBlob, _fileTypeFromBlob;
}).catch(warnIfFileTypeIsNotInstalled);
var _fileTypeFromBlob;
var fileTypeFromBlob2 = (file2) => {
  if (_fileTypeFromBlob)
    return _fileTypeFromBlob(file2);
  return loadFileType().then((mod) => {
    if (mod)
      return mod(file2);
  });
};
var fileType = async (file2, extension, name = file2?.name ?? "") => {
  if (Array.isArray(file2))
    return await Promise.all(file2.map((f) => fileType(f, extension, name))), true;
  if (!file2)
    return false;
  let result = await fileTypeFromBlob2(file2);
  if (!result)
    throw new InvalidFileType(name, extension);
  if (typeof extension === "string") {
    if (!checkFileExtension(result.mime, extension))
      throw new InvalidFileType(name, extension);
  }
  for (let i2 = 0;i2 < extension.length; i2++)
    if (checkFileExtension(result.mime, extension[i2]))
      return true;
  throw new InvalidFileType(name, extension);
};
var validateFile = (options, value) => {
  if (value instanceof ElysiaFile)
    return true;
  if (!(value instanceof Blob))
    return false;
  if (options.minSize && value.size < parseFileUnit(options.minSize))
    return false;
  if (options.maxSize && value.size > parseFileUnit(options.maxSize))
    return false;
  if (options.extension) {
    if (typeof options.extension === "string")
      return checkFileExtension(value.type, options.extension);
    for (let i2 = 0;i2 < options.extension.length; i2++)
      if (checkFileExtension(value.type, options.extension[i2]))
        return true;
    return false;
  }
  return true;
};
var fullFormats = { date, time: getTime(true), "date-time": getDateTime(true), "iso-time": getTime(false), "iso-date-time": getDateTime(false), duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/, uri, "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu, email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i, hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/, ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, regex, uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/, "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, byte, int32: { type: "number", validate: validateInt32 }, int64: { type: "number", validate: validateInt64 }, float: { type: "number", validate: validateNumber }, double: { type: "number", validate: validateNumber }, password: true, binary: true };
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function date(str) {
  let matches = DATE.exec(str);
  if (!matches)
    return false;
  let year = +matches[1], month = +matches[2], day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
}
var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
function getTime(strictTimeZone) {
  return function(str) {
    let matches = TIME.exec(str);
    if (!matches)
      return false;
    let hr = +matches[1], min = +matches[2], sec = +matches[3], tz = matches[4], tzSign = matches[5] === "-" ? -1 : 1, tzH = +(matches[6] || 0), tzM = +(matches[7] || 0);
    if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
      return false;
    if (hr <= 23 && min <= 59 && sec < 60)
      return true;
    let utcMin = min - tzM * tzSign, utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
    return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
  };
}
var parseDateTimeEmptySpace = (str) => {
  if (str.charCodeAt(str.length - 6) === 32)
    return str.slice(0, -6) + "+" + str.slice(-5);
  return str;
};
var DATE_TIME_SEPARATOR = /t|\s/i;
function getDateTime(strictTimeZone) {
  let time = getTime(strictTimeZone);
  return function(str) {
    let dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
  };
}
var NOT_URI_FRAGMENT = /\/|:/;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function uri(str) {
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
function byte(str) {
  return BYTE.lastIndex = 0, BYTE.test(str);
}
var MIN_INT32 = -2147483648;
var MAX_INT32 = 2147483647;
function validateInt32(value) {
  return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
}
function validateInt64(value) {
  return Number.isInteger(value);
}
function validateNumber() {
  return true;
}
var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str))
    return false;
  try {
    return new RegExp(str), true;
  } catch (e) {
    return false;
  }
}
var isISO8601 = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
var isFormalDate = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/;
var isShortenDate = /^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/;
var _validateDate = fullFormats.date;
var _validateDateTime = fullFormats["date-time"];
if (!exports_format.Has("date"))
  exports_format.Set("date", (value) => {
    let temp = parseDateTimeEmptySpace(value).replace(/"/g, "");
    if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDate(temp)) {
      let date2 = new Date(temp);
      if (!Number.isNaN(date2.getTime()))
        return true;
    }
    return false;
  });
if (!exports_format.Has("date-time"))
  exports_format.Set("date-time", (value) => {
    let temp = value.replace(/"/g, "");
    if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDateTime(temp)) {
      let date2 = new Date(temp);
      if (!Number.isNaN(date2.getTime()))
        return true;
    }
    return false;
  });
Object.entries(fullFormats).forEach((formatEntry) => {
  let [formatName, formatValue] = formatEntry;
  if (!exports_format.Has(formatName)) {
    if (formatValue instanceof RegExp)
      exports_format.Set(formatName, (value) => formatValue.test(value));
    else if (typeof formatValue === "function")
      exports_format.Set(formatName, formatValue);
  }
});
if (!exports_format.Has("numeric"))
  exports_format.Set("numeric", (value) => !!value && !isNaN(+value));
if (!exports_format.Has("integer"))
  exports_format.Set("integer", (value) => !!value && Number.isInteger(+value));
if (!exports_format.Has("boolean"))
  exports_format.Set("boolean", (value) => value === "true" || value === "false");
if (!exports_format.Has("ObjectString"))
  exports_format.Set("ObjectString", (value) => {
    let start = value.charCodeAt(0);
    if (start === 9 || start === 10 || start === 32)
      start = value.trimStart().charCodeAt(0);
    if (start !== 123 && start !== 91)
      return false;
    try {
      return JSON.parse(value), true;
    } catch {
      return false;
    }
  });
if (!exports_format.Has("ArrayString"))
  exports_format.Set("ArrayString", (value) => {
    let start = value.charCodeAt(0);
    if (start === 9 || start === 10 || start === 32)
      start = value.trimStart().charCodeAt(0);
    if (start !== 123 && start !== 91)
      return false;
    try {
      return JSON.parse(value), true;
    } catch {
      return false;
    }
  });
var t = Object.assign({}, Type);
createType("UnionEnum", (schema, value) => (typeof value === "number" || typeof value === "string" || value === null) && schema.enum.includes(value));
createType("ArrayBuffer", (schema, value) => value instanceof ArrayBuffer);
var internalFiles = createType("Files", (options, value) => {
  if (options.minItems && options.minItems > 1 && !Array.isArray(value))
    return false;
  if (!Array.isArray(value))
    return validateFile(options, value);
  if (options.minItems && value.length < options.minItems)
    return false;
  if (options.maxItems && value.length > options.maxItems)
    return false;
  for (let i2 = 0;i2 < value.length; i2++)
    if (!validateFile(options, value[i2]))
      return false;
  return true;
});
var internalFormData = createType("ElysiaForm", ({ compiler, ...schema }, value) => {
  if (!(value instanceof FormData))
    return false;
  if (compiler) {
    if (!(ELYSIA_FORM_DATA in value))
      throw new ValidationError("property", schema, value);
    if (!compiler.Check(value[ELYSIA_FORM_DATA]))
      throw compiler.Error(value[ELYSIA_FORM_DATA]);
  }
  return true;
});
var ElysiaType = { String: (property) => Type.String(property), Numeric: (property) => {
  let schema = Type.Number(property), compiler = compile(schema);
  return t.Transform(t.Union([t.String({ format: "numeric", default: 0 }), t.Number(property)], property)).Decode((value) => {
    let number = +value;
    if (isNaN(number))
      return value;
    if (property && !compiler.Check(number))
      throw compiler.Error(number);
    return number;
  }).Encode((value) => value);
}, Integer: (property) => {
  let schema = Type.Integer(property), compiler = compile(schema);
  return t.Transform(t.Union([t.String({ format: "integer", default: 0 }), Type.Integer(property)], property)).Decode((value) => {
    let number = +value;
    if (!compiler.Check(number))
      throw compiler.Error(number);
    return number;
  }).Encode((value) => value);
}, Date: (property) => {
  let schema = Type.Date(property), compiler = compile(schema), _default = property?.default ? new Date(property.default) : undefined;
  return t.Transform(t.Union([Type.Date(property), t.String({ format: "date-time", default: _default?.toISOString() }), t.String({ format: "date", default: _default?.toISOString() }), t.Number({ default: _default?.getTime() })], property)).Decode((value) => {
    if (typeof value === "number") {
      let date3 = new Date(value);
      if (!compiler.Check(date3))
        throw compiler.Error(date3);
      return date3;
    }
    if (value instanceof Date)
      return value;
    let date2 = new Date(parseDateTimeEmptySpace(value));
    if (!date2 || isNaN(date2.getTime()))
      throw new ValidationError("property", schema, date2);
    if (!compiler.Check(date2))
      throw compiler.Error(date2);
    return date2;
  }).Encode((value) => {
    if (value instanceof Date)
      return value.toISOString();
    if (typeof value === "string") {
      if (isNaN(new Date(parseDateTimeEmptySpace(value)).getTime()))
        throw new ValidationError("property", schema, value);
      return value;
    }
    if (!compiler.Check(value))
      throw compiler.Error(value);
    return value;
  });
}, BooleanString: (property) => {
  let schema = Type.Boolean(property), compiler = compile(schema);
  return t.Transform(t.Union([t.Boolean(property), t.String({ format: "boolean", default: false })], property)).Decode((value) => {
    if (typeof value === "string")
      return value === "true";
    if (value !== undefined && !compiler.Check(value))
      throw compiler.Error(value);
    return value;
  }).Encode((value) => value);
}, ObjectString: (properties, options) => {
  let schema = t.Object(properties, options), compiler = compile(schema);
  return t.Transform(t.Union([t.String({ format: "ObjectString", default: "{}" }), schema], { elysiaMeta: "ObjectString" })).Decode((value) => {
    if (typeof value === "string") {
      if (value.charCodeAt(0) !== 123)
        throw new ValidationError("property", schema, value);
      if (!compiler.Check(value = tryParse(value, schema)))
        throw compiler.Error(value);
      return compiler.Decode(value);
    }
    return value;
  }).Encode((value) => {
    let original;
    if (typeof value === "string")
      value = tryParse(original = value, schema);
    if (!compiler.Check(value))
      throw compiler.Error(value);
    return original ?? JSON.stringify(value);
  });
}, ArrayString: (children = t.String(), options) => {
  let schema = t.Array(children, options), compiler = compile(schema), decode2 = (value, isProperty = false) => {
    if (value.charCodeAt(0) === 91) {
      if (!compiler.Check(value = tryParse(value, schema)))
        throw compiler.Error(value);
      return compiler.Decode(value);
    }
    if (isProperty)
      return value;
    throw new ValidationError("property", schema, value);
  };
  return t.Transform(t.Union([t.String({ format: "ArrayString", default: options?.default }), schema])).Decode((value) => {
    if (Array.isArray(value)) {
      let values = [];
      for (let i2 = 0;i2 < value.length; i2++) {
        let v = value[i2];
        if (typeof v === "string") {
          let t2 = decode2(v, true);
          if (Array.isArray(t2))
            values = values.concat(t2);
          else
            values.push(t2);
          continue;
        }
        values.push(v);
      }
      return values;
    }
    if (typeof value === "string")
      return decode2(value);
    return value;
  }).Encode((value) => {
    let original;
    if (typeof value === "string")
      value = tryParse(original = value, schema);
    if (!compiler.Check(value))
      throw new ValidationError("property", schema, value);
    return original ?? JSON.stringify(value);
  });
}, ArrayQuery: (children = t.String(), options) => {
  let schema = t.Array(children, options), compiler = compile(schema), decode2 = (value) => {
    if (value.indexOf(",") !== -1)
      return compiler.Decode(value.split(","));
    return [value];
  };
  return t.Transform(t.Union([t.String({ default: options?.default }), schema], { elysiaMeta: "ArrayQuery" })).Decode((value) => {
    if (Array.isArray(value)) {
      let values = [];
      for (let i2 = 0;i2 < value.length; i2++) {
        let v = value[i2];
        if (typeof v === "string") {
          let t2 = decode2(v);
          if (Array.isArray(t2))
            values = values.concat(t2);
          else
            values.push(t2);
          continue;
        }
        values.push(v);
      }
      return values;
    }
    if (typeof value === "string")
      return decode2(value);
    return value;
  }).Encode((value) => {
    let original;
    if (typeof value === "string")
      value = tryParse(original = value, schema);
    if (!compiler.Check(value))
      throw new ValidationError("property", schema, value);
    return original ?? JSON.stringify(value);
  });
}, File: createType("File", validateFile), Files: (options = {}) => t.Transform(internalFiles(options)).Decode((value) => {
  if (Array.isArray(value))
    return value;
  return [value];
}).Encode((value) => value), Nullable: (schema, options) => t.Union([schema, t.Null()], { ...options, nullable: true }), MaybeEmpty: (schema, options) => t.Union([schema, t.Null(), t.Undefined()], options), Cookie: (properties, { domain, expires, httpOnly, maxAge, path, priority, sameSite, secure, secrets, sign, ...options } = {}) => {
  let v = t.Object(properties, options);
  return v.config = { domain, expires, httpOnly, maxAge, path, priority, sameSite, secure, secrets, sign }, v;
}, UnionEnum: (values, options = {}) => {
  let type = values.every((value) => typeof value === "string") ? { type: "string" } : values.every((value) => typeof value === "number") ? { type: "number" } : values.every((value) => value === null) ? { type: "null" } : {};
  if (values.some((x2) => typeof x2 === "object" && x2 !== null))
    throw Error("This type does not support objects or arrays");
  return { default: values[0], ...options, [Kind]: "UnionEnum", ...type, enum: values };
}, NoValidate: (v, enabled = true) => {
  return v.noValidate = enabled, v;
}, Form: (v, options = {}) => {
  let schema = t.Object(v, { default: form({}), ...options }), compiler = compile(schema);
  return t.Union([schema, internalFormData({ compiler })]);
}, ArrayBuffer(options = {}) {
  return { default: [1, 2, 3], ...options, [Kind]: "ArrayBuffer" };
}, Uint8Array: (options) => {
  let schema = Type.Uint8Array(options), compiler = compile(schema);
  return t.Transform(t.Union([t.ArrayBuffer(), Type.Uint8Array(options)])).Decode((value) => {
    if (value instanceof ArrayBuffer) {
      if (!compiler.Check(value = new Uint8Array(value)))
        throw compiler.Error(value);
      return value;
    }
    return value;
  }).Encode((value) => value);
} };
t.BooleanString = ElysiaType.BooleanString;
t.ObjectString = ElysiaType.ObjectString;
t.ArrayString = ElysiaType.ArrayString;
t.ArrayQuery = ElysiaType.ArrayQuery;
t.Numeric = ElysiaType.Numeric;
t.Integer = ElysiaType.Integer;
t.File = (arg) => {
  if (arg?.type)
    loadFileType();
  return ElysiaType.File({ default: "File", ...arg, extension: arg?.type, type: "string", format: "binary" });
};
t.Files = (arg) => {
  if (arg?.type)
    loadFileType();
  return ElysiaType.Files({ ...arg, elysiaMeta: "Files", default: "Files", extension: arg?.type, type: "array", items: { ...arg, default: "Files", type: "string", format: "binary" } });
};
t.Nullable = ElysiaType.Nullable;
t.MaybeEmpty = ElysiaType.MaybeEmpty;
t.Cookie = ElysiaType.Cookie;
t.Date = ElysiaType.Date;
t.UnionEnum = ElysiaType.UnionEnum;
t.NoValidate = ElysiaType.NoValidate;
t.Form = ElysiaType.Form;
t.ArrayBuffer = ElysiaType.ArrayBuffer;
t.Uint8Array = ElysiaType.Uint8Array;
var import_cookie = __toESM2(require_dist(), 1);
var import_fast_decode_uri_component = __toESM2(require_fast_decode_uri_component(), 1);

class Cookie {
  name;
  jar;
  initial;
  constructor(name, jar, initial = {}) {
    this.name = name;
    this.jar = jar;
    this.initial = initial;
  }
  get cookie() {
    return this.jar[this.name] ?? this.initial;
  }
  set cookie(jar) {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    this.jar[this.name] = jar;
  }
  get setCookie() {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    return this.jar[this.name];
  }
  set setCookie(jar) {
    this.cookie = jar;
  }
  get value() {
    return this.cookie.value;
  }
  set value(value) {
    this.setCookie.value = value;
  }
  get expires() {
    return this.cookie.expires;
  }
  set expires(expires) {
    this.setCookie.expires = expires;
  }
  get maxAge() {
    return this.cookie.maxAge;
  }
  set maxAge(maxAge) {
    this.setCookie.maxAge = maxAge;
  }
  get domain() {
    return this.cookie.domain;
  }
  set domain(domain) {
    this.setCookie.domain = domain;
  }
  get path() {
    return this.cookie.path;
  }
  set path(path) {
    this.setCookie.path = path;
  }
  get secure() {
    return this.cookie.secure;
  }
  set secure(secure) {
    this.setCookie.secure = secure;
  }
  get httpOnly() {
    return this.cookie.httpOnly;
  }
  set httpOnly(httpOnly) {
    this.setCookie.httpOnly = httpOnly;
  }
  get sameSite() {
    return this.cookie.sameSite;
  }
  set sameSite(sameSite) {
    this.setCookie.sameSite = sameSite;
  }
  get priority() {
    return this.cookie.priority;
  }
  set priority(priority) {
    this.setCookie.priority = priority;
  }
  get partitioned() {
    return this.cookie.partitioned;
  }
  set partitioned(partitioned) {
    this.setCookie.partitioned = partitioned;
  }
  get secrets() {
    return this.cookie.secrets;
  }
  set secrets(secrets) {
    this.setCookie.secrets = secrets;
  }
  update(config) {
    return this.setCookie = Object.assign(this.cookie, typeof config === "function" ? config(this.cookie) : config), this;
  }
  set(config) {
    return this.setCookie = Object.assign({ ...this.initial, value: this.value }, typeof config === "function" ? config(this.cookie) : config), this;
  }
  remove() {
    if (this.value === undefined)
      return;
    return this.set({ expires: new Date(0), maxAge: 0, value: "" }), this;
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
}
var createCookieJar = (set2, store, initial) => {
  if (!set2.cookie)
    set2.cookie = {};
  return new Proxy(store, { get(_2, key) {
    if (key in store)
      return new Cookie(key, set2.cookie, Object.assign({}, initial ?? {}, store[key]));
    return new Cookie(key, set2.cookie, Object.assign({}, initial));
  } });
};
var parseCookie = async (set2, cookieString, { secrets, sign, ...initial } = {}) => {
  if (!cookieString)
    return createCookieJar(set2, {}, initial);
  let isStringKey = typeof secrets === "string";
  if (sign && sign !== true && !Array.isArray(sign))
    sign = [sign];
  let jar = {}, cookies = import_cookie.parse(cookieString);
  for (let [name, v] of Object.entries(cookies)) {
    if (v === undefined)
      continue;
    let value = import_fast_decode_uri_component.default(v);
    if (value) {
      let starts = value.charCodeAt(0), ends = value.charCodeAt(value.length - 1);
      if (starts === 123 && ends === 125 || starts === 91 && ends === 93)
        try {
          value = JSON.parse(value);
        } catch {}
    }
    if (sign === true || sign?.includes(name)) {
      if (!secrets)
        throw Error("No secret is provided to cookie plugin");
      if (isStringKey) {
        let temp = await unsignCookie(value, secrets);
        if (temp === false)
          throw new InvalidCookieSignature(name);
        value = temp;
      } else {
        let decoded = true;
        for (let i2 = 0;i2 < secrets.length; i2++) {
          let temp = await unsignCookie(value, secrets[i2]);
          if (temp !== false) {
            decoded = true, value = temp;
            break;
          }
        }
        if (!decoded)
          throw new InvalidCookieSignature(name);
      }
    }
    jar[name] = { value };
  }
  return createCookieJar(set2, jar, initial);
};
var serializeCookie = (cookies) => {
  if (!cookies || !isNotEmpty(cookies))
    return;
  let set2 = [];
  for (let [key, property] of Object.entries(cookies)) {
    if (!key || !property)
      continue;
    let value = property.value;
    if (value === undefined || value === null)
      continue;
    set2.push(import_cookie.serialize(key, typeof value === "object" ? JSON.stringify(value) : value + "", property));
  }
  if (set2.length === 0)
    return;
  if (set2.length === 1)
    return set2[0];
  return set2;
};
var env2 = isBun ? Bun.env : typeof process < "u" && process?.env ? process.env : {};
var handleFile = (response, set2) => {
  if (!isBun && response instanceof Promise)
    return response.then((res) => handleFile(res, set2));
  let size = response.size, immutable = set2 && (set2.status === 206 || set2.status === 304 || set2.status === 412 || set2.status === 416), defaultHeader = immutable ? {} : { "accept-ranges": "bytes", "content-range": size ? `bytes 0-${size - 1}/${size}` : undefined };
  if (!set2 && !size)
    return new Response(response);
  if (!set2)
    return new Response(response, { headers: defaultHeader });
  if (set2.headers instanceof Headers) {
    for (let key of Object.keys(defaultHeader))
      if (key in set2.headers)
        set2.headers.append(key, defaultHeader[key]);
    if (immutable)
      set2.headers.delete("content-length"), set2.headers.delete("accept-ranges");
    return new Response(response, set2);
  }
  if (isNotEmpty(set2.headers))
    return new Response(response, { status: set2.status, headers: Object.assign(defaultHeader, set2.headers) });
  return new Response(response, { status: set2.status, headers: defaultHeader });
};
var parseSetCookies = (headers, setCookie) => {
  if (!headers)
    return headers;
  headers.delete("set-cookie");
  for (let i2 = 0;i2 < setCookie.length; i2++) {
    let index = setCookie[i2].indexOf("=");
    headers.append("set-cookie", `${setCookie[i2].slice(0, index)}=${setCookie[i2].slice(index + 1) || ""}`);
  }
  return headers;
};
var responseToSetHeaders = (response, set2) => {
  if (set2?.headers) {
    if (response) {
      if (hasHeaderShorthand)
        Object.assign(set2.headers, response.headers.toJSON());
      else
        for (let [key, value] of response.headers.entries())
          if (key in set2.headers)
            set2.headers[key] = value;
    }
    if (set2.status === 200)
      set2.status = response.status;
    if (set2.headers["content-encoding"])
      delete set2.headers["content-encoding"];
    return set2;
  }
  if (!response)
    return { headers: {}, status: set2?.status ?? 200 };
  if (hasHeaderShorthand) {
    if (set2 = { headers: response.headers.toJSON(), status: set2?.status ?? 200 }, set2.headers["content-encoding"])
      delete set2.headers["content-encoding"];
    return set2;
  }
  set2 = { headers: {}, status: set2?.status ?? 200 };
  for (let [key, value] of response.headers.entries()) {
    if (key === "content-encoding")
      continue;
    if (key in set2.headers)
      set2.headers[key] = value;
  }
  return set2;
};
var allowRapidStream = env2.ELYSIA_RAPID_STREAM === "true";
var createStreamHandler = ({ mapResponse, mapCompactResponse }) => async (generator, set2, request) => {
  let init = generator.next?.();
  if (set2)
    handleSet(set2);
  if (init instanceof Promise)
    init = await init;
  if (init?.value instanceof ReadableStream)
    generator = init.value;
  else if (init && (typeof init?.done > "u" || init?.done)) {
    if (set2)
      return mapResponse(init.value, set2, request);
    return mapCompactResponse(init.value, request);
  }
  let isSSE = init?.value?.sse ?? generator?.sse ?? set2?.headers["content-type"]?.startsWith("text/event-stream"), format = isSSE ? (data) => `data: ${data}

` : (data) => data, contentType = isSSE ? "text/event-stream" : init?.value && typeof init?.value === "object" ? "application/json" : "text/plain";
  if (set2?.headers) {
    if (!set2.headers["transfer-encoding"])
      set2.headers["transfer-encoding"] = "chunked";
    if (!set2.headers["content-type"])
      set2.headers["content-type"] = contentType;
    if (!set2.headers["cache-control"])
      set2.headers["cache-control"] = "no-cache";
  } else
    set2 = { status: 200, headers: { "content-type": contentType, "transfer-encoding": "chunked", "cache-control": "no-cache", connection: "keep-alive" } };
  let isBrowser = request?.headers.has("Origin");
  return new Response(new ReadableStream({ async start(controller) {
    let end = false;
    if (request?.signal?.addEventListener("abort", () => {
      end = true;
      try {
        controller.close();
      } catch {}
    }), !init || init.value instanceof ReadableStream)
      ;
    else if (init.value !== undefined && init.value !== null)
      if (init.value.toSSE)
        controller.enqueue(init.value.toSSE());
      else if (typeof init.value === "object")
        try {
          controller.enqueue(format(JSON.stringify(init.value)));
        } catch {
          controller.enqueue(format(init.value.toString()));
        }
      else
        controller.enqueue(format(init.value.toString()));
    try {
      for await (let chunk of generator) {
        if (end)
          break;
        if (chunk === undefined || chunk === null)
          continue;
        if (chunk.toSSE)
          controller.enqueue(chunk.toSSE());
        else {
          if (typeof chunk === "object")
            try {
              controller.enqueue(format(JSON.stringify(chunk)));
            } catch {
              controller.enqueue(format(chunk.toString()));
            }
          else
            controller.enqueue(format(chunk.toString()));
          if (!allowRapidStream && isBrowser && !isSSE)
            await new Promise((resolve) => setTimeout(() => resolve(), 0));
        }
      }
    } catch (error) {
      console.warn(error);
    }
    try {
      controller.close();
    } catch {}
  } }), set2);
};
async function* streamResponse(response) {
  let body = response.body;
  if (!body)
    return;
  let reader = body.getReader(), decoder = new TextDecoder;
  try {
    while (true) {
      let { done, value } = await reader.read();
      if (done)
        break;
      if (typeof value === "string")
        yield value;
      else
        yield decoder.decode(value);
    }
  } finally {
    reader.releaseLock();
  }
}
var handleSet = (set2) => {
  if (typeof set2.status === "string")
    set2.status = StatusMap[set2.status];
  if (set2.cookie && isNotEmpty(set2.cookie)) {
    let cookie = serializeCookie(set2.cookie);
    if (cookie)
      set2.headers["set-cookie"] = cookie;
  }
  if (set2.headers["set-cookie"] && Array.isArray(set2.headers["set-cookie"]))
    set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["set-cookie"]);
};
var createResponseHandler = (handler) => {
  let handleStream = createStreamHandler(handler);
  return (response, set2, request) => {
    let isCookieSet = false;
    if (set2.headers instanceof Headers)
      for (let key of set2.headers.keys())
        if (key === "set-cookie") {
          if (isCookieSet)
            continue;
          isCookieSet = true;
          for (let cookie of set2.headers.getSetCookie())
            response.headers.append("set-cookie", cookie);
        } else
          response.headers.append(key, set2.headers?.get(key) ?? "");
    else
      for (let key in set2.headers)
        response.headers.append(key, set2.headers[key]);
    let status2 = set2.status ?? 200;
    if (response.status !== status2 && status2 !== 200 && (response.status <= 300 || response.status > 400)) {
      let newResponse = new Response(response.body, { headers: response.headers, status: set2.status });
      if (!newResponse.headers.has("content-length") && newResponse.headers.get("transfer-encoding") === "chunked")
        return handleStream(streamResponse(newResponse), responseToSetHeaders(newResponse, set2), request);
      return newResponse;
    }
    if (!response.headers.has("content-length") && response.headers.get("transfer-encoding") === "chunked")
      return handleStream(streamResponse(response), responseToSetHeaders(response, set2), request);
    return response;
  };
};
async function tee(source, branches = 2) {
  let buffer = [], done = false, waiting = [];
  (async () => {
    for await (let value of source)
      buffer.push(value), waiting.forEach((w) => w.resolve()), waiting = [];
    done = true, waiting.forEach((w) => w.resolve());
  })();
  async function* makeIterator() {
    let i2 = 0;
    while (true)
      if (i2 < buffer.length)
        yield buffer[i2++];
      else if (done)
        return;
      else
        await new Promise((resolve) => waiting.push({ resolve }));
  }
  return Array.from({ length: branches }, makeIterator);
}
var handleElysiaFile = (file2, set2 = { headers: {} }) => {
  let path = file2.path, contentType = mime[path.slice(path.lastIndexOf(".") + 1)];
  if (contentType)
    set2.headers["content-type"] = contentType;
  if (file2.stats && set2.status !== 206 && set2.status !== 304 && set2.status !== 412 && set2.status !== 416)
    return file2.stats.then((stat2) => {
      let size = stat2.size;
      if (size !== undefined)
        set2.headers["content-range"] = `bytes 0-${size - 1}/${size}`, set2.headers["content-length"] = size;
      return handleFile(file2.value, set2);
    });
  return handleFile(file2.value, set2);
};
var mapResponse = (response, set2, request) => {
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
    switch (handleSet(set2), response?.constructor?.name) {
      case "String":
        return set2.headers["content-type"] = "text/plain", new Response(response, set2);
      case "Array":
      case "Object":
        return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
      case "ElysiaFile":
        return handleElysiaFile(response, set2);
      case "File":
        return handleFile(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapResponse(response.response, set2, request);
      case undefined:
        if (!response)
          return new Response("", set2);
        return new Response(JSON.stringify(response), set2);
      case "Response":
        return handleResponse(response, set2, request);
      case "Error":
        return errorToResponse(response, set2);
      case "Promise":
        return response.then((x2) => mapResponse(x2, set2, request));
      case "Function":
        return mapResponse(response(), set2, request);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      case "FormData":
        return new Response(response, set2);
      default:
        if (response instanceof Response)
          return handleResponse(response, set2, request);
        if (response instanceof Promise)
          return response.then((x2) => mapResponse(x2, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapResponse(response.response, set2, request);
        if (typeof response?.next === "function" || response instanceof ReadableStream)
          return handleStream(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x2) => mapResponse(x2, set2));
        if (typeof response?.toResponse === "function")
          return mapResponse(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  if (typeof response?.next === "function" || response instanceof ReadableStream)
    return handleStream(response, set2, request);
  return mapCompactResponse(response, request);
};
var mapEarlyResponse = (response, set2, request) => {
  if (response === undefined || response === null)
    return;
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
    switch (handleSet(set2), response?.constructor?.name) {
      case "String":
        return set2.headers["content-type"] = "text/plain", new Response(response, set2);
      case "Array":
      case "Object":
        return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
      case "ElysiaFile":
        return handleElysiaFile(response, set2);
      case "File":
        return handleFile(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapEarlyResponse(response.response, set2, request);
      case undefined:
        if (!response)
          return;
        return new Response(JSON.stringify(response), set2);
      case "Response":
        return handleResponse(response, set2, request);
      case "Promise":
        return response.then((x2) => mapEarlyResponse(x2, set2));
      case "Error":
        return errorToResponse(response, set2);
      case "Function":
        return mapEarlyResponse(response(), set2);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "FormData":
        return new Response(response);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response)
          return handleResponse(response, set2, request);
        if (response instanceof Promise)
          return response.then((x2) => mapEarlyResponse(x2, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapEarlyResponse(response.response, set2, request);
        if (typeof response?.next === "function" || response instanceof ReadableStream)
          return handleStream(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x2) => mapEarlyResponse(x2, set2));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  else
    switch (response?.constructor?.name) {
      case "String":
        return set2.headers["content-type"] = "text/plain", new Response(response);
      case "Array":
      case "Object":
        return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
      case "ElysiaFile":
        return handleElysiaFile(response, set2);
      case "File":
        return handleFile(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapEarlyResponse(response.response, set2, request);
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
      case "Response":
        return response;
      case "Promise":
        return response.then((x2) => {
          let r = mapEarlyResponse(x2, set2);
          if (r !== undefined)
            return r;
        });
      case "Error":
        return errorToResponse(response, set2);
      case "Function":
        return mapCompactResponse(response(), request);
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      case "FormData":
        return new Response(response);
      default:
        if (response instanceof Response)
          return response;
        if (response instanceof Promise)
          return response.then((x2) => mapEarlyResponse(x2, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapEarlyResponse(response.response, set2, request);
        if (typeof response?.next === "function" || response instanceof ReadableStream)
          return handleStream(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x2) => mapEarlyResponse(x2, set2));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response);
    }
};
var mapCompactResponse = (response, request) => {
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response, { headers: { "Content-Type": "text/plain" } });
    case "Object":
    case "Array":
      return new Response(JSON.stringify(response), { headers: { "Content-Type": "application/json" } });
    case "ElysiaFile":
      return handleElysiaFile(response);
    case "File":
      return handleFile(response);
    case "Blob":
      return handleFile(response);
    case "ElysiaCustomStatusResponse":
      return mapResponse(response.response, { status: response.code, headers: {} });
    case undefined:
      if (!response)
        return new Response("");
      return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
    case "Response":
      return response;
    case "Error":
      return errorToResponse(response);
    case "Promise":
      return response.then((x2) => mapCompactResponse(x2, request));
    case "Function":
      return mapCompactResponse(response(), request);
    case "Number":
    case "Boolean":
      return new Response(response.toString());
    case "FormData":
      return new Response(response);
    default:
      if (response instanceof Response)
        return response;
      if (response instanceof Promise)
        return response.then((x2) => mapCompactResponse(x2, request));
      if (response instanceof Error)
        return errorToResponse(response);
      if (response instanceof ElysiaCustomStatusResponse)
        return mapResponse(response.response, { status: response.code, headers: {} });
      if (typeof response?.next === "function" || response instanceof ReadableStream)
        return handleStream(response, undefined, request);
      if (typeof response?.then === "function")
        return response.then((x2) => mapResponse(x2, set));
      if (typeof response?.toResponse === "function")
        return mapCompactResponse(response.toResponse());
      if ("charCodeAt" in response) {
        let code = response.charCodeAt(0);
        if (code === 123 || code === 91)
          return new Response(JSON.stringify(response), { headers: { "Content-Type": "application/json" } });
      }
      return new Response(response);
  }
};
var errorToResponse = (error, set2) => new Response(JSON.stringify({ name: error?.name, message: error?.message, cause: error?.cause }), { status: set2?.status !== 200 ? set2?.status ?? 500 : 500, headers: set2?.headers });
var createStaticHandler = (handle, hooks, setHeaders = {}) => {
  if (typeof handle === "function")
    return;
  let response = mapResponse(handle, { headers: setHeaders });
  if (!hooks.parse?.length && !hooks.transform?.length && !hooks.beforeHandle?.length && !hooks.afterHandle?.length)
    return () => response.clone();
};
var handleResponse = createResponseHandler({ mapResponse, mapCompactResponse });
var handleStream = createStreamHandler({ mapResponse, mapCompactResponse });
var WebStandardAdapter = { name: "web-standard", isWebStandard: true, handler: { mapResponse, mapEarlyResponse, mapCompactResponse, createStaticHandler }, composeHandler: { mapResponseContext: "c.request", preferWebstandardHeaders: true, headers: `c.headers={}
for(const [k,v] of c.request.headers.entries())c.headers[k]=v
`, parser: { json(isOptional) {
  if (isOptional)
    return `try{c.body=await c.request.json()}catch{}
`;
  return `c.body=await c.request.json()
`;
}, text() {
  return `c.body=await c.request.text()
`;
}, urlencoded() {
  return `c.body=parseQuery(await c.request.text())
`;
}, arrayBuffer() {
  return `c.body=await c.request.arrayBuffer()
`;
}, formData(isOptional) {
  let fnLiteral = `
c.body={}
`;
  if (isOptional)
    fnLiteral += "let form;try{form=await c.request.formData()}catch{}";
  else
    fnLiteral += `const form=await c.request.formData()
`;
  return fnLiteral + `for(const key of form.keys()){if(c.body[key]) continue
const value=form.getAll(key)
if(value.length===1)c.body[key]=value[0]
else c.body[key]=value}`;
} } }, async stop(app, closeActiveConnections) {
  if (!app.server)
    throw Error("Elysia isn't running. Call `app.listen` to start the server.");
  if (app.server) {
    if (await app.server.stop(closeActiveConnections), app.server = null, app.event.stop?.length)
      for (let i2 = 0;i2 < app.event.stop.length; i2++)
        app.event.stop[i2].fn(app);
  }
}, composeGeneralHandler: { parameters: "r", createContext(app) {
  let decoratorsLiteral = "", fnLiteral = "", defaultHeaders = app.setHeaders;
  for (let key of Object.keys(app.decorator))
    decoratorsLiteral += `,'${key}':decorator['${key}']`;
  let standardHostname = app.config.handler?.standardHostname ?? true, hasTrace = !!app.event.trace?.length;
  if (fnLiteral += `const u=r.url,s=u.indexOf('/',${standardHostname ? 11 : 7}),qi=u.indexOf('?',s+1)
let p
if(qi===-1)p=u.substring(s)
else p=u.substring(s, qi)
`, hasTrace)
    fnLiteral += `const id=randomId()
`;
  if (fnLiteral += "const c={request:r,store,qi,path:p,url:u,redirect,status,set:{headers:", fnLiteral += Object.keys(defaultHeaders ?? {}).length ? "Object.assign({},app.setHeaders)" : "Object.create(null)", fnLiteral += ",status:200}", app.inference.server)
    fnLiteral += ",get server(){return app.getServer()}";
  if (hasTrace)
    fnLiteral += ",[ELYSIA_REQUEST_ID]:id";
  return fnLiteral += decoratorsLiteral, fnLiteral += `}
`, fnLiteral;
}, error404(hasEventHook, hasErrorHook, afterHandle = "") {
  let findDynamicRoute = "if(route===null){" + afterHandle + (hasErrorHook ? "" : "c.set.status=404") + `
return `;
  if (hasErrorHook)
    findDynamicRoute += `app.handleError(c,notFound,false,${this.parameters})`;
  else
    findDynamicRoute += hasEventHook ? "c.response=c.responseValue=new Response(error404Message,{status:c.set.status===200?404:c.set.status,headers:c.set.headers})" : "c.response=c.responseValue=error404.clone()";
  return findDynamicRoute += "}", { declare: hasErrorHook ? "" : `const error404Message=notFound.message.toString()
const error404=new Response(error404Message,{status:404})
`, code: findDynamicRoute };
} }, composeError: { mapResponseContext: "", validationError: "return new Response(error.message,{headers:Object.assign({'content-type':'application/json'},set.headers),status:set.status})", unknownError: "return new Response(error.message,{headers:set.headers,status:error.status??set.status??500})" }, listen() {
  return () => {
    throw Error("WebStandard does not support listen, you might want to export default Elysia.fetch instead");
  };
} };
function isCloudflareWorker() {
  try {
    if (typeof caches < "u" && typeof caches.default < "u")
      return true;
    if (typeof WebSocketPair < "u")
      return true;
  } catch {
    return false;
  }
  return false;
}
var CloudflareAdapter = { ...WebStandardAdapter, name: "cloudflare-worker", composeGeneralHandler: { ...WebStandardAdapter.composeGeneralHandler, error404(hasEventHook, hasErrorHook, afterHandle) {
  let { code } = WebStandardAdapter.composeGeneralHandler.error404(hasEventHook, hasErrorHook, afterHandle);
  return { code, declare: hasErrorHook ? "" : `const error404Message=notFound.message.toString()
const error404={clone:()=>new Response(error404Message,{status:404})}
` };
} }, beforeCompile(app) {
  for (let route of app.routes)
    route.compile();
}, listen(app) {
  return (options, callback) => {
    console.warn("Cloudflare Worker does not support listen method. Please export default Elysia instance instead."), app.compile();
  };
} };
var separateFunction = (code) => {
  if (code.startsWith("async"))
    code = code.slice(5);
  code = code.trimStart();
  let index = -1;
  if (code.charCodeAt(0) === 40) {
    if (index = code.indexOf("=>", code.indexOf(")")), index !== -1) {
      let bracketEndIndex = index;
      while (bracketEndIndex > 0)
        if (code.charCodeAt(--bracketEndIndex) === 41)
          break;
      let body = code.slice(index + 2);
      if (body.charCodeAt(0) === 32)
        body = body.trimStart();
      return [code.slice(1, bracketEndIndex), body, { isArrowReturn: body.charCodeAt(0) !== 123 }];
    }
  }
  if (/^(\w+)=>/g.test(code)) {
    if (index = code.indexOf("=>"), index !== -1) {
      let body = code.slice(index + 2);
      if (body.charCodeAt(0) === 32)
        body = body.trimStart();
      return [code.slice(0, index), body, { isArrowReturn: body.charCodeAt(0) !== 123 }];
    }
  }
  if (code.startsWith("function")) {
    index = code.indexOf("(");
    let end = code.indexOf(")");
    return [code.slice(index + 1, end), code.slice(end + 2), { isArrowReturn: false }];
  }
  let start = code.indexOf("(");
  if (start !== -1) {
    let sep = code.indexOf(`
`, 2), parameter = code.slice(0, sep), end = parameter.lastIndexOf(")") + 1, body = code.slice(sep + 1);
    return [parameter.slice(start, end), "{" + body, { isArrowReturn: false }];
  }
  let x2 = code.split(`
`, 2);
  return [x2[0], x2[1], { isArrowReturn: false }];
};
var bracketPairRange = (parameter) => {
  let start = parameter.indexOf("{");
  if (start === -1)
    return [-1, 0];
  let end = start + 1, deep = 1;
  for (;end < parameter.length; end++) {
    let char = parameter.charCodeAt(end);
    if (char === 123)
      deep++;
    else if (char === 125)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [0, parameter.length];
  return [start, end + 1];
};
var bracketPairRangeReverse = (parameter) => {
  let end = parameter.lastIndexOf("}");
  if (end === -1)
    return [-1, 0];
  let start = end - 1, deep = 1;
  for (;start >= 0; start--) {
    let char = parameter.charCodeAt(start);
    if (char === 125)
      deep++;
    else if (char === 123)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [-1, 0];
  return [start, end + 1];
};
var removeColonAlias = (parameter) => {
  while (true) {
    let start = parameter.indexOf(":");
    if (start === -1)
      break;
    let end = parameter.indexOf(",", start);
    if (end === -1)
      end = parameter.indexOf("}", start) - 1;
    if (end === -2)
      end = parameter.length;
    parameter = parameter.slice(0, start) + parameter.slice(end);
  }
  return parameter;
};
var retrieveRootParamters = (parameter) => {
  let hasParenthesis = false;
  if (parameter.charCodeAt(0) === 40)
    parameter = parameter.slice(1, -1);
  if (parameter.charCodeAt(0) === 123)
    hasParenthesis = true, parameter = parameter.slice(1, -1);
  parameter = parameter.replace(/( |\t|\n)/g, "").trim();
  let parameters = [];
  while (true) {
    let [start, end] = bracketPairRange(parameter);
    if (start === -1)
      break;
    if (parameters.push(parameter.slice(0, start - 1)), parameter.charCodeAt(end) === 44)
      end++;
    parameter = parameter.slice(end);
  }
  if (parameter = removeColonAlias(parameter), parameter)
    parameters = parameters.concat(parameter.split(","));
  let parameterMap = Object.create(null);
  for (let p of parameters) {
    if (p.indexOf(",") === -1) {
      parameterMap[p] = true;
      continue;
    }
    for (let q of p.split(","))
      parameterMap[q.trim()] = true;
  }
  return { hasParenthesis, parameters: parameterMap };
};
var findParameterReference = (parameter, inference) => {
  let { parameters, hasParenthesis } = retrieveRootParamters(parameter);
  if (parameters.query)
    inference.query = true;
  if (parameters.headers)
    inference.headers = true;
  if (parameters.body)
    inference.body = true;
  if (parameters.cookie)
    inference.cookie = true;
  if (parameters.set)
    inference.set = true;
  if (parameters.server)
    inference.server = true;
  if (parameters.route)
    inference.route = true;
  if (parameters.url)
    inference.url = true;
  if (parameters.path)
    inference.path = true;
  if (hasParenthesis)
    return `{ ${Object.keys(parameters).join(", ")} }`;
  return Object.keys(parameters).join(", ");
};
var findEndIndex = (type, content, index) => {
  let regex2 = new RegExp(`${type.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}[\\n\\t,; ]`);
  if (index !== undefined)
    regex2.lastIndex = index;
  let match = regex2.exec(content);
  return match ? match.index : -1;
};
var findAlias = (type, body, depth = 0) => {
  if (depth > 5)
    return [];
  let aliases = [], content = body;
  while (true) {
    let index = findEndIndex(" = " + type, content);
    if (index === -1)
      index = findEndIndex("=" + type, content);
    if (index === -1) {
      let lastIndex = content.indexOf(" = " + type);
      if (lastIndex === -1)
        lastIndex = content.indexOf("=" + type);
      if (lastIndex + 3 + type.length !== content.length)
        break;
      index = lastIndex;
    }
    let part = content.slice(0, index), lastPart = part.lastIndexOf(" "), variable = part.slice(lastPart !== -1 ? lastPart + 1 : -1);
    if (variable === "}") {
      let [start, end] = bracketPairRangeReverse(part);
      aliases.push(removeColonAlias(content.slice(start, end))), content = content.slice(index + 3 + type.length);
      continue;
    }
    while (variable.charCodeAt(0) === 44)
      variable = variable.slice(1);
    while (variable.charCodeAt(0) === 9)
      variable = variable.slice(1);
    if (!variable.includes("("))
      aliases.push(variable);
    content = content.slice(index + 3 + type.length);
  }
  for (let alias of aliases) {
    if (alias.charCodeAt(0) === 123)
      continue;
    let deepAlias = findAlias(alias, body);
    if (deepAlias.length > 0)
      aliases.push(...deepAlias);
  }
  return aliases;
};
var extractMainParameter = (parameter) => {
  if (!parameter)
    return;
  if (parameter.charCodeAt(0) !== 123)
    return parameter;
  if (parameter = parameter.slice(2, -2), !parameter.includes(",")) {
    if (parameter.indexOf("...") !== -1)
      return parameter.slice(parameter.indexOf("...") + 3);
    return;
  }
  let spreadIndex = parameter.indexOf("...");
  if (spreadIndex === -1)
    return;
  return parameter.slice(spreadIndex + 3).trimEnd();
};
var inferBodyReference = (code, aliases, inference) => {
  let access = (type, alias) => new RegExp(`${alias}\\.(${type})|${alias}\\["${type}"\\]|${alias}\\['${type}'\\]`).test(code);
  for (let alias of aliases) {
    if (!alias)
      continue;
    if (alias.charCodeAt(0) === 123) {
      let parameters = retrieveRootParamters(alias).parameters;
      if (parameters.query)
        inference.query = true;
      if (parameters.headers)
        inference.headers = true;
      if (parameters.body)
        inference.body = true;
      if (parameters.cookie)
        inference.cookie = true;
      if (parameters.set)
        inference.set = true;
      if (parameters.server)
        inference.server = true;
      if (parameters.url)
        inference.url = true;
      if (parameters.route)
        inference.route = true;
      if (parameters.path)
        inference.path = true;
      continue;
    }
    if (!inference.query && (access("query", alias) || code.includes("return " + alias) || code.includes("return " + alias + ".query")))
      inference.query = true;
    if (!inference.headers && access("headers", alias))
      inference.headers = true;
    if (!inference.body && access("body", alias))
      inference.body = true;
    if (!inference.cookie && access("cookie", alias))
      inference.cookie = true;
    if (!inference.set && access("set", alias))
      inference.set = true;
    if (!inference.server && access("server", alias))
      inference.server = true;
    if (!inference.route && access("route", alias))
      inference.route = true;
    if (!inference.url && access("url", alias))
      inference.url = true;
    if (!inference.path && access("path", alias))
      inference.path = true;
    if (inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server && inference.route && inference.url && inference.path)
      break;
  }
  return aliases;
};
var isContextPassToFunction = (context, body, inference) => {
  try {
    let captureFunction = new RegExp(`\\w\\((.*?)?${context}`, "gs");
    captureFunction.test(body);
    let nextChar = body.charCodeAt(captureFunction.lastIndex);
    if (nextChar === 41 || nextChar === 44)
      return inference.query = true, inference.headers = true, inference.body = true, inference.cookie = true, inference.set = true, inference.server = true, inference.url = true, inference.route = true, inference.path = true, true;
    return false;
  } catch (error) {
    return console.log("[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to maintainers:"), console.log("--- body ---"), console.log(body), console.log("--- context ---"), console.log(context), true;
  }
};
var pendingGC;
var caches2 = {};
var clearSucroseCache = (delay) => {
  if (delay === null || isCloudflareWorker())
    return;
  if (delay === undefined)
    delay = 295000;
  if (pendingGC)
    clearTimeout(pendingGC);
  pendingGC = setTimeout(() => {
    if (caches2 = {}, pendingGC = undefined, isBun)
      Bun.gc(false);
  }, delay);
};
var mergeInference = (a, b) => {
  return { body: a.body || b.body, cookie: a.cookie || b.cookie, headers: a.headers || b.headers, query: a.query || b.query, set: a.set || b.set, server: a.server || b.server, url: a.url || b.url, route: a.route || b.route, path: a.path || b.path };
};
var sucrose = (lifeCycle, inference = { query: false, headers: false, body: false, cookie: false, set: false, server: false, url: false, route: false, path: false }, settings = {}) => {
  let events = [];
  if (lifeCycle.request?.length)
    events.push(...lifeCycle.request);
  if (lifeCycle.beforeHandle?.length)
    events.push(...lifeCycle.beforeHandle);
  if (lifeCycle.parse?.length)
    events.push(...lifeCycle.parse);
  if (lifeCycle.error?.length)
    events.push(...lifeCycle.error);
  if (lifeCycle.transform?.length)
    events.push(...lifeCycle.transform);
  if (lifeCycle.afterHandle?.length)
    events.push(...lifeCycle.afterHandle);
  if (lifeCycle.mapResponse?.length)
    events.push(...lifeCycle.mapResponse);
  if (lifeCycle.afterResponse?.length)
    events.push(...lifeCycle.afterResponse);
  if (lifeCycle.handler && typeof lifeCycle.handler === "function")
    events.push(lifeCycle.handler);
  for (let i2 = 0;i2 < events.length; i2++) {
    let e = events[i2];
    if (!e)
      continue;
    let event = typeof e === "object" ? e.fn : e;
    if (typeof event !== "function")
      continue;
    let content = event.toString(), key = checksum(content), cachedInference = caches2[key];
    if (cachedInference) {
      inference = mergeInference(inference, cachedInference);
      continue;
    }
    clearSucroseCache(settings.gcTime);
    let fnInference = { query: false, headers: false, body: false, cookie: false, set: false, server: false, url: false, route: false, path: false }, [parameter, body] = separateFunction(content), rootParameters = findParameterReference(parameter, fnInference), mainParameter = extractMainParameter(rootParameters);
    if (mainParameter) {
      let aliases = findAlias(mainParameter, body.slice(1, -1));
      aliases.splice(0, -1, mainParameter);
      let code = body;
      if (code.charCodeAt(0) === 123 && code.charCodeAt(body.length - 1) === 125)
        code = code.slice(1, -1);
      if (!isContextPassToFunction(mainParameter, code, fnInference))
        inferBodyReference(code, aliases, fnInference);
      if (!fnInference.query && code.includes("return " + mainParameter + ".query"))
        fnInference.query = true;
    }
    if (!caches2[key])
      caches2[key] = fnInference;
    if (inference = mergeInference(inference, fnInference), inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server && inference.url && inference.route && inference.path)
      break;
  }
  return inference;
};
var mapResponse2 = (response, set2, request) => {
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
    switch (handleSet(set2), response?.constructor?.name) {
      case "String":
        return new Response(response, set2);
      case "Array":
      case "Object":
        return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
      case "ElysiaFile":
        return handleFile(response.value, set2);
      case "File":
        return handleFile(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapResponse2(response.response, set2, request);
      case undefined:
        if (!response)
          return new Response("", set2);
        return new Response(JSON.stringify(response), set2);
      case "Response":
        return handleResponse2(response, set2, request);
      case "Error":
        return errorToResponse2(response, set2);
      case "Promise":
        return response.then((x2) => mapResponse2(x2, set2, request));
      case "Function":
        return mapResponse2(response(), set2, request);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      case "FormData":
        return new Response(response, set2);
      default:
        if (response instanceof Response)
          return handleResponse2(response, set2, request);
        if (response instanceof Promise)
          return response.then((x2) => mapResponse2(x2, set2));
        if (response instanceof Error)
          return errorToResponse2(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapResponse2(response.response, set2, request);
        if (typeof response?.next === "function" || response instanceof ReadableStream)
          return handleStream2(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x2) => mapResponse2(x2, set2));
        if (typeof response?.toResponse === "function")
          return mapResponse2(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  if (typeof response?.next === "function" || response instanceof ReadableStream)
    return handleStream2(response, set2, request);
  return mapCompactResponse2(response, request);
};
var mapEarlyResponse2 = (response, set2, request) => {
  if (response === undefined || response === null)
    return;
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
    switch (handleSet(set2), response?.constructor?.name) {
      case "String":
        return new Response(response, set2);
      case "Array":
      case "Object":
        return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
      case "ElysiaFile":
        return handleFile(response.value, set2);
      case "File":
        return handleFile(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapEarlyResponse2(response.response, set2, request);
      case undefined:
        if (!response)
          return;
        return new Response(JSON.stringify(response), set2);
      case "Response":
        return handleResponse2(response, set2, request);
      case "Promise":
        return response.then((x2) => mapEarlyResponse2(x2, set2));
      case "Error":
        return errorToResponse2(response, set2);
      case "Function":
        return mapEarlyResponse2(response(), set2);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "FormData":
        return new Response(response);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response)
          return handleResponse2(response, set2, request);
        if (response instanceof Promise)
          return response.then((x2) => mapEarlyResponse2(x2, set2));
        if (response instanceof Error)
          return errorToResponse2(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapEarlyResponse2(response.response, set2, request);
        if (typeof response?.next === "function" || response instanceof ReadableStream)
          return handleStream2(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x2) => mapEarlyResponse2(x2, set2));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse2(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  else
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Array":
      case "Object":
        return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
      case "ElysiaFile":
        return handleFile(response.value, set2);
      case "File":
        return handleFile(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapEarlyResponse2(response.response, set2, request);
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
      case "Response":
        return response;
      case "Promise":
        return response.then((x2) => {
          let r = mapEarlyResponse2(x2, set2);
          if (r !== undefined)
            return r;
        });
      case "Error":
        return errorToResponse2(response, set2);
      case "Function":
        return mapCompactResponse2(response(), request);
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      case "FormData":
        return new Response(response);
      default:
        if (response instanceof Response)
          return response;
        if (response instanceof Promise)
          return response.then((x2) => mapEarlyResponse2(x2, set2));
        if (response instanceof Error)
          return errorToResponse2(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapEarlyResponse2(response.response, set2, request);
        if (typeof response?.next === "function" || response instanceof ReadableStream)
          return handleStream2(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x2) => mapEarlyResponse2(x2, set2));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse2(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response);
    }
};
var mapCompactResponse2 = (response, request) => {
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response);
    case "Object":
    case "Array":
      return new Response(JSON.stringify(response), { headers: { "Content-Type": "application/json" } });
    case "ElysiaFile":
      return handleFile(response.value);
    case "File":
      return handleFile(response);
    case "Blob":
      return handleFile(response);
    case "ElysiaCustomStatusResponse":
      return mapResponse2(response.response, { status: response.code, headers: {} });
    case undefined:
      if (!response)
        return new Response("");
      return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
    case "Response":
      return response;
    case "Error":
      return errorToResponse2(response);
    case "Promise":
      return response.then((x2) => mapCompactResponse2(x2, request));
    case "Function":
      return mapCompactResponse2(response(), request);
    case "Number":
    case "Boolean":
      return new Response(response.toString());
    case "FormData":
      return new Response(response);
    default:
      if (response instanceof Response)
        return response;
      if (response instanceof Promise)
        return response.then((x2) => mapCompactResponse2(x2, request));
      if (response instanceof Error)
        return errorToResponse2(response);
      if (response instanceof ElysiaCustomStatusResponse)
        return mapResponse2(response.response, { status: response.code, headers: {} });
      if (typeof response?.next === "function" || response instanceof ReadableStream)
        return handleStream2(response, undefined, request);
      if (typeof response?.then === "function")
        return response.then((x2) => mapResponse2(x2, set));
      if (typeof response?.toResponse === "function")
        return mapCompactResponse2(response.toResponse());
      if ("charCodeAt" in response) {
        let code = response.charCodeAt(0);
        if (code === 123 || code === 91)
          return new Response(JSON.stringify(response), { headers: { "Content-Type": "application/json" } });
      }
      return new Response(response);
  }
};
var errorToResponse2 = (error, set2) => new Response(JSON.stringify({ name: error?.name, message: error?.message, cause: error?.cause }), { status: set2?.status !== 200 ? set2?.status ?? 500 : 500, headers: set2?.headers });
var createStaticHandler2 = (handle, hooks, setHeaders = {}) => {
  if (typeof handle === "function")
    return;
  let response = mapResponse2(handle, { headers: setHeaders });
  if (!hooks.parse?.length && !hooks.transform?.length && !hooks.beforeHandle?.length && !hooks.afterHandle?.length)
    return () => response.clone();
};
var handleResponse2 = createResponseHandler({ mapResponse: mapResponse2, mapCompactResponse: mapCompactResponse2 });
var handleStream2 = createStreamHandler({ mapResponse: mapResponse2, mapCompactResponse: mapCompactResponse2 });
var import_fast_decode_uri_component3 = __toESM2(require_fast_decode_uri_component(), 1);
var import_fast_decode_uri_component2 = __toESM2(require_fast_decode_uri_component(), 1);
var KEY_HAS_PLUS = 1;
var KEY_NEEDS_DECODE = 2;
var VALUE_HAS_PLUS = 4;
var VALUE_NEEDS_DECODE = 8;
function parseQueryFromURL(input, startIndex = 0, array, object) {
  let result = Object.create(null), flags = 0, inputLength = input.length, startingIndex = startIndex - 1, equalityIndex = startingIndex;
  for (let i2 = 0;i2 < inputLength; i2++)
    switch (input.charCodeAt(i2)) {
      case 38:
        processKeyValuePair(input, i2), startingIndex = i2, equalityIndex = i2, flags = 0;
        break;
      case 61:
        if (equalityIndex <= startingIndex)
          equalityIndex = i2;
        else
          flags |= VALUE_NEEDS_DECODE;
        break;
      case 43:
        if (equalityIndex > startingIndex)
          flags |= VALUE_HAS_PLUS;
        else
          flags |= KEY_HAS_PLUS;
        break;
      case 37:
        if (equalityIndex > startingIndex)
          flags |= VALUE_NEEDS_DECODE;
        else
          flags |= KEY_NEEDS_DECODE;
        break;
    }
  if (startingIndex < inputLength)
    processKeyValuePair(input, inputLength);
  return result;
  function processKeyValuePair(input2, endIndex) {
    let hasBothKeyValuePair = equalityIndex > startingIndex, effectiveEqualityIndex = hasBothKeyValuePair ? equalityIndex : endIndex, keySlice = input2.slice(startingIndex + 1, effectiveEqualityIndex);
    if (!hasBothKeyValuePair && keySlice.length === 0)
      return;
    let finalKey = keySlice;
    if (flags & KEY_HAS_PLUS)
      finalKey = finalKey.replace(/\+/g, " ");
    if (flags & KEY_NEEDS_DECODE)
      finalKey = import_fast_decode_uri_component2.default(finalKey) || finalKey;
    let finalValue = "";
    if (hasBothKeyValuePair) {
      let valueSlice = input2.slice(equalityIndex + 1, endIndex);
      if (flags & VALUE_HAS_PLUS)
        valueSlice = valueSlice.replace(/\+/g, " ");
      if (flags & VALUE_NEEDS_DECODE)
        valueSlice = import_fast_decode_uri_component2.default(valueSlice) || valueSlice;
      finalValue = valueSlice;
    }
    let currentValue = result[finalKey];
    if (array?.[finalKey])
      if (finalValue.charCodeAt(0) === 91) {
        if (object?.[finalKey])
          finalValue = JSON.parse(finalValue);
        else
          finalValue = finalValue.slice(1, -1).split(",");
        if (currentValue === undefined)
          result[finalKey] = finalValue;
        else if (Array.isArray(currentValue))
          currentValue.push(...finalValue);
        else
          result[finalKey] = finalValue, result[finalKey].unshift(currentValue);
      } else if (currentValue === undefined)
        result[finalKey] = finalValue;
      else if (Array.isArray(currentValue))
        currentValue.push(finalValue);
      else
        result[finalKey] = [currentValue, finalValue];
    else
      result[finalKey] = finalValue;
  }
}
function parseQueryStandardSchema(input, startIndex = 0) {
  let result = Object.create(null), flags = 0, inputLength = input.length, startingIndex = startIndex - 1, equalityIndex = startingIndex;
  for (let i2 = 0;i2 < inputLength; i2++)
    switch (input.charCodeAt(i2)) {
      case 38:
        processKeyValuePair(input, i2), startingIndex = i2, equalityIndex = i2, flags = 0;
        break;
      case 61:
        if (equalityIndex <= startingIndex)
          equalityIndex = i2;
        else
          flags |= VALUE_NEEDS_DECODE;
        break;
      case 43:
        if (equalityIndex > startingIndex)
          flags |= VALUE_HAS_PLUS;
        else
          flags |= KEY_HAS_PLUS;
        break;
      case 37:
        if (equalityIndex > startingIndex)
          flags |= VALUE_NEEDS_DECODE;
        else
          flags |= KEY_NEEDS_DECODE;
        break;
    }
  if (startingIndex < inputLength)
    processKeyValuePair(input, inputLength);
  return result;
  function processKeyValuePair(input2, endIndex) {
    let hasBothKeyValuePair = equalityIndex > startingIndex, effectiveEqualityIndex = hasBothKeyValuePair ? equalityIndex : endIndex, keySlice = input2.slice(startingIndex + 1, effectiveEqualityIndex);
    if (!hasBothKeyValuePair && keySlice.length === 0)
      return;
    let finalKey = keySlice;
    if (flags & KEY_HAS_PLUS)
      finalKey = finalKey.replace(/\+/g, " ");
    if (flags & KEY_NEEDS_DECODE)
      finalKey = import_fast_decode_uri_component2.default(finalKey) || finalKey;
    let finalValue = "";
    if (hasBothKeyValuePair) {
      let valueSlice = input2.slice(equalityIndex + 1, endIndex);
      if (flags & VALUE_HAS_PLUS)
        valueSlice = valueSlice.replace(/\+/g, " ");
      if (flags & VALUE_NEEDS_DECODE)
        valueSlice = import_fast_decode_uri_component2.default(valueSlice) || valueSlice;
      finalValue = valueSlice;
    }
    let currentValue = result[finalKey];
    if (finalValue.charCodeAt(0) === 91 && finalValue.charCodeAt(finalValue.length - 1) === 93) {
      try {
        finalValue = JSON.parse(finalValue);
      } catch {}
      if (currentValue === undefined)
        result[finalKey] = finalValue;
      else if (Array.isArray(currentValue))
        currentValue.push(finalValue);
      else
        result[finalKey] = [currentValue, finalValue];
    } else if (finalValue.charCodeAt(0) === 123 && finalValue.charCodeAt(finalValue.length - 1) === 125) {
      try {
        finalValue = JSON.parse(finalValue);
      } catch {}
      if (currentValue === undefined)
        result[finalKey] = finalValue;
      else if (Array.isArray(currentValue))
        currentValue.push(finalValue);
      else
        result[finalKey] = [currentValue, finalValue];
    } else {
      if (finalValue.includes(","))
        finalValue = finalValue.split(",");
      if (currentValue === undefined)
        result[finalKey] = finalValue;
      else if (Array.isArray(currentValue))
        currentValue.push(finalValue);
      else
        result[finalKey] = [currentValue, finalValue];
    }
  }
}
function parseQuery(input) {
  let result = Object.create(null), flags = 0, inputLength = input.length, startingIndex = -1, equalityIndex = -1;
  for (let i2 = 0;i2 < inputLength; i2++)
    switch (input.charCodeAt(i2)) {
      case 38:
        processKeyValuePair(input, i2), startingIndex = i2, equalityIndex = i2, flags = 0;
        break;
      case 61:
        if (equalityIndex <= startingIndex)
          equalityIndex = i2;
        else
          flags |= VALUE_NEEDS_DECODE;
        break;
      case 43:
        if (equalityIndex > startingIndex)
          flags |= VALUE_HAS_PLUS;
        else
          flags |= KEY_HAS_PLUS;
        break;
      case 37:
        if (equalityIndex > startingIndex)
          flags |= VALUE_NEEDS_DECODE;
        else
          flags |= KEY_NEEDS_DECODE;
        break;
    }
  if (startingIndex < inputLength)
    processKeyValuePair(input, inputLength);
  return result;
  function processKeyValuePair(input2, endIndex) {
    let hasBothKeyValuePair = equalityIndex > startingIndex, effectiveEqualityIndex = hasBothKeyValuePair ? equalityIndex : endIndex, keySlice = input2.slice(startingIndex + 1, effectiveEqualityIndex);
    if (!hasBothKeyValuePair && keySlice.length === 0)
      return;
    let finalKey = keySlice;
    if (flags & KEY_HAS_PLUS)
      finalKey = finalKey.replace(/\+/g, " ");
    if (flags & KEY_NEEDS_DECODE)
      finalKey = import_fast_decode_uri_component2.default(finalKey) || finalKey;
    let finalValue = "";
    if (hasBothKeyValuePair) {
      let valueSlice = input2.slice(equalityIndex + 1, endIndex);
      if (flags & VALUE_HAS_PLUS)
        valueSlice = valueSlice.replace(/\+/g, " ");
      if (flags & VALUE_NEEDS_DECODE)
        valueSlice = import_fast_decode_uri_component2.default(valueSlice) || valueSlice;
      finalValue = valueSlice;
    }
    let currentValue = result[finalKey];
    if (currentValue === undefined)
      result[finalKey] = finalValue;
    else if (Array.isArray(currentValue))
      currentValue.push(finalValue);
    else
      result[finalKey] = [currentValue, finalValue];
  }
}
var ELYSIA_TRACE = Symbol("ElysiaTrace");
var createProcess = () => {
  let { promise, resolve } = Promise.withResolvers(), { promise: end, resolve: resolveEnd } = Promise.withResolvers(), { promise: error, resolve: resolveError } = Promise.withResolvers(), callbacks = [], callbacksEnd = [];
  return [(callback) => {
    if (callback)
      callbacks.push(callback);
    return promise;
  }, (process2) => {
    let processes = [], resolvers = [], groupError = null;
    for (let i2 = 0;i2 < (process2.total ?? 0); i2++) {
      let { promise: promise2, resolve: resolve2 } = Promise.withResolvers(), { promise: end2, resolve: resolveEnd2 } = Promise.withResolvers(), { promise: error2, resolve: resolveError2 } = Promise.withResolvers(), callbacks2 = [], callbacksEnd2 = [];
      processes.push((callback) => {
        if (callback)
          callbacks2.push(callback);
        return promise2;
      }), resolvers.push((process3) => {
        let result2 = { ...process3, end: end2, error: error2, index: i2, onStop(callback) {
          if (callback)
            callbacksEnd2.push(callback);
          return end2;
        } };
        resolve2(result2);
        for (let i22 = 0;i22 < callbacks2.length; i22++)
          callbacks2[i22](result2);
        return (error3 = null) => {
          let end3 = performance.now();
          if (error3)
            groupError = error3;
          let detail = { end: end3, error: error3, get elapsed() {
            return end3 - process3.begin;
          } };
          for (let i22 = 0;i22 < callbacksEnd2.length; i22++)
            callbacksEnd2[i22](detail);
          resolveEnd2(end3), resolveError2(error3);
        };
      });
    }
    let result = { ...process2, end, error, onEvent(callback) {
      for (let i2 = 0;i2 < processes.length; i2++)
        processes[i2](callback);
    }, onStop(callback) {
      if (callback)
        callbacksEnd.push(callback);
      return end;
    } };
    resolve(result);
    for (let i2 = 0;i2 < callbacks.length; i2++)
      callbacks[i2](result);
    return { resolveChild: resolvers, resolve(error2 = null) {
      let end2 = performance.now();
      if (!error2 && groupError)
        error2 = groupError;
      let detail = { end: end2, error: error2, get elapsed() {
        return end2 - process2.begin;
      } };
      for (let i2 = 0;i2 < callbacksEnd.length; i2++)
        callbacksEnd[i2](detail);
      resolveEnd(end2), resolveError(error2);
    } };
  }];
};
var createTracer = (traceListener) => {
  return (context) => {
    let [onRequest, resolveRequest] = createProcess(), [onParse, resolveParse] = createProcess(), [onTransform, resolveTransform] = createProcess(), [onBeforeHandle, resolveBeforeHandle] = createProcess(), [onHandle, resolveHandle] = createProcess(), [onAfterHandle, resolveAfterHandle] = createProcess(), [onError, resolveError] = createProcess(), [onMapResponse, resolveMapResponse] = createProcess(), [onAfterResponse, resolveAfterResponse] = createProcess();
    return traceListener({ id: context[ELYSIA_REQUEST_ID], context, set: context.set, onRequest, onParse, onTransform, onBeforeHandle, onHandle, onAfterHandle, onMapResponse, onAfterResponse, onError, time: Date.now(), store: context.store }), { request: resolveRequest, parse: resolveParse, transform: resolveTransform, beforeHandle: resolveBeforeHandle, handle: resolveHandle, afterHandle: resolveAfterHandle, error: resolveError, mapResponse: resolveMapResponse, afterResponse: resolveAfterResponse };
  };
};
var Kind3 = Symbol.for("TypeBox.Kind");
var Hint2 = Symbol.for("TypeBox.Hint");
var isSpecialProperty = (name) => /(\ |-|\t|\n|\.)/.test(name) || !isNaN(+name[0]);
var joinProperty = (v1, v2, isOptional = false) => {
  if (typeof v2 === "number")
    return `${v1}[${v2}]`;
  if (isSpecialProperty(v2))
    return `${v1}${isOptional ? "?." : ""}["${v2}"]`;
  return `${v1}${isOptional ? "?" : ""}.${v2}`;
};
var encodeProperty = (v) => isSpecialProperty(v) ? `"${v}"` : v;
var sanitize = (key, sanitize2 = 0, schema) => {
  if (schema.type !== "string" || schema.const || schema.trusted)
    return key;
  let hof = "";
  for (let i2 = sanitize2 - 1;i2 >= 0; i2--)
    hof += `d.h${i2}(`;
  return hof + key + ")".repeat(sanitize2);
};
var mergeObjectIntersection = (schema) => {
  if (!schema.allOf || Kind3 in schema && (schema[Kind3] !== "Intersect" || schema.type !== "object"))
    return schema;
  let { allOf, ...newSchema } = schema;
  if (newSchema.properties = {}, Kind3 in newSchema)
    newSchema[Kind3] = "Object";
  for (let type of allOf) {
    if (type.type !== "object")
      continue;
    let { properties, required, type: _2, [Kind3]: __, ...rest } = type;
    if (required)
      newSchema.required = newSchema.required ? newSchema.required.concat(required) : required;
    Object.assign(newSchema, rest);
    for (let property in type.properties)
      newSchema.properties[property] = mergeObjectIntersection(type.properties[property]);
  }
  return newSchema;
};
var handleRecord = (schema, property, instruction) => {
  let child = schema.patternProperties["^(.*)$"] ?? schema.patternProperties[Object.keys(schema.patternProperties)[0]];
  if (!child)
    return property;
  let i2 = instruction.array;
  instruction.array++;
  let v = `(()=>{const ar${i2}s=Object.keys(${property}),ar${i2}v={};for(let i=0;i<ar${i2}s.length;i++){const ar${i2}p=${property}[ar${i2}s[i]];ar${i2}v[ar${i2}s[i]]=${mirror(child, `ar${i2}p`, instruction)}`, optionals = instruction.optionalsInArray[i2 + 1];
  if (optionals)
    for (let oi = 0;oi < optionals.length; oi++) {
      let target = `ar${i2}v[ar${i2}s[i]].${optionals[oi]}`;
      v += `;if(${target}===undefined)delete ${target}`;
    }
  return v += `}return ar${i2}v})()`, v;
};
var handleTuple = (schema, property, instruction) => {
  let i2 = instruction.array;
  instruction.array++;
  let isRoot = property === "v" && !instruction.unions.length, v = "";
  if (!isRoot)
    v = "(()=>{";
  v += `const ar${i2}v=[`;
  for (let i22 = 0;i22 < schema.length; i22++) {
    if (i22 !== 0)
      v += ",";
    v += mirror(schema[i22], joinProperty(property, i22, instruction.parentIsOptional), instruction);
  }
  if (v += "];", !isRoot)
    v += `return ar${i2}v})()`;
  return v;
};
function deepClone(source, weak = new WeakMap) {
  if (source === null || typeof source !== "object" || typeof source === "function")
    return source;
  if (weak.has(source))
    return weak.get(source);
  if (Array.isArray(source)) {
    let copy = Array(source.length);
    weak.set(source, copy);
    for (let i2 = 0;i2 < source.length; i2++)
      copy[i2] = deepClone(source[i2], weak);
    return copy;
  }
  if (typeof source === "object") {
    let keys = Object.keys(source).concat(Object.getOwnPropertySymbols(source)), cloned = {};
    for (let key of keys)
      cloned[key] = deepClone(source[key], weak);
    return cloned;
  }
  return source;
}
var handleUnion = (schemas, property, instruction) => {
  if (instruction.TypeCompiler === undefined) {
    if (!instruction.typeCompilerWanred)
      console.warn(Error("[exact-mirror] TypeBox's TypeCompiler is required to use Union")), instruction.typeCompilerWanred = true;
    return property;
  }
  instruction.unionKeys[property] = 1;
  let ui = instruction.unions.length, typeChecks = instruction.unions[ui] = [], v = `(()=>{
`, unwrapRef = (type) => {
    if (!(Kind3 in type) || !type.$ref)
      return type;
    if (type[Kind3] === "This")
      return deepClone(instruction.definitions[type.$ref]);
    else if (type[Kind3] === "Ref")
      if (!instruction.modules)
        console.warn(Error("[exact-mirror] modules is required when using nested cyclic reference"));
      else
        return instruction.modules.Import(type.$ref);
    return type;
  };
  for (let i2 = 0;i2 < schemas.length; i2++) {
    let type = unwrapRef(schemas[i2]);
    if (Array.isArray(type.anyOf))
      for (let i22 = 0;i22 < type.anyOf.length; i22++)
        type.anyOf[i22] = unwrapRef(type.anyOf[i22]);
    else if (type.items)
      if (Array.isArray(type.items))
        for (let i22 = 0;i22 < type.items.length; i22++)
          type.items[i22] = unwrapRef(type.items[i22]);
      else
        type.items = unwrapRef(type.items);
    typeChecks.push(TypeCompiler.Compile(type)), v += `if(d.unions[${ui}][${i2}].Check(${property})){return ${mirror(type, property, { ...instruction, recursion: instruction.recursion + 1, parentIsOptional: true })}}
`;
  }
  return v += `return ${instruction.removeUnknownUnionType ? "undefined" : property}})()`, v;
};
var mirror = (schema, property, instruction) => {
  if (!schema)
    return "";
  let isRoot = property === "v" && !instruction.unions.length;
  if (Kind3 in schema && schema[Kind3] === "Import" && schema.$ref in schema.$defs)
    return mirror(schema.$defs[schema.$ref], property, { ...instruction, definitions: Object.assign(instruction.definitions, schema.$defs) });
  if (isRoot && schema.type !== "object" && schema.type !== "array" && !schema.anyOf)
    return `return ${sanitize("v", instruction.sanitize?.length, schema)}`;
  if (instruction.recursion >= instruction.recursionLimit)
    return property;
  let v = "";
  if (schema.$id && Hint2 in schema)
    instruction.definitions[schema.$id] = schema;
  switch (schema.type) {
    case "object":
      if (schema[Kind3] === "Record") {
        v = handleRecord(schema, property, instruction);
        break;
      }
      if (schema = mergeObjectIntersection(schema), v += "{", schema.additionalProperties)
        v += `...${property},`;
      let keys = Object.keys(schema.properties);
      for (let i22 = 0;i22 < keys.length; i22++) {
        let key = keys[i22], isOptional = !schema.required || schema.required && !schema.required.includes(key) || Array.isArray(schema.properties[key].anyOf), name = joinProperty(property, key, instruction.parentIsOptional);
        if (isOptional) {
          let index = instruction.array;
          if (property.startsWith("ar")) {
            let refName = name.slice(name.indexOf(".") + 1), array = instruction.optionalsInArray;
            if (array[index])
              array[index].push(refName);
            else
              array[index] = [refName];
          } else
            instruction.optionals.push(name);
        }
        let child = schema.properties[key];
        if (i22 !== 0)
          v += ",";
        v += `${encodeProperty(key)}:${isOptional ? `${name}===undefined?undefined:` : ""}${mirror(child, name, { ...instruction, recursion: instruction.recursion + 1, parentIsOptional: isOptional })}`;
      }
      v += "}";
      break;
    case "array":
      if (schema.items.type !== "object" && schema.items.type !== "array")
        if (Array.isArray(schema.items)) {
          v = handleTuple(schema.items, property, instruction);
          break;
        } else if (isRoot)
          return "return v";
        else if (Kind3 in schema.items && schema.items.$ref && (schema.items[Kind3] === "Ref" || schema.items[Kind3] === "This"))
          v = mirror(deepClone(instruction.definitions[schema.items.$ref]), property, { ...instruction, parentIsOptional: true, recursion: instruction.recursion + 1 });
        else {
          v = property;
          break;
        }
      let i2 = instruction.array;
      instruction.array++;
      let reference = property;
      if (isRoot)
        v = `const ar${i2}v=new Array(${property}.length);`;
      else
        reference = `ar${i2}s`, v = `((${reference})=>{const ar${i2}v=new Array(${reference}.length);`;
      v += `for(let i=0;i<${reference}.length;i++){const ar${i2}p=${reference}[i];ar${i2}v[i]=${mirror(schema.items, `ar${i2}p`, instruction)}`;
      let optionals = instruction.optionalsInArray[i2 + 1];
      if (optionals)
        for (let oi = 0;oi < optionals.length; oi++) {
          let target = `ar${i2}v[i].${optionals[oi]}`;
          v += `;if(${target}===undefined)delete ${target}`;
        }
      if (v += "}", !isRoot)
        v += `return ar${i2}v})(${property})`;
      break;
    default:
      if (schema.$ref && schema.$ref in instruction.definitions)
        return mirror(instruction.definitions[schema.$ref], property, instruction);
      if (Array.isArray(schema.anyOf)) {
        v = handleUnion(schema.anyOf, property, instruction);
        break;
      }
      v = sanitize(property, instruction.sanitize?.length, schema);
      break;
  }
  if (!isRoot)
    return v;
  if (schema.type === "array")
    v = `${v}const x=ar0v;`;
  else
    v = `const x=${v}
`;
  for (let i2 = 0;i2 < instruction.optionals.length; i2++) {
    let key = instruction.optionals[i2], prop = key.slice(1);
    if (v += `if(${key}===undefined`, instruction.unionKeys[key])
      v += `||x${prop}===undefined`;
    let shouldQuestion = prop.charCodeAt(0) !== 63 && schema.type !== "array";
    v += `)delete x${shouldQuestion ? prop.charCodeAt(0) === 91 ? "?." : "?" : ""}${prop}
`;
  }
  return `${v}return x`;
};
var createMirror = (schema, { TypeCompiler: TypeCompiler22, modules, definitions, sanitize: sanitize2, recursionLimit = 8, removeUnknownUnionType = false } = {}) => {
  let unions = [];
  if (typeof sanitize2 === "function")
    sanitize2 = [sanitize2];
  let f = mirror(schema, "v", { optionals: [], optionalsInArray: [], array: 0, parentIsOptional: false, unions, unionKeys: {}, TypeCompiler: TypeCompiler22, modules, definitions: definitions ?? modules?.$defs ?? {}, sanitize: sanitize2, recursion: 0, recursionLimit, removeUnknownUnionType });
  if (!unions.length && !sanitize2?.length)
    return Function("v", f);
  let hof;
  if (sanitize2?.length) {
    hof = {};
    for (let i2 = 0;i2 < sanitize2.length; i2++)
      hof[`h${i2}`] = sanitize2[i2];
  }
  return Function("d", `return function mirror(v){${f}}`)({ unions, ...hof });
};
var isOptional = (schema) => {
  if (!schema)
    return false;
  if (schema?.[Kind] === "Import" && schema.References)
    return schema.References().some(isOptional);
  if (schema.schema)
    schema = schema.schema;
  return !!schema && OptionalKind in schema;
};
var hasAdditionalProperties = (_schema) => {
  if (!_schema)
    return false;
  let schema = _schema?.schema ?? _schema;
  if (schema[Kind] === "Import" && _schema.References)
    return _schema.References().some(hasAdditionalProperties);
  if (schema.anyOf)
    return schema.anyOf.some(hasAdditionalProperties);
  if (schema.someOf)
    return schema.someOf.some(hasAdditionalProperties);
  if (schema.allOf)
    return schema.allOf.some(hasAdditionalProperties);
  if (schema.not)
    return schema.not.some(hasAdditionalProperties);
  if (schema.type === "object") {
    let properties = schema.properties;
    if ("additionalProperties" in schema)
      return schema.additionalProperties;
    if ("patternProperties" in schema)
      return false;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (property.type === "object") {
        if (hasAdditionalProperties(property))
          return true;
      } else if (property.anyOf) {
        for (let i2 = 0;i2 < property.anyOf.length; i2++)
          if (hasAdditionalProperties(property.anyOf[i2]))
            return true;
      }
      return property.additionalProperties;
    }
    return false;
  }
  if (schema.type === "array" && schema.items && !Array.isArray(schema.items))
    return hasAdditionalProperties(schema.items);
  return false;
};
var hasType = (type, schema) => {
  if (!schema)
    return false;
  if (Kind in schema && schema[Kind] === type)
    return true;
  if (schema.type === "object") {
    let properties = schema.properties;
    if (!properties)
      return false;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (property.type === "object") {
        if (hasType(type, property))
          return true;
      } else if (property.anyOf) {
        for (let i2 = 0;i2 < property.anyOf.length; i2++)
          if (hasType(type, property.anyOf[i2]))
            return true;
      }
      if (Kind in property && property[Kind] === type)
        return true;
    }
    return false;
  }
  return !!schema.properties && Kind in schema.properties && schema.properties[Kind] === type;
};
var hasElysiaMeta = (meta, _schema) => {
  if (!_schema)
    return false;
  let schema = _schema?.schema ?? _schema;
  if (schema.elysiaMeta === meta)
    return true;
  if (schema[Kind] === "Import" && _schema.References)
    return _schema.References().some((schema2) => hasElysiaMeta(meta, schema2));
  if (schema.anyOf)
    return schema.anyOf.some((schema2) => hasElysiaMeta(meta, schema2));
  if (schema.someOf)
    return schema.someOf.some((schema2) => hasElysiaMeta(meta, schema2));
  if (schema.allOf)
    return schema.allOf.some((schema2) => hasElysiaMeta(meta, schema2));
  if (schema.not)
    return schema.not.some((schema2) => hasElysiaMeta(meta, schema2));
  if (schema.type === "object") {
    let properties = schema.properties;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (property.type === "object") {
        if (hasElysiaMeta(meta, property))
          return true;
      } else if (property.anyOf) {
        for (let i2 = 0;i2 < property.anyOf.length; i2++)
          if (hasElysiaMeta(meta, property.anyOf[i2]))
            return true;
      }
      return schema.elysiaMeta === meta;
    }
    return false;
  }
  if (schema.type === "array" && schema.items && !Array.isArray(schema.items))
    return hasElysiaMeta(meta, schema.items);
  return false;
};
var hasProperty = (expectedProperty, _schema) => {
  if (!_schema)
    return;
  let schema = _schema.schema ?? _schema;
  if (schema[Kind] === "Import" && _schema.References)
    return _schema.References().some((schema2) => hasProperty(expectedProperty, schema2));
  if (schema.type === "object") {
    let properties = schema.properties;
    if (!properties)
      return false;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (expectedProperty in property)
        return true;
      if (property.type === "object") {
        if (hasProperty(expectedProperty, property))
          return true;
      } else if (property.anyOf) {
        for (let i2 = 0;i2 < property.anyOf.length; i2++)
          if (hasProperty(expectedProperty, property.anyOf[i2]))
            return true;
      }
    }
    return false;
  }
  return expectedProperty in schema;
};
var hasRef = (schema) => {
  if (!schema)
    return false;
  if (schema.oneOf) {
    for (let i2 = 0;i2 < schema.oneOf.length; i2++)
      if (hasRef(schema.oneOf[i2]))
        return true;
  }
  if (schema.anyOf) {
    for (let i2 = 0;i2 < schema.anyOf.length; i2++)
      if (hasRef(schema.anyOf[i2]))
        return true;
  }
  if (schema.oneOf) {
    for (let i2 = 0;i2 < schema.oneOf.length; i2++)
      if (hasRef(schema.oneOf[i2]))
        return true;
  }
  if (schema.allOf) {
    for (let i2 = 0;i2 < schema.allOf.length; i2++)
      if (hasRef(schema.allOf[i2]))
        return true;
  }
  if (schema.not && hasRef(schema.not))
    return true;
  if (schema.type === "object" && schema.properties) {
    let properties = schema.properties;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (hasRef(property))
        return true;
      if (property.type === "array" && property.items && hasRef(property.items))
        return true;
    }
  }
  if (schema.type === "array" && schema.items && hasRef(schema.items))
    return true;
  return schema[Kind] === "Ref" && "$ref" in schema;
};
var hasTransform = (schema) => {
  if (!schema)
    return false;
  if (schema.$ref && schema.$defs && schema.$ref in schema.$defs && hasTransform(schema.$defs[schema.$ref]))
    return true;
  if (schema.oneOf) {
    for (let i2 = 0;i2 < schema.oneOf.length; i2++)
      if (hasTransform(schema.oneOf[i2]))
        return true;
  }
  if (schema.anyOf) {
    for (let i2 = 0;i2 < schema.anyOf.length; i2++)
      if (hasTransform(schema.anyOf[i2]))
        return true;
  }
  if (schema.allOf) {
    for (let i2 = 0;i2 < schema.allOf.length; i2++)
      if (hasTransform(schema.allOf[i2]))
        return true;
  }
  if (schema.not && hasTransform(schema.not))
    return true;
  if (schema.type === "object" && schema.properties) {
    let properties = schema.properties;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (hasTransform(property))
        return true;
      if (property.type === "array" && property.items && hasTransform(property.items))
        return true;
    }
  }
  if (schema.type === "array" && schema.items && hasTransform(schema.items))
    return true;
  return TransformKind in schema;
};
var replaceSchemaType = (schema, options, _config = {}) => {
  let config = _config;
  if (config.root = true, !Array.isArray(options))
    return options.original = schema, _replaceSchemaType(schema, options, config);
  for (let option of options)
    option.original = schema, schema = _replaceSchemaType(schema, option, config);
  return schema;
};
var _replaceSchemaType = (schema, options, config) => {
  if (!schema)
    return schema;
  let root = config.root;
  if (options.onlyFirst && schema.type === options.onlyFirst)
    return options.to(schema) ?? schema;
  if (options.untilObjectFound && !root && schema.type === "object")
    return schema;
  let fromSymbol = options.from[Kind];
  if (schema.oneOf) {
    for (let i2 = 0;i2 < schema.oneOf.length; i2++)
      schema.oneOf[i2] = _replaceSchemaType(schema.oneOf[i2], options, config);
    return schema;
  }
  if (schema.anyOf) {
    for (let i2 = 0;i2 < schema.anyOf.length; i2++)
      schema.anyOf[i2] = _replaceSchemaType(schema.anyOf[i2], options, config);
    return schema;
  }
  if (schema.allOf) {
    for (let i2 = 0;i2 < schema.allOf.length; i2++)
      schema.allOf[i2] = _replaceSchemaType(schema.allOf[i2], options, config);
    return schema;
  }
  if (schema.not)
    return _replaceSchemaType(schema.not, options, config);
  let isRoot = root && !!options.excludeRoot;
  if (schema[Kind] === fromSymbol) {
    let { anyOf, oneOf, allOf, not, properties: properties2, items, ...rest } = schema, to = options.to(rest);
    if (!to)
      return schema;
    let transform2, composeProperties = (schema2) => {
      let v = _composeProperties(schema2);
      if (v.$id)
        delete v.$id;
      return v;
    }, _composeProperties = (v) => {
      if (properties2 && v.type === "object") {
        let newProperties = {};
        for (let [key, value2] of Object.entries(properties2))
          newProperties[key] = _replaceSchemaType(value2, options, { ...config, root: false });
        return { ...rest, ...v, properties: newProperties };
      }
      if (items && v.type === "array")
        return { ...rest, ...v, items: _replaceSchemaType(items, options, { ...config, root: false }) };
      let value = { ...rest, ...v };
      if (delete value.required, properties2 && v.type === "string" && v.format === "ObjectString" && v.default === "{}")
        transform2 = t.ObjectString(properties2, rest), value.properties = properties2;
      else if (items && v.type === "string" && v.format === "ArrayString" && v.default === "[]")
        transform2 = t.ArrayString(items, rest), value.items = items;
      return value;
    };
    if (isRoot) {
      if (properties2) {
        let newProperties = {};
        for (let [key, value] of Object.entries(properties2))
          newProperties[key] = _replaceSchemaType(value, options, { ...config, root: false });
        return { ...rest, properties: newProperties };
      } else if (items?.map)
        return { ...rest, items: items.map((v) => _replaceSchemaType(v, options, { ...config, root: false })) };
      return rest;
    }
    if (to.anyOf)
      for (let i2 = 0;i2 < to.anyOf.length; i2++)
        to.anyOf[i2] = composeProperties(to.anyOf[i2]);
    else if (to.oneOf)
      for (let i2 = 0;i2 < to.oneOf.length; i2++)
        to.oneOf[i2] = composeProperties(to.oneOf[i2]);
    else if (to.allOf)
      for (let i2 = 0;i2 < to.allOf.length; i2++)
        to.allOf[i2] = composeProperties(to.allOf[i2]);
    else if (to.not)
      to.not = composeProperties(to.not);
    if (transform2)
      to[TransformKind] = transform2[TransformKind];
    if (to.anyOf || to.oneOf || to.allOf || to.not)
      return to;
    if (properties2) {
      let newProperties = {};
      for (let [key, value] of Object.entries(properties2))
        newProperties[key] = _replaceSchemaType(value, options, { ...config, root: false });
      return { ...rest, ...to, properties: newProperties };
    } else if (items?.map)
      return { ...rest, ...to, items: items.map((v) => _replaceSchemaType(v, options, { ...config, root: false })) };
    return { ...rest, ...to };
  }
  let properties = schema?.properties;
  if (properties && root && options.rootOnly !== true)
    for (let [key, value] of Object.entries(properties))
      switch (value[Kind]) {
        case fromSymbol:
          let { anyOf, oneOf, allOf, not, type, ...rest } = value, to = options.to(rest);
          if (!to)
            return schema;
          if (to.anyOf)
            for (let i2 = 0;i2 < to.anyOf.length; i2++)
              to.anyOf[i2] = { ...rest, ...to.anyOf[i2] };
          else if (to.oneOf)
            for (let i2 = 0;i2 < to.oneOf.length; i2++)
              to.oneOf[i2] = { ...rest, ...to.oneOf[i2] };
          else if (to.allOf)
            for (let i2 = 0;i2 < to.allOf.length; i2++)
              to.allOf[i2] = { ...rest, ...to.allOf[i2] };
          else if (to.not)
            to.not = { ...rest, ...to.not };
          properties[key] = { ...rest, ..._replaceSchemaType(rest, options, { ...config, root: false }) };
          break;
        case "Object":
        case "Union":
          properties[key] = _replaceSchemaType(value, options, { ...config, root: false });
          break;
        default:
          if (Array.isArray(value.items))
            for (let i2 = 0;i2 < value.items.length; i2++)
              value.items[i2] = _replaceSchemaType(value.items[i2], options, { ...config, root: false });
          else if (value.anyOf || value.oneOf || value.allOf || value.not)
            properties[key] = _replaceSchemaType(value, options, { ...config, root: false });
          else if (value.type === "array")
            value.items = _replaceSchemaType(value.items, options, { ...config, root: false });
          break;
      }
  if (schema.type === "array" && schema.items)
    if (Array.isArray(schema.items))
      schema.items = schema.items.map((item) => _replaceSchemaType(item, options, { ...config, root: false }));
    else
      schema.items = _replaceSchemaType(schema.items, options, { ...config, root: false });
  return schema;
};
var createCleaner = (schema) => (value) => {
  if (typeof value === "object")
    try {
      return exports_value2.Clean(schema, value);
    } catch {}
  return value;
};
var getSchemaValidator = (s, { models = {}, dynamic = false, modules, normalize = false, additionalProperties = false, forceAdditionalProperties = false, coerce = false, additionalCoerce = [], validators, sanitize: sanitize2 } = {}) => {
  if (validators = validators?.filter((x2) => x2), !s) {
    if (!validators?.length)
      return;
    s = validators[0], validators = validators.slice(1);
  }
  let doesHaveRef = undefined, replaceSchema = (schema2) => {
    if (coerce)
      return replaceSchemaType(schema2, [{ from: t.Number(), to: (options) => t.Numeric(options), untilObjectFound: true }, { from: t.Boolean(), to: (options) => t.BooleanString(options), untilObjectFound: true }, ...Array.isArray(additionalCoerce) ? additionalCoerce : [additionalCoerce]]);
    return replaceSchemaType(schema2, additionalCoerce);
  }, mapSchema = (s2) => {
    if (s2 && typeof s2 !== "string" && "~standard" in s2)
      return s2;
    if (!s2)
      return;
    let schema2;
    if (typeof s2 !== "string")
      schema2 = s2;
    else if (schema2 = modules && s2 in modules.$defs ? modules.Import(s2) : models[s2], !schema2)
      return;
    if (Kind in schema2) {
      if (schema2[Kind] === "Import") {
        if (!hasRef(schema2.$defs[schema2.$ref])) {
          if (schema2 = schema2.$defs[schema2.$ref], coerce || additionalCoerce)
            schema2 = replaceSchema(schema2);
        }
      } else if (hasRef(schema2)) {
        let id = randomId();
        schema2 = t.Module({ ...modules?.$defs, [id]: schema2 }).Import(id);
      } else if (coerce || additionalCoerce)
        schema2 = replaceSchema(schema2);
    }
    return schema2;
  }, schema = mapSchema(s), _validators = validators;
  if ("~standard" in schema || validators?.length && validators.some((x2) => x2 && typeof x2 !== "string" && ("~standard" in x2))) {
    let typeboxSubValidator = (schema2) => {
      let mirror2;
      if (normalize === true || normalize === "exactMirror")
        try {
          mirror2 = createMirror(schema2, { TypeCompiler, sanitize: sanitize2?.(), modules });
        } catch {
          console.warn("Failed to create exactMirror. Please report the following code to https://github.com/elysiajs/elysia/issues"), console.warn(schema2), mirror2 = createCleaner(schema2);
        }
      let vali = getSchemaValidator(schema2, { models, modules, dynamic, normalize, additionalProperties: true, forceAdditionalProperties: true, coerce, additionalCoerce });
      return vali.Decode = mirror2, (v) => {
        if (vali.Check(v))
          return { value: vali.Decode(v) };
        else
          return { issues: [...vali.Errors(v)] };
      };
    }, mainCheck = schema["~standard"] ? schema["~standard"].validate : typeboxSubValidator(schema), checkers = [];
    if (validators?.length)
      for (let validator2 of validators) {
        if (!validator2)
          continue;
        if (typeof validator2 === "string")
          continue;
        if (validator2?.["~standard"]) {
          checkers.push(validator2["~standard"]);
          continue;
        }
        if (Kind in validator2) {
          checkers.push(typeboxSubValidator(validator2));
          continue;
        }
      }
    async function Check2(value) {
      let v = mainCheck(value);
      if (v instanceof Promise)
        v = await v;
      if (v.issues)
        return v;
      let values = [];
      if (v && typeof v === "object")
        values.push(v.value);
      for (let i2 = 0;i2 < checkers.length; i2++) {
        if (v = checkers[i2].validate(value), v instanceof Promise)
          v = await v;
        if (v.issues)
          return v;
        if (v && typeof v === "object")
          values.push(v.value);
      }
      if (!values.length)
        return { value: v };
      if (values.length === 1)
        return { value: values[0] };
      if (values.length === 2)
        return { value: mergeDeep(values[0], values[1]) };
      let newValue = mergeDeep(values[0], values[1]);
      for (let i2 = 2;i2 < values.length; i2++)
        newValue = mergeDeep(newValue, values[i2]);
      return { value: newValue };
    }
    let validator = { provider: "standard", schema, references: "", checkFunc: () => {}, code: "", Check: Check2, Errors: (value) => Check2(value)?.then?.((x2) => x2?.issues), Code: () => "", Decode: Check2, Encode: (value) => value, hasAdditionalProperties: false, hasDefault: false, isOptional: false, hasTransform: false, hasRef: false };
    return validator.parse = (v) => {
      try {
        return validator.Decode(validator.Clean?.(v) ?? v);
      } catch (error) {
        throw [...validator.Errors(v)].map(mapValueError);
      }
    }, validator.safeParse = (v) => {
      try {
        return { success: true, data: validator.Decode(validator.Clean?.(v) ?? v), error: null };
      } catch (error) {
        let errors = [...compiled.Errors(v)].map(mapValueError);
        return { success: false, data: null, error: errors[0]?.summary, errors };
      }
    }, validator;
  } else if (validators?.length) {
    let hasAdditional = false, validators2 = _validators, { schema: mergedObjectSchema, notObjects } = mergeObjectSchemas([schema, ...validators2.map(mapSchema)]);
    if (notObjects) {
      if (schema = t.Intersect([...mergedObjectSchema ? [mergedObjectSchema] : [], ...notObjects.map((x2) => {
        let schema2 = mapSchema(x2);
        if (schema2.type === "object" && "additionalProperties" in schema2) {
          if (!hasAdditional && schema2.additionalProperties === false)
            hasAdditional = true;
          delete schema2.additionalProperties;
        }
        return schema2;
      })]), schema.type === "object" && hasAdditional)
        schema.additionalProperties = false;
    }
  } else if (schema.type === "object" && (("additionalProperties" in schema) === false || forceAdditionalProperties))
    schema.additionalProperties = additionalProperties;
  else
    schema = replaceSchemaType(schema, { onlyFirst: "object", from: t.Object({}), to({ properties, ...options }) {
      if (!properties)
        return;
      if ("additionalProperties" in schema)
        return;
      return t.Object(properties, { ...options, additionalProperties: false });
    } });
  if (dynamic)
    if (Kind in schema) {
      let validator = { provider: "typebox", schema, references: "", checkFunc: () => {}, code: "", Check: (value) => exports_value2.Check(schema, value), Errors: (value) => exports_value2.Errors(schema, value), Code: () => "", Clean: createCleaner(schema), Decode: (value) => exports_value2.Decode(schema, value), Encode: (value) => exports_value2.Encode(schema, value), get hasAdditionalProperties() {
        if ("~hasAdditionalProperties" in this)
          return this["~hasAdditionalProperties"];
        return this["~hasAdditionalProperties"] = hasAdditionalProperties(schema);
      }, get hasDefault() {
        if ("~hasDefault" in this)
          return this["~hasDefault"];
        return this["~hasDefault"] = hasProperty("default", schema);
      }, get isOptional() {
        if ("~isOptional" in this)
          return this["~isOptional"];
        return this["~isOptional"] = isOptional(schema);
      }, get hasTransform() {
        if ("~hasTransform" in this)
          return this["~hasTransform"];
        return this["~hasTransform"] = hasTransform(schema);
      }, "~hasRef": doesHaveRef, get hasRef() {
        if ("~hasRef" in this)
          return this["~hasRef"];
        return this["~hasRef"] = hasTransform(schema);
      } };
      if (schema.config) {
        if (validator.config = schema.config, validator?.schema?.config)
          delete validator.schema.config;
      }
      if (normalize && schema.additionalProperties === false)
        if (normalize === true || normalize === "exactMirror")
          try {
            validator.Clean = createMirror(schema, { TypeCompiler, sanitize: sanitize2?.(), modules });
          } catch {
            console.warn("Failed to create exactMirror. Please report the following code to https://github.com/elysiajs/elysia/issues"), console.warn(schema), validator.Clean = createCleaner(schema);
          }
        else
          validator.Clean = createCleaner(schema);
      return validator.parse = (v) => {
        try {
          return validator.Decode(validator.Clean?.(v) ?? v);
        } catch (error) {
          throw [...validator.Errors(v)].map(mapValueError);
        }
      }, validator.safeParse = (v) => {
        try {
          return { success: true, data: validator.Decode(validator.Clean?.(v) ?? v), error: null };
        } catch (error) {
          let errors = [...compiled.Errors(v)].map(mapValueError);
          return { success: false, data: null, error: errors[0]?.summary, errors };
        }
      }, validator;
    } else {
      let validator = { provider: "standard", schema, references: "", checkFunc: () => {}, code: "", Check: (v) => schema["~standard"].validate(v), Errors(value) {
        let response = schema["~standard"].validate(value);
        if (response instanceof Promise)
          throw Error("Async validation is not supported in non-dynamic schema");
        return response.issues;
      }, Code: () => "", Decode(value) {
        let response = schema["~standard"].validate(value);
        if (response instanceof Promise)
          throw Error("Async validation is not supported in non-dynamic schema");
        return response;
      }, Encode: (value) => value, hasAdditionalProperties: false, hasDefault: false, isOptional: false, hasTransform: false, hasRef: false };
      return validator.parse = (v) => {
        try {
          return validator.Decode(validator.Clean?.(v) ?? v);
        } catch (error) {
          throw [...validator.Errors(v)].map(mapValueError);
        }
      }, validator.safeParse = (v) => {
        try {
          return { success: true, data: validator.Decode(validator.Clean?.(v) ?? v), error: null };
        } catch (error) {
          let errors = [...compiled.Errors(v)].map(mapValueError);
          return { success: false, data: null, error: errors[0]?.summary, errors };
        }
      }, validator;
    }
  let compiled;
  if (Kind in schema) {
    if (compiled = TypeCompiler.Compile(schema, Object.values(models).filter((x2) => (Kind in x2))), compiled.provider = "typebox", schema.config) {
      if (compiled.config = schema.config, compiled?.schema?.config)
        delete compiled.schema.config;
    }
    if (normalize === true || normalize === "exactMirror")
      try {
        compiled.Clean = createMirror(schema, { TypeCompiler, sanitize: sanitize2?.(), modules });
      } catch (error) {
        console.warn("Failed to create exactMirror. Please report the following code to https://github.com/elysiajs/elysia/issues"), console.dir(schema, { depth: null }), compiled.Clean = createCleaner(schema);
      }
    else if (normalize === "typebox")
      compiled.Clean = createCleaner(schema);
  } else
    compiled = { provider: "standard", schema, references: "", checkFunc(value) {
      let response = schema["~standard"].validate(value);
      if (response instanceof Promise)
        throw Error("Async validation is not supported in non-dynamic schema");
      return response;
    }, code: "", Check: (v) => schema["~standard"].validate(v), Errors(value) {
      let response = schema["~standard"].validate(value);
      if (response instanceof Promise)
        throw Error("Async validation is not supported in non-dynamic schema");
      return response.issues;
    }, Code: () => "", Decode(value) {
      let response = schema["~standard"].validate(value);
      if (response instanceof Promise)
        throw Error("Async validation is not supported in non-dynamic schema");
      return response;
    }, Encode: (value) => value, hasAdditionalProperties: false, hasDefault: false, isOptional: false, hasTransform: false, hasRef: false };
  if (compiled.parse = (v) => {
    try {
      return compiled.Decode(compiled.Clean?.(v) ?? v);
    } catch (error) {
      throw [...compiled.Errors(v)].map(mapValueError);
    }
  }, compiled.safeParse = (v) => {
    try {
      return { success: true, data: compiled.Decode(compiled.Clean?.(v) ?? v), error: null };
    } catch (error) {
      let errors = [...compiled.Errors(v)].map(mapValueError);
      return { success: false, data: null, error: errors[0]?.summary, errors };
    }
  }, Kind in schema)
    Object.assign(compiled, { get hasAdditionalProperties() {
      if ("~hasAdditionalProperties" in this)
        return this["~hasAdditionalProperties"];
      return this["~hasAdditionalProperties"] = hasAdditionalProperties(compiled);
    }, get hasDefault() {
      if ("~hasDefault" in this)
        return this["~hasDefault"];
      return this["~hasDefault"] = hasProperty("default", compiled);
    }, get isOptional() {
      if ("~isOptional" in this)
        return this["~isOptional"];
      return this["~isOptional"] = isOptional(compiled);
    }, get hasTransform() {
      if ("~hasTransform" in this)
        return this["~hasTransform"];
      return this["~hasTransform"] = hasTransform(schema);
    }, get hasRef() {
      if ("~hasRef" in this)
        return this["~hasRef"];
      return this["~hasRef"] = hasRef(schema);
    }, "~hasRef": doesHaveRef });
  return compiled;
};
var isUnion = (schema) => schema[Kind] === "Union" || !schema.schema && !!schema.anyOf;
var mergeObjectSchemas = (schemas) => {
  if (schemas.length === 0)
    return { schema: undefined, notObjects: [] };
  if (schemas.length === 1)
    return schemas[0].type === "object" ? { schema: schemas[0], notObjects: [] } : { schema: undefined, notObjects: schemas };
  let newSchema, notObjects = [], additionalPropertiesIsTrue = false, additionalPropertiesIsFalse = false;
  for (let schema of schemas) {
    if (schema.type !== "object") {
      notObjects.push(schema);
      continue;
    }
    if ("additionalProperties" in schema) {
      if (schema.additionalProperties === true)
        additionalPropertiesIsTrue = true;
      else if (schema.additionalProperties === false)
        additionalPropertiesIsFalse = true;
    }
    if (!newSchema) {
      newSchema = schema;
      continue;
    }
    newSchema = { ...newSchema, ...schema, properties: { ...newSchema.properties, ...schema.properties }, required: [...newSchema?.required ?? [], ...schema.required ?? []] };
  }
  if (newSchema) {
    if (newSchema.required)
      newSchema.required = [...new Set(newSchema.required)];
    if (additionalPropertiesIsFalse)
      newSchema.additionalProperties = false;
    else if (additionalPropertiesIsTrue)
      newSchema.additionalProperties = true;
  }
  return { schema: newSchema, notObjects };
};
var getResponseSchemaValidator = (s, { models = {}, modules, dynamic = false, normalize = false, additionalProperties = false, validators = [], sanitize: sanitize2 }) => {
  if (validators = validators.filter((x2) => x2), !s) {
    if (!validators?.length)
      return;
    s = validators[0], validators = validators.slice(1);
  }
  let maybeSchemaOrRecord;
  if (typeof s !== "string")
    maybeSchemaOrRecord = s;
  else if (maybeSchemaOrRecord = modules && s in modules.$defs ? modules.Import(s) : models[s], !maybeSchemaOrRecord)
    return;
  if (!maybeSchemaOrRecord)
    return;
  if (Kind in maybeSchemaOrRecord || "~standard" in maybeSchemaOrRecord)
    return { 200: getSchemaValidator(maybeSchemaOrRecord, { modules, models, additionalProperties, dynamic, normalize, coerce: false, additionalCoerce: [], validators: validators.map((x2) => x2[200]), sanitize: sanitize2 }) };
  let record = {};
  return Object.keys(maybeSchemaOrRecord).forEach((status2) => {
    if (isNaN(+status2))
      return;
    let maybeNameOrSchema = maybeSchemaOrRecord[+status2];
    if (typeof maybeNameOrSchema === "string") {
      if (maybeNameOrSchema in models) {
        let schema = models[maybeNameOrSchema];
        if (!schema)
          return;
        record[+status2] = Kind in schema || "~standard" in schema ? getSchemaValidator(schema, { modules, models, additionalProperties, dynamic, normalize, coerce: false, additionalCoerce: [], validators: validators.map((x2) => x2[+status2]), sanitize: sanitize2 }) : schema;
      }
      return;
    }
    record[+status2] = Kind in maybeNameOrSchema || "~standard" in maybeNameOrSchema ? getSchemaValidator(maybeNameOrSchema, { modules, models, additionalProperties, dynamic, normalize, coerce: false, additionalCoerce: [], validators: validators.map((x2) => x2[+status2]), sanitize: sanitize2 }) : maybeNameOrSchema;
  }), record;
};
var _stringToStructureCoercions;
var stringToStructureCoercions = () => {
  if (!_stringToStructureCoercions)
    _stringToStructureCoercions = [{ from: t.Object({}), to: () => t.ObjectString({}), excludeRoot: true }, { from: t.Array(t.Any()), to: () => t.ArrayString(t.Any()) }];
  return _stringToStructureCoercions;
};
var _queryCoercions;
var queryCoercions = () => {
  if (!_queryCoercions)
    _queryCoercions = [{ from: t.Object({}), to: () => t.ObjectString({}), excludeRoot: true }, { from: t.Array(t.Any()), to: () => t.ArrayQuery(t.Any()) }];
  return _queryCoercions;
};
var _coercePrimitiveRoot;
var coercePrimitiveRoot = () => {
  if (!_coercePrimitiveRoot)
    _coercePrimitiveRoot = [{ from: t.Number(), to: (options) => t.Numeric(options), rootOnly: true }, { from: t.Boolean(), to: (options) => t.BooleanString(options), rootOnly: true }];
  return _coercePrimitiveRoot;
};
var getCookieValidator = ({ validator, modules, defaultConfig = {}, config, dynamic, normalize = false, models, validators, sanitize: sanitize2 }) => {
  let cookieValidator = validator?.provider ? validator : getSchemaValidator(validator, { modules, dynamic, models, normalize, additionalProperties: true, coerce: true, additionalCoerce: stringToStructureCoercions(), validators, sanitize: sanitize2 });
  if (cookieValidator)
    cookieValidator.config = mergeCookie(cookieValidator.config, config);
  else
    cookieValidator = getSchemaValidator(t.Cookie(t.Any()), { modules, dynamic, models, additionalProperties: true, validators, sanitize: sanitize2 }), cookieValidator.config = defaultConfig;
  return cookieValidator;
};
var unwrapImportSchema = (schema) => schema && schema[Kind] === "Import" && schema.$defs[schema.$ref][Kind] === "Object" ? schema.$defs[schema.$ref] : schema;
var allocateIf = (value, condition) => condition ? value : "";
var defaultParsers = ["json", "text", "urlencoded", "arrayBuffer", "formdata", "application/json", "text/plain", "application/x-www-form-urlencoded", "application/octet-stream", "multipart/form-data"];
var createReport = ({ context = "c", trace = [], addFn }) => {
  if (!trace.length)
    return () => {
      return { resolveChild() {
        return () => {};
      }, resolve() {} };
    };
  for (let i2 = 0;i2 < trace.length; i2++)
    addFn(`let report${i2},reportChild${i2},reportErr${i2},reportErrChild${i2};let trace${i2}=${context}[ELYSIA_TRACE]?.[${i2}]??trace[${i2}](${context});
`);
  return (event, { name, total = 0, alias } = {}) => {
    if (!name)
      name = "anonymous";
    let reporter = event === "error" ? "reportErr" : "report";
    for (let i2 = 0;i2 < trace.length; i2++)
      if (addFn(`${alias ? "const " : ""}${alias ?? reporter}${i2}=trace${i2}.${event}({id,event:'${event}',name:'${name}',begin:performance.now(),total:${total}})
`), alias)
        addFn(`${reporter}${i2}=${alias}${i2}
`);
    return { resolve() {
      for (let i2 = 0;i2 < trace.length; i2++)
        addFn(`${alias ?? reporter}${i2}.resolve()
`);
    }, resolveChild(name2) {
      for (let i2 = 0;i2 < trace.length; i2++)
        addFn(`${reporter}Child${i2}=${reporter}${i2}.resolveChild?.shift()?.({id,event:'${event}',name:'${name2}',begin:performance.now()})
`);
      return (binding) => {
        for (let i2 = 0;i2 < trace.length; i2++)
          if (binding)
            addFn(`if(${binding} instanceof Error){${reporter}Child${i2}?.(${binding}) }else{${reporter}Child${i2}?.()}`);
          else
            addFn(`${reporter}Child${i2}?.()
`);
      };
    } };
  };
};
var composeCleaner = ({ schema, name, type, typeAlias = type, normalize, ignoreTryCatch = false }) => {
  if (!normalize || !schema.Clean)
    return "";
  if (normalize === true || normalize === "exactMirror") {
    if (ignoreTryCatch)
      return `${name}=validator.${typeAlias}.Clean(${name})
`;
    return `try{${name}=validator.${typeAlias}.Clean(${name})
}catch{}`;
  }
  if (normalize === "typebox")
    return `${name}=validator.${typeAlias}.Clean(${name})
`;
  return "";
};
var composeValidationFactory = ({ injectResponse = "", normalize = false, validator, encodeSchema = false, isStaticResponse = false, hasSanitize = false, allowUnsafeValidationDetails = false }) => ({ validate: (type, value = `c.${type}`, error) => `c.set.status=422;throw new ValidationError('${type}',validator.${type},${value},${allowUnsafeValidationDetails}${error ? "," + error : ""})`, response: (name = "r") => {
  if (isStaticResponse || !validator.response)
    return "";
  let code = injectResponse + `
`;
  code += `if(${name} instanceof ElysiaCustomStatusResponse){c.set.status=${name}.code
${name}=${name}.response}if(${name} instanceof Response === false)switch(c.set.status){`;
  for (let [status2, value] of Object.entries(validator.response)) {
    if (code += `
case ${status2}:
`, value.provider === "standard") {
      code += `let vare${status2}=validator.response[${status2}].Check(${name})
if(vare${status2} instanceof Promise)vare${status2}=await vare${status2}
if(vare${status2}.issues)throw new ValidationError('response',validator.response[${status2}],${name},${allowUnsafeValidationDetails},vare${status2}.issues)
${name}=vare${status2}.value
c.set.status=${status2}
break
`;
      continue;
    }
    let noValidate = value.schema?.noValidate === true;
    if (!noValidate && value.schema?.$ref && value.schema?.$defs) {
      let refKey = value.schema.$ref, defKey = typeof refKey === "string" && refKey.includes("/") ? refKey.split("/").pop() : refKey;
      if (value.schema.$defs[defKey]?.noValidate === true)
        noValidate = true;
    }
    let appliedCleaner = noValidate || hasSanitize, clean2 = ({ ignoreTryCatch = false } = {}) => composeCleaner({ name, schema: value, type: "response", typeAlias: `response[${status2}]`, normalize, ignoreTryCatch });
    if (appliedCleaner)
      code += clean2();
    let applyErrorCleaner = !appliedCleaner && normalize && !noValidate;
    if (encodeSchema && value.hasTransform && !noValidate) {
      if (code += `try{${name}=validator.response[${status2}].Encode(${name})
`, !appliedCleaner)
        code += clean2({ ignoreTryCatch: true });
      code += `c.set.status=${status2}}catch{` + (applyErrorCleaner ? `try{
` + clean2({ ignoreTryCatch: true }) + `${name}=validator.response[${status2}].Encode(${name})
}catch{throw new ValidationError('response',validator.response[${status2}],${name},${allowUnsafeValidationDetails})}` : `throw new ValidationError('response',validator.response[${status2}],${name}),${allowUnsafeValidationDetails}`) + "}";
    } else {
      if (!appliedCleaner)
        code += clean2();
      if (!noValidate)
        code += `if(validator.response[${status2}].Check(${name})===false)throw new ValidationError('response',validator.response[${status2}],${name},${allowUnsafeValidationDetails})
c.set.status=${status2}
`;
    }
    code += `break
`;
  }
  return code + "}";
} });
var isAsyncName = (v) => {
  return (v?.fn ?? v).constructor.name === "AsyncFunction";
};
var matchResponseClone = /=>\s?response\.clone\(/;
var matchFnReturn = /(?:return|=>)\s?\S+\(|a(?:sync|wait)/;
var isAsync = (v) => {
  let isObject2 = typeof v === "object";
  if (isObject2 && v.isAsync !== undefined)
    return v.isAsync;
  let fn = isObject2 ? v.fn : v;
  if (fn.constructor.name === "AsyncFunction")
    return true;
  let literal = fn.toString();
  if (matchResponseClone.test(literal)) {
    if (isObject2)
      v.isAsync = false;
    return false;
  }
  let result = matchFnReturn.test(literal);
  if (isObject2)
    v.isAsync = result;
  return result;
};
var hasReturn = (v) => {
  let isObject2 = typeof v === "object";
  if (isObject2 && v.hasReturn !== undefined)
    return v.hasReturn;
  let fnLiteral = isObject2 ? v.fn.toString() : typeof v === "string" ? v.toString() : v, parenthesisEnd = fnLiteral.indexOf(")");
  if (fnLiteral.charCodeAt(parenthesisEnd + 2) === 61 && fnLiteral.charCodeAt(parenthesisEnd + 5) !== 123) {
    if (isObject2)
      v.hasReturn = true;
    return true;
  }
  let result = fnLiteral.includes("return");
  if (isObject2)
    v.hasReturn = result;
  return result;
};
var isGenerator = (v) => {
  let fn = v?.fn ?? v;
  return fn.constructor.name === "AsyncGeneratorFunction" || fn.constructor.name === "GeneratorFunction";
};
var coerceTransformDecodeError = (fnLiteral, type, allowUnsafeValidationDetails = false, value = `c.${type}`) => `try{${fnLiteral}}catch(error){if(error.constructor.name === 'TransformDecodeError'){c.set.status=422
throw error.error ?? new ValidationError('${type}',validator.${type},${value},${allowUnsafeValidationDetails})}}`;
var composeHandler = ({ app, path, method, hooks, validator, handler, allowMeta = false, inference }) => {
  let adapter = app["~adapter"].composeHandler, adapterHandler = app["~adapter"].handler, isHandleFn = typeof handler === "function";
  if (!isHandleFn) {
    handler = adapterHandler.mapResponse(handler, { headers: app.setHeaders ?? {} });
    let isResponse = handler instanceof Response || handler?.constructor?.name === "Response" && typeof handler?.clone === "function";
    if (hooks.parse?.length && hooks.transform?.length && hooks.beforeHandle?.length && hooks.afterHandle?.length) {
      if (isResponse)
        return Function("a", `"use strict";
return function(){return a.clone()}`)(handler);
      return Function("a", `"use strict";
return function(){return a}`)(handler);
    }
    if (isResponse) {
      let response = handler;
      handler = () => response.clone();
    }
  }
  let handle = isHandleFn ? "handler(c)" : "handler", hasTrace = !!hooks.trace?.length, fnLiteral = "";
  if (inference = sucrose(Object.assign({ handler }, hooks), inference, app.config.sucrose), adapter.declare) {
    let literal = adapter.declare(inference);
    if (literal)
      fnLiteral += literal;
  }
  if (inference.server)
    fnLiteral += `Object.defineProperty(c,'server',{get:function(){return getServer()}})
`;
  validator.createBody?.(), validator.createQuery?.(), validator.createHeaders?.(), validator.createParams?.(), validator.createCookie?.(), validator.createResponse?.();
  let hasValidation = !!validator.body || !!validator.headers || !!validator.params || !!validator.query || !!validator.cookie || !!validator.response, hasQuery = inference.query || !!validator.query, requestNoBody = hooks.parse?.length === 1 && hooks.parse[0].fn === "none", hasBody = method !== "" && method !== "GET" && method !== "HEAD" && (inference.body || !!validator.body || !!hooks.parse?.length) && !requestNoBody, defaultHeaders = app.setHeaders, hasDefaultHeaders = defaultHeaders && !!Object.keys(defaultHeaders).length, hasHeaders = inference.headers || !!validator.headers || adapter.preferWebstandardHeaders !== true && inference.body, hasCookie = inference.cookie || !!validator.cookie, cookieMeta = validator.cookie?.config ? mergeCookie(validator?.cookie?.config, app.config.cookie) : app.config.cookie, _encodeCookie = "", encodeCookie = () => {
    if (_encodeCookie)
      return _encodeCookie;
    if (cookieMeta?.sign) {
      if (!cookieMeta.secrets)
        throw Error(`t.Cookie required secret which is not set in (${method}) ${path}.`);
      let secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
      if (_encodeCookie += `const _setCookie = c.set.cookie
if(_setCookie){`, cookieMeta.sign === true)
        _encodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)){c.set.cookie[key].value=await signCookie(cookie.value,'${secret}')}`;
      else
        for (let name of cookieMeta.sign)
          _encodeCookie += `if(_setCookie['${name}']?.value)c.set.cookie['${name}'].value=await signCookie(_setCookie['${name}'].value,'${secret}')
`;
      _encodeCookie += `}
`;
    }
    return _encodeCookie;
  }, normalize = app.config.normalize, encodeSchema = app.config.encodeSchema, allowUnsafeValidationDetails = app.config.allowUnsafeValidationDetails, validation = composeValidationFactory({ normalize, validator, encodeSchema, isStaticResponse: handler instanceof Response, hasSanitize: !!app.config.sanitize, allowUnsafeValidationDetails });
  if (hasHeaders)
    fnLiteral += adapter.headers;
  if (hasTrace)
    fnLiteral += `const id=c[ELYSIA_REQUEST_ID]
`;
  let report = createReport({ trace: hooks.trace, addFn: (word) => {
    fnLiteral += word;
  } });
  if (fnLiteral += "try{", hasCookie) {
    let get = (name, defaultValue) => {
      let value = cookieMeta?.[name] ?? defaultValue;
      if (!value)
        return typeof defaultValue === "string" ? `${name}:"${defaultValue}",` : `${name}:${defaultValue},`;
      if (typeof value === "string")
        return `${name}:'${value}',`;
      if (value instanceof Date)
        return `${name}: new Date(${value.getTime()}),`;
      return `${name}:${value},`;
    }, options = cookieMeta ? `{secrets:${cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? `'${cookieMeta.secrets}'` : "[" + cookieMeta.secrets.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},sign:${cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? "[" + cookieMeta.sign.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},` + get("domain") + get("expires") + get("httpOnly") + get("maxAge") + get("path", "/") + get("priority") + get("sameSite") + get("secure") + "}" : "undefined";
    if (hasHeaders)
      fnLiteral += `
c.cookie=await parseCookie(c.set,c.headers.cookie,${options})
`;
    else
      fnLiteral += `
c.cookie=await parseCookie(c.set,c.request.headers.get('cookie'),${options})
`;
  }
  if (hasQuery) {
    let arrayProperties = {}, objectProperties = {}, hasArrayProperty = false, hasObjectProperty = false;
    if (validator.query?.schema) {
      let schema = unwrapImportSchema(validator.query?.schema);
      if (Kind in schema && schema.properties)
        for (let [key, value] of Object.entries(schema.properties)) {
          if (hasElysiaMeta("ArrayQuery", value))
            arrayProperties[key] = 1, hasArrayProperty = true;
          if (hasElysiaMeta("ObjectString", value))
            objectProperties[key] = 1, hasObjectProperty = true;
        }
    }
    fnLiteral += `if(c.qi===-1){c.query=Object.create(null)}else{c.query=parseQueryFromURL(c.url,c.qi+1,${hasArrayProperty ? JSON.stringify(arrayProperties) : undefined},${hasObjectProperty ? JSON.stringify(objectProperties) : undefined})}`;
  }
  let isAsyncHandler = typeof handler === "function" && isAsync(handler), saveResponse = hasTrace || hooks.afterResponse?.length ? "c.response=c.responseValue= " : "", responseKeys = Object.keys(validator.response ?? {}), hasMultipleResponses = responseKeys.length > 1, hasSingle200 = responseKeys.length === 0 || responseKeys.length === 1 && responseKeys[0] === "200", maybeAsync = hasCookie || hasBody || isAsyncHandler || !!hooks.parse?.length || !!hooks.afterHandle?.some(isAsync) || !!hooks.beforeHandle?.some(isAsync) || !!hooks.transform?.some(isAsync) || !!hooks.mapResponse?.some(isAsync) || validator.body?.provider === "standard" || validator.headers?.provider === "standard" || validator.query?.provider === "standard" || validator.params?.provider === "standard" || validator.cookie?.provider === "standard" || Object.values(validator.response ?? {}).find((x2) => x2.provider === "standard"), maybeStream = (typeof handler === "function" ? isGenerator(handler) : false) || !!hooks.beforeHandle?.some(isGenerator) || !!hooks.afterHandle?.some(isGenerator) || !!hooks.transform?.some(isGenerator), hasSet = inference.cookie || inference.set || hasHeaders || hasTrace || hasMultipleResponses || !hasSingle200 || isHandleFn && hasDefaultHeaders || maybeStream, _afterResponse, afterResponse = () => {
    if (_afterResponse !== undefined)
      return _afterResponse;
    if (!hooks.afterResponse?.length && !hasTrace)
      return "";
    let afterResponse2 = "";
    afterResponse2 += `
setImmediate(async()=>{if(c.responseValue){if(c.responseValue instanceof ElysiaCustomStatusResponse) c.set.status=c.responseValue.code
if(afterHandlerStreamListener)for await(const v of afterHandlerStreamListener){}
}
`;
    let reporter = createReport({ trace: hooks.trace, addFn: (word) => {
      afterResponse2 += word;
    } })("afterResponse", { total: hooks.afterResponse?.length });
    if (hooks.afterResponse?.length && hooks.afterResponse)
      for (let i2 = 0;i2 < hooks.afterResponse.length; i2++) {
        let endUnit = reporter.resolveChild(hooks.afterResponse[i2].fn.name), prefix = isAsync(hooks.afterResponse[i2]) ? "await " : "";
        afterResponse2 += `
${prefix}e.afterResponse[${i2}](c)
`, endUnit();
      }
    return reporter.resolve(), afterResponse2 += `})
`, _afterResponse = afterResponse2;
  }, mapResponse3 = (r = "r") => {
    let after = afterResponse(), response = `${hasSet ? "mapResponse" : "mapCompactResponse"}(${saveResponse}${r}${hasSet ? ",c.set" : ""}${mapResponseContext})
`;
    if (!after)
      return `return ${response}`;
    return `const _res=${response}` + after + "return _res";
  }, mapResponseContext = maybeStream || adapter.mapResponseContext ? `,${adapter.mapResponseContext}` : "";
  if (hasTrace || inference.route)
    fnLiteral += `c.route=\`${path}\`
`;
  if (hasTrace || hooks.afterResponse?.length)
    fnLiteral += `let afterHandlerStreamListener
`;
  let parseReporter = report("parse", { total: hooks.parse?.length });
  if (hasBody) {
    let hasBodyInference = !!hooks.parse?.length || inference.body || validator.body;
    if (adapter.parser.declare)
      fnLiteral += adapter.parser.declare;
    fnLiteral += `
try{`;
    let parser = typeof hooks.parse === "string" ? hooks.parse : Array.isArray(hooks.parse) && hooks.parse.length === 1 ? typeof hooks.parse[0] === "string" ? hooks.parse[0] : typeof hooks.parse[0].fn === "string" ? hooks.parse[0].fn : undefined : undefined;
    if (!parser && validator.body && !hooks.parse?.length) {
      let schema = validator.body.schema;
      if (schema && schema.anyOf && schema[Kind] === "Union" && schema.anyOf?.length === 2 && schema.anyOf?.find((x2) => x2[Kind] === "ElysiaForm"))
        parser = "formdata";
    }
    if (parser && defaultParsers.includes(parser)) {
      let reporter = report("parse", { total: hooks.parse?.length }), isOptionalBody = !!validator.body?.isOptional;
      switch (parser) {
        case "json":
        case "application/json":
          fnLiteral += adapter.parser.json(isOptionalBody);
          break;
        case "text":
        case "text/plain":
          fnLiteral += adapter.parser.text(isOptionalBody);
          break;
        case "urlencoded":
        case "application/x-www-form-urlencoded":
          fnLiteral += adapter.parser.urlencoded(isOptionalBody);
          break;
        case "arrayBuffer":
        case "application/octet-stream":
          fnLiteral += adapter.parser.arrayBuffer(isOptionalBody);
          break;
        case "formdata":
        case "multipart/form-data":
          fnLiteral += adapter.parser.formData(isOptionalBody);
          break;
        default:
          if (parser[0] in app["~parser"])
            fnLiteral += hasHeaders ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", fnLiteral += `
if(contentType){const index=contentType.indexOf(';')
if(index!==-1)contentType=contentType.substring(0,index)}
else{contentType=''}c.contentType=contentType
let result=parser['${parser}'](c, contentType)
if(result instanceof Promise)result=await result
if(result instanceof ElysiaCustomStatusResponse)throw result
if(result!==undefined)c.body=result
delete c.contentType
`;
          break;
      }
      reporter.resolve();
    } else if (hasBodyInference) {
      fnLiteral += `
`, fnLiteral += `let contentType
if(c.request.body)`, fnLiteral += hasHeaders ? `contentType=c.headers['content-type']
` : `contentType=c.request.headers.get('content-type')
`;
      let hasDefaultParser = false;
      if (hooks.parse?.length)
        fnLiteral += `if(contentType){
const index=contentType.indexOf(';')

if(index!==-1)contentType=contentType.substring(0,index)}else{contentType=''}let used=false
c.contentType=contentType
`;
      else {
        hasDefaultParser = true;
        let isOptionalBody = !!validator.body?.isOptional;
        fnLiteral += `if(contentType)switch(contentType.charCodeAt(12)){
case 106:` + adapter.parser.json(isOptionalBody) + `break
case 120:` + adapter.parser.urlencoded(isOptionalBody) + `break
case 111:` + adapter.parser.arrayBuffer(isOptionalBody) + `break
case 114:` + adapter.parser.formData(isOptionalBody) + `break
default:if(contentType.charCodeAt(0)===116){` + adapter.parser.text(isOptionalBody) + `}break
}`;
      }
      let reporter = report("parse", { total: hooks.parse?.length });
      if (hooks.parse)
        for (let i2 = 0;i2 < hooks.parse.length; i2++) {
          let name = `bo${i2}`;
          if (i2 !== 0)
            fnLiteral += `
if(!used){`;
          if (typeof hooks.parse[i2].fn === "string") {
            let endUnit = reporter.resolveChild(hooks.parse[i2].fn), isOptionalBody = !!validator.body?.isOptional;
            switch (hooks.parse[i2].fn) {
              case "json":
              case "application/json":
                hasDefaultParser = true, fnLiteral += adapter.parser.json(isOptionalBody);
                break;
              case "text":
              case "text/plain":
                hasDefaultParser = true, fnLiteral += adapter.parser.text(isOptionalBody);
                break;
              case "urlencoded":
              case "application/x-www-form-urlencoded":
                hasDefaultParser = true, fnLiteral += adapter.parser.urlencoded(isOptionalBody);
                break;
              case "arrayBuffer":
              case "application/octet-stream":
                hasDefaultParser = true, fnLiteral += adapter.parser.arrayBuffer(isOptionalBody);
                break;
              case "formdata":
              case "multipart/form-data":
                hasDefaultParser = true, fnLiteral += adapter.parser.formData(isOptionalBody);
                break;
              default:
                fnLiteral += `let ${name}=parser['${hooks.parse[i2].fn}'](c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true;}
`;
            }
            endUnit();
          } else {
            let endUnit = reporter.resolveChild(hooks.parse[i2].fn.name);
            fnLiteral += `let ${name}=e.parse[${i2}]
${name}=${name}(c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true}`, endUnit();
          }
          if (i2 !== 0)
            fnLiteral += "}";
          if (hasDefaultParser)
            break;
        }
      if (reporter.resolve(), !hasDefaultParser) {
        let isOptionalBody = !!validator.body?.isOptional;
        if (hooks.parse?.length)
          fnLiteral += `
if(!used){
`;
        fnLiteral += `switch(contentType){case 'application/json':
` + adapter.parser.json(isOptionalBody) + `break
case 'text/plain':` + adapter.parser.text(isOptionalBody) + `break
case 'application/x-www-form-urlencoded':` + adapter.parser.urlencoded(isOptionalBody) + `break
case 'application/octet-stream':` + adapter.parser.arrayBuffer(isOptionalBody) + `break
case 'multipart/form-data':` + adapter.parser.formData(isOptionalBody) + `break
`;
        for (let key of Object.keys(app["~parser"]))
          fnLiteral += `case '${key}':let bo${key}=parser['${key}'](c,contentType)
if(bo${key} instanceof Promise)bo${key}=await bo${key}
if(bo${key} instanceof ElysiaCustomStatusResponse){` + mapResponse3(`bo${key}`) + `}if(bo${key}!==undefined)c.body=bo${key}
break
`;
        if (hooks.parse?.length)
          fnLiteral += "}";
        fnLiteral += "}";
      }
      if (hooks.parse?.length)
        fnLiteral += `
delete c.contentType`;
    }
    fnLiteral += "}catch(error){throw new ParseError(error)}";
  }
  if (parseReporter.resolve(), hooks?.transform || hasTrace) {
    let reporter = report("transform", { total: hooks.transform?.length });
    if (hooks.transform?.length) {
      fnLiteral += `let transformed
`;
      for (let i2 = 0;i2 < hooks.transform.length; i2++) {
        let transform2 = hooks.transform[i2], endUnit = reporter.resolveChild(transform2.fn.name);
        if (fnLiteral += isAsync(transform2) ? `transformed=await e.transform[${i2}](c)
` : `transformed=e.transform[${i2}](c)
`, transform2.subType === "mapDerive")
          fnLiteral += "if(transformed instanceof ElysiaCustomStatusResponse){" + mapResponse3("transformed") + `}else{transformed.request=c.request
transformed.store=c.store
transformed.qi=c.qi
transformed.path=c.path
transformed.url=c.url
transformed.redirect=c.redirect
transformed.set=c.set
transformed.error=c.error
c=transformed}`;
        else
          fnLiteral += "if(transformed instanceof ElysiaCustomStatusResponse){" + mapResponse3("transformed") + `}else Object.assign(c,transformed)
`;
        endUnit();
      }
    }
    reporter.resolve();
  }
  let fileUnions = [];
  if (validator) {
    if (validator.headers) {
      if (validator.headers.hasDefault)
        for (let [key, value] of Object.entries(exports_value2.Default(validator.headers.schema, {}))) {
          let parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
          if (parsed !== undefined)
            fnLiteral += `c.headers['${key}']??=${parsed}
`;
        }
      if (fnLiteral += composeCleaner({ name: "c.headers", schema: validator.headers, type: "headers", normalize }), validator.headers.isOptional)
        fnLiteral += "if(isNotEmpty(c.headers)){";
      if (validator.headers?.provider === "standard")
        fnLiteral += `let vah=validator.headers.Check(c.headers)
if(vah instanceof Promise)vah=await vah
if(vah.issues){` + validation.validate("headers", undefined, "vah.issues") + `}else{c.headers=vah.value}
`;
      else if (validator.headers?.schema?.noValidate !== true)
        fnLiteral += "if(validator.headers.Check(c.headers) === false){" + validation.validate("headers") + "}";
      if (validator.headers.hasTransform)
        fnLiteral += coerceTransformDecodeError(`c.headers=validator.headers.Decode(c.headers)
`, "headers", allowUnsafeValidationDetails);
      if (validator.headers.isOptional)
        fnLiteral += "}";
    }
    if (validator.params) {
      if (validator.params.hasDefault)
        for (let [key, value] of Object.entries(exports_value2.Default(validator.params.schema, {}))) {
          let parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
          if (parsed !== undefined)
            fnLiteral += `c.params['${key}']??=${parsed}
`;
        }
      if (validator.params.provider === "standard")
        fnLiteral += `let vap=validator.params.Check(c.params)
if(vap instanceof Promise)vap=await vap
if(vap.issues){` + validation.validate("params", undefined, "vap.issues") + `}else{c.params=vap.value}
`;
      else if (validator.params?.schema?.noValidate !== true)
        fnLiteral += "if(validator.params.Check(c.params)===false){" + validation.validate("params") + "}";
      if (validator.params.hasTransform)
        fnLiteral += coerceTransformDecodeError(`c.params=validator.params.Decode(c.params)
`, "params", allowUnsafeValidationDetails);
    }
    if (validator.query) {
      if (Kind in validator.query?.schema && validator.query.hasDefault)
        for (let [key, value] of Object.entries(exports_value2.Default(validator.query.schema, {}))) {
          let parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
          if (parsed !== undefined)
            fnLiteral += `if(c.query['${key}']===undefined)c.query['${key}']=${parsed}
`;
        }
      if (fnLiteral += composeCleaner({ name: "c.query", schema: validator.query, type: "query", normalize }), validator.query.isOptional)
        fnLiteral += "if(isNotEmpty(c.query)){";
      if (validator.query.provider === "standard")
        fnLiteral += `let vaq=validator.query.Check(c.query)
if(vaq instanceof Promise)vaq=await vaq
if(vaq.issues){` + validation.validate("query", undefined, "vaq.issues") + `}else{c.query=vaq.value}
`;
      else if (validator.query?.schema?.noValidate !== true)
        fnLiteral += "if(validator.query.Check(c.query)===false){" + validation.validate("query") + "}";
      if (validator.query.hasTransform)
        fnLiteral += coerceTransformDecodeError(`c.query=validator.query.Decode(c.query)
`, "query", allowUnsafeValidationDetails), fnLiteral += coerceTransformDecodeError(`c.query=validator.query.Decode(c.query)
`, "query", allowUnsafeValidationDetails);
      if (validator.query.isOptional)
        fnLiteral += "}";
    }
    if (hasBody && validator.body) {
      if (validator.body.hasTransform || validator.body.isOptional)
        fnLiteral += `const isNotEmptyObject=c.body&&(typeof c.body==="object"&&(isNotEmpty(c.body)||c.body instanceof ArrayBuffer))
`;
      let hasUnion = isUnion(validator.body.schema), hasNonUnionFileWithDefault = false;
      if (validator.body.hasDefault) {
        let value = exports_value2.Default(validator.body.schema, validator.body.schema.type === "object" || unwrapImportSchema(validator.body.schema)[Kind] === "Object" ? {} : undefined), schema = unwrapImportSchema(validator.body.schema);
        if (!hasUnion && value && typeof value === "object" && (hasType("File", schema) || hasType("Files", schema))) {
          hasNonUnionFileWithDefault = true;
          for (let [k2, v] of Object.entries(value))
            if (v === "File" || v === "Files")
              delete value[k2];
          if (!isNotEmpty(value))
            value = undefined;
        }
        let parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
        if (value !== undefined && value !== null)
          if (Array.isArray(value))
            fnLiteral += `if(!c.body)c.body=${parsed}
`;
          else if (typeof value === "object")
            fnLiteral += `c.body=Object.assign(${parsed},c.body)
`;
          else
            fnLiteral += `c.body=${parsed}
`;
        if (fnLiteral += composeCleaner({ name: "c.body", schema: validator.body, type: "body", normalize }), validator.body.provider === "standard")
          fnLiteral += `let vab=validator.body.Check(c.body)
if(vab instanceof Promise)vab=await vab
if(vab.issues){` + validation.validate("body", undefined, "vab.issues") + `}else{c.body=vab.value}
`;
        else if (validator.body?.schema?.noValidate !== true)
          if (validator.body.isOptional)
            fnLiteral += "if(isNotEmptyObject&&validator.body.Check(c.body)===false){" + validation.validate("body") + "}";
          else
            fnLiteral += "if(validator.body.Check(c.body)===false){" + validation.validate("body") + "}";
      } else if (fnLiteral += composeCleaner({ name: "c.body", schema: validator.body, type: "body", normalize }), validator.body.provider === "standard")
        fnLiteral += `let vab=validator.body.Check(c.body)
if(vab instanceof Promise)vab=await vab
if(vab.issues){` + validation.validate("body", undefined, "vab.issues") + `}else{c.body=vab.value}
`;
      else if (validator.body?.schema?.noValidate !== true)
        if (validator.body.isOptional)
          fnLiteral += "if(isNotEmptyObject&&validator.body.Check(c.body)===false){" + validation.validate("body") + "}";
        else
          fnLiteral += "if(validator.body.Check(c.body)===false){" + validation.validate("body") + "}";
      if (validator.body.hasTransform)
        fnLiteral += coerceTransformDecodeError(`if(isNotEmptyObject)c.body=validator.body.Decode(c.body)
`, "body", allowUnsafeValidationDetails);
      if (hasUnion && validator.body.schema.anyOf?.length) {
        let iterator = Object.values(validator.body.schema.anyOf);
        for (let i2 = 0;i2 < iterator.length; i2++) {
          let type = iterator[i2];
          if (hasType("File", type) || hasType("Files", type)) {
            let candidate = getSchemaValidator(type, { modules: app.definitions.typebox, dynamic: !app.config.aot, models: app.definitions.type, normalize: app.config.normalize, additionalCoerce: coercePrimitiveRoot(), sanitize: () => app.config.sanitize });
            if (candidate) {
              let isFirst = fileUnions.length === 0, iterator2 = Object.entries(type.properties), validator2 = isFirst ? `
` : " else ";
              validator2 += `if(fileUnions[${fileUnions.length}].Check(c.body)){`;
              let validateFile2 = "", validatorLength = 0;
              for (let i22 = 0;i22 < iterator2.length; i22++) {
                let [k2, v] = iterator2[i22];
                if (!v.extension || v[Kind] !== "File" && v[Kind] !== "Files")
                  continue;
                if (validatorLength)
                  validateFile2 += ",";
                validateFile2 += `fileType(c.body.${k2},${JSON.stringify(v.extension)},'body.${k2}')`, validatorLength++;
              }
              if (validateFile2) {
                if (validatorLength === 1)
                  validator2 += `await ${validateFile2}
`;
                else if (validatorLength > 1)
                  validator2 += `await Promise.all([${validateFile2}])
`;
                validator2 += "}", fnLiteral += validator2, fileUnions.push(candidate);
              }
            }
          }
        }
      } else if (hasNonUnionFileWithDefault || !hasUnion && (hasType("File", unwrapImportSchema(validator.body.schema)) || hasType("Files", unwrapImportSchema(validator.body.schema)))) {
        let validateFile2 = "", i2 = 0;
        for (let [k2, v] of Object.entries(unwrapImportSchema(validator.body.schema).properties)) {
          if (!v.extension || v[Kind] !== "File" && v[Kind] !== "Files")
            continue;
          if (i2)
            validateFile2 += ",";
          validateFile2 += `fileType(c.body.${k2},${JSON.stringify(v.extension)},'body.${k2}')`, i2++;
        }
        if (i2)
          fnLiteral += `
`;
        if (i2 === 1)
          fnLiteral += `await ${validateFile2}
`;
        else if (i2 > 1)
          fnLiteral += `await Promise.all([${validateFile2}])
`;
      }
    }
    if (validator.cookie) {
      if (validator.cookie.config = mergeCookie(validator.cookie.config, validator.cookie?.config ?? {}), fnLiteral += `let cookieValue={}
for(const [key,value] of Object.entries(c.cookie))cookieValue[key]=value.value
`, validator.cookie.isOptional)
        fnLiteral += "if(isNotEmpty(c.cookie)){";
      if (validator.cookie.provider === "standard")
        fnLiteral += `let vac=validator.cookie.Check(cookieValue)
if(vac instanceof Promise)vac=await vac
if(vac.issues){` + validation.validate("cookie", undefined, "vac.issues") + `}else{cookieValue=vac.value}
`, fnLiteral += `for(const k of Object.keys(cookieValue))c.cookie[k].value=cookieValue[k]
`;
      else if (validator.body?.schema?.noValidate !== true) {
        if (fnLiteral += "if(validator.cookie.Check(cookieValue)===false){" + validation.validate("cookie", "cookieValue") + "}", validator.cookie.hasTransform)
          fnLiteral += coerceTransformDecodeError("for(const [key,value] of Object.entries(validator.cookie.Decode(cookieValue))){c.cookie[key].value=value}", "cookie", allowUnsafeValidationDetails);
      }
      if (validator.cookie.isOptional)
        fnLiteral += "}";
    }
  }
  if (hooks?.beforeHandle || hasTrace) {
    let reporter = report("beforeHandle", { total: hooks.beforeHandle?.length }), hasResolve = false;
    if (hooks.beforeHandle?.length)
      for (let i2 = 0;i2 < hooks.beforeHandle.length; i2++) {
        let beforeHandle = hooks.beforeHandle[i2], endUnit = reporter.resolveChild(beforeHandle.fn.name), returning = hasReturn(beforeHandle);
        if (beforeHandle.subType === "resolve" || beforeHandle.subType === "mapResolve") {
          if (!hasResolve)
            hasResolve = true, fnLiteral += `
let resolved
`;
          if (fnLiteral += isAsync(beforeHandle) ? `resolved=await e.beforeHandle[${i2}](c);
` : `resolved=e.beforeHandle[${i2}](c);
`, beforeHandle.subType === "mapResolve")
            fnLiteral += "if(resolved instanceof ElysiaCustomStatusResponse){" + mapResponse3("resolved") + `}else{resolved.request=c.request
resolved.store=c.store
resolved.qi=c.qi
resolved.path=c.path
resolved.url=c.url
resolved.redirect=c.redirect
resolved.set=c.set
resolved.error=c.error
c=resolved}`;
          else
            fnLiteral += "if(resolved instanceof ElysiaCustomStatusResponse){" + mapResponse3("resolved") + `}else Object.assign(c, resolved)
`;
          endUnit();
        } else if (!returning)
          fnLiteral += isAsync(beforeHandle) ? `await e.beforeHandle[${i2}](c)
` : `e.beforeHandle[${i2}](c)
`, endUnit();
        else {
          if (fnLiteral += isAsync(beforeHandle) ? `be=await e.beforeHandle[${i2}](c)
` : `be=e.beforeHandle[${i2}](c)
`, endUnit("be"), fnLiteral += "if(be!==undefined){", reporter.resolve(), hooks.afterHandle?.length || hasTrace) {
            report("handle", { name: isHandleFn ? handler.name : undefined }).resolve();
            let reporter2 = report("afterHandle", { total: hooks.afterHandle?.length });
            if (hooks.afterHandle?.length)
              for (let i22 = 0;i22 < hooks.afterHandle.length; i22++) {
                let hook = hooks.afterHandle[i22], returning2 = hasReturn(hook), endUnit2 = reporter2.resolveChild(hook.fn.name);
                if (fnLiteral += `c.response=c.responseValue=be
`, !returning2)
                  fnLiteral += isAsync(hook.fn) ? `await e.afterHandle[${i22}](c, be)
` : `e.afterHandle[${i22}](c, be)
`;
                else
                  fnLiteral += isAsync(hook.fn) ? `af=await e.afterHandle[${i22}](c)
` : `af=e.afterHandle[${i22}](c)
`, fnLiteral += `if(af!==undefined) c.response=c.responseValue=be=af
`;
                endUnit2("af");
              }
            reporter2.resolve();
          }
          if (validator.response)
            fnLiteral += validation.response("be");
          let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
          if (hooks.mapResponse?.length) {
            fnLiteral += `c.response=c.responseValue=be
`;
            for (let i22 = 0;i22 < hooks.mapResponse.length; i22++) {
              let mapResponse4 = hooks.mapResponse[i22], endUnit2 = mapResponseReporter.resolveChild(mapResponse4.fn.name);
              fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse4) ? "await " : ""}e.mapResponse[${i22}](c)
if(mr!==undefined)be=c.response=c.responseValue=mr}`, endUnit2();
            }
          }
          mapResponseReporter.resolve(), fnLiteral += afterResponse(), fnLiteral += encodeCookie(), fnLiteral += `return mapEarlyResponse(${saveResponse}be,c.set${mapResponseContext})}
`;
        }
      }
    reporter.resolve();
  }
  function reportHandler(name) {
    let handleReporter = report("handle", { name, alias: "reportHandler" });
    return () => {
      if (hasTrace)
        fnLiteral += 'if(r&&(r[Symbol.iterator]||r[Symbol.asyncIterator])&&typeof r.next==="function"){' + (maybeAsync ? "" : "(async()=>{") + `const stream=await tee(r,3)
r=stream[0]
const listener=stream[1]
` + (hasTrace || hooks.afterResponse?.length ? `afterHandlerStreamListener=stream[2]
` : "") + `setImmediate(async ()=>{if(listener)for await(const v of listener){}
`, handleReporter.resolve(), fnLiteral += "})" + (maybeAsync ? "" : "})()") + "}else{", handleReporter.resolve(), fnLiteral += `}
`;
    };
  }
  if (hooks.afterHandle?.length || hasTrace) {
    let resolveHandler = reportHandler(isHandleFn ? handler.name : undefined);
    if (hooks.afterHandle?.length)
      fnLiteral += isAsyncHandler ? `let r=c.response=c.responseValue=await ${handle}
` : `let r=c.response=c.responseValue=${handle}
`;
    else
      fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`;
    resolveHandler();
    let reporter = report("afterHandle", { total: hooks.afterHandle?.length });
    if (hooks.afterHandle?.length)
      for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
        let hook = hooks.afterHandle[i2], returning = hasReturn(hook), endUnit = reporter.resolveChild(hook.fn.name);
        if (!returning)
          fnLiteral += isAsync(hook.fn) ? `await e.afterHandle[${i2}](c)
` : `e.afterHandle[${i2}](c)
`, endUnit();
        else if (fnLiteral += isAsync(hook.fn) ? `af=await e.afterHandle[${i2}](c)
` : `af=e.afterHandle[${i2}](c)
`, endUnit("af"), validator.response)
          fnLiteral += "if(af!==undefined){", reporter.resolve(), fnLiteral += validation.response("af"), fnLiteral += "c.response=c.responseValue=af}";
        else
          fnLiteral += "if(af!==undefined){", reporter.resolve(), fnLiteral += "c.response=c.responseValue=af}";
      }
    if (reporter.resolve(), hooks.afterHandle?.length)
      fnLiteral += `r=c.response
`;
    if (validator.response)
      fnLiteral += validation.response();
    fnLiteral += encodeCookie();
    let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
    if (hooks.mapResponse?.length)
      for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
        let mapResponse4 = hooks.mapResponse[i2], endUnit = mapResponseReporter.resolveChild(mapResponse4.fn.name);
        fnLiteral += `mr=${isAsyncName(mapResponse4) ? "await " : ""}e.mapResponse[${i2}](c)
if(mr!==undefined)r=c.response=c.responseValue=mr
`, endUnit();
      }
    mapResponseReporter.resolve(), fnLiteral += mapResponse3();
  } else {
    let resolveHandler = reportHandler(isHandleFn ? handler.name : undefined);
    if (validator.response || hooks.mapResponse?.length || hasTrace) {
      if (fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`, resolveHandler(), validator.response)
        fnLiteral += validation.response();
      let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
      if (hooks.mapResponse?.length) {
        fnLiteral += `
c.response=c.responseValue=r
`;
        for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
          let mapResponse4 = hooks.mapResponse[i2], endUnit = mapResponseReporter.resolveChild(mapResponse4.fn.name);
          fnLiteral += `
if(mr===undefined){mr=${isAsyncName(mapResponse4) ? "await " : ""}e.mapResponse[${i2}](c)
if(mr!==undefined)r=c.response=c.responseValue=mr}
`, endUnit();
        }
      }
      if (mapResponseReporter.resolve(), fnLiteral += encodeCookie(), handler instanceof Response)
        fnLiteral += afterResponse(), fnLiteral += inference.set ? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})
else return ${handle}.clone()` : `return ${handle}.clone()`, fnLiteral += `
`;
      else
        fnLiteral += mapResponse3();
    } else if (hasCookie || hasTrace) {
      fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`, resolveHandler();
      let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
      if (hooks.mapResponse?.length) {
        fnLiteral += `c.response=c.responseValue= r
`;
        for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
          let mapResponse4 = hooks.mapResponse[i2], endUnit = mapResponseReporter.resolveChild(mapResponse4.fn.name);
          fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse4) ? "await " : ""}e.mapResponse[${i2}](c)
if(mr!==undefined)r=c.response=c.responseValue=mr}`, endUnit();
        }
      }
      mapResponseReporter.resolve(), fnLiteral += encodeCookie() + mapResponse3();
    } else {
      resolveHandler();
      let handled = isAsyncHandler ? `await ${handle}` : handle;
      if (handler instanceof Response)
        fnLiteral += afterResponse(), fnLiteral += inference.set ? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})
else return ${handle}.clone()
` : `return ${handle}.clone()
`;
      else
        fnLiteral += mapResponse3(handled);
    }
  }
  if (fnLiteral += `
}catch(error){`, !maybeAsync && hooks.error?.length)
    fnLiteral += "return(async()=>{";
  if (fnLiteral += `const set=c.set
if(!set.status||set.status<300)set.status=error?.status||500
`, hasCookie)
    fnLiteral += encodeCookie();
  if (hasTrace && hooks.trace)
    for (let i2 = 0;i2 < hooks.trace.length; i2++)
      fnLiteral += `report${i2}?.resolve(error);reportChild${i2}?.(error)
`;
  let errorReporter = report("error", { total: hooks.error?.length });
  if (hooks.error?.length) {
    if (fnLiteral += `c.error=error
`, hasValidation)
      fnLiteral += `if(error instanceof TypeBoxError){c.code="VALIDATION"
c.set.status=422}else{c.code=error.code??error[ERROR_CODE]??"UNKNOWN"}`;
    else
      fnLiteral += `c.code=error.code??error[ERROR_CODE]??"UNKNOWN"
`;
    if (fnLiteral += `let er
`, hooks.mapResponse?.length)
      fnLiteral += `let mep
`;
    for (let i2 = 0;i2 < hooks.error.length; i2++) {
      let endUnit = errorReporter.resolveChild(hooks.error[i2].fn.name);
      if (isAsync(hooks.error[i2]))
        fnLiteral += `er=await e.error[${i2}](c)
`;
      else
        fnLiteral += `er=e.error[${i2}](c)
if(er instanceof Promise)er=await er
`;
      if (endUnit(), hooks.mapResponse?.length) {
        let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
        for (let i22 = 0;i22 < hooks.mapResponse.length; i22++) {
          let mapResponse4 = hooks.mapResponse[i22], endUnit2 = mapResponseReporter.resolveChild(mapResponse4.fn.name);
          fnLiteral += `c.response=c.responseValue=er
mep=e.mapResponse[${i22}](c)
if(mep instanceof Promise)er=await er
if(mep!==undefined)er=mep
`, endUnit2();
        }
        mapResponseReporter.resolve();
      }
      if (fnLiteral += `er=mapEarlyResponse(er,set${mapResponseContext})
`, fnLiteral += "if(er){", hasTrace && hooks.trace) {
        for (let i22 = 0;i22 < hooks.trace.length; i22++)
          fnLiteral += `report${i22}.resolve()
`;
        errorReporter.resolve();
      }
      fnLiteral += "return er}";
    }
  }
  if (errorReporter.resolve(), fnLiteral += "return handleError(c,error,true)", !maybeAsync && hooks.error?.length)
    fnLiteral += "})()";
  fnLiteral += "}";
  let adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "", init = "const {handler,handleError,hooks:e, " + allocateIf("validator,", hasValidation) + "mapResponse,mapCompactResponse,mapEarlyResponse,isNotEmpty,utils:{" + allocateIf("parseQuery,", hasBody) + allocateIf("parseQueryFromURL,", hasQuery) + "},error:{" + allocateIf("ValidationError,", hasValidation) + allocateIf("ParseError", hasBody) + "},fileType,schema,definitions,tee,ERROR_CODE," + allocateIf("parseCookie,", hasCookie) + allocateIf("signCookie,", hasCookie) + allocateIf("decodeURIComponent,", hasQuery) + "ElysiaCustomStatusResponse," + allocateIf("ELYSIA_TRACE,", hasTrace) + allocateIf("ELYSIA_REQUEST_ID,", hasTrace) + allocateIf("parser,", hooks.parse?.length) + allocateIf("getServer,", inference.server) + allocateIf("fileUnions,", fileUnions.length) + adapterVariables + allocateIf("TypeBoxError", hasValidation) + `}=hooks
const trace=e.trace
return ${maybeAsync ? "async " : ""}function handle(c){`;
  if (hooks.beforeHandle?.length)
    init += `let be
`;
  if (hooks.afterHandle?.length)
    init += `let af
`;
  if (hooks.mapResponse?.length)
    init += `let mr
`;
  if (allowMeta)
    init += `c.schema=schema
c.defs=definitions
`;
  fnLiteral = init + fnLiteral + "}", init = "";
  try {
    return Function("hooks", `"use strict";
` + fnLiteral)({ handler, hooks: lifeCycleToFn(hooks), validator: hasValidation ? validator : undefined, handleError: app.handleError, mapResponse: adapterHandler.mapResponse, mapCompactResponse: adapterHandler.mapCompactResponse, mapEarlyResponse: adapterHandler.mapEarlyResponse, isNotEmpty, utils: { parseQuery: hasBody ? parseQuery : undefined, parseQueryFromURL: hasQuery ? validator.query?.provider === "standard" ? parseQueryStandardSchema : parseQueryFromURL : undefined }, error: { ValidationError: hasValidation ? ValidationError : undefined, ParseError: hasBody ? ParseError2 : undefined }, fileType, schema: app.router.history, definitions: app.definitions.type, tee, ERROR_CODE, parseCookie: hasCookie ? parseCookie : undefined, signCookie: hasCookie ? signCookie : undefined, decodeURIComponent: hasQuery ? import_fast_decode_uri_component3.default : undefined, ElysiaCustomStatusResponse, ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined, ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined, getServer: inference.server ? () => app.getServer() : undefined, fileUnions: fileUnions.length ? fileUnions : undefined, TypeBoxError: hasValidation ? TypeBoxError : undefined, parser: app["~parser"], ...adapter.inject });
  } catch (error) {
    let debugHooks = lifeCycleToFn(hooks);
    console.log("[Composer] failed to generate optimized handler"), console.log("---"), console.log({ handler: typeof handler === "function" ? handler.toString() : handler, instruction: fnLiteral, hooks: { ...debugHooks, transform: debugHooks?.transform?.map?.((x2) => x2.toString()), resolve: debugHooks?.resolve?.map?.((x2) => x2.toString()), beforeHandle: debugHooks?.beforeHandle?.map?.((x2) => x2.toString()), afterHandle: debugHooks?.afterHandle?.map?.((x2) => x2.toString()), mapResponse: debugHooks?.mapResponse?.map?.((x2) => x2.toString()), parse: debugHooks?.parse?.map?.((x2) => x2.toString()), error: debugHooks?.error?.map?.((x2) => x2.toString()), afterResponse: debugHooks?.afterResponse?.map?.((x2) => x2.toString()), stop: debugHooks?.stop?.map?.((x2) => x2.toString()) }, validator, definitions: app.definitions.type, error }), console.log("---"), process.exit(1);
  }
};
var createOnRequestHandler = (app, addFn) => {
  let fnLiteral = "", reporter = createReport({ trace: app.event.trace, addFn: addFn ?? ((word) => {
    fnLiteral += word;
  }) })("request", { total: app.event.request?.length });
  if (app.event.request?.length) {
    fnLiteral += "try{";
    for (let i2 = 0;i2 < app.event.request.length; i2++) {
      let hook = app.event.request[i2], withReturn = hasReturn(hook), maybeAsync = isAsync(hook), endUnit = reporter.resolveChild(app.event.request[i2].fn.name);
      if (withReturn)
        fnLiteral += `re=mapEarlyResponse(${maybeAsync ? "await " : ""}onRequest[${i2}](c),c.set)
`, endUnit("re"), fnLiteral += `if(re!==undefined)return re
`;
      else
        fnLiteral += `${maybeAsync ? "await " : ""}onRequest[${i2}](c)
`, endUnit();
    }
    fnLiteral += "}catch(error){return app.handleError(c,error,false)}";
  }
  return reporter.resolve(), fnLiteral;
};
var createHoc = (app, fnName = "map") => {
  let hoc = app.extender.higherOrderFunctions;
  if (!hoc.length)
    return "return " + fnName;
  let adapter = app["~adapter"].composeGeneralHandler, handler = fnName;
  for (let i2 = 0;i2 < hoc.length; i2++)
    handler = `hoc[${i2}](${handler},${adapter.parameters})`;
  return `return function hocMap(${adapter.parameters}){return ${handler}(${adapter.parameters})}`;
};
var composeGeneralHandler = (app) => {
  let adapter = app["~adapter"].composeGeneralHandler;
  app.router.http.build();
  let isWebstandard = app["~adapter"].isWebStandard, hasTrace = app.event.trace?.length, fnLiteral = "", router = app.router, findDynamicRoute = router.http.root.WS ? "const route=router.find(r.method==='GET'&&r.headers.get('upgrade')==='websocket'?'WS':r.method,p)" : "const route=router.find(r.method,p)";
  if (findDynamicRoute += router.http.root.ALL ? `??router.find('ALL',p)
` : `
`, isWebstandard)
    findDynamicRoute += `if(r.method==='HEAD'){const route=router.find('GET',p)
if(route){c.params=route.params
const _res=route.store.handler?route.store.handler(c):route.store.compile()(c)
if(_res)return getResponseLength(_res).then((length)=>{_res.headers.set('content-length', length)
return new Response(null,{status:_res.status,statusText:_res.statusText,headers:_res.headers})
})}}`;
  let afterResponse = `c.error=notFound
`;
  if (app.event.afterResponse?.length && !app.event.error) {
    afterResponse = `
c.error=notFound
`;
    let prefix = app.event.afterResponse.some(isAsync) ? "async" : "";
    afterResponse += `
setImmediate(${prefix}()=>{if(c.responseValue instanceof ElysiaCustomStatusResponse) c.set.status=c.responseValue.code
`;
    for (let i2 = 0;i2 < app.event.afterResponse.length; i2++) {
      let fn2 = app.event.afterResponse[i2].fn;
      afterResponse += `
${isAsyncName(fn2) ? "await " : ""}afterResponse[${i2}](c)
`;
    }
    afterResponse += `})
`;
  }
  if (app.inference.query)
    afterResponse += `
if(c.qi===-1){c.query={}}else{c.query=parseQueryFromURL(c.url,c.qi+1)}`;
  let error404 = adapter.error404(!!app.event.request?.length, !!app.event.error?.length, afterResponse);
  findDynamicRoute += error404.code, findDynamicRoute += `
c.params=route.params
if(route.store.handler)return route.store.handler(c)
return route.store.compile()(c)
`;
  let switchMap = "";
  for (let [path, methods] of Object.entries(router.static)) {
    if (switchMap += `case'${path}':`, app.config.strictPath !== true)
      switchMap += `case'${getLoosePath(path)}':`;
    let encoded = encodePath(path);
    if (path !== encoded)
      switchMap += `case'${encoded}':`;
    if (switchMap += "switch(r.method){", "GET" in methods || "WS" in methods) {
      if (switchMap += "case 'GET':", "WS" in methods) {
        if (switchMap += `if(r.headers.get('upgrade')==='websocket')return ht[${methods.WS}].composed(c)
`, "GET" in methods === false)
          if ("ALL" in methods)
            switchMap += `return ht[${methods.ALL}].composed(c)
`;
          else
            switchMap += `break map
`;
      }
      if ("GET" in methods)
        switchMap += `return ht[${methods.GET}].composed(c)
`;
    }
    if (isWebstandard && (("GET" in methods) || ("ALL" in methods)) && "HEAD" in methods === false)
      switchMap += `case 'HEAD':const _res=ht[${methods.GET ?? methods.ALL}].composed(c)
return getResponseLength(_res).then((length)=>{_res.headers.set('content-length', length)
return new Response(null,{status:_res.status,statusText:_res.statusText,headers:_res.headers})
})
`;
    for (let [method, index] of Object.entries(methods)) {
      if (method === "ALL" || method === "GET" || method === "WS")
        continue;
      switchMap += `case '${method}':return ht[${index}].composed(c)
`;
    }
    if ("ALL" in methods)
      switchMap += `default:return ht[${methods.ALL}].composed(c)
`;
    else
      switchMap += `default:break map
`;
    switchMap += "}";
  }
  let maybeAsync = !!app.event.request?.some(isAsync), adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "";
  if (fnLiteral += `
const {app,mapEarlyResponse,NotFoundError,randomId,handleError,status,redirect,getResponseLength,ElysiaCustomStatusResponse,` + allocateIf("parseQueryFromURL,", app.inference.query) + allocateIf("ELYSIA_TRACE,", hasTrace) + allocateIf("ELYSIA_REQUEST_ID,", hasTrace) + adapterVariables + `}=data
const store=app.singleton.store
const decorator=app.singleton.decorator
const staticRouter=app.router.static.http
const ht=app.router.history
const router=app.router.http
const trace=app.event.trace?.map(x=>typeof x==='function'?x:x.fn)??[]
const notFound=new NotFoundError()
const hoc=app.extender.higherOrderFunctions.map(x=>x.fn)
`, app.event.request?.length)
    fnLiteral += `const onRequest=app.event.request.map(x=>x.fn)
`;
  if (app.event.afterResponse?.length)
    fnLiteral += `const afterResponse=app.event.afterResponse.map(x=>x.fn)
`;
  if (fnLiteral += error404.declare, app.event.trace?.length)
    fnLiteral += "const " + app.event.trace.map((_2, i2) => `tr${i2}=app.event.trace[${i2}].fn`).join(",") + `
`;
  if (fnLiteral += `${maybeAsync ? "async " : ""}function map(${adapter.parameters}){`, app.event.request?.length)
    fnLiteral += `let re
`;
  if (fnLiteral += adapter.createContext(app), app.event.trace?.length)
    fnLiteral += "c[ELYSIA_TRACE]=[" + app.event.trace.map((_2, i2) => `tr${i2}(c)`).join(",") + `]
`;
  if (fnLiteral += createOnRequestHandler(app), switchMap)
    fnLiteral += `
map: switch(p){
` + switchMap + "}";
  fnLiteral += findDynamicRoute + `}
` + createHoc(app);
  let handleError = composeErrorHandler(app);
  app.handleError = handleError;
  let fn = Function("data", `"use strict";
` + fnLiteral)({ app, mapEarlyResponse: app["~adapter"].handler.mapEarlyResponse, NotFoundError, randomId, handleError, status, redirect, getResponseLength, ElysiaCustomStatusResponse, parseQueryFromURL: app.inference.query ? parseQueryFromURL : undefined, ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined, ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined, ...adapter.inject });
  if (isBun)
    Bun.gc(false);
  return fn;
};
var composeErrorHandler = (app) => {
  let hooks = app.event, fnLiteral = "", adapter = app["~adapter"].composeError, adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "", hasTrace = !!app.event.trace?.length;
  if (fnLiteral += "const {mapResponse,ERROR_CODE,ElysiaCustomStatusResponse," + allocateIf("onError,", app.event.error) + allocateIf("afterResponse,", app.event.afterResponse) + allocateIf("trace,", app.event.trace) + allocateIf("onMapResponse,", app.event.mapResponse) + allocateIf("ELYSIA_TRACE,", hasTrace) + allocateIf("ELYSIA_REQUEST_ID,", hasTrace) + adapterVariables + `}=inject
`, fnLiteral += `return ${app.event.error?.find(isAsync) || app.event.mapResponse?.find(isAsync) ? "async " : ""}function(context,error,skipGlobal){`, fnLiteral += "", hasTrace)
    fnLiteral += `const id=context[ELYSIA_REQUEST_ID]
`;
  let report = createReport({ context: "context", trace: hooks.trace, addFn: (word) => {
    fnLiteral += word;
  } }), afterResponse = () => {
    if (!hooks.afterResponse?.length && !hasTrace)
      return "";
    let afterResponse2 = "", prefix = hooks.afterResponse?.some(isAsync) ? "async" : "";
    afterResponse2 += `
setImmediate(${prefix}()=>{`;
    let reporter = createReport({ context: "context", trace: hooks.trace, addFn: (word) => {
      afterResponse2 += word;
    } })("afterResponse", { total: hooks.afterResponse?.length, name: "context" });
    if (hooks.afterResponse?.length && hooks.afterResponse)
      for (let i2 = 0;i2 < hooks.afterResponse.length; i2++) {
        let fn = hooks.afterResponse[i2].fn, endUnit = reporter.resolveChild(fn.name);
        afterResponse2 += `
${isAsyncName(fn) ? "await " : ""}afterResponse[${i2}](context)
`, endUnit();
      }
    return reporter.resolve(), afterResponse2 += `})
`, afterResponse2;
  };
  if (fnLiteral += `const set=context.set
let _r
if(!context.code)context.code=error.code??error[ERROR_CODE]
if(!(context.error instanceof Error))context.error=error
if(error instanceof ElysiaCustomStatusResponse){set.status=error.status=error.code
error.message=error.response}`, adapter.declare)
    fnLiteral += adapter.declare;
  let saveResponse = hasTrace || !!hooks.afterResponse?.length ? "context.response = " : "";
  if (app.event.error)
    for (let i2 = 0;i2 < app.event.error.length; i2++) {
      let handler = app.event.error[i2], response = `${isAsync(handler) ? "await " : ""}onError[${i2}](context)
`;
      if (fnLiteral += "if(skipGlobal!==true){", hasReturn(handler)) {
        fnLiteral += `_r=${response}
if(_r!==undefined){if(_r instanceof Response){` + afterResponse() + `return mapResponse(_r,set${adapter.mapResponseContext})}if(_r instanceof ElysiaCustomStatusResponse){error.status=error.code
error.message = error.response}if(set.status===200||!set.status)set.status=error.status
`;
        let mapResponseReporter2 = report("mapResponse", { total: hooks.mapResponse?.length, name: "context" });
        if (hooks.mapResponse?.length)
          for (let i22 = 0;i22 < hooks.mapResponse.length; i22++) {
            let mapResponse3 = hooks.mapResponse[i22], endUnit = mapResponseReporter2.resolveChild(mapResponse3.fn.name);
            fnLiteral += `context.response=context.responseValue=_r_r=${isAsyncName(mapResponse3) ? "await " : ""}onMapResponse[${i22}](context)
`, endUnit();
          }
        mapResponseReporter2.resolve(), fnLiteral += afterResponse() + `return mapResponse(${saveResponse}_r,set${adapter.mapResponseContext})}`;
      } else
        fnLiteral += response;
      fnLiteral += "}";
    }
  fnLiteral += `if(error.constructor.name==="ValidationError"||error.constructor.name==="TransformDecodeError"){
if(error.error)error=error.error
set.status=error.status??422
` + afterResponse() + adapter.validationError + `
}
`, fnLiteral += "if(error instanceof Error){" + afterResponse() + `
if(typeof error.toResponse==='function')return context.response=context.responseValue=error.toResponse()
` + adapter.unknownError + `
}`;
  let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length, name: "context" });
  if (fnLiteral += `
if(!context.response)context.response=context.responseValue=error.message??error
`, hooks.mapResponse?.length) {
    fnLiteral += `let mr
`;
    for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
      let mapResponse3 = hooks.mapResponse[i2], endUnit = mapResponseReporter.resolveChild(mapResponse3.fn.name);
      fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse3) ? "await " : ""}onMapResponse[${i2}](context)
if(mr!==undefined)error=context.response=context.responseValue=mr}`, endUnit();
    }
  }
  mapResponseReporter.resolve(), fnLiteral += afterResponse() + `
return mapResponse(${saveResponse}error,set${adapter.mapResponseContext})}`;
  let mapFn = (x2) => typeof x2 === "function" ? x2 : x2.fn;
  return Function("inject", `"use strict";
` + fnLiteral)({ mapResponse: app["~adapter"].handler.mapResponse, ERROR_CODE, ElysiaCustomStatusResponse, onError: app.event.error?.map(mapFn), afterResponse: app.event.afterResponse?.map(mapFn), trace: app.event.trace?.map(mapFn), onMapResponse: app.event.mapResponse?.map(mapFn), ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined, ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined, ...adapter.inject });
};
var allocateIf2 = (value, condition) => condition ? value : "";
var createContext = (app, route, inference, isInline = false) => {
  let fnLiteral = "", defaultHeaders = app.setHeaders, hasTrace = !!app.event.trace?.length;
  if (hasTrace)
    fnLiteral += `const id=randomId()
`;
  let isDynamic = /[:*]/.test(route.path), getQi = `const u=request.url,s=u.indexOf('/',${app.config.handler?.standardHostname ?? true ? 11 : 7}),qi=u.indexOf('?', s + 1)
`, needsQuery = inference.query || !!route.hooks.query || !!route.hooks.standaloneValidator?.find((x2) => x2.query) || app.event.request?.length;
  if (needsQuery)
    fnLiteral += getQi;
  let getPath = !inference.path ? "" : !isDynamic ? `path:'${route.path}',` : "get path(){" + (needsQuery ? "" : getQi) + `if(qi===-1)return u.substring(s)
return u.substring(s,qi)
},`;
  if (fnLiteral += allocateIf2("const c=", !isInline) + "{request,store," + allocateIf2("qi,", needsQuery) + allocateIf2("params:request.params,", isDynamic) + getPath + allocateIf2("url:request.url,", hasTrace || inference.url || needsQuery) + "redirect,status,set:{headers:" + (isNotEmpty(defaultHeaders) ? "Object.assign({},app.setHeaders)" : "Object.create(null)") + ",status:200}", inference.server)
    fnLiteral += ",get server(){return app.getServer()}";
  if (hasTrace)
    fnLiteral += ",[ELYSIA_REQUEST_ID]:id";
  {
    let decoratorsLiteral = "";
    for (let key of Object.keys(app.singleton.decorator))
      decoratorsLiteral += `,'${key}':decorator['${key}']`;
    fnLiteral += decoratorsLiteral;
  }
  return fnLiteral += `}
`, fnLiteral;
};
var createBunRouteHandler = (app, route) => {
  let hasTrace = !!app.event.trace?.length, hasHoc = !!app.extender.higherOrderFunctions.length, inference = sucrose(route.hooks, app.inference);
  inference = sucrose({ handler: route.handler }, inference);
  let fnLiteral = "const handler=data.handler,app=data.app,store=data.store,decorator=data.decorator,redirect=data.redirect,route=data.route,mapEarlyResponse=data.mapEarlyResponse," + allocateIf2("randomId=data.randomId,", hasTrace) + allocateIf2("ELYSIA_REQUEST_ID=data.ELYSIA_REQUEST_ID,", hasTrace) + allocateIf2("ELYSIA_TRACE=data.ELYSIA_TRACE,", hasTrace) + allocateIf2("trace=data.trace,", hasTrace) + allocateIf2("hoc=data.hoc,", hasHoc) + `status=data.status
`;
  if (app.event.request?.length)
    fnLiteral += `const onRequest=app.event.request.map(x=>x.fn)
`;
  fnLiteral += `${app.event.request?.find(isAsync) ? "async" : ""} function map(request){`;
  let needsQuery = inference.query || !!route.hooks.query || !!route.hooks.standaloneValidator?.find((x2) => x2.query);
  if (hasTrace || needsQuery || app.event.request?.length)
    fnLiteral += createContext(app, route, inference), fnLiteral += createOnRequestHandler(app), fnLiteral += "return handler(c)}";
  else
    fnLiteral += `return handler(${createContext(app, route, inference, true)})}`;
  return fnLiteral += createHoc(app), Function("data", fnLiteral)({ app, handler: route.compile?.() ?? route.composed, redirect, status, hoc: app.extender.higherOrderFunctions.map((x2) => x2.fn), store: app.store, decorator: app.decorator, route: route.path, randomId: hasTrace ? randomId : undefined, ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined, ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined, trace: hasTrace ? app.event.trace?.map((x2) => x2?.fn ?? x2) : undefined, mapEarlyResponse: mapEarlyResponse2 });
};
var createNativeStaticHandler = (handle, hooks, set2) => {
  if (typeof handle === "function" || handle instanceof Blob)
    return;
  if (isHTMLBundle(handle))
    return () => handle;
  let response = mapResponse2(handle, set2 ?? { headers: {} });
  if (!hooks.parse?.length && !hooks.transform?.length && !hooks.beforeHandle?.length && !hooks.afterHandle?.length) {
    if (response instanceof Promise)
      return response.then((response2) => {
        if (!response2)
          return;
        if (!response2.headers.has("content-type"))
          response2.headers.append("content-type", "text/plain");
        return response2.clone();
      });
    if (!response.headers.has("content-type"))
      response.headers.append("content-type", "text/plain");
    return () => response.clone();
  }
};
var websocket = { open(ws) {
  ws.data.open?.(ws);
}, message(ws, message) {
  ws.data.message?.(ws, message);
}, drain(ws) {
  ws.data.drain?.(ws);
}, close(ws, code, reason) {
  ws.data.close?.(ws, code, reason);
} };

class ElysiaWS {
  raw;
  data;
  body;
  constructor(raw, data, body = undefined) {
    this.raw = raw;
    this.data = data;
    this.body = body;
    this.validator = raw.data?.validator, this.sendText = raw.sendText.bind(raw), this.sendBinary = raw.sendBinary.bind(raw), this.close = raw.close.bind(raw), this.terminate = raw.terminate.bind(raw), this.publishText = raw.publishText.bind(raw), this.publishBinary = raw.publishBinary.bind(raw), this.subscribe = raw.subscribe.bind(raw), this.unsubscribe = raw.unsubscribe.bind(raw), this.isSubscribed = raw.isSubscribed.bind(raw), this.cork = raw.cork.bind(raw), this.remoteAddress = raw.remoteAddress, this.binaryType = raw.binaryType, this.data = raw.data, this.send = this.send.bind(this), this.ping = this.ping.bind(this), this.pong = this.pong.bind(this), this.publish = this.publish.bind(this);
  }
  send(data, compress) {
    if (Buffer.isBuffer(data))
      return this.raw.send(data, compress);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.send(data, compress);
  }
  ping(data) {
    if (Buffer.isBuffer(data))
      return this.raw.ping(data);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.ping(data);
  }
  pong(data) {
    if (Buffer.isBuffer(data))
      return this.raw.pong(data);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.pong(data);
  }
  publish(topic, data, compress) {
    if (Buffer.isBuffer(data))
      return this.raw.publish(topic, data, compress);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.publish(topic, data, compress);
  }
  sendText;
  sendBinary;
  close;
  terminate;
  publishText;
  publishBinary;
  subscribe;
  unsubscribe;
  isSubscribed;
  cork;
  remoteAddress;
  binaryType;
  get readyState() {
    return this.raw.readyState;
  }
  validator;
  ["~types"];
  get id() {
    return this.data.id;
  }
}
var createWSMessageParser = (parse2) => {
  let parsers = typeof parse2 === "function" ? [parse2] : parse2;
  return async function(ws, message) {
    if (typeof message === "string") {
      let start = message?.charCodeAt(0);
      if (start === 34 || start === 47 || start === 91 || start === 123)
        try {
          message = JSON.parse(message);
        } catch {}
      else if (isNumericString(message))
        message = +message;
      else if (message === "true")
        message = true;
      else if (message === "false")
        message = false;
      else if (message === "null")
        message = null;
    }
    if (parsers)
      for (let i2 = 0;i2 < parsers.length; i2++) {
        let temp = parsers[i2](ws, message);
        if (temp instanceof Promise)
          temp = await temp;
        if (temp !== undefined)
          return temp;
      }
    return message;
  };
};
var createHandleWSResponse = (validateResponse) => {
  let handleWSResponse = (ws, data) => {
    if (data instanceof Promise)
      return data.then((data2) => handleWSResponse(ws, data2));
    if (Buffer.isBuffer(data))
      return ws.send(data.toString());
    if (data === undefined)
      return;
    let send = (datum) => {
      if (validateResponse?.Check(datum) === false)
        return ws.send(new ValidationError("message", validateResponse, datum).message);
      if (typeof datum === "object")
        return ws.send(JSON.stringify(datum));
      ws.send(datum);
    };
    if (typeof data?.next !== "function")
      return void send(data);
    let init = data.next();
    if (init instanceof Promise)
      return (async () => {
        let first = await init;
        if (validateResponse?.Check(first) === false)
          return ws.send(new ValidationError("message", validateResponse, first).message);
        if (send(first.value), !first.done)
          for await (let datum of data)
            send(datum);
      })();
    if (send(init.value), !init.done)
      for (let datum of data)
        send(datum);
  };
  return handleWSResponse;
};
var optionalParam = /:.+?\?(?=\/|$)/;
var getPossibleParams = (path) => {
  let match = optionalParam.exec(path);
  if (!match)
    return [path];
  let routes = [], head = path.slice(0, match.index), param = match[0].slice(0, -1), tail = path.slice(match.index + match[0].length);
  routes.push(head.slice(0, -1)), routes.push(head + param);
  for (let fragment of getPossibleParams(tail)) {
    if (!fragment)
      continue;
    if (!fragment.startsWith("/:"))
      routes.push(head.slice(0, -1) + fragment);
    routes.push(head + param + fragment);
  }
  return routes;
};
var isHTMLBundle = (handle) => {
  return typeof handle === "object" && handle !== null && (handle.toString() === "[object HTMLBundle]" || typeof handle.index === "string");
};
var supportedMethods = { GET: true, HEAD: true, OPTIONS: true, DELETE: true, PATCH: true, POST: true, PUT: true };
var mapRoutes = (app) => {
  if (!app.config.aot || !app.config.systemRouter)
    return;
  let routes = {}, add = (route, handler) => {
    let path = encodeURI(route.path);
    if (routes[path]) {
      if (!routes[path][route.method])
        routes[path][route.method] = handler;
    } else
      routes[path] = { [route.method]: handler };
  }, tree = app.routeTree;
  for (let route of app.router.history) {
    if (typeof route.handler !== "function")
      continue;
    let method = route.method;
    if (method === "GET" && `WS_${route.path}` in tree || method === "WS" || route.path.charCodeAt(route.path.length - 1) === 42 || !(method in supportedMethods))
      continue;
    if (method === "ALL") {
      if (!(`WS_${route.path}` in tree))
        routes[route.path] = route.hooks?.config?.mount ? route.hooks.trace || app.event.trace || app.extender.higherOrderFunctions ? createBunRouteHandler(app, route) : route.hooks.mount || route.handler : route.handler;
      continue;
    }
    let compiled, handler = app.config.precompile ? createBunRouteHandler(app, route) : (request) => {
      if (compiled)
        return compiled(request);
      return (compiled = createBunRouteHandler(app, route))(request);
    };
    for (let path of getPossibleParams(route.path))
      add({ method, path }, handler);
  }
  return routes;
};
var mergeRoutes = (r1, r2) => {
  if (!r2)
    return r1;
  for (let key of Object.keys(r2)) {
    if (r1[key] === r2[key])
      continue;
    if (!r1[key]) {
      r1[key] = r2[key];
      continue;
    }
    if (r1[key] && r2[key]) {
      if (typeof r1[key] === "function" || r1[key] instanceof Response) {
        r1[key] = r2[key];
        continue;
      }
      r1[key] = { ...r1[key], ...r2[key] };
    }
  }
  return r1;
};
var BunAdapter = { ...WebStandardAdapter, name: "bun", handler: { mapResponse: mapResponse2, mapEarlyResponse: mapEarlyResponse2, mapCompactResponse: mapCompactResponse2, createStaticHandler: createStaticHandler2, createNativeStaticHandler }, composeHandler: { ...WebStandardAdapter.composeHandler, headers: hasHeaderShorthand ? `c.headers=c.request.headers.toJSON()
` : `c.headers={}
for(const [k,v] of c.request.headers.entries())c.headers[k]=v
` }, listen(app) {
  return (options, callback) => {
    if (typeof Bun > "u")
      throw Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (app.compile(), typeof options === "string") {
      if (!isNumericString(options))
        throw Error("Port must be a numeric value");
      options = parseInt(options);
    }
    let createStaticRoute = (iterator, { withAsync = false } = {}) => {
      let staticRoutes = {}, ops = [];
      for (let [path, route] of Object.entries(iterator))
        if (path = encodeURI(path), supportPerMethodInlineHandler) {
          if (!route)
            continue;
          for (let [method, value] of Object.entries(route)) {
            if (!value || !(method in supportedMethods))
              continue;
            if (value instanceof Promise) {
              if (withAsync) {
                if (!staticRoutes[path])
                  staticRoutes[path] = {};
                ops.push(value.then((awaited) => {
                  if (awaited instanceof Response)
                    staticRoutes[path][method] = awaited;
                  if (isHTMLBundle(awaited))
                    staticRoutes[path][method] = awaited;
                }));
              }
              continue;
            }
            if (!(value instanceof Response) && !isHTMLBundle(value))
              continue;
            if (!staticRoutes[path])
              staticRoutes[path] = {};
            staticRoutes[path][method] = value;
          }
        } else {
          if (!route)
            continue;
          if (route instanceof Promise) {
            if (withAsync) {
              if (!staticRoutes[path])
                staticRoutes[path] = {};
              ops.push(route.then((awaited) => {
                if (awaited instanceof Response)
                  staticRoutes[path] = awaited;
              }));
            }
            continue;
          }
          if (!(route instanceof Response))
            continue;
          staticRoutes[path] = route;
        }
      if (withAsync)
        return Promise.all(ops).then(() => staticRoutes);
      return staticRoutes;
    }, serve = typeof options === "object" ? { development: !isProduction, reusePort: true, idleTimeout: 30, ...app.config.serve || {}, ...options || {}, routes: mergeRoutes(mergeRoutes(createStaticRoute(app.router.response), mapRoutes(app)), app.config.serve?.routes), websocket: { ...app.config.websocket || {}, ...websocket || {}, ...options.websocket || {} }, fetch: app.fetch } : { development: !isProduction, reusePort: true, idleTimeout: 30, ...app.config.serve || {}, routes: mergeRoutes(mergeRoutes(createStaticRoute(app.router.response), mapRoutes(app)), app.config.serve?.routes), websocket: { ...app.config.websocket || {}, ...websocket || {} }, port: options, fetch: app.fetch };
    if (app.server = Bun.serve(serve), app.event.start)
      for (let i2 = 0;i2 < app.event.start.length; i2++)
        app.event.start[i2].fn(app);
    if (callback)
      callback(app.server);
    process.on("beforeExit", async () => {
      if (app.server) {
        if (await app.server.stop?.(), app.server = null, app.event.stop)
          for (let i2 = 0;i2 < app.event.stop.length; i2++)
            app.event.stop[i2].fn(app);
      }
    }), app.promisedModules.then(async () => {
      app.server?.reload({ ...serve, fetch: app.fetch, routes: mergeRoutes(mergeRoutes(await createStaticRoute(app.router.response, { withAsync: true }), mapRoutes(app)), app.config.serve?.routes) }), Bun?.gc(false);
    });
  };
}, async stop(app, closeActiveConnections) {
  if (app.server) {
    if (await app.server.stop(closeActiveConnections), app.server = null, app.event.stop?.length)
      for (let i2 = 0;i2 < app.event.stop.length; i2++)
        app.event.stop[i2].fn(app);
  } else
    console.log("Elysia isn't running. Call `app.listen` to start the server.", Error().stack);
}, ws(app, path, options) {
  let { parse: parse2, body, response, ...rest } = options, validateMessage = getSchemaValidator(body, { modules: app.definitions.typebox, models: app.definitions.type, normalize: app.config.normalize }), validateResponse = getSchemaValidator(response, { modules: app.definitions.typebox, models: app.definitions.type, normalize: app.config.normalize });
  app.route("WS", path, async (context) => {
    let server = context.server ?? app.server, { set: set2, path: path2, qi, headers, query, params } = context;
    if (context.validator = validateResponse, options.upgrade) {
      if (typeof options.upgrade === "function") {
        let temp = options.upgrade(context);
        if (temp instanceof Promise)
          await temp;
      } else if (options.upgrade)
        Object.assign(set2.headers, options.upgrade);
    }
    if (set2.cookie && isNotEmpty(set2.cookie)) {
      let cookie = serializeCookie(set2.cookie);
      if (cookie)
        set2.headers["set-cookie"] = cookie;
    }
    if (set2.headers["set-cookie"] && Array.isArray(set2.headers["set-cookie"]))
      set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["set-cookie"]);
    let handleResponse3 = createHandleWSResponse(validateResponse), parseMessage = createWSMessageParser(parse2), _id;
    if (typeof options.beforeHandle === "function") {
      let result = options.beforeHandle(context);
      if (result instanceof Promise)
        await result;
    }
    let errorHandlers = [...options.error ? Array.isArray(options.error) ? options.error : [options.error] : [], ...(app.event.error ?? []).map((x2) => typeof x2 === "function" ? x2 : x2.fn)].filter((x2) => x2), hasCustomErrorHandlers = errorHandlers.length > 0, handleErrors = !hasCustomErrorHandlers ? () => {} : async (ws, error) => {
      for (let handleError of errorHandlers) {
        let response2 = handleError(Object.assign(context, { error }));
        if (response2 instanceof Promise)
          response2 = await response2;
        if (await handleResponse3(ws, response2), response2)
          break;
      }
    };
    if (server?.upgrade(context.request, { headers: isNotEmpty(set2.headers) ? set2.headers : undefined, data: { ...context, get id() {
      if (_id)
        return _id;
      return _id = randomId();
    }, validator: validateResponse, ping(ws, data) {
      options.ping?.(ws, data);
    }, pong(ws, data) {
      options.pong?.(ws, data);
    }, open: async (ws) => {
      try {
        await handleResponse3(ws, options.open?.(new ElysiaWS(ws, context)));
      } catch (error) {
        handleErrors(ws, error);
      }
    }, message: async (ws, _message) => {
      let message = await parseMessage(ws, _message);
      if (validateMessage?.Check(message) === false) {
        let validationError = new ValidationError("message", validateMessage, message);
        if (!hasCustomErrorHandlers)
          return void ws.send(validationError.message);
        return handleErrors(ws, validationError);
      }
      try {
        await handleResponse3(ws, options.message?.(new ElysiaWS(ws, context, message), message));
      } catch (error) {
        handleErrors(ws, error);
      }
    }, drain: async (ws) => {
      try {
        await handleResponse3(ws, options.drain?.(new ElysiaWS(ws, context)));
      } catch (error) {
        handleErrors(ws, error);
      }
    }, close: async (ws, code, reason) => {
      try {
        await handleResponse3(ws, options.close?.(new ElysiaWS(ws, context), code, reason));
      } catch (error) {
        handleErrors(ws, error);
      }
    } } }))
      return;
    return set2.status = 400, "Expected a websocket connection";
  }, { ...rest, websocket: options });
} };
var injectDefaultValues = (typeChecker, obj) => {
  let schema = typeChecker.schema;
  if (!schema)
    return;
  if (schema.$defs?.[schema.$ref])
    schema = schema.$defs[schema.$ref];
  if (!schema?.properties)
    return;
  for (let [key, keySchema] of Object.entries(schema.properties))
    obj[key] ??= keySchema.default;
};
var createDynamicHandler = (app) => {
  let { mapResponse: mapResponse3, mapEarlyResponse: mapEarlyResponse3 } = app["~adapter"].handler, defaultHeader = app.setHeaders;
  return async (request) => {
    let url = request.url, s = url.indexOf("/", 11), qi = url.indexOf("?", s + 1), path = qi === -1 ? url.substring(s) : url.substring(s, qi), set2 = { cookie: {}, status: 200, headers: defaultHeader ? { ...defaultHeader } : {} }, context = Object.assign({}, app.singleton.decorator, { set: set2, store: app.singleton.store, request, path, qi, error: status, status, redirect });
    try {
      if (app.event.request)
        for (let i2 = 0;i2 < app.event.request.length; i2++) {
          let onRequest = app.event.request[i2].fn, response2 = onRequest(context);
          if (response2 instanceof Promise)
            response2 = await response2;
          if (response2 = mapEarlyResponse3(response2, set2), response2)
            return context.response = response2;
        }
      let methodKey = request.method === "GET" && request.headers.get("upgrade")?.toLowerCase() === "websocket" ? "WS" : request.method, handler = app.router.dynamic.find(request.method, path) ?? app.router.dynamic.find(methodKey, path) ?? app.router.dynamic.find("ALL", path);
      if (!handler)
        throw context.query = qi === -1 ? {} : parseQuery(url.substring(qi + 1)), new NotFoundError;
      let { handle, hooks, validator, content, route } = handler.store, body;
      if (request.method !== "GET" && request.method !== "HEAD")
        if (content)
          switch (content) {
            case "application/json":
              body = await request.json();
              break;
            case "text/plain":
              body = await request.text();
              break;
            case "application/x-www-form-urlencoded":
              body = parseQuery(await request.text());
              break;
            case "application/octet-stream":
              body = await request.arrayBuffer();
              break;
            case "multipart/form-data":
              body = {};
              let form2 = await request.formData();
              for (let key of form2.keys()) {
                if (body[key])
                  continue;
                let value = form2.getAll(key);
                if (value.length === 1)
                  body[key] = value[0];
                else
                  body[key] = value;
              }
              break;
          }
        else {
          let contentType;
          if (request.body)
            contentType = request.headers.get("content-type");
          if (contentType) {
            let index = contentType.indexOf(";");
            if (index !== -1)
              contentType = contentType.slice(0, index);
            if (context.contentType = contentType, hooks.parse)
              for (let i2 = 0;i2 < hooks.parse.length; i2++) {
                let hook = hooks.parse[i2].fn;
                if (typeof hook === "string")
                  switch (hook) {
                    case "json":
                    case "application/json":
                      body = await request.json();
                      break;
                    case "text":
                    case "text/plain":
                      body = await request.text();
                      break;
                    case "urlencoded":
                    case "application/x-www-form-urlencoded":
                      body = parseQuery(await request.text());
                      break;
                    case "arrayBuffer":
                    case "application/octet-stream":
                      body = await request.arrayBuffer();
                      break;
                    case "formdata":
                    case "multipart/form-data":
                      body = {};
                      let form2 = await request.formData();
                      for (let key of form2.keys()) {
                        if (body[key])
                          continue;
                        let value = form2.getAll(key);
                        if (value.length === 1)
                          body[key] = value[0];
                        else
                          body[key] = value;
                      }
                      break;
                    default:
                      let parser = app["~parser"][hook];
                      if (parser) {
                        let temp = parser(context, contentType);
                        if (temp instanceof Promise)
                          temp = await temp;
                        if (temp) {
                          body = temp;
                          break;
                        }
                      }
                      break;
                  }
                else {
                  let temp = hook(context, contentType);
                  if (temp instanceof Promise)
                    temp = await temp;
                  if (temp) {
                    body = temp;
                    break;
                  }
                }
              }
            if (delete context.contentType, body === undefined)
              switch (contentType) {
                case "application/json":
                  body = await request.json();
                  break;
                case "text/plain":
                  body = await request.text();
                  break;
                case "application/x-www-form-urlencoded":
                  body = parseQuery(await request.text());
                  break;
                case "application/octet-stream":
                  body = await request.arrayBuffer();
                  break;
                case "multipart/form-data":
                  body = {};
                  let form2 = await request.formData();
                  for (let key of form2.keys()) {
                    if (body[key])
                      continue;
                    let value = form2.getAll(key);
                    if (value.length === 1)
                      body[key] = value[0];
                    else
                      body[key] = value;
                  }
                  break;
              }
          }
        }
      context.route = route, context.body = body, context.params = handler?.params || undefined, context.query = qi === -1 ? {} : parseQuery(url.substring(qi + 1)), context.headers = {};
      for (let [key, value] of request.headers.entries())
        context.headers[key] = value;
      let cookieMeta = { domain: app.config.cookie?.domain ?? validator?.cookie?.config.domain, expires: app.config.cookie?.expires ?? validator?.cookie?.config.expires, httpOnly: app.config.cookie?.httpOnly ?? validator?.cookie?.config.httpOnly, maxAge: app.config.cookie?.maxAge ?? validator?.cookie?.config.maxAge, path: app.config.cookie?.path ?? validator?.cookie?.config.path, priority: app.config.cookie?.priority ?? validator?.cookie?.config.priority, partitioned: app.config.cookie?.partitioned ?? validator?.cookie?.config.partitioned, sameSite: app.config.cookie?.sameSite ?? validator?.cookie?.config.sameSite, secure: app.config.cookie?.secure ?? validator?.cookie?.config.secure, secrets: app.config.cookie?.secrets ?? validator?.cookie?.config.secrets, sign: app.config.cookie?.sign ?? validator?.cookie?.config.sign }, cookieHeaderValue = request.headers.get("cookie");
      context.cookie = await parseCookie(context.set, cookieHeaderValue, cookieMeta);
      let headerValidator = validator?.createHeaders?.();
      if (headerValidator)
        injectDefaultValues(headerValidator, context.headers);
      let paramsValidator = validator?.createParams?.();
      if (paramsValidator)
        injectDefaultValues(paramsValidator, context.params);
      let queryValidator = validator?.createQuery?.();
      if (queryValidator)
        injectDefaultValues(queryValidator, context.query);
      if (hooks.transform)
        for (let i2 = 0;i2 < hooks.transform.length; i2++) {
          let hook = hooks.transform[i2], response2 = hook.fn(context);
          if (response2 instanceof Promise)
            response2 = await response2;
          if (response2 instanceof ElysiaCustomStatusResponse) {
            let result = mapEarlyResponse3(response2, context.set);
            if (result)
              return context.response = result;
          }
          if (hook.subType === "derive")
            Object.assign(context, response2);
        }
      if (validator) {
        if (headerValidator) {
          let _header = structuredClone(context.headers);
          for (let [key, value] of request.headers)
            _header[key] = value;
          if (validator.headers.Check(_header) === false)
            throw new ValidationError("header", validator.headers, _header);
        } else if (validator.headers?.Decode)
          context.headers = validator.headers.Decode(context.headers);
        if (paramsValidator?.Check(context.params) === false)
          throw new ValidationError("params", validator.params, context.params);
        else if (validator.params?.Decode)
          context.params = validator.params.Decode(context.params);
        if (validator.query?.schema) {
          let schema = validator.query.schema;
          if (schema.$defs?.[schema.$ref])
            schema = schema.$defs[schema.$ref];
          let properties = schema.properties;
          for (let property of Object.keys(properties)) {
            let value = properties[property];
            if ((value.type === "array" || value.items?.type === "string") && typeof context.query[property] === "string" && context.query[property])
              context.query[property] = context.query[property].split(",");
          }
        }
        if (queryValidator?.Check(context.query) === false)
          throw new ValidationError("query", validator.query, context.query);
        else if (validator.query?.Decode)
          context.query = validator.query.Decode(context.query);
        if (validator.createCookie?.()) {
          let cookieValue = {};
          for (let [key, value] of Object.entries(context.cookie))
            cookieValue[key] = value.value;
          if (validator.cookie.Check(cookieValue) === false)
            throw new ValidationError("cookie", validator.cookie, cookieValue);
          else if (validator.cookie?.Decode)
            cookieValue = validator.cookie.Decode(cookieValue);
        }
        if (validator.createBody?.()?.Check(body) === false)
          throw new ValidationError("body", validator.body, body);
        else if (validator.body?.Decode)
          context.body = validator.body.Decode(body);
      }
      if (hooks.beforeHandle)
        for (let i2 = 0;i2 < hooks.beforeHandle.length; i2++) {
          let hook = hooks.beforeHandle[i2], response2 = hook.fn(context);
          if (response2 instanceof Promise)
            response2 = await response2;
          if (response2 instanceof ElysiaCustomStatusResponse) {
            let result = mapEarlyResponse3(response2, context.set);
            if (result)
              return context.response = result;
          }
          if (hook.subType === "resolve") {
            Object.assign(context, response2);
            continue;
          }
          if (response2 !== undefined) {
            if (context.response = response2, hooks.afterHandle)
              for (let i22 = 0;i22 < hooks.afterHandle.length; i22++) {
                let newResponse = hooks.afterHandle[i22].fn(context);
                if (newResponse instanceof Promise)
                  newResponse = await newResponse;
                if (newResponse)
                  response2 = newResponse;
              }
            let result = mapEarlyResponse3(response2, context.set);
            if (result)
              return context.response = result;
          }
        }
      let response = typeof handle === "function" ? handle(context) : handle;
      if (response instanceof Promise)
        response = await response;
      if (!hooks.afterHandle?.length) {
        let isCustomStatuResponse = response instanceof ElysiaCustomStatusResponse, status2 = isCustomStatuResponse ? response.code : set2.status ? typeof set2.status === "string" ? StatusMap[set2.status] : set2.status : 200;
        if (isCustomStatuResponse)
          set2.status = status2, response = response.response;
        let responseValidator = validator?.createResponse?.()?.[status2];
        if (responseValidator?.Check(response) === false)
          if (responseValidator?.Clean) {
            let temp = responseValidator.Clean(response);
            if (responseValidator?.Check(temp) === false)
              throw new ValidationError("response", responseValidator, response);
            response = temp;
          } else
            throw new ValidationError("response", responseValidator, response);
        if (responseValidator?.Encode)
          response = responseValidator.Encode(response);
        if (responseValidator?.Clean)
          response = responseValidator.Clean(response);
      } else {
        context.response = response;
        for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
          let response2 = hooks.afterHandle[i2].fn(context);
          if (response2 instanceof Promise)
            response2 = await response2;
          let isCustomStatuResponse = response2 instanceof ElysiaCustomStatusResponse, status2 = isCustomStatuResponse ? response2.code : set2.status ? typeof set2.status === "string" ? StatusMap[set2.status] : set2.status : 200;
          if (isCustomStatuResponse)
            set2.status = status2, response2 = response2.response;
          let responseValidator = validator?.createResponse?.()?.[status2];
          if (responseValidator?.Check(response2) === false)
            if (responseValidator?.Clean) {
              let temp = responseValidator.Clean(response2);
              if (responseValidator?.Check(temp) === false)
                throw new ValidationError("response", responseValidator, response2);
              response2 = temp;
            } else
              throw new ValidationError("response", responseValidator, response2);
          if (responseValidator?.Encode)
            context.response = response2 = responseValidator.Encode(response2);
          if (responseValidator?.Clean)
            context.response = response2 = responseValidator.Clean(response2);
          let result = mapEarlyResponse3(response2, context.set);
          if (result !== undefined)
            return context.response = result;
        }
      }
      if (context.set.cookie && cookieMeta?.sign) {
        let secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
        if (cookieMeta.sign === true) {
          if (secret)
            for (let [key, cookie] of Object.entries(context.set.cookie))
              context.set.cookie[key].value = await signCookie(cookie.value, secret);
        } else {
          let properties = validator?.cookie?.schema?.properties;
          if (secret)
            for (let name of cookieMeta.sign) {
              if (!(name in properties))
                continue;
              if (context.set.cookie[name]?.value)
                context.set.cookie[name].value = await signCookie(context.set.cookie[name].value, secret);
            }
        }
      }
      return mapResponse3(context.response = response, context.set);
    } catch (error) {
      let reportedError = error instanceof TransformDecodeError && error.error ? error.error : error;
      return app.handleError(context, reportedError);
    } finally {
      if (app.event.afterResponse)
        setImmediate(async () => {
          for (let afterResponse of app.event.afterResponse)
            await afterResponse.fn(context);
        });
    }
  };
};
var createDynamicErrorHandler = (app) => {
  let { mapResponse: mapResponse3 } = app["~adapter"].handler;
  return async (context, error) => {
    let errorContext = Object.assign(context, { error, code: error.code });
    if (errorContext.set = context.set, app.event.error)
      for (let i2 = 0;i2 < app.event.error.length; i2++) {
        let response = app.event.error[i2].fn(errorContext);
        if (response instanceof Promise)
          response = await response;
        if (response !== undefined && response !== null)
          return context.response = mapResponse3(response, context.set);
      }
    return new Response(typeof error.cause === "string" ? error.cause : error.message, { headers: context.set.headers, status: error.status ?? 500 });
  };
};

class Elysia {
  config;
  server = null;
  dependencies = {};
  "~Prefix" = "";
  "~Singleton" = null;
  "~Definitions" = null;
  "~Metadata" = null;
  "~Ephemeral" = null;
  "~Volatile" = null;
  "~Routes" = null;
  singleton = { decorator: {}, store: {}, derive: {}, resolve: {} };
  get store() {
    return this.singleton.store;
  }
  get decorator() {
    return this.singleton.decorator;
  }
  definitions = { typebox: t.Module({}), type: {}, error: {} };
  extender = { macro: {}, higherOrderFunctions: [] };
  validator = { global: null, scoped: null, local: null, getCandidate() {
    if (!this.global && !this.scoped && !this.local)
      return { body: undefined, headers: undefined, params: undefined, query: undefined, cookie: undefined, response: undefined };
    return mergeSchemaValidator(mergeSchemaValidator(this.global, this.scoped), this.local);
  } };
  standaloneValidator = { global: null, scoped: null, local: null };
  event = {};
  telemetry;
  router = { "~http": undefined, get http() {
    if (!this["~http"])
      this["~http"] = new _({ lazy: true, onParam: import_fast_decode_uri_component4.default });
    return this["~http"];
  }, "~dynamic": undefined, get dynamic() {
    if (!this["~dynamic"])
      this["~dynamic"] = new _({ onParam: import_fast_decode_uri_component4.default });
    return this["~dynamic"];
  }, static: {}, response: {}, history: [] };
  routeTree = {};
  get routes() {
    return this.router.history;
  }
  getGlobalRoutes() {
    return this.router.history;
  }
  getGlobalDefinitions() {
    return this.definitions;
  }
  inference = { body: false, cookie: false, headers: false, query: false, set: false, server: false, path: false, route: false, url: false };
  getServer() {
    return this.server;
  }
  getParent() {
    return null;
  }
  "~parser" = {};
  _promisedModules;
  get promisedModules() {
    if (!this._promisedModules)
      this._promisedModules = new PromiseGroup(console.error, () => {});
    return this._promisedModules;
  }
  constructor(config = {}) {
    if (config.tags)
      if (!config.detail)
        config.detail = { tags: config.tags };
      else
        config.detail.tags = config.tags;
    if (this.config = { aot: env2.ELYSIA_AOT !== "false", nativeStaticResponse: true, systemRouter: true, encodeSchema: true, normalize: true, ...config, prefix: config.prefix ? config.prefix.charCodeAt(0) === 47 ? config.prefix : `/${config.prefix}` : undefined, cookie: { path: "/", ...config?.cookie }, experimental: config?.experimental ?? {}, seed: config?.seed === undefined ? "" : config?.seed }, this["~adapter"] = config.adapter ?? (typeof Bun < "u" ? BunAdapter : WebStandardAdapter), config?.analytic && (config?.name || config?.seed !== undefined))
      this.telemetry = { stack: Error().stack };
  }
  "~adapter";
  env(model, _env = env2) {
    if (getSchemaValidator(model, { modules: this.definitions.typebox, dynamic: true, additionalProperties: true, coerce: true, sanitize: () => this.config.sanitize }).Check(_env) === false) {
      let error = new ValidationError("env", model, _env);
      throw Error(error.all.map((x2) => x2.summary).join(`
`));
    }
    return this;
  }
  wrap(fn) {
    return this.extender.higherOrderFunctions.push({ checksum: checksum(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: fn.toString() })), fn }), this;
  }
  get models() {
    let models = {};
    for (let name of Object.keys(this.definitions.type))
      models[name] = getSchemaValidator(this.definitions.typebox.Import(name));
    return models.modules = this.definitions.typebox, models;
  }
  add(method, path, handle, localHook, options) {
    let skipPrefix = options?.skipPrefix ?? false, allowMeta = options?.allowMeta ?? false;
    localHook ??= {}, this.applyMacro(localHook);
    let standaloneValidators = [];
    if (localHook.standaloneValidator)
      standaloneValidators = standaloneValidators.concat(localHook.standaloneValidator);
    if (this.standaloneValidator.local)
      standaloneValidators = standaloneValidators.concat(this.standaloneValidator.local);
    if (this.standaloneValidator.scoped)
      standaloneValidators = standaloneValidators.concat(this.standaloneValidator.scoped);
    if (this.standaloneValidator.global)
      standaloneValidators = standaloneValidators.concat(this.standaloneValidator.global);
    if (path !== "" && path.charCodeAt(0) !== 47)
      path = "/" + path;
    if (this.config.prefix && !skipPrefix)
      path = this.config.prefix + path;
    if (localHook?.type)
      switch (localHook.type) {
        case "text":
          localHook.type = "text/plain";
          break;
        case "json":
          localHook.type = "application/json";
          break;
        case "formdata":
          localHook.type = "multipart/form-data";
          break;
        case "urlencoded":
          localHook.type = "application/x-www-form-urlencoded";
          break;
        case "arrayBuffer":
          localHook.type = "application/octet-stream";
          break;
        default:
          break;
      }
    let instanceValidator = this.validator.getCandidate(), cloned = { body: localHook?.body ?? instanceValidator?.body, headers: localHook?.headers ?? instanceValidator?.headers, params: localHook?.params ?? instanceValidator?.params, query: localHook?.query ?? instanceValidator?.query, cookie: localHook?.cookie ?? instanceValidator?.cookie, response: localHook?.response ?? instanceValidator?.response }, shouldPrecompile = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.compose === true, createValidator = () => {
      let models = this.definitions.type, dynamic = !this.config.aot, normalize = this.config.normalize, modules = this.definitions.typebox, sanitize2 = () => this.config.sanitize, cookieValidator = () => {
        if (cloned.cookie || standaloneValidators.find((x2) => x2.cookie))
          return getCookieValidator({ modules, validator: cloned.cookie, defaultConfig: this.config.cookie, normalize, config: cloned.cookie?.config ?? {}, dynamic, models, validators: standaloneValidators.map((x2) => x2.cookie), sanitize: sanitize2 });
      };
      return shouldPrecompile ? { body: getSchemaValidator(cloned.body, { modules, dynamic, models, normalize, additionalCoerce: coercePrimitiveRoot(), validators: standaloneValidators.map((x2) => x2.body), sanitize: sanitize2 }), headers: getSchemaValidator(cloned.headers, { modules, dynamic, models, additionalProperties: true, coerce: true, additionalCoerce: stringToStructureCoercions(), validators: standaloneValidators.map((x2) => x2.headers), sanitize: sanitize2 }), params: getSchemaValidator(cloned.params, { modules, dynamic, models, coerce: true, additionalCoerce: stringToStructureCoercions(), validators: standaloneValidators.map((x2) => x2.params), sanitize: sanitize2 }), query: getSchemaValidator(cloned.query, { modules, dynamic, models, normalize, coerce: true, additionalCoerce: queryCoercions(), validators: standaloneValidators.map((x2) => x2.query), sanitize: sanitize2 }), cookie: cookieValidator(), response: getResponseSchemaValidator(cloned.response, { modules, dynamic, models, normalize, validators: standaloneValidators.map((x2) => x2.response), sanitize: sanitize2 }) } : { createBody() {
        if (this.body)
          return this.body;
        return this.body = getSchemaValidator(cloned.body, { modules, dynamic, models, normalize, additionalCoerce: coercePrimitiveRoot(), validators: standaloneValidators.map((x2) => x2.body), sanitize: sanitize2 });
      }, createHeaders() {
        if (this.headers)
          return this.headers;
        return this.headers = getSchemaValidator(cloned.headers, { modules, dynamic, models, normalize, additionalProperties: !normalize, coerce: true, additionalCoerce: stringToStructureCoercions(), validators: standaloneValidators.map((x2) => x2.headers), sanitize: sanitize2 });
      }, createParams() {
        if (this.params)
          return this.params;
        return this.params = getSchemaValidator(cloned.params, { modules, dynamic, models, normalize, coerce: true, additionalCoerce: stringToStructureCoercions(), validators: standaloneValidators.map((x2) => x2.params), sanitize: sanitize2 });
      }, createQuery() {
        if (this.query)
          return this.query;
        return this.query = getSchemaValidator(cloned.query, { modules, dynamic, models, normalize, coerce: true, additionalCoerce: queryCoercions(), validators: standaloneValidators.map((x2) => x2.query), sanitize: sanitize2 });
      }, createCookie() {
        if (this.cookie)
          return this.cookie;
        return this.cookie = cookieValidator();
      }, createResponse() {
        if (this.response)
          return this.response;
        return this.response = getResponseSchemaValidator(cloned.response, { modules, dynamic, models, normalize, validators: standaloneValidators.map((x2) => x2.response), sanitize: sanitize2 });
      } };
    };
    if (instanceValidator.body || instanceValidator.cookie || instanceValidator.headers || instanceValidator.params || instanceValidator.query || instanceValidator.response)
      localHook = mergeHook(localHook, instanceValidator);
    if (localHook.tags)
      if (!localHook.detail)
        localHook.detail = { tags: localHook.tags };
      else
        localHook.detail.tags = localHook.tags;
    if (isNotEmpty(this.config.detail))
      localHook.detail = mergeDeep(Object.assign({}, this.config.detail), localHook.detail);
    let hooks = isNotEmpty(this.event) ? mergeHook(this.event, localHookToLifeCycleStore(localHook)) : { ...lifeCycleToArray(localHookToLifeCycleStore(localHook)) };
    if (standaloneValidators.length)
      Object.assign(hooks, { standaloneValidator: standaloneValidators });
    if (this.config.aot === false) {
      let validator = createValidator();
      this.router.dynamic.add(method, path, { validator, hooks, content: localHook?.type, handle, route: path });
      let encoded = encodePath(path, { dynamic: true });
      if (path !== encoded)
        this.router.dynamic.add(method, encoded, { validator, hooks, content: localHook?.type, handle, route: path });
      if (!this.config.strictPath) {
        let loosePath = getLoosePath(path);
        this.router.dynamic.add(method, loosePath, { validator, hooks, content: localHook?.type, handle, route: path });
        let encoded2 = encodePath(loosePath);
        if (loosePath !== encoded2)
          this.router.dynamic.add(method, loosePath, { validator, hooks, content: localHook?.type, handle, route: path });
      }
      this.router.history.push({ method, path, composed: null, handler: handle, compile: undefined, hooks });
      return;
    }
    let adapter = this["~adapter"].handler, nativeStaticHandler = typeof handle !== "function" ? () => {
      let context = { redirect, request: this["~adapter"].isWebStandard ? new Request(`http://ely.sia${path}`, { method }) : undefined, server: null, set: { headers: Object.assign({}, this.setHeaders) }, status, store: this.store };
      try {
        this.event.request?.map((x2) => {
          if (typeof x2.fn === "function")
            return x2.fn(context);
          if (typeof x2 === "function")
            return x2(context);
        });
      } catch (error) {
        let res;
        if (context.error = error, this.event.error?.some((x2) => {
          if (typeof x2.fn === "function")
            return res = x2.fn(context);
          if (typeof x2 === "function")
            return res = x2(context);
        }), res !== undefined)
          handle = res;
      }
      let fn = adapter.createNativeStaticHandler?.(handle, hooks, context.set);
      return fn instanceof Promise ? fn.then((fn2) => {
        if (fn2)
          return fn2;
      }) : fn?.();
    } : undefined, useNativeStaticResponse = this.config.nativeStaticResponse === true, addResponsePath = (path2) => {
      if (!useNativeStaticResponse || !nativeStaticHandler)
        return;
      if (supportPerMethodInlineHandler)
        if (this.router.response[path2])
          this.router.response[path2][method] = nativeStaticHandler();
        else
          this.router.response[path2] = { [method]: nativeStaticHandler() };
      else
        this.router.response[path2] = nativeStaticHandler();
    };
    addResponsePath(path);
    let _compiled, compile2 = () => {
      if (_compiled)
        return _compiled;
      return _compiled = composeHandler({ app: this, path, method, hooks, validator: createValidator(), handler: typeof handle !== "function" && typeof adapter.createStaticHandler !== "function" ? () => handle : handle, allowMeta, inference: this.inference });
    }, oldIndex;
    if (`${method}_${path}` in this.routeTree)
      for (let i2 = 0;i2 < this.router.history.length; i2++) {
        let route = this.router.history[i2];
        if (route.path === path && route.method === method) {
          oldIndex = i2;
          break;
        }
      }
    else
      this.routeTree[`${method}_${path}`] = this.router.history.length;
    let index = oldIndex ?? this.router.history.length, mainHandler = shouldPrecompile ? compile2() : (ctx) => (this.router.history[index].composed = compile2())(ctx);
    if (oldIndex !== undefined)
      this.router.history[oldIndex] = Object.assign({ method, path, composed: mainHandler, compile: compile2, handler: handle, hooks }, standaloneValidators.length ? { standaloneValidators } : undefined, localHook.webSocket ? { websocket: localHook.websocket } : undefined);
    else
      this.router.history.push(Object.assign({ method, path, composed: mainHandler, compile: compile2, handler: handle, hooks }, localHook.webSocket ? { websocket: localHook.websocket } : undefined));
    let handler = { handler: shouldPrecompile ? mainHandler : undefined, compile() {
      return this.handler = compile2();
    } }, staticRouter = this.router.static, isStaticPath = path.indexOf(":") === -1 && path.indexOf("*") === -1;
    if (method === "WS") {
      if (isStaticPath) {
        if (path in staticRouter)
          staticRouter[path][method] = index;
        else
          staticRouter[path] = { [method]: index };
        return;
      }
      if (this.router.http.add("WS", path, handler), !this.config.strictPath)
        this.router.http.add("WS", getLoosePath(path), handler);
      let encoded = encodePath(path, { dynamic: true });
      if (path !== encoded)
        this.router.http.add("WS", encoded, handler);
      return;
    }
    if (isStaticPath) {
      if (path in staticRouter)
        staticRouter[path][method] = index;
      else
        staticRouter[path] = { [method]: index };
      if (!this.config.strictPath)
        addResponsePath(getLoosePath(path));
    } else {
      if (this.router.http.add(method, path, handler), !this.config.strictPath) {
        let loosePath = getLoosePath(path);
        addResponsePath(loosePath), this.router.http.add(method, loosePath, handler);
      }
      let encoded = encodePath(path, { dynamic: true });
      if (path !== encoded)
        this.router.http.add(method, encoded, handler), addResponsePath(encoded);
    }
  }
  setHeaders;
  headers(header) {
    if (!header)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    return this.setHeaders = mergeDeep(this.setHeaders, header), this;
  }
  onStart(handler) {
    return this.on("start", handler), this;
  }
  onRequest(handler) {
    return this.on("request", handler), this;
  }
  onParse(options, handler) {
    if (!handler) {
      if (typeof options === "string")
        return this.on("parse", this["~parser"][options]);
      return this.on("parse", options);
    }
    return this.on(options, "parse", handler);
  }
  parser(name, parser) {
    return this["~parser"][name] = parser, this;
  }
  onTransform(options, handler) {
    if (!handler)
      return this.on("transform", options);
    return this.on(options, "transform", handler);
  }
  resolve(optionsOrResolve, resolve) {
    if (!resolve)
      resolve = optionsOrResolve, optionsOrResolve = { as: "local" };
    let hook = { subType: "resolve", fn: resolve };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  mapResolve(optionsOrResolve, mapper) {
    if (!mapper)
      mapper = optionsOrResolve, optionsOrResolve = { as: "local" };
    let hook = { subType: "mapResolve", fn: mapper };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  onBeforeHandle(options, handler) {
    if (!handler)
      return this.on("beforeHandle", options);
    return this.on(options, "beforeHandle", handler);
  }
  onAfterHandle(options, handler) {
    if (!handler)
      return this.on("afterHandle", options);
    return this.on(options, "afterHandle", handler);
  }
  mapResponse(options, handler) {
    if (!handler)
      return this.on("mapResponse", options);
    return this.on(options, "mapResponse", handler);
  }
  onAfterResponse(options, handler) {
    if (!handler)
      return this.on("afterResponse", options);
    return this.on(options, "afterResponse", handler);
  }
  trace(options, handler) {
    if (!handler)
      handler = options, options = { as: "local" };
    if (!Array.isArray(handler))
      handler = [handler];
    for (let fn of handler)
      this.on(options, "trace", createTracer(fn));
    return this;
  }
  error(name, error) {
    switch (typeof name) {
      case "string":
        return error.prototype[ERROR_CODE] = name, this.definitions.error[name] = error, this;
      case "function":
        return this.definitions.error = name(this.definitions.error), this;
    }
    for (let [code, error2] of Object.entries(name))
      error2.prototype[ERROR_CODE] = code, this.definitions.error[code] = error2;
    return this;
  }
  onError(options, handler) {
    if (!handler)
      return this.on("error", options);
    return this.on(options, "error", handler);
  }
  onStop(handler) {
    return this.on("stop", handler), this;
  }
  on(optionsOrType, typeOrHandlers, handlers) {
    let type;
    switch (typeof optionsOrType) {
      case "string":
        type = optionsOrType, handlers = typeOrHandlers;
        break;
      case "object":
        if (type = typeOrHandlers, !Array.isArray(typeOrHandlers) && typeof typeOrHandlers === "object")
          handlers = typeOrHandlers;
        break;
    }
    if (Array.isArray(handlers))
      handlers = fnToContainer(handlers);
    else if (typeof handlers === "function")
      handlers = [{ fn: handlers }];
    else
      handlers = [handlers];
    let handles = handlers;
    for (let handle of handles)
      if (handle.scope = typeof optionsOrType === "string" ? "local" : optionsOrType?.as ?? "local", type === "resolve" || type === "derive")
        handle.subType = type;
    if (type !== "trace")
      this.inference = sucrose({ [type]: handles.map((x2) => x2.fn) }, this.inference, this.config.sucrose);
    for (let handle of handles) {
      let fn = asHookType(handle, "global", { skipIfHasType: true });
      switch (type) {
        case "start":
          this.event.start ??= [], this.event.start.push(fn);
          break;
        case "request":
          this.event.request ??= [], this.event.request.push(fn);
          break;
        case "parse":
          this.event.parse ??= [], this.event.parse.push(fn);
          break;
        case "transform":
          this.event.transform ??= [], this.event.transform.push(fn);
          break;
        case "derive":
          this.event.transform ??= [], this.event.transform.push(fnToContainer(fn, "derive"));
          break;
        case "beforeHandle":
          this.event.beforeHandle ??= [], this.event.beforeHandle.push(fn);
          break;
        case "resolve":
          this.event.beforeHandle ??= [], this.event.beforeHandle.push(fnToContainer(fn, "resolve"));
          break;
        case "afterHandle":
          this.event.afterHandle ??= [], this.event.afterHandle.push(fn);
          break;
        case "mapResponse":
          this.event.mapResponse ??= [], this.event.mapResponse.push(fn);
          break;
        case "afterResponse":
          this.event.afterResponse ??= [], this.event.afterResponse.push(fn);
          break;
        case "trace":
          this.event.trace ??= [], this.event.trace.push(fn);
          break;
        case "error":
          this.event.error ??= [], this.event.error.push(fn);
          break;
        case "stop":
          this.event.stop ??= [], this.event.stop.push(fn);
          break;
      }
    }
    return this;
  }
  as(type) {
    if (promoteEvent(this.event.parse, type), promoteEvent(this.event.transform, type), promoteEvent(this.event.beforeHandle, type), promoteEvent(this.event.afterHandle, type), promoteEvent(this.event.mapResponse, type), promoteEvent(this.event.afterResponse, type), promoteEvent(this.event.trace, type), promoteEvent(this.event.error, type), type === "scoped") {
      if (this.validator.scoped = mergeSchemaValidator(this.validator.scoped, this.validator.local), this.validator.local = null, this.standaloneValidator.local !== null)
        this.standaloneValidator.scoped ||= [], this.standaloneValidator.scoped.push(...this.standaloneValidator.local), this.standaloneValidator.local = null;
    } else if (type === "global") {
      if (this.validator.global = mergeSchemaValidator(this.validator.global, mergeSchemaValidator(this.validator.scoped, this.validator.local)), this.validator.scoped = null, this.validator.local = null, this.standaloneValidator.local !== null)
        this.standaloneValidator.scoped ||= [], this.standaloneValidator.scoped.push(...this.standaloneValidator.local), this.standaloneValidator.local = null;
      if (this.standaloneValidator.scoped !== null)
        this.standaloneValidator.global ||= [], this.standaloneValidator.global.push(...this.standaloneValidator.scoped), this.standaloneValidator.scoped = null;
    }
    return this;
  }
  group(prefix, schemaOrRun, run) {
    let instance = new Elysia({ ...this.config, prefix: "" });
    instance.singleton = { ...this.singleton }, instance.definitions = { ...this.definitions }, instance.getServer = () => this.getServer(), instance.inference = cloneInference(this.inference), instance.extender = { ...this.extender }, instance["~parser"] = this["~parser"], instance.standaloneValidator = { local: [...this.standaloneValidator.local ?? []], scoped: [...this.standaloneValidator.scoped ?? []], global: [...this.standaloneValidator.global ?? []] };
    let isSchema = typeof schemaOrRun === "object", sandbox = (isSchema ? run : schemaOrRun)(instance);
    if (this.singleton = mergeDeep(this.singleton, instance.singleton), this.definitions = mergeDeep(this.definitions, instance.definitions), sandbox.event.request?.length)
      this.event.request = [...this.event.request || [], ...sandbox.event.request || []];
    if (sandbox.event.mapResponse?.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...sandbox.event.mapResponse || []];
    return this.model(sandbox.definitions.type), Object.values(instance.router.history).forEach(({ method, path, handler, hooks }) => {
      if (path = (isSchema ? "" : this.config.prefix ?? "") + prefix + path, isSchema) {
        let { body, headers, query, params, cookie, response, ...hook } = schemaOrRun, localHook = hooks, hasStandaloneSchema = body || headers || query || params || cookie || response;
        this.add(method, path, handler, mergeHook(hook, { ...localHook || {}, error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [...localHook.error ?? [], ...sandbox.event.error ?? []] : [localHook.error, ...sandbox.event.error ?? []], standaloneValidator: !hasStandaloneSchema ? localHook.standaloneValidator : [...localHook.standaloneValidator ?? [], { body, headers, query, params, cookie, response }] }), undefined);
      } else
        this.add(method, path, handler, mergeHook(hooks, { error: sandbox.event.error }), { skipPrefix: true });
    }), this;
  }
  guard(hook, run) {
    if (!run) {
      if (typeof hook === "object") {
        if (this.applyMacro(hook), hook.detail)
          if (this.config.detail)
            this.config.detail = mergeDeep(Object.assign({}, this.config.detail), hook.detail);
          else
            this.config.detail = hook.detail;
        if (hook.tags)
          if (!this.config.detail)
            this.config.detail = { tags: hook.tags };
          else
            this.config.detail.tags = hook.tags;
        let type = hook.as ?? "local";
        if (hook.schema === "standalone") {
          if (!this.standaloneValidator[type])
            this.standaloneValidator[type] = [];
          let response = !hook?.response ? undefined : typeof hook.response === "string" || (Kind in hook.response) || ("~standard" in hook.response) ? { 200: hook.response } : hook?.response;
          this.standaloneValidator[type].push({ body: hook.body, headers: hook.headers, params: hook.params, query: hook.query, response, cookie: hook.cookie });
        } else
          this.validator[type] = { body: hook.body ?? this.validator[type]?.body, headers: hook.headers ?? this.validator[type]?.headers, params: hook.params ?? this.validator[type]?.params, query: hook.query ?? this.validator[type]?.query, response: hook.response ?? this.validator[type]?.response, cookie: hook.cookie ?? this.validator[type]?.cookie };
        if (hook.parse)
          this.on({ as: type }, "parse", hook.parse);
        if (hook.transform)
          this.on({ as: type }, "transform", hook.transform);
        if (hook.derive)
          this.on({ as: type }, "derive", hook.derive);
        if (hook.beforeHandle)
          this.on({ as: type }, "beforeHandle", hook.beforeHandle);
        if (hook.resolve)
          this.on({ as: type }, "resolve", hook.resolve);
        if (hook.afterHandle)
          this.on({ as: type }, "afterHandle", hook.afterHandle);
        if (hook.mapResponse)
          this.on({ as: type }, "mapResponse", hook.mapResponse);
        if (hook.afterResponse)
          this.on({ as: type }, "afterResponse", hook.afterResponse);
        if (hook.error)
          this.on({ as: type }, "error", hook.error);
        return this;
      }
      return this.guard({}, hook);
    }
    let instance = new Elysia({ ...this.config, prefix: "" });
    instance.singleton = { ...this.singleton }, instance.definitions = { ...this.definitions }, instance.inference = cloneInference(this.inference), instance.extender = { ...this.extender }, instance.getServer = () => this.getServer();
    let sandbox = run(instance);
    if (this.singleton = mergeDeep(this.singleton, instance.singleton), this.definitions = mergeDeep(this.definitions, instance.definitions), sandbox.getServer = () => this.server, sandbox.event.request?.length)
      this.event.request = [...this.event.request || [], ...sandbox.event.request || []];
    if (sandbox.event.mapResponse?.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...sandbox.event.mapResponse || []];
    return this.model(sandbox.definitions.type), Object.values(instance.router.history).forEach(({ method, path, handler, hooks: localHook }) => {
      let { body, headers, query, params, cookie, response, ...guardHook } = hook, hasStandaloneSchema = body || headers || query || params || cookie || response;
      this.add(method, path, handler, mergeHook(guardHook, { ...localHook || {}, error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [...localHook.error ?? [], ...sandbox.event.error ?? []] : [localHook.error, ...sandbox.event.error ?? []], standaloneValidator: !hasStandaloneSchema ? localHook.standaloneValidator : [...localHook.standaloneValidator ?? [], { body, headers, query, params, cookie, response }] }));
    }), this;
  }
  use(plugin) {
    if (!plugin)
      return this;
    if (Array.isArray(plugin)) {
      let app = this;
      for (let p of plugin)
        app = app.use(p);
      return app;
    }
    if (plugin instanceof Promise)
      return this.promisedModules.add(plugin.then((plugin2) => {
        if (typeof plugin2 === "function")
          return plugin2(this);
        if (plugin2 instanceof Elysia)
          return this._use(plugin2).compile();
        if (plugin2.constructor?.name === "Elysia")
          return this._use(plugin2).compile();
        if (typeof plugin2.default === "function")
          return plugin2.default(this);
        if (plugin2.default instanceof Elysia)
          return this._use(plugin2.default);
        if (plugin2.constructor?.name === "Elysia")
          return this._use(plugin2.default);
        if (plugin2.constructor?.name === "_Elysia")
          return this._use(plugin2.default);
        try {
          return this._use(plugin2.default);
        } catch (error) {
          throw console.error('Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.'), error;
        }
      }).then((v) => {
        if (v && typeof v.compile === "function")
          v.compile();
        return v;
      })), this;
    return this._use(plugin);
  }
  propagatePromiseModules(plugin) {
    if (plugin.promisedModules.size <= 0)
      return this;
    for (let promise of plugin.promisedModules.promises)
      this.promisedModules.add(promise.then((v) => {
        if (!v)
          return;
        let t2 = this._use(v);
        if (t2 instanceof Promise)
          return t2.then((v2) => {
            if (v2)
              v2.compile();
            else
              v.compile();
          });
        return v.compile();
      }));
    return this;
  }
  _use(plugin) {
    if (typeof plugin === "function") {
      let instance = plugin(this);
      if (instance instanceof Promise)
        return this.promisedModules.add(instance.then((plugin2) => {
          if (plugin2 instanceof Elysia) {
            plugin2.getServer = () => this.getServer(), plugin2.getGlobalRoutes = () => this.getGlobalRoutes(), plugin2.getGlobalDefinitions = () => this.getGlobalDefinitions(), plugin2.model(this.definitions.type), plugin2.error(this.definitions.error);
            for (let { method, path, handler, hooks } of Object.values(plugin2.router.history))
              this.add(method, path, handler, hooks, undefined);
            if (plugin2 === this)
              return;
            return this.propagatePromiseModules(plugin2), plugin2;
          }
          if (typeof plugin2 === "function")
            return plugin2(this);
          if (typeof plugin2.default === "function")
            return plugin2.default(this);
          return this._use(plugin2);
        }).then((v) => {
          if (v && typeof v.compile === "function")
            v.compile();
          return v;
        })), this;
      return instance;
    }
    this.propagatePromiseModules(plugin);
    let name = plugin.config.name, seed = plugin.config.seed;
    if (plugin.getParent = () => this, plugin.getServer = () => this.getServer(), plugin.getGlobalRoutes = () => this.getGlobalRoutes(), plugin.getGlobalDefinitions = () => this.getGlobalDefinitions(), plugin.standaloneValidator?.scoped)
      if (this.standaloneValidator.local)
        this.standaloneValidator.local = this.standaloneValidator.local.concat(plugin.standaloneValidator.scoped);
      else
        this.standaloneValidator.local = plugin.standaloneValidator.scoped;
    if (plugin.standaloneValidator?.global)
      if (this.standaloneValidator.global)
        this.standaloneValidator.global = this.standaloneValidator.global.concat(plugin.standaloneValidator.global);
      else
        this.standaloneValidator.global = plugin.standaloneValidator.global;
    if (isNotEmpty(plugin["~parser"]))
      this["~parser"] = { ...plugin["~parser"], ...this["~parser"] };
    if (plugin.setHeaders)
      this.headers(plugin.setHeaders);
    if (name) {
      if (!(name in this.dependencies))
        this.dependencies[name] = [];
      let current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
      if (!this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
        this.extender.macro = { ...this.extender.macro, ...plugin.extender.macro }, this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(plugin.extender.higherOrderFunctions);
    } else {
      if (isNotEmpty(plugin.extender.macro))
        this.extender.macro = { ...this.extender.macro, ...plugin.extender.macro };
      if (plugin.extender.higherOrderFunctions.length)
        this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(plugin.extender.higherOrderFunctions);
    }
    if (plugin.extender.higherOrderFunctions.length) {
      deduplicateChecksum(this.extender.higherOrderFunctions);
      let hofHashes = [];
      for (let i2 = 0;i2 < this.extender.higherOrderFunctions.length; i2++) {
        let hof = this.extender.higherOrderFunctions[i2];
        if (hof.checksum) {
          if (hofHashes.includes(hof.checksum))
            this.extender.higherOrderFunctions.splice(i2, 1), i2--;
          hofHashes.push(hof.checksum);
        }
      }
      hofHashes.length = 0;
    }
    if (this.inference = mergeInference(this.inference, plugin.inference), isNotEmpty(plugin.singleton.decorator))
      this.decorate(plugin.singleton.decorator);
    if (isNotEmpty(plugin.singleton.store))
      this.state(plugin.singleton.store);
    if (isNotEmpty(plugin.definitions.type))
      this.model(plugin.definitions.type);
    if (isNotEmpty(plugin.definitions.error))
      this.error(plugin.definitions.error);
    if (isNotEmpty(plugin.extender.macro))
      this.extender.macro = { ...this.extender.macro, ...plugin.extender.macro };
    for (let { method, path, handler, hooks } of Object.values(plugin.router.history))
      this.add(method, path, handler, hooks);
    if (name) {
      if (!(name in this.dependencies))
        this.dependencies[name] = [];
      let current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
      if (this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
        return this;
      if (this.dependencies[name].push(this.config?.analytic ? { name: plugin.config.name, seed: plugin.config.seed, checksum: current, dependencies: plugin.dependencies, stack: plugin.telemetry?.stack, routes: plugin.router.history, decorators: plugin.singleton, store: plugin.singleton.store, error: plugin.definitions.error, derive: plugin.event.transform?.filter((x2) => x2?.subType === "derive").map((x2) => ({ fn: x2.toString(), stack: Error().stack ?? "" })), resolve: plugin.event.transform?.filter((x2) => x2?.subType === "resolve").map((x2) => ({ fn: x2.toString(), stack: Error().stack ?? "" })) } : { name: plugin.config.name, seed: plugin.config.seed, checksum: current, dependencies: plugin.dependencies }), isNotEmpty(plugin.event))
        this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event), current);
    } else if (isNotEmpty(plugin.event))
      this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event));
    if (plugin.validator.global)
      this.validator.global = mergeHook(this.validator.global, { ...plugin.validator.global });
    if (plugin.validator.scoped)
      this.validator.local = mergeHook(this.validator.local, { ...plugin.validator.scoped });
    return this;
  }
  macro(macroOrName, macro) {
    if (typeof macroOrName === "string" && !macro)
      throw Error("Macro function is required");
    if (typeof macroOrName === "string")
      this.extender.macro[macroOrName] = macro;
    else
      this.extender.macro = { ...this.extender.macro, ...macroOrName };
    return this;
  }
  applyMacro(localHook, appliable = localHook, { iteration = 0, applied = {} } = {}) {
    if (iteration >= 16)
      return;
    let macro = this.extender.macro;
    for (let [key, value] of Object.entries(appliable)) {
      if (key in macro === false)
        continue;
      let macroHook = typeof macro[key] === "function" ? macro[key](value) : macro[key];
      if (!macroHook || typeof macro[key] === "object" && value === false)
        return;
      let seed = checksum(key + JSON.stringify(macroHook.seed ?? value));
      if (seed in applied)
        continue;
      applied[seed] = true;
      for (let [k2, value2] of Object.entries(macroHook)) {
        if (k2 === "seed")
          continue;
        if (k2 in emptySchema) {
          insertStandaloneValidator(localHook, k2, value2), delete localHook[key];
          continue;
        }
        if (k2 === "detail") {
          if (!localHook.detail)
            localHook.detail = {};
          localHook.detail = mergeDeep(localHook.detail, value2, { mergeArray: true }), delete localHook[key];
          continue;
        }
        if (k2 in macro) {
          this.applyMacro(localHook, { [k2]: value2 }, { applied, iteration: iteration + 1 }), delete localHook[key];
          continue;
        }
        if ((k2 === "derive" || k2 === "resolve") && typeof value2 === "function")
          value2 = { fn: value2, subType: k2 };
        switch (typeof localHook[k2]) {
          case "function":
            localHook[k2] = [localHook[k2], value2];
            break;
          case "object":
            if (Array.isArray(localHook[k2]))
              localHook[k2].push(value2);
            else
              localHook[k2] = [localHook[k2], value2];
            break;
          case "undefined":
            localHook[k2] = value2;
            break;
        }
        delete localHook[key];
      }
    }
  }
  mount(path, handleOrConfig, config) {
    if (path instanceof Elysia || typeof path === "function" || path.length === 0 || path === "/") {
      let run = typeof path === "function" ? path : path instanceof Elysia ? path.compile().fetch : handleOrConfig instanceof Elysia ? handleOrConfig.compile().fetch : typeof handleOrConfig === "function" ? handleOrConfig : (() => {
        throw Error("Invalid handler");
      })(), handler2 = ({ request, path: path2 }) => run(new Request(replaceUrlPath(request.url, path2), { method: request.method, headers: request.headers, signal: request.signal, credentials: request.credentials, referrerPolicy: request.referrerPolicy, duplex: request.duplex, redirect: request.redirect, mode: request.mode, keepalive: request.keepalive, integrity: request.integrity, body: request.body }));
      return this.route("ALL", "/*", handler2, { parse: "none", ...config, detail: { ...config?.detail, hide: true }, config: { mount: run } }), this;
    }
    let handle = handleOrConfig instanceof Elysia ? handleOrConfig.compile().fetch : typeof handleOrConfig === "function" ? handleOrConfig : (() => {
      throw Error("Invalid handler");
    })(), length = path.length - (path.endsWith("*") ? 1 : 0), handler = ({ request, path: path2 }) => handle(new Request(replaceUrlPath(request.url, path2.slice(length) || "/"), { method: request.method, headers: request.headers, signal: request.signal, credentials: request.credentials, referrerPolicy: request.referrerPolicy, duplex: request.duplex, redirect: request.redirect, mode: request.mode, keepalive: request.keepalive, integrity: request.integrity, body: request.body }));
    return this.route("ALL", path, handler, { parse: "none", ...config, detail: { ...config?.detail, hide: true }, config: { mount: handle } }), this.route("ALL", path + (path.endsWith("/") ? "*" : "/*"), handler, { parse: "none", ...config, detail: { ...config?.detail, hide: true }, config: { mount: handle } }), this;
  }
  get(path, handler, hook) {
    return this.add("GET", path, handler, hook), this;
  }
  post(path, handler, hook) {
    return this.add("POST", path, handler, hook), this;
  }
  put(path, handler, hook) {
    return this.add("PUT", path, handler, hook), this;
  }
  patch(path, handler, hook) {
    return this.add("PATCH", path, handler, hook), this;
  }
  delete(path, handler, hook) {
    return this.add("DELETE", path, handler, hook), this;
  }
  options(path, handler, hook) {
    return this.add("OPTIONS", path, handler, hook), this;
  }
  all(path, handler, hook) {
    return this.add("ALL", path, handler, hook), this;
  }
  head(path, handler, hook) {
    return this.add("HEAD", path, handler, hook), this;
  }
  connect(path, handler, hook) {
    return this.add("CONNECT", path, handler, hook), this;
  }
  route(method, path, handler, hook) {
    return this.add(method.toUpperCase(), path, handler, hook, hook?.config), this;
  }
  ws(path, options) {
    if (this["~adapter"].ws)
      this["~adapter"].ws(this, path, options);
    else
      console.warn("Current adapter doesn't support WebSocket");
    return this;
  }
  state(options, name, value) {
    if (name === undefined)
      value = options, options = { as: "append" }, name = "";
    else if (value === undefined) {
      if (typeof options === "string")
        value = name, name = options, options = { as: "append" };
      else if (typeof options === "object")
        value = name, name = "";
    }
    let { as } = options;
    if (typeof name !== "string")
      return this;
    switch (typeof value) {
      case "object":
        if (!value || !isNotEmpty(value))
          return this;
        if (name) {
          if (name in this.singleton.store)
            this.singleton.store[name] = mergeDeep(this.singleton.store[name], value, { override: as === "override" });
          else
            this.singleton.store[name] = value;
          return this;
        }
        if (value === null)
          return this;
        return this.singleton.store = mergeDeep(this.singleton.store, value, { override: as === "override" }), this;
      case "function":
        if (name) {
          if (as === "override" || !(name in this.singleton.store))
            this.singleton.store[name] = value;
        } else
          this.singleton.store = value(this.singleton.store);
        return this;
      default:
        if (as === "override" || !(name in this.singleton.store))
          this.singleton.store[name] = value;
        return this;
    }
  }
  decorate(options, name, value) {
    if (name === undefined)
      value = options, options = { as: "append" }, name = "";
    else if (value === undefined) {
      if (typeof options === "string")
        value = name, name = options, options = { as: "append" };
      else if (typeof options === "object")
        value = name, name = "";
    }
    let { as } = options;
    if (typeof name !== "string")
      return this;
    switch (typeof value) {
      case "object":
        if (name) {
          if (name in this.singleton.decorator)
            this.singleton.decorator[name] = mergeDeep(this.singleton.decorator[name], value, { override: as === "override" });
          else
            this.singleton.decorator[name] = value;
          return this;
        }
        if (value === null)
          return this;
        return this.singleton.decorator = mergeDeep(this.singleton.decorator, value, { override: as === "override" }), this;
      case "function":
        if (name) {
          if (as === "override" || !(name in this.singleton.decorator))
            this.singleton.decorator[name] = value;
        } else
          this.singleton.decorator = value(this.singleton.decorator);
        return this;
      default:
        if (as === "override" || !(name in this.singleton.decorator))
          this.singleton.decorator[name] = value;
        return this;
    }
  }
  derive(optionsOrTransform, transform2) {
    if (!transform2)
      transform2 = optionsOrTransform, optionsOrTransform = { as: "local" };
    let hook = { subType: "derive", fn: transform2 };
    return this.onTransform(optionsOrTransform, hook);
  }
  model(name, model) {
    let onlyTypebox = (a) => {
      let res = {};
      for (let key in a)
        if (!("~standard" in a[key]))
          res[key] = a[key];
      return res;
    };
    switch (typeof name) {
      case "object":
        let parsedTypebox = {}, kvs = Object.entries(name);
        if (!kvs.length)
          return this;
        for (let [key, value] of kvs) {
          if (key in this.definitions.type)
            continue;
          if ("~standard" in value)
            this.definitions.type[key] = value;
          else
            parsedTypebox[key] = this.definitions.type[key] = value, parsedTypebox[key].$id ??= `#/components/schemas/${key}`;
        }
        return this.definitions.typebox = t.Module({ ...this.definitions.typebox.$defs, ...parsedTypebox }), this;
      case "function":
        let result = name(this.definitions.type);
        return this.definitions.type = result, this.definitions.typebox = t.Module(onlyTypebox(result)), this;
      case "string":
        if (!model)
          break;
        if (this.definitions.type[name] = model, "~standard" in model)
          return this;
        let newModel = { ...model, id: model.$id ?? `#/components/schemas/${name}` };
        return this.definitions.typebox = t.Module({ ...this.definitions.typebox.$defs, ...newModel }), this;
    }
    if (!model)
      return this;
    if (this.definitions.type[name] = model, "~standard" in model)
      return this;
    return this.definitions.typebox = t.Module({ ...this.definitions.typebox.$defs, [name]: model }), this;
  }
  Ref(key) {
    return t.Ref(key);
  }
  mapDerive(optionsOrDerive, mapper) {
    if (!mapper)
      mapper = optionsOrDerive, optionsOrDerive = { as: "local" };
    let hook = { subType: "mapDerive", fn: mapper };
    return this.onTransform(optionsOrDerive, hook);
  }
  affix(base, type, word) {
    if (word === "")
      return this;
    let delimieter = ["_", "-", " "], capitalize = (word2) => word2[0].toUpperCase() + word2.slice(1), joinKey = base === "prefix" ? (prefix, word2) => delimieter.includes(prefix.at(-1) ?? "") ? prefix + word2 : prefix + capitalize(word2) : delimieter.includes(word.at(-1) ?? "") ? (suffix, word2) => word2 + suffix : (suffix, word2) => word2 + capitalize(suffix), remap = (type2) => {
      let store = {};
      switch (type2) {
        case "decorator":
          for (let key in this.singleton.decorator)
            store[joinKey(word, key)] = this.singleton.decorator[key];
          this.singleton.decorator = store;
          break;
        case "state":
          for (let key in this.singleton.store)
            store[joinKey(word, key)] = this.singleton.store[key];
          this.singleton.store = store;
          break;
        case "model":
          for (let key in this.definitions.type)
            store[joinKey(word, key)] = this.definitions.type[key];
          this.definitions.type = store;
          break;
        case "error":
          for (let key in this.definitions.error)
            store[joinKey(word, key)] = this.definitions.error[key];
          this.definitions.error = store;
          break;
      }
    }, types = Array.isArray(type) ? type : [type];
    for (let type2 of types.some((x2) => x2 === "all") ? ["decorator", "state", "model", "error"] : types)
      remap(type2);
    return this;
  }
  prefix(type, word) {
    return this.affix("prefix", type, word);
  }
  suffix(type, word) {
    return this.affix("suffix", type, word);
  }
  compile() {
    if (this["~adapter"].beforeCompile?.(this), this["~adapter"].isWebStandard) {
      if (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this), typeof this.server?.reload === "function")
        this.server.reload({ ...this.server || {}, fetch: this.fetch });
      return this;
    }
    if (typeof this.server?.reload === "function")
      this.server.reload(this.server || {});
    return this._handle = composeGeneralHandler(this), this;
  }
  handle = async (request) => this.fetch(request);
  fetch = (request) => {
    return (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this))(request);
  };
  handleError = async (context, error) => {
    return (this.handleError = this.config.aot ? composeErrorHandler(this) : createDynamicErrorHandler(this))(context, error);
  };
  listen = (options, callback) => {
    return this["~adapter"].listen(this)(options, callback), this;
  };
  stop = async (closeActiveConnections) => {
    return await this["~adapter"].stop?.(this, closeActiveConnections), this;
  };
  [Symbol.dispose] = () => {
    if (this.server)
      this.stop();
  };
  get modules() {
    return this.promisedModules;
  }
}

// node_modules/@elysiajs/cors/dist/index.mjs
var isBun3 = typeof new Headers()?.toJSON === "function";
var processHeaders = (headers) => {
  if (isBun3)
    return Object.keys(headers.toJSON()).join(", ");
  let keys = "";
  let i2 = 0;
  headers.forEach((_2, key) => {
    if (i2)
      keys = keys + ", " + key;
    else
      keys = key;
    i2++;
  });
  return keys;
};
var cors = (config) => {
  let {
    aot = true,
    origin = true,
    methods = true,
    allowedHeaders = true,
    exposeHeaders = true,
    credentials = true,
    maxAge = 5,
    preflight = true
  } = config ?? {};
  if (Array.isArray(allowedHeaders))
    allowedHeaders = allowedHeaders.join(", ");
  if (Array.isArray(exposeHeaders))
    exposeHeaders = exposeHeaders.join(", ");
  const origins = typeof origin === "boolean" ? undefined : Array.isArray(origin) ? origin : [origin];
  const app = new Elysia({
    name: "@elysiajs/cors",
    seed: config,
    aot
  });
  const anyOrigin = origins?.some((o) => o === "*");
  const originMap = {};
  if (origins) {
    for (const origin2 of origins)
      if (typeof origin2 === "string")
        originMap[origin2] = true;
  }
  const processOrigin = (origin2, request, from) => {
    if (Array.isArray(origin2))
      return origin2.some((o) => processOrigin(o, request, from));
    switch (typeof origin2) {
      case "string":
        if (from in originMap)
          return true;
        const fromProtocol = from.indexOf("://");
        if (fromProtocol !== -1)
          from = from.slice(fromProtocol + 3);
        return origin2 === from;
      case "function":
        return origin2(request) === true;
      case "object":
        if (origin2 instanceof RegExp)
          return origin2.test(from);
    }
    return false;
  };
  const handleOrigin = (set2, request) => {
    if (origin === true) {
      set2.headers.vary = "*";
      set2.headers["access-control-allow-origin"] = request.headers.get("Origin") || "*";
      return;
    }
    if (anyOrigin) {
      set2.headers.vary = "*";
      set2.headers["access-control-allow-origin"] = "*";
      return;
    }
    if (!origins?.length)
      return;
    const headers = [];
    if (origins.length) {
      const from = request.headers.get("Origin") ?? "";
      for (let i2 = 0;i2 < origins.length; i2++) {
        const value = processOrigin(origins[i2], request, from);
        if (value === true) {
          set2.headers.vary = origin ? "Origin" : "*";
          set2.headers["access-control-allow-origin"] = from || "*";
          return;
        }
      }
    }
    set2.headers.vary = "Origin";
    if (headers.length)
      set2.headers["access-control-allow-origin"] = headers.join(", ");
  };
  const handleMethod = (set2, method) => {
    if (!method)
      return;
    if (methods === true)
      return set2.headers["access-control-allow-methods"] = method ?? "*";
    if (methods === false || !methods?.length)
      return;
    if (methods === "*")
      return set2.headers["access-control-allow-methods"] = "*";
    if (!Array.isArray(methods))
      return set2.headers["access-control-allow-methods"] = methods;
    set2.headers["access-control-allow-methods"] = methods.join(", ");
  };
  const defaultHeaders = {};
  if (typeof exposeHeaders === "string")
    defaultHeaders["access-control-expose-headers"] = exposeHeaders;
  if (typeof allowedHeaders === "string")
    defaultHeaders["access-control-allow-headers"] = allowedHeaders;
  if (credentials === true)
    defaultHeaders["access-control-allow-credentials"] = "true";
  app.headers(defaultHeaders);
  function handleOption({ set: set2, request, headers }) {
    handleOrigin(set2, request);
    handleMethod(set2, request.headers.get("access-control-request-method"));
    if (allowedHeaders === true || exposeHeaders === true) {
      if (allowedHeaders === true)
        set2.headers["access-control-allow-headers"] = headers["access-control-request-headers"];
      if (exposeHeaders === true)
        set2.headers["access-control-expose-headers"] = Object.keys(headers).join(",");
    }
    if (maxAge)
      set2.headers["access-control-max-age"] = maxAge.toString();
    return new Response(null, {
      status: 204
    });
  }
  if (preflight)
    app.options("/", handleOption).options("/*", handleOption);
  return app.onRequest(function processCors({ set: set2, request }) {
    handleOrigin(set2, request);
    handleMethod(set2, request.method);
    if (allowedHeaders === true || exposeHeaders === true) {
      const headers = processHeaders(request.headers);
      if (allowedHeaders === true)
        set2.headers["access-control-allow-headers"] = headers;
      if (exposeHeaders === true)
        set2.headers["access-control-expose-headers"] = headers;
    }
  });
};

// src/config/database.ts
init_dist_es13();
init_dist_es15();
var AWS_REGION = process.env.AWS_REGION || "us-east-1";
var TABLE_NAME = process.env.DYNAMODB_TABLE_NAME || "PFF_Storage_Table";
var AWS_ACCESS_KEY_ID = process.env.LAB_ACCESS_KEY_ID || "type";
var AWS_SECRET_ACCESS_KEY = process.env.LAB_SECRET_ACCESS_KEY || "script";
var AWS_SESSION_TOKEN = process.env.LAB_SESSION_TOKEN || "\u0E14\u0E48\u0E32";
var client = new DynamoDBClient({
  region: AWS_REGION
});
var docClient = DynamoDBDocumentClient.from(client);

// src/models/user.model.ts
var findAll = async () => {
  const result = await docClient.send(new (await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8))).ScanCommand({
    TableName: TABLE_NAME,
    FilterExpression: "begins_with(PK, :user)",
    ExpressionAttributeValues: {
      ":user": "USER#"
    }
  }));
  return result.Items || [];
};
var findById = async (id) => {
  const result = await docClient.send(new (await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8))).GetCommand({
    TableName: TABLE_NAME,
    Key: {
      PK: `USER#${id}`,
      SK: `USER#${id}`
    }
  }));
  return result.Item;
};
var create2 = async (data) => {
  const { id, name, email } = data;
  const userId = id || Date.now().toString();
  const user = {
    PK: `USER#${userId}`,
    SK: `USER#${userId}`,
    id: userId,
    name,
    email,
    createdAt: new Date().toISOString()
  };
  await docClient.send(new (await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8))).PutCommand({
    TableName: TABLE_NAME,
    Item: user
  }));
  return user;
};

// src/controllers/user.controller.ts
var getAllUsers = async () => {
  return await findAll();
};
var getUserById = async ({ params }) => {
  const user = await findById(params.id);
  if (!user)
    return { error: "User not found" };
  return user;
};
var createUser = async ({ body }) => {
  const newUser = await create2(body);
  return newUser;
};

// src/routes/user.routes.ts
var userRoutes = new Elysia({ prefix: "/users" }).get("/health", () => "User routes are healthy").get("/", getAllUsers).get("/:id", getUserById).post("/", createUser);
var user_routes_default = userRoutes;

// src/models/warehouse.model.ts
var findAll2 = async () => {
  const result = await docClient.send(new (await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8))).QueryCommand({
    TableName: TABLE_NAME,
    KeyConditionExpression: "PK = :pk",
    ExpressionAttributeValues: {
      ":pk": "WAREHOUSE#LIST"
    }
  }));
  return result.Items || [];
};
var findById2 = async (warehouseId) => {
  const result = await docClient.send(new (await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8))).GetCommand({
    TableName: TABLE_NAME,
    Key: {
      PK: "WAREHOUSE#LIST",
      SK: `WAREHOUSE#${warehouseId}`
    }
  }));
  return result.Item;
};
var create3 = async (data) => {
  const warehouseId = `WH${Date.now()}`;
  const warehouse = {
    PK: "WAREHOUSE#LIST",
    SK: `WAREHOUSE#${warehouseId}`,
    type: "Warehouse",
    GSI1SK: `WAREHOUSE#${warehouseId}`,
    Type: "Warehouse",
    warehouseId,
    ...data
  };
  await docClient.send(new (await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8))).PutCommand({
    TableName: TABLE_NAME,
    Item: warehouse
  }));
  if (data.totalRooms && data.totalRooms > 0) {
    const { PutCommand: PutCommand3 } = await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8));
    const roomPromises = [];
    for (let i4 = 1;i4 <= data.totalRooms; i4++) {
      const roomId = `R${Date.now()}_${i4}`;
      const room = {
        PK: `WAREHOUSE#${warehouseId}`,
        SK: `ROOM#${roomId}`,
        Type: "Room",
        warehouseId,
        roomId,
        roomNumber: `${i4}`,
        status: "AVAILABLE",
        size: data.size || "N/A"
      };
      roomPromises.push(docClient.send(new PutCommand3({
        TableName: TABLE_NAME,
        Item: room
      })));
      await new Promise((resolve) => setTimeout(resolve, 1));
    }
    await Promise.all(roomPromises);
  }
  return warehouse;
};
var getRoomsByWarehouseId = async (warehouseId) => {
  const result = await docClient.send(new (await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8))).QueryCommand({
    TableName: TABLE_NAME,
    KeyConditionExpression: "PK = :pk AND begins_with(SK, :sk)",
    ExpressionAttributeValues: {
      ":pk": `WAREHOUSE#${warehouseId}`,
      ":sk": "ROOM#"
    }
  }));
  return result.Items || [];
};
var createRoom = async (warehouseId, data) => {
  const roomId = `R${Date.now()}`;
  const room = {
    PK: `WAREHOUSE#${warehouseId}`,
    SK: `ROOM#${roomId}`,
    Type: "Room",
    warehouseId,
    roomId,
    ...data
  };
  await docClient.send(new (await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8))).PutCommand({
    TableName: TABLE_NAME,
    Item: room
  }));
  return room;
};
var updateRoomStatus = async (warehouseId, roomId, status2) => {
  const result = await docClient.send(new (await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8))).UpdateCommand({
    TableName: TABLE_NAME,
    Key: {
      PK: `WAREHOUSE#${warehouseId}`,
      SK: `ROOM#${roomId}`
    },
    UpdateExpression: "SET #status = :status",
    ExpressionAttributeNames: {
      "#status": "status"
    },
    ExpressionAttributeValues: {
      ":status": status2
    },
    ReturnValues: "ALL_NEW"
  }));
  return result.Attributes;
};
var update = async (warehouseId, data) => {
  const { UpdateCommand: UpdateCommand3, PutCommand: PutCommand3 } = await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8));
  if (data.totalRooms !== undefined) {
    const currentRooms = await getRoomsByWarehouseId(warehouseId);
    const currentCount = currentRooms.length;
    const newCount = data.totalRooms;
    if (newCount > currentCount) {
      const roomsToAdd = newCount - currentCount;
      for (let i4 = 1;i4 <= roomsToAdd; i4++) {
        const roomNumber = currentCount + i4;
        const roomId = `R${Date.now()}_${roomNumber}`;
        const room = {
          PK: `WAREHOUSE#${warehouseId}`,
          SK: `ROOM#${roomId}`,
          Type: "Room",
          warehouseId,
          roomId,
          roomNumber: `${roomNumber}`,
          status: "AVAILABLE",
          size: data.size || "N/A"
        };
        await docClient.send(new PutCommand3({
          TableName: TABLE_NAME,
          Item: room
        }));
        await new Promise((resolve) => setTimeout(resolve, 1));
      }
    } else if (newCount < currentCount) {
      const { DeleteCommand: DeleteCommand3 } = await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8));
      const roomsToRemove = currentCount - newCount;
      const availableRooms = currentRooms.filter((room) => room.status === "AVAILABLE").slice(0, roomsToRemove);
      if (availableRooms.length < roomsToRemove) {
        throw new Error(`Cannot reduce room count. Only ${availableRooms.length} available rooms can be removed.`);
      }
      for (const room of availableRooms) {
        await docClient.send(new DeleteCommand3({
          TableName: TABLE_NAME,
          Key: {
            PK: `WAREHOUSE#${warehouseId}`,
            SK: `ROOM#${room.roomId}`
          }
        }));
      }
    }
  }
  const updateExpressions = [];
  const expressionAttributeNames = {};
  const expressionAttributeValues = {};
  Object.keys(data).forEach((key, index) => {
    if (key !== "warehouseId" && key !== "PK" && key !== "SK") {
      updateExpressions.push(`#field${index} = :value${index}`);
      expressionAttributeNames[`#field${index}`] = key;
      expressionAttributeValues[`:value${index}`] = data[key];
    }
  });
  if (updateExpressions.length === 0) {
    throw new Error("No fields to update");
  }
  const result = await docClient.send(new UpdateCommand3({
    TableName: TABLE_NAME,
    Key: {
      PK: "WAREHOUSE#LIST",
      SK: `WAREHOUSE#${warehouseId}`
    },
    UpdateExpression: `SET ${updateExpressions.join(", ")}`,
    ExpressionAttributeNames: expressionAttributeNames,
    ExpressionAttributeValues: expressionAttributeValues,
    ReturnValues: "ALL_NEW"
  }));
  return result.Attributes;
};
var deleteWarehouse = async (warehouseId) => {
  const { DeleteCommand: DeleteCommand3 } = await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8));
  const rooms = await getRoomsByWarehouseId(warehouseId);
  for (const room of rooms) {
    await docClient.send(new DeleteCommand3({
      TableName: TABLE_NAME,
      Key: {
        PK: `WAREHOUSE#${warehouseId}`,
        SK: `ROOM#${room.roomId}`
      }
    }));
  }
  await docClient.send(new DeleteCommand3({
    TableName: TABLE_NAME,
    Key: {
      PK: "WAREHOUSE#LIST",
      SK: `WAREHOUSE#${warehouseId}`
    }
  }));
  return { success: true, message: "Warehouse deleted successfully" };
};
var getStats = async () => {
  const warehouses = await findAll2();
  const total = warehouses.length;
  let availableCount = 0;
  let occupiedCount = 0;
  for (const warehouse of warehouses) {
    const rooms = await getRoomsByWarehouseId(warehouse.warehouseId);
    availableCount += rooms.filter((room) => room.status === "AVAILABLE").length;
    occupiedCount += rooms.filter((room) => room.status === "OCCUPIED").length;
  }
  return {
    total,
    available: availableCount,
    rented: occupiedCount
  };
};

// src/controllers/warehouse.controller.ts
var getAllWarehouses = async ({ query }) => {
  try {
    const warehouses = await findAll2();
    let warehousesWithRooms = await Promise.all(warehouses.map(async (warehouse) => {
      const rooms = await getRoomsByWarehouseId(warehouse.warehouseId);
      const availableRooms = rooms.filter((room) => room.status === "AVAILABLE").length;
      const totalRooms = rooms.length;
      return {
        ...warehouse,
        id: warehouse.warehouseId,
        availableRooms,
        totalRooms
      };
    }));
    if (query) {
      if (query.size && query.size !== "all") {
        warehousesWithRooms = warehousesWithRooms.filter((w3) => {
          const sizeNum = parseInt(w3.size) || 0;
          if (query.size === "small")
            return sizeNum < 200;
          if (query.size === "medium")
            return sizeNum >= 200 && sizeNum <= 500;
          if (query.size === "big")
            return sizeNum > 500;
          return true;
        });
      }
      if (query.location && query.location !== "all") {
        warehousesWithRooms = warehousesWithRooms.filter((w3) => {
          const location = w3.location?.toLowerCase() || "";
          const queryLocation = query.location.toLowerCase();
          const locationMap = {
            bangkok: ["\u0E01\u0E23\u0E38\u0E07\u0E40\u0E17\u0E1E", "bangkok"],
            nonthaburi: ["\u0E19\u0E19\u0E17\u0E1A\u0E38\u0E23\u0E35", "nonthaburi"],
            nakhonpathom: ["\u0E19\u0E04\u0E23\u0E1B\u0E10\u0E21", "nakhonpathom"],
            chachoengsao: ["\u0E09\u0E30\u0E40\u0E0A\u0E34\u0E07\u0E40\u0E17\u0E23\u0E32", "chachoengsao"],
            rayong: ["\u0E23\u0E30\u0E22\u0E2D\u0E07", "rayong"],
            khonkaen: ["\u0E02\u0E2D\u0E19\u0E41\u0E01\u0E48\u0E19", "khonkaen"],
            nakhonratchasima: ["\u0E19\u0E04\u0E23\u0E23\u0E32\u0E0A\u0E2A\u0E35\u0E21\u0E32", "nakhonratchasima"],
            chiangmai: ["\u0E40\u0E0A\u0E35\u0E22\u0E07\u0E43\u0E2B\u0E21\u0E48", "chiangmai"],
            lamphun: ["\u0E25\u0E33\u0E1E\u0E39\u0E19", "lamphun"],
            songkhla: ["\u0E2A\u0E07\u0E02\u0E25\u0E32", "songkhla"],
            suratthani: ["\u0E2A\u0E38\u0E23\u0E32\u0E29\u0E0E\u0E23\u0E4C\u0E18\u0E32\u0E19\u0E35", "suratthani"],
            chumphon: ["\u0E0A\u0E38\u0E21\u0E1E\u0E23", "chumphon"]
          };
          const matchTerms = locationMap[queryLocation] || [queryLocation];
          return matchTerms.some((term) => location.includes(term.toLowerCase()));
        });
      }
      if (query.priceRange && query.priceRange !== "all") {
        warehousesWithRooms = warehousesWithRooms.filter((w3) => {
          const price = w3.price || 0;
          if (query.priceRange === "under10000")
            return price < 1e4;
          if (query.priceRange === "10000-30000")
            return price >= 1e4 && price <= 30000;
          if (query.priceRange === "30000-60000")
            return price >= 30000 && price <= 60000;
          if (query.priceRange === "60000-100000")
            return price >= 60000 && price <= 1e5;
          if (query.priceRange === "over100000")
            return price > 1e5;
          return true;
        });
      }
    }
    return {
      success: true,
      warehouses: warehousesWithRooms,
      count: warehousesWithRooms.length
    };
  } catch (error) {
    console.error("Error fetching warehouses:", error);
    return {
      error: "Failed to fetch warehouses",
      details: error.message,
      status: 500
    };
  }
};
var getWarehouseById = async ({ params }) => {
  try {
    const warehouse = await findById2(params.id);
    if (!warehouse) {
      return {
        error: "Warehouse not found",
        status: 404
      };
    }
    return warehouse;
  } catch (error) {
    console.error("Error fetching warehouse:", error);
    return {
      error: "Failed to fetch warehouse",
      details: error.message,
      status: 500
    };
  }
};
var createWarehouse = async ({ body }) => {
  try {
    const warehouse = await create3(body);
    return {
      success: true,
      warehouse,
      message: "Warehouse created successfully"
    };
  } catch (error) {
    console.error("Error creating warehouse:", error);
    return {
      error: "Failed to create warehouse",
      details: error.message,
      status: 500
    };
  }
};
var getWarehouseStats = async () => {
  try {
    const stats = await getStats();
    return {
      success: true,
      stats
    };
  } catch (error) {
    console.error("Error fetching warehouse stats:", error);
    return {
      error: "Failed to fetch warehouse stats",
      details: error.message,
      status: 500
    };
  }
};
var getWarehouseRooms = async ({ params }) => {
  try {
    const rooms = await getRoomsByWarehouseId(params.id);
    return {
      success: true,
      rooms,
      count: rooms.length
    };
  } catch (error) {
    console.error("Error fetching warehouse rooms:", error);
    return {
      error: "Failed to fetch rooms",
      details: error.message,
      status: 500
    };
  }
};
var createRoom2 = async ({ params, body }) => {
  try {
    const room = await createRoom(params.id, body);
    return {
      success: true,
      room,
      message: "Room created successfully"
    };
  } catch (error) {
    console.error("Error creating room:", error);
    return {
      error: "Failed to create room",
      details: error.message,
      status: 500
    };
  }
};
var updateWarehouse = async ({ params, body }) => {
  try {
    const warehouse = await update(params.id, body);
    return {
      success: true,
      warehouse,
      message: "Warehouse updated successfully"
    };
  } catch (error) {
    console.error("Error updating warehouse:", error);
    return {
      error: "Failed to update warehouse",
      details: error.message,
      status: 500
    };
  }
};
var deleteWarehouse2 = async ({ params }) => {
  try {
    const result = await deleteWarehouse(params.id);
    return {
      success: true,
      message: "Warehouse deleted successfully"
    };
  } catch (error) {
    console.error("Error deleting warehouse:", error);
    return {
      error: "Failed to delete warehouse",
      details: error.message,
      status: 500
    };
  }
};

// src/routes/warehouse.routes.ts
var warehouseRoutes = new Elysia({ prefix: "/warehouses" }).get("/", getAllWarehouses).get("/stats", getWarehouseStats).get("/:id", getWarehouseById).get("/:id/rooms", getWarehouseRooms).post("/", createWarehouse).post("/:id/rooms", createRoom2).put("/:id", updateWarehouse).delete("/:id", deleteWarehouse2);
var warehouse_routes_default = warehouseRoutes;

// src/models/booking.model.ts
var create4 = async (data) => {
  const rentalId = `RNT${Date.now()}`;
  const rental = {
    PK: `USER#${data.userId}`,
    SK: `RENTAL#${rentalId}`,
    type: "Rental",
    GSI1SK: `STATUS#${data.status}#${new Date().toISOString()}`,
    Type: "Rental",
    rentalId,
    ...data
  };
  await docClient.send(new (await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8))).PutCommand({
    TableName: TABLE_NAME,
    Item: rental
  }));
  return rental;
};
var findById3 = async (userId, rentalId) => {
  const result = await docClient.send(new (await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8))).GetCommand({
    TableName: TABLE_NAME,
    Key: {
      PK: `USER#${userId}`,
      SK: `RENTAL#${rentalId}`
    }
  }));
  return result.Item;
};
var findByUserId = async (userId) => {
  const result = await docClient.send(new (await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8))).QueryCommand({
    TableName: TABLE_NAME,
    KeyConditionExpression: "PK = :pk AND begins_with(SK, :sk)",
    ExpressionAttributeValues: {
      ":pk": `USER#${userId}`,
      ":sk": "RENTAL#"
    }
  }));
  return result.Items || [];
};
var findActiveRentals = async (userId) => {
  const result = await docClient.send(new (await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8))).QueryCommand({
    TableName: TABLE_NAME,
    KeyConditionExpression: "PK = :pk AND begins_with(SK, :sk)",
    FilterExpression: "#status = :status",
    ExpressionAttributeNames: {
      "#status": "status"
    },
    ExpressionAttributeValues: {
      ":pk": `USER#${userId}`,
      ":sk": "RENTAL#",
      ":status": "ACTIVE"
    }
  }));
  return result.Items || [];
};
var updateStatus = async (userId, rentalId, status2) => {
  const result = await docClient.send(new (await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8))).UpdateCommand({
    TableName: TABLE_NAME,
    Key: {
      PK: `USER#${userId}`,
      SK: `RENTAL#${rentalId}`
    },
    UpdateExpression: "SET #status = :status, GSI1SK = :gsi1sk",
    ExpressionAttributeNames: {
      "#status": "status"
    },
    ExpressionAttributeValues: {
      ":status": status2,
      ":gsi1sk": `STATUS#${status2}#${new Date().toISOString()}`
    },
    ReturnValues: "ALL_NEW"
  }));
  return result.Attributes;
};
var updatePaymentSlip = async (rentalId, paymentSlipUrl) => {
  const { QueryCommand: QueryCommand5 } = await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8));
  const findCommand = new QueryCommand5({
    TableName: TABLE_NAME,
    IndexName: "GSI1_By_Type_and_Status",
    KeyConditionExpression: "#type = :type",
    FilterExpression: "rentalId = :rentalId",
    ExpressionAttributeNames: {
      "#type": "type"
    },
    ExpressionAttributeValues: {
      ":type": "Rental",
      ":rentalId": rentalId
    },
    Limit: 1
  });
  const findResult = await docClient.send(findCommand);
  if (!findResult.Items || findResult.Items.length === 0) {
    throw new Error("Rental not found");
  }
  const rental = findResult.Items[0];
  const userId = rental.userId;
  const result = await docClient.send(new (await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8))).UpdateCommand({
    TableName: TABLE_NAME,
    Key: {
      PK: `USER#${userId}`,
      SK: `RENTAL#${rentalId}`
    },
    UpdateExpression: "SET paymentSlip = :paymentSlip",
    ExpressionAttributeValues: {
      ":paymentSlip": paymentSlipUrl
    },
    ReturnValues: "ALL_NEW"
  }));
  return result.Attributes;
};
var findAll3 = async () => {
  const { QueryCommand: QueryCommand5 } = await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8));
  const command = new QueryCommand5({
    TableName: TABLE_NAME,
    IndexName: "GSI1_By_Type_and_Status",
    KeyConditionExpression: "#type = :type",
    ExpressionAttributeNames: {
      "#type": "type"
    },
    ExpressionAttributeValues: {
      ":type": "Rental"
    }
  });
  const result = await docClient.send(command);
  return result.Items || [];
};
var findPendingRentals = async () => {
  const { QueryCommand: QueryCommand5 } = await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8));
  const command = new QueryCommand5({
    TableName: TABLE_NAME,
    IndexName: "GSI1_By_Type_and_Status",
    KeyConditionExpression: "#type = :type AND begins_with(GSI1SK, :status)",
    ExpressionAttributeNames: {
      "#type": "type"
    },
    ExpressionAttributeValues: {
      ":type": "Rental",
      ":status": "STATUS#PENDING"
    }
  });
  const result = await docClient.send(command);
  return result.Items || [];
};
var approveRental = async (userId, rentalId, approvedBy) => {
  const result = await docClient.send(new (await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8))).UpdateCommand({
    TableName: TABLE_NAME,
    Key: {
      PK: `USER#${userId}`,
      SK: `RENTAL#${rentalId}`
    },
    UpdateExpression: "SET #status = :status, approvedAt = :approvedAt, approvedBy = :approvedBy, GSI1SK = :gsi1sk",
    ExpressionAttributeNames: {
      "#status": "status"
    },
    ExpressionAttributeValues: {
      ":status": "ACTIVE",
      ":approvedAt": new Date().toISOString(),
      ":approvedBy": approvedBy,
      ":gsi1sk": `STATUS#ACTIVE#${new Date().toISOString()}`
    },
    ReturnValues: "ALL_NEW"
  }));
  return result.Attributes;
};
var rejectRental = async (userId, rentalId, rejectedBy) => {
  const result = await docClient.send(new (await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8))).UpdateCommand({
    TableName: TABLE_NAME,
    Key: {
      PK: `USER#${userId}`,
      SK: `RENTAL#${rentalId}`
    },
    UpdateExpression: "SET #status = :status, rejectedAt = :rejectedAt, rejectedBy = :rejectedBy, GSI1SK = :gsi1sk",
    ExpressionAttributeNames: {
      "#status": "status"
    },
    ExpressionAttributeValues: {
      ":status": "REJECTED",
      ":rejectedAt": new Date().toISOString(),
      ":rejectedBy": rejectedBy,
      ":gsi1sk": `STATUS#REJECTED#${new Date().toISOString()}`
    },
    ReturnValues: "ALL_NEW"
  }));
  return result.Attributes;
};
var createProduct = async (data) => {
  const productId = `PRD${Date.now()}`;
  const product = {
    PK: `USER#${data.userId}`,
    SK: `PRODUCT#${productId}`,
    Type: "Product",
    productId,
    ...data
  };
  await docClient.send(new (await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8))).PutCommand({
    TableName: TABLE_NAME,
    Item: product
  }));
  return product;
};
var findProductsByUserId = async (userId) => {
  const result = await docClient.send(new (await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8))).QueryCommand({
    TableName: TABLE_NAME,
    KeyConditionExpression: "PK = :pk AND begins_with(SK, :sk)",
    ExpressionAttributeValues: {
      ":pk": `USER#${userId}`,
      ":sk": "PRODUCT#"
    }
  }));
  return result.Items || [];
};
var updateProduct = async (userId, productId, updates) => {
  const updateExpressions = [];
  const expressionAttributeNames = {};
  const expressionAttributeValues = {};
  Object.keys(updates).forEach((key, index) => {
    if (key !== "userId" && key !== "productId") {
      updateExpressions.push(`#attr${index} = :val${index}`);
      expressionAttributeNames[`#attr${index}`] = key;
      expressionAttributeValues[`:val${index}`] = updates[key];
    }
  });
  const result = await docClient.send(new (await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8))).UpdateCommand({
    TableName: TABLE_NAME,
    Key: {
      PK: `USER#${userId}`,
      SK: `PRODUCT#${productId}`
    },
    UpdateExpression: `SET ${updateExpressions.join(", ")}`,
    ExpressionAttributeNames: expressionAttributeNames,
    ExpressionAttributeValues: expressionAttributeValues,
    ReturnValues: "ALL_NEW"
  }));
  return result.Attributes;
};
var deleteProduct = async (userId, productId) => {
  await docClient.send(new (await Promise.resolve().then(() => (init_dist_es15(), exports_dist_es8))).DeleteCommand({
    TableName: TABLE_NAME,
    Key: {
      PK: `USER#${userId}`,
      SK: `PRODUCT#${productId}`
    }
  }));
};

// src/controllers/booking.controller.ts
var createRental = async ({ body }) => {
  try {
    const { userId, roomId, warehouseId, startDate, endDate } = body;
    if (!userId || !roomId || !warehouseId || !startDate || !endDate) {
      return {
        error: "Missing required fields",
        status: 400
      };
    }
    const rooms = await getRoomsByWarehouseId(warehouseId);
    const room = rooms.find((r3) => r3.roomId === roomId);
    if (!room) {
      return {
        error: "Room not found",
        status: 404
      };
    }
    if (room.status !== "AVAILABLE") {
      return {
        error: "Room is not available",
        status: 400
      };
    }
    const rental = await create4({
      userId,
      roomId,
      warehouseId,
      startDate,
      endDate,
      status: "PENDING",
      createdAt: new Date().toISOString()
    });
    return {
      success: true,
      rental,
      message: "Rental request submitted successfully. Waiting for admin approval."
    };
  } catch (error) {
    console.error("Error creating rental:", error);
    return {
      error: "Failed to create rental",
      details: error.message,
      status: 500
    };
  }
};
var getUserRentals = async ({ params }) => {
  try {
    const rentals = await findByUserId(params.userId);
    return {
      success: true,
      rentals,
      count: rentals.length
    };
  } catch (error) {
    console.error("Error fetching user rentals:", error);
    return {
      error: "Failed to fetch rentals",
      details: error.message,
      status: 500
    };
  }
};
var getActiveRentals = async ({ params }) => {
  try {
    const rentals = await findActiveRentals(params.userId);
    return {
      success: true,
      rentals,
      count: rentals.length
    };
  } catch (error) {
    console.error("Error fetching active rentals:", error);
    return {
      error: "Failed to fetch rentals",
      details: error.message,
      status: 500
    };
  }
};
var updateRentalStatus = async ({ params, body }) => {
  try {
    const { status: status2 } = body;
    const { userId, rentalId } = params;
    if (!["ACTIVE", "EXPIRED", "CANCELLED"].includes(status2)) {
      return {
        error: "Invalid status value",
        status: 400
      };
    }
    const rental = await findById3(userId, rentalId);
    if (!rental) {
      return {
        error: "Rental not found",
        status: 404
      };
    }
    if ((status2 === "CANCELLED" || status2 === "EXPIRED") && rental.status === "ACTIVE") {
      await updateRoomStatus(rental.warehouseId, rental.roomId, "AVAILABLE");
    }
    const updatedRental = await updateStatus(userId, rentalId, status2);
    return {
      success: true,
      rental: updatedRental,
      message: `Rental ${status2.toLowerCase()} successfully`
    };
  } catch (error) {
    console.error("Error updating rental status:", error);
    return {
      error: "Failed to update rental",
      details: error.message,
      status: 500
    };
  }
};
var updateRentalPaymentSlip = async ({ params, body }) => {
  try {
    const { rentalId } = params;
    const { paymentSlip } = body;
    if (!paymentSlip) {
      return {
        error: "Payment slip URL is required",
        status: 400
      };
    }
    console.log(`Updating rental ${rentalId} with payment slip:`, paymentSlip);
    const updatedRental = await updatePaymentSlip(rentalId, paymentSlip);
    return {
      success: true,
      rental: updatedRental,
      message: "Payment slip updated successfully"
    };
  } catch (error) {
    console.error("Error updating payment slip:", error);
    return {
      error: "Failed to update payment slip",
      details: error.message,
      status: 500
    };
  }
};
var getAllRentals = async () => {
  try {
    const rentals = await findAll3();
    return {
      success: true,
      rentals,
      count: rentals.length
    };
  } catch (error) {
    console.error("Error fetching all rentals:", error);
    return {
      error: "Failed to fetch rentals",
      details: error.message,
      status: 500
    };
  }
};
var createProduct2 = async ({ body }) => {
  try {
    const { userId, name, importDate, expiryDate, quantity, status: status2, roomId } = body;
    if (!userId || !name || !importDate || !quantity || !roomId) {
      return {
        error: "Missing required fields",
        status: 400
      };
    }
    const product = await createProduct({
      userId,
      name,
      importDate,
      expiryDate: expiryDate || "",
      quantity,
      status: status2 || "in-stock",
      roomId
    });
    return {
      success: true,
      product,
      message: "Product created successfully"
    };
  } catch (error) {
    console.error("Error creating product:", error);
    return {
      error: "Failed to create product",
      details: error.message,
      status: 500
    };
  }
};
var getUserProducts = async ({ params }) => {
  try {
    const products = await findProductsByUserId(params.userId);
    return {
      success: true,
      products,
      count: products.length
    };
  } catch (error) {
    console.error("Error fetching user products:", error);
    return {
      error: "Failed to fetch products",
      details: error.message,
      status: 500
    };
  }
};
var updateProduct2 = async ({ params, body }) => {
  try {
    const { userId, productId } = params;
    const updatedProduct = await updateProduct(userId, productId, body);
    return {
      success: true,
      product: updatedProduct,
      message: "Product updated successfully"
    };
  } catch (error) {
    console.error("Error updating product:", error);
    return {
      error: "Failed to update product",
      details: error.message,
      status: 500
    };
  }
};
var deleteProduct2 = async ({ params }) => {
  try {
    const { userId, productId } = params;
    await deleteProduct(userId, productId);
    return {
      success: true,
      message: "Product deleted successfully"
    };
  } catch (error) {
    console.error("Error deleting product:", error);
    return {
      error: "Failed to delete product",
      details: error.message,
      status: 500
    };
  }
};

// src/routes/booking.routes.ts
var rentalRoutes = new Elysia({ prefix: "/api" }).post("/rentals", createRental).get("/rentals", getAllRentals).get("/users/:userId/rentals", getUserRentals).get("/users/:userId/rentals/active", getActiveRentals).patch("/users/:userId/rentals/:rentalId/status", updateRentalStatus).patch("/rentals/:rentalId", updateRentalPaymentSlip).post("/products", createProduct2).get("/users/:userId/products", getUserProducts).patch("/users/:userId/products/:productId", updateProduct2).delete("/users/:userId/products/:productId", deleteProduct2);
var booking_routes_default = rentalRoutes;

// node_modules/@aws-sdk/client-cognito-identity-provider/dist-es/CognitoIdentityProviderClient.js
var import_middleware_host_header3 = __toESM(require_dist_cjs4(), 1);
var import_middleware_logger3 = __toESM(require_dist_cjs5(), 1);
var import_middleware_recursion_detection3 = __toESM(require_dist_cjs6(), 1);
var import_middleware_user_agent3 = __toESM(require_dist_cjs31(), 1);
var import_config_resolver6 = __toESM(require_dist_cjs33(), 1);
var import_core31 = __toESM(require_dist_cjs19(), 1);
var import_middleware_content_length3 = __toESM(require_dist_cjs34(), 1);
var import_middleware_endpoint64 = __toESM(require_dist_cjs37(), 1);
var import_middleware_retry6 = __toESM(require_dist_cjs40(), 1);
var import_smithy_client86 = __toESM(require_dist_cjs28(), 1);

// node_modules/@aws-sdk/client-cognito-identity-provider/dist-es/auth/httpAuthSchemeProvider.js
var import_core27 = __toESM(require_dist_cjs30(), 1);
var import_util_middleware3 = __toESM(require_dist_cjs2(), 1);
var defaultCognitoIdentityProviderHttpAuthSchemeParametersProvider = async (config, context, input) => {
  return {
    operation: import_util_middleware3.getSmithyContext(context).operation,
    region: await import_util_middleware3.normalizeProvider(config.region)() || (() => {
      throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
    })()
  };
};
function createAwsAuthSigv4HttpAuthOption3(authParameters) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "cognito-idp",
      region: authParameters.region
    },
    propertiesExtractor: (config, context) => ({
      signingProperties: {
        config,
        context
      }
    })
  };
}
function createSmithyApiNoAuthHttpAuthOption2(authParameters) {
  return {
    schemeId: "smithy.api#noAuth"
  };
}
var defaultCognitoIdentityProviderHttpAuthSchemeProvider = (authParameters) => {
  const options = [];
  switch (authParameters.operation) {
    case "AssociateSoftwareToken": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "ChangePassword": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "CompleteWebAuthnRegistration": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "ConfirmDevice": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "ConfirmForgotPassword": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "ConfirmSignUp": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "DeleteUser": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "DeleteUserAttributes": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "DeleteWebAuthnCredential": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "ForgetDevice": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "ForgotPassword": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "GetDevice": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "GetTokensFromRefreshToken": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "GetUser": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "GetUserAttributeVerificationCode": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "GetUserAuthFactors": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "GlobalSignOut": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "InitiateAuth": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "ListDevices": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "ListWebAuthnCredentials": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "ResendConfirmationCode": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "RespondToAuthChallenge": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "RevokeToken": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "SetUserMFAPreference": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "SetUserSettings": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "SignUp": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "StartWebAuthnRegistration": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "UpdateAuthEventFeedback": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "UpdateDeviceStatus": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "UpdateUserAttributes": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "VerifySoftwareToken": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    case "VerifyUserAttribute": {
      options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
      break;
    }
    default: {
      options.push(createAwsAuthSigv4HttpAuthOption3(authParameters));
    }
  }
  return options;
};
var resolveHttpAuthSchemeConfig3 = (config) => {
  const config_0 = import_core27.resolveAwsSdkSigV4Config(config);
  return Object.assign(config_0, {
    authSchemePreference: import_util_middleware3.normalizeProvider(config.authSchemePreference ?? [])
  });
};

// node_modules/@aws-sdk/client-cognito-identity-provider/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters3 = (options) => {
  return Object.assign(options, {
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    defaultSigningName: "cognito-idp"
  });
};
var commonParams3 = {
  UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
  Endpoint: { type: "builtInParams", name: "endpoint" },
  Region: { type: "builtInParams", name: "region" },
  UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
};
// node_modules/@aws-sdk/client-cognito-identity-provider/package.json
var package_default3 = {
  name: "@aws-sdk/client-cognito-identity-provider",
  description: "AWS SDK for JavaScript Cognito Identity Provider Client for Node.js, Browser and React Native",
  version: "3.914.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline client-cognito-identity-provider",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo cognito-identity-provider"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha256-browser": "5.2.0",
    "@aws-crypto/sha256-js": "5.2.0",
    "@aws-sdk/core": "3.914.0",
    "@aws-sdk/credential-provider-node": "3.914.0",
    "@aws-sdk/middleware-host-header": "3.914.0",
    "@aws-sdk/middleware-logger": "3.914.0",
    "@aws-sdk/middleware-recursion-detection": "3.914.0",
    "@aws-sdk/middleware-user-agent": "3.914.0",
    "@aws-sdk/region-config-resolver": "3.914.0",
    "@aws-sdk/types": "3.914.0",
    "@aws-sdk/util-endpoints": "3.914.0",
    "@aws-sdk/util-user-agent-browser": "3.914.0",
    "@aws-sdk/util-user-agent-node": "3.914.0",
    "@smithy/config-resolver": "^4.4.0",
    "@smithy/core": "^3.17.0",
    "@smithy/fetch-http-handler": "^5.3.4",
    "@smithy/hash-node": "^4.2.3",
    "@smithy/invalid-dependency": "^4.2.3",
    "@smithy/middleware-content-length": "^4.2.3",
    "@smithy/middleware-endpoint": "^4.3.4",
    "@smithy/middleware-retry": "^4.4.4",
    "@smithy/middleware-serde": "^4.2.3",
    "@smithy/middleware-stack": "^4.2.3",
    "@smithy/node-config-provider": "^4.3.3",
    "@smithy/node-http-handler": "^4.4.2",
    "@smithy/protocol-http": "^5.3.3",
    "@smithy/smithy-client": "^4.9.0",
    "@smithy/types": "^4.8.0",
    "@smithy/url-parser": "^4.2.3",
    "@smithy/util-base64": "^4.3.0",
    "@smithy/util-body-length-browser": "^4.2.0",
    "@smithy/util-body-length-node": "^4.2.1",
    "@smithy/util-defaults-mode-browser": "^4.3.3",
    "@smithy/util-defaults-mode-node": "^4.2.5",
    "@smithy/util-endpoints": "^3.2.3",
    "@smithy/util-middleware": "^4.2.3",
    "@smithy/util-retry": "^4.2.3",
    "@smithy/util-utf8": "^4.2.0",
    tslib: "^2.6.2"
  },
  devDependencies: {
    "@tsconfig/node18": "18.2.4",
    "@types/node": "^18.19.69",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typescript: "~5.8.3"
  },
  engines: {
    node: ">=18.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-cognito-identity-provider",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-cognito-identity-provider"
  }
};

// node_modules/@aws-sdk/client-cognito-identity-provider/dist-es/runtimeConfig.js
init_dist_es12();
var import_core30 = __toESM(require_dist_cjs30(), 1);
var import_util_user_agent_node3 = __toESM(require_dist_cjs41(), 1);
var import_config_resolver5 = __toESM(require_dist_cjs33(), 1);
var import_hash_node3 = __toESM(require_dist_cjs42(), 1);
var import_middleware_retry5 = __toESM(require_dist_cjs40(), 1);
var import_node_config_provider5 = __toESM(require_dist_cjs36(), 1);
var import_node_http_handler4 = __toESM(require_dist_cjs14(), 1);
var import_util_body_length_node3 = __toESM(require_dist_cjs43(), 1);
var import_util_retry3 = __toESM(require_dist_cjs39(), 1);

// node_modules/@aws-sdk/client-cognito-identity-provider/dist-es/runtimeConfig.shared.js
var import_core28 = __toESM(require_dist_cjs30(), 1);
var import_core29 = __toESM(require_dist_cjs19(), 1);
var import_smithy_client82 = __toESM(require_dist_cjs28(), 1);
var import_url_parser4 = __toESM(require_dist_cjs22(), 1);
var import_util_base643 = __toESM(require_dist_cjs11(), 1);
var import_util_utf83 = __toESM(require_dist_cjs10(), 1);

// node_modules/@aws-sdk/client-cognito-identity-provider/dist-es/endpoint/endpointResolver.js
var import_util_endpoints5 = __toESM(require_dist_cjs23(), 1);
var import_util_endpoints6 = __toESM(require_dist_cjs20(), 1);

// node_modules/@aws-sdk/client-cognito-identity-provider/dist-es/endpoint/ruleset.js
var w3 = "required";
var x4 = "fn";
var y2 = "argv";
var z2 = "ref";
var a3 = true;
var b3 = "isSet";
var c3 = "booleanEquals";
var d3 = "error";
var e3 = "endpoint";
var f3 = "tree";
var g3 = "PartitionResult";
var h3 = "getAttr";
var i4 = "stringEquals";
var j3 = { [w3]: false, type: "String" };
var k4 = { [w3]: true, default: false, type: "Boolean" };
var l3 = { [z2]: "Endpoint" };
var m3 = { [x4]: c3, [y2]: [{ [z2]: "UseFIPS" }, true] };
var n3 = { [x4]: c3, [y2]: [{ [z2]: "UseDualStack" }, true] };
var o3 = {};
var p3 = { [z2]: "Region" };
var q3 = { [x4]: h3, [y2]: [{ [z2]: g3 }, "supportsFIPS"] };
var r3 = { [z2]: g3 };
var s3 = { [x4]: c3, [y2]: [true, { [x4]: h3, [y2]: [r3, "supportsDualStack"] }] };
var t4 = [m3];
var u3 = [n3];
var v3 = [p3];
var _data3 = { version: "1.0", parameters: { Region: j3, UseDualStack: k4, UseFIPS: k4, Endpoint: j3 }, rules: [{ conditions: [{ [x4]: b3, [y2]: [l3] }], rules: [{ conditions: t4, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d3 }, { conditions: u3, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d3 }, { endpoint: { url: l3, properties: o3, headers: o3 }, type: e3 }], type: f3 }, { conditions: [{ [x4]: b3, [y2]: v3 }], rules: [{ conditions: [{ [x4]: "aws.partition", [y2]: v3, assign: g3 }], rules: [{ conditions: [m3, n3], rules: [{ conditions: [{ [x4]: c3, [y2]: [a3, q3] }, s3], rules: [{ conditions: [{ [x4]: i4, [y2]: [p3, "us-east-1"] }], endpoint: { url: "https://cognito-idp-fips.us-east-1.amazonaws.com", properties: o3, headers: o3 }, type: e3 }, { conditions: [{ [x4]: i4, [y2]: [p3, "us-east-2"] }], endpoint: { url: "https://cognito-idp-fips.us-east-2.amazonaws.com", properties: o3, headers: o3 }, type: e3 }, { conditions: [{ [x4]: i4, [y2]: [p3, "us-west-1"] }], endpoint: { url: "https://cognito-idp-fips.us-west-1.amazonaws.com", properties: o3, headers: o3 }, type: e3 }, { conditions: [{ [x4]: i4, [y2]: [p3, "us-west-2"] }], endpoint: { url: "https://cognito-idp-fips.us-west-2.amazonaws.com", properties: o3, headers: o3 }, type: e3 }, { endpoint: { url: "https://cognito-idp-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: o3, headers: o3 }, type: e3 }], type: f3 }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d3 }], type: f3 }, { conditions: t4, rules: [{ conditions: [{ [x4]: c3, [y2]: [q3, a3] }], rules: [{ endpoint: { url: "https://cognito-idp-fips.{Region}.{PartitionResult#dnsSuffix}", properties: o3, headers: o3 }, type: e3 }], type: f3 }, { error: "FIPS is enabled but this partition does not support FIPS", type: d3 }], type: f3 }, { conditions: u3, rules: [{ conditions: [s3], rules: [{ conditions: [{ [x4]: i4, [y2]: ["aws", { [x4]: h3, [y2]: [r3, "name"] }] }], endpoint: { url: "https://cognito-idp.{Region}.amazonaws.com", properties: o3, headers: o3 }, type: e3 }, { endpoint: { url: "https://cognito-idp.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: o3, headers: o3 }, type: e3 }], type: f3 }, { error: "DualStack is enabled but this partition does not support DualStack", type: d3 }], type: f3 }, { endpoint: { url: "https://cognito-idp.{Region}.{PartitionResult#dnsSuffix}", properties: o3, headers: o3 }, type: e3 }], type: f3 }], type: f3 }, { error: "Invalid Configuration: Missing Region", type: d3 }] };
var ruleSet3 = _data3;

// node_modules/@aws-sdk/client-cognito-identity-provider/dist-es/endpoint/endpointResolver.js
var cache3 = new import_util_endpoints6.EndpointCache({
  size: 50,
  params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
});
var defaultEndpointResolver3 = (endpointParams, context = {}) => {
  return cache3.get(endpointParams, () => import_util_endpoints6.resolveEndpoint(ruleSet3, {
    endpointParams,
    logger: context.logger
  }));
};
import_util_endpoints6.customEndpointFunctions.aws = import_util_endpoints5.awsEndpointFunctions;

// node_modules/@aws-sdk/client-cognito-identity-provider/dist-es/runtimeConfig.shared.js
var getRuntimeConfig5 = (config) => {
  return {
    apiVersion: "2016-04-18",
    base64Decoder: config?.base64Decoder ?? import_util_base643.fromBase64,
    base64Encoder: config?.base64Encoder ?? import_util_base643.toBase64,
    disableHostPrefix: config?.disableHostPrefix ?? false,
    endpointProvider: config?.endpointProvider ?? defaultEndpointResolver3,
    extensions: config?.extensions ?? [],
    httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultCognitoIdentityProviderHttpAuthSchemeProvider,
    httpAuthSchemes: config?.httpAuthSchemes ?? [
      {
        schemeId: "aws.auth#sigv4",
        identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
        signer: new import_core28.AwsSdkSigV4Signer
      },
      {
        schemeId: "smithy.api#noAuth",
        identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
        signer: new import_core29.NoAuthSigner
      }
    ],
    logger: config?.logger ?? new import_smithy_client82.NoOpLogger,
    serviceId: config?.serviceId ?? "Cognito Identity Provider",
    urlParser: config?.urlParser ?? import_url_parser4.parseUrl,
    utf8Decoder: config?.utf8Decoder ?? import_util_utf83.fromUtf8,
    utf8Encoder: config?.utf8Encoder ?? import_util_utf83.toUtf8
  };
};

// node_modules/@aws-sdk/client-cognito-identity-provider/dist-es/runtimeConfig.js
var import_smithy_client83 = __toESM(require_dist_cjs28(), 1);
var import_util_defaults_mode_node3 = __toESM(require_dist_cjs44(), 1);
var import_smithy_client84 = __toESM(require_dist_cjs28(), 1);
var getRuntimeConfig6 = (config) => {
  import_smithy_client84.emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = import_util_defaults_mode_node3.resolveDefaultsModeConfig(config);
  const defaultConfigProvider = () => defaultsMode().then(import_smithy_client83.loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig5(config);
  import_core30.emitWarningIfUnsupportedVersion(process.version);
  const loaderConfig = {
    profile: config?.profile,
    logger: clientSharedValues.logger
  };
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    authSchemePreference: config?.authSchemePreference ?? import_node_config_provider5.loadConfig(import_core30.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
    bodyLengthChecker: config?.bodyLengthChecker ?? import_util_body_length_node3.calculateBodyLength,
    credentialDefaultProvider: config?.credentialDefaultProvider ?? defaultProvider,
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? import_util_user_agent_node3.createDefaultUserAgentProvider({ serviceId: clientSharedValues.serviceId, clientVersion: package_default3.version }),
    maxAttempts: config?.maxAttempts ?? import_node_config_provider5.loadConfig(import_middleware_retry5.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
    region: config?.region ?? import_node_config_provider5.loadConfig(import_config_resolver5.NODE_REGION_CONFIG_OPTIONS, { ...import_config_resolver5.NODE_REGION_CONFIG_FILE_OPTIONS, ...loaderConfig }),
    requestHandler: import_node_http_handler4.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
    retryMode: config?.retryMode ?? import_node_config_provider5.loadConfig({
      ...import_middleware_retry5.NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || import_util_retry3.DEFAULT_RETRY_MODE
    }, config),
    sha256: config?.sha256 ?? import_hash_node3.Hash.bind(null, "sha256"),
    streamCollector: config?.streamCollector ?? import_node_http_handler4.streamCollector,
    useDualstackEndpoint: config?.useDualstackEndpoint ?? import_node_config_provider5.loadConfig(import_config_resolver5.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
    useFipsEndpoint: config?.useFipsEndpoint ?? import_node_config_provider5.loadConfig(import_config_resolver5.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
    userAgentAppId: config?.userAgentAppId ?? import_node_config_provider5.loadConfig(import_util_user_agent_node3.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
  };
};

// node_modules/@aws-sdk/client-cognito-identity-provider/dist-es/runtimeExtensions.js
var import_region_config_resolver3 = __toESM(require_dist_cjs45(), 1);
var import_protocol_http5 = __toESM(require_dist_cjs3(), 1);
var import_smithy_client85 = __toESM(require_dist_cjs28(), 1);

// node_modules/@aws-sdk/client-cognito-identity-provider/dist-es/auth/httpAuthExtensionConfiguration.js
var getHttpAuthExtensionConfiguration3 = (runtimeConfig) => {
  const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
  let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
  let _credentials = runtimeConfig.credentials;
  return {
    setHttpAuthScheme(httpAuthScheme) {
      const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
      if (index === -1) {
        _httpAuthSchemes.push(httpAuthScheme);
      } else {
        _httpAuthSchemes.splice(index, 1, httpAuthScheme);
      }
    },
    httpAuthSchemes() {
      return _httpAuthSchemes;
    },
    setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
      _httpAuthSchemeProvider = httpAuthSchemeProvider;
    },
    httpAuthSchemeProvider() {
      return _httpAuthSchemeProvider;
    },
    setCredentials(credentials) {
      _credentials = credentials;
    },
    credentials() {
      return _credentials;
    }
  };
};
var resolveHttpAuthRuntimeConfig3 = (config) => {
  return {
    httpAuthSchemes: config.httpAuthSchemes(),
    httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
    credentials: config.credentials()
  };
};

// node_modules/@aws-sdk/client-cognito-identity-provider/dist-es/runtimeExtensions.js
var resolveRuntimeExtensions3 = (runtimeConfig, extensions2) => {
  const extensionConfiguration = Object.assign(import_region_config_resolver3.getAwsRegionExtensionConfiguration(runtimeConfig), import_smithy_client85.getDefaultExtensionConfiguration(runtimeConfig), import_protocol_http5.getHttpHandlerExtensionConfiguration(runtimeConfig), getHttpAuthExtensionConfiguration3(runtimeConfig));
  extensions2.forEach((extension) => extension.configure(extensionConfiguration));
  return Object.assign(runtimeConfig, import_region_config_resolver3.resolveAwsRegionExtensionConfiguration(extensionConfiguration), import_smithy_client85.resolveDefaultRuntimeConfig(extensionConfiguration), import_protocol_http5.resolveHttpHandlerRuntimeConfig(extensionConfiguration), resolveHttpAuthRuntimeConfig3(extensionConfiguration));
};

// node_modules/@aws-sdk/client-cognito-identity-provider/dist-es/CognitoIdentityProviderClient.js
class CognitoIdentityProviderClient extends import_smithy_client86.Client {
  config;
  constructor(...[configuration]) {
    const _config_0 = getRuntimeConfig6(configuration || {});
    super(_config_0);
    this.initConfig = _config_0;
    const _config_1 = resolveClientEndpointParameters3(_config_0);
    const _config_2 = import_middleware_user_agent3.resolveUserAgentConfig(_config_1);
    const _config_3 = import_middleware_retry6.resolveRetryConfig(_config_2);
    const _config_4 = import_config_resolver6.resolveRegionConfig(_config_3);
    const _config_5 = import_middleware_host_header3.resolveHostHeaderConfig(_config_4);
    const _config_6 = import_middleware_endpoint64.resolveEndpointConfig(_config_5);
    const _config_7 = resolveHttpAuthSchemeConfig3(_config_6);
    const _config_8 = resolveRuntimeExtensions3(_config_7, configuration?.extensions || []);
    this.config = _config_8;
    this.middlewareStack.use(import_middleware_user_agent3.getUserAgentPlugin(this.config));
    this.middlewareStack.use(import_middleware_retry6.getRetryPlugin(this.config));
    this.middlewareStack.use(import_middleware_content_length3.getContentLengthPlugin(this.config));
    this.middlewareStack.use(import_middleware_host_header3.getHostHeaderPlugin(this.config));
    this.middlewareStack.use(import_middleware_logger3.getLoggerPlugin(this.config));
    this.middlewareStack.use(import_middleware_recursion_detection3.getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(import_core31.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
      httpAuthSchemeParametersProvider: defaultCognitoIdentityProviderHttpAuthSchemeParametersProvider,
      identityProviderConfigProvider: async (config) => new import_core31.DefaultIdentityProviderConfig({
        "aws.auth#sigv4": config.credentials
      })
    }));
    this.middlewareStack.use(import_core31.getHttpSigningPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
}

// node_modules/@aws-sdk/client-cognito-identity-provider/dist-es/protocols/Aws_json1_1.js
var import_core32 = __toESM(require_dist_cjs30(), 1);
var import_protocol_http6 = __toESM(require_dist_cjs3(), 1);
var import_smithy_client89 = __toESM(require_dist_cjs28(), 1);

// node_modules/@aws-sdk/client-cognito-identity-provider/dist-es/models/CognitoIdentityProviderServiceException.js
var import_smithy_client87 = __toESM(require_dist_cjs28(), 1);
class CognitoIdentityProviderServiceException extends import_smithy_client87.ServiceException {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, CognitoIdentityProviderServiceException.prototype);
  }
}

// node_modules/@aws-sdk/client-cognito-identity-provider/dist-es/models/models_0.js
var import_smithy_client88 = __toESM(require_dist_cjs28(), 1);
class InternalErrorException extends CognitoIdentityProviderServiceException {
  name = "InternalErrorException";
  $fault = "server";
  constructor(opts) {
    super({
      name: "InternalErrorException",
      $fault: "server",
      ...opts
    });
    Object.setPrototypeOf(this, InternalErrorException.prototype);
  }
}

class InvalidParameterException extends CognitoIdentityProviderServiceException {
  name = "InvalidParameterException";
  $fault = "client";
  reasonCode;
  constructor(opts) {
    super({
      name: "InvalidParameterException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidParameterException.prototype);
    this.reasonCode = opts.reasonCode;
  }
}

class NotAuthorizedException extends CognitoIdentityProviderServiceException {
  name = "NotAuthorizedException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "NotAuthorizedException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, NotAuthorizedException.prototype);
  }
}

class ResourceNotFoundException3 extends CognitoIdentityProviderServiceException {
  name = "ResourceNotFoundException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "ResourceNotFoundException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, ResourceNotFoundException3.prototype);
  }
}

class TooManyRequestsException2 extends CognitoIdentityProviderServiceException {
  name = "TooManyRequestsException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "TooManyRequestsException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, TooManyRequestsException2.prototype);
  }
}

class UserImportInProgressException extends CognitoIdentityProviderServiceException {
  name = "UserImportInProgressException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "UserImportInProgressException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, UserImportInProgressException.prototype);
  }
}

class UserNotFoundException extends CognitoIdentityProviderServiceException {
  name = "UserNotFoundException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "UserNotFoundException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, UserNotFoundException.prototype);
  }
}

class InvalidLambdaResponseException extends CognitoIdentityProviderServiceException {
  name = "InvalidLambdaResponseException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "InvalidLambdaResponseException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidLambdaResponseException.prototype);
  }
}

class LimitExceededException2 extends CognitoIdentityProviderServiceException {
  name = "LimitExceededException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "LimitExceededException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, LimitExceededException2.prototype);
  }
}

class TooManyFailedAttemptsException extends CognitoIdentityProviderServiceException {
  name = "TooManyFailedAttemptsException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "TooManyFailedAttemptsException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, TooManyFailedAttemptsException.prototype);
  }
}

class UnexpectedLambdaException extends CognitoIdentityProviderServiceException {
  name = "UnexpectedLambdaException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "UnexpectedLambdaException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, UnexpectedLambdaException.prototype);
  }
}

class UserLambdaValidationException extends CognitoIdentityProviderServiceException {
  name = "UserLambdaValidationException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "UserLambdaValidationException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, UserLambdaValidationException.prototype);
  }
}
class CodeDeliveryFailureException extends CognitoIdentityProviderServiceException {
  name = "CodeDeliveryFailureException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "CodeDeliveryFailureException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, CodeDeliveryFailureException.prototype);
  }
}

class InvalidPasswordException extends CognitoIdentityProviderServiceException {
  name = "InvalidPasswordException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "InvalidPasswordException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidPasswordException.prototype);
  }
}

class InvalidSmsRoleAccessPolicyException extends CognitoIdentityProviderServiceException {
  name = "InvalidSmsRoleAccessPolicyException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "InvalidSmsRoleAccessPolicyException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidSmsRoleAccessPolicyException.prototype);
  }
}

class InvalidSmsRoleTrustRelationshipException extends CognitoIdentityProviderServiceException {
  name = "InvalidSmsRoleTrustRelationshipException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "InvalidSmsRoleTrustRelationshipException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidSmsRoleTrustRelationshipException.prototype);
  }
}

class PreconditionNotMetException extends CognitoIdentityProviderServiceException {
  name = "PreconditionNotMetException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "PreconditionNotMetException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, PreconditionNotMetException.prototype);
  }
}

class UnsupportedUserStateException extends CognitoIdentityProviderServiceException {
  name = "UnsupportedUserStateException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "UnsupportedUserStateException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, UnsupportedUserStateException.prototype);
  }
}

class UsernameExistsException extends CognitoIdentityProviderServiceException {
  name = "UsernameExistsException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "UsernameExistsException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, UsernameExistsException.prototype);
  }
}

class AliasExistsException extends CognitoIdentityProviderServiceException {
  name = "AliasExistsException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "AliasExistsException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, AliasExistsException.prototype);
  }
}

class InvalidUserPoolConfigurationException extends CognitoIdentityProviderServiceException {
  name = "InvalidUserPoolConfigurationException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "InvalidUserPoolConfigurationException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidUserPoolConfigurationException.prototype);
  }
}
class InvalidEmailRoleAccessPolicyException extends CognitoIdentityProviderServiceException {
  name = "InvalidEmailRoleAccessPolicyException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "InvalidEmailRoleAccessPolicyException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidEmailRoleAccessPolicyException.prototype);
  }
}

class MFAMethodNotFoundException extends CognitoIdentityProviderServiceException {
  name = "MFAMethodNotFoundException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "MFAMethodNotFoundException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, MFAMethodNotFoundException.prototype);
  }
}

class PasswordResetRequiredException extends CognitoIdentityProviderServiceException {
  name = "PasswordResetRequiredException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "PasswordResetRequiredException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, PasswordResetRequiredException.prototype);
  }
}

class UnsupportedOperationException extends CognitoIdentityProviderServiceException {
  name = "UnsupportedOperationException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "UnsupportedOperationException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, UnsupportedOperationException.prototype);
  }
}

class UserNotConfirmedException extends CognitoIdentityProviderServiceException {
  name = "UserNotConfirmedException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "UserNotConfirmedException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, UserNotConfirmedException.prototype);
  }
}
class UserPoolAddOnNotEnabledException extends CognitoIdentityProviderServiceException {
  name = "UserPoolAddOnNotEnabledException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "UserPoolAddOnNotEnabledException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, UserPoolAddOnNotEnabledException.prototype);
  }
}

class CodeMismatchException extends CognitoIdentityProviderServiceException {
  name = "CodeMismatchException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "CodeMismatchException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, CodeMismatchException.prototype);
  }
}

class ExpiredCodeException extends CognitoIdentityProviderServiceException {
  name = "ExpiredCodeException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "ExpiredCodeException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, ExpiredCodeException.prototype);
  }
}

class PasswordHistoryPolicyViolationException extends CognitoIdentityProviderServiceException {
  name = "PasswordHistoryPolicyViolationException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "PasswordHistoryPolicyViolationException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, PasswordHistoryPolicyViolationException.prototype);
  }
}

class SoftwareTokenMFANotFoundException extends CognitoIdentityProviderServiceException {
  name = "SoftwareTokenMFANotFoundException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "SoftwareTokenMFANotFoundException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, SoftwareTokenMFANotFoundException.prototype);
  }
}
class ConcurrentModificationException extends CognitoIdentityProviderServiceException {
  name = "ConcurrentModificationException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "ConcurrentModificationException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, ConcurrentModificationException.prototype);
  }
}

class ForbiddenException extends CognitoIdentityProviderServiceException {
  name = "ForbiddenException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "ForbiddenException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, ForbiddenException.prototype);
  }
}
class WebAuthnChallengeNotFoundException extends CognitoIdentityProviderServiceException {
  name = "WebAuthnChallengeNotFoundException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "WebAuthnChallengeNotFoundException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, WebAuthnChallengeNotFoundException.prototype);
  }
}

class WebAuthnClientMismatchException extends CognitoIdentityProviderServiceException {
  name = "WebAuthnClientMismatchException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "WebAuthnClientMismatchException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, WebAuthnClientMismatchException.prototype);
  }
}

class WebAuthnCredentialNotSupportedException extends CognitoIdentityProviderServiceException {
  name = "WebAuthnCredentialNotSupportedException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "WebAuthnCredentialNotSupportedException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, WebAuthnCredentialNotSupportedException.prototype);
  }
}

class WebAuthnNotEnabledException extends CognitoIdentityProviderServiceException {
  name = "WebAuthnNotEnabledException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "WebAuthnNotEnabledException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, WebAuthnNotEnabledException.prototype);
  }
}

class WebAuthnOriginNotAllowedException extends CognitoIdentityProviderServiceException {
  name = "WebAuthnOriginNotAllowedException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "WebAuthnOriginNotAllowedException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, WebAuthnOriginNotAllowedException.prototype);
  }
}

class WebAuthnRelyingPartyMismatchException extends CognitoIdentityProviderServiceException {
  name = "WebAuthnRelyingPartyMismatchException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "WebAuthnRelyingPartyMismatchException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, WebAuthnRelyingPartyMismatchException.prototype);
  }
}

class DeviceKeyExistsException extends CognitoIdentityProviderServiceException {
  name = "DeviceKeyExistsException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "DeviceKeyExistsException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, DeviceKeyExistsException.prototype);
  }
}

class GroupExistsException extends CognitoIdentityProviderServiceException {
  name = "GroupExistsException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "GroupExistsException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, GroupExistsException.prototype);
  }
}
class DuplicateProviderException extends CognitoIdentityProviderServiceException {
  name = "DuplicateProviderException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "DuplicateProviderException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, DuplicateProviderException.prototype);
  }
}

class ManagedLoginBrandingExistsException extends CognitoIdentityProviderServiceException {
  name = "ManagedLoginBrandingExistsException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "ManagedLoginBrandingExistsException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, ManagedLoginBrandingExistsException.prototype);
  }
}
class TermsExistsException extends CognitoIdentityProviderServiceException {
  name = "TermsExistsException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "TermsExistsException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, TermsExistsException.prototype);
  }
}
class FeatureUnavailableInTierException extends CognitoIdentityProviderServiceException {
  name = "FeatureUnavailableInTierException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "FeatureUnavailableInTierException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, FeatureUnavailableInTierException.prototype);
  }
}

class TierChangeNotAllowedException extends CognitoIdentityProviderServiceException {
  name = "TierChangeNotAllowedException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "TierChangeNotAllowedException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, TierChangeNotAllowedException.prototype);
  }
}

class UserPoolTaggingException extends CognitoIdentityProviderServiceException {
  name = "UserPoolTaggingException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "UserPoolTaggingException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, UserPoolTaggingException.prototype);
  }
}
class InvalidOAuthFlowException extends CognitoIdentityProviderServiceException {
  name = "InvalidOAuthFlowException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "InvalidOAuthFlowException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidOAuthFlowException.prototype);
  }
}

class ScopeDoesNotExistException extends CognitoIdentityProviderServiceException {
  name = "ScopeDoesNotExistException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "ScopeDoesNotExistException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, ScopeDoesNotExistException.prototype);
  }
}

class UnsupportedIdentityProviderException extends CognitoIdentityProviderServiceException {
  name = "UnsupportedIdentityProviderException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "UnsupportedIdentityProviderException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, UnsupportedIdentityProviderException.prototype);
  }
}
var AttributeTypeFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Value && { Value: import_smithy_client88.SENSITIVE_STRING }
});
var UserTypeFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Username && { Username: import_smithy_client88.SENSITIVE_STRING },
  ...obj.Attributes && { Attributes: obj.Attributes.map((item) => AttributeTypeFilterSensitiveLog(item)) }
});

// node_modules/@aws-sdk/client-cognito-identity-provider/dist-es/models/models_1.js
class RefreshTokenReuseException extends CognitoIdentityProviderServiceException {
  name = "RefreshTokenReuseException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "RefreshTokenReuseException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, RefreshTokenReuseException.prototype);
  }
}
class UnauthorizedException2 extends CognitoIdentityProviderServiceException {
  name = "UnauthorizedException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "UnauthorizedException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, UnauthorizedException2.prototype);
  }
}

class UnsupportedTokenTypeException extends CognitoIdentityProviderServiceException {
  name = "UnsupportedTokenTypeException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "UnsupportedTokenTypeException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, UnsupportedTokenTypeException.prototype);
  }
}

class WebAuthnConfigurationMissingException extends CognitoIdentityProviderServiceException {
  name = "WebAuthnConfigurationMissingException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "WebAuthnConfigurationMissingException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, WebAuthnConfigurationMissingException.prototype);
  }
}

class EnableSoftwareTokenMFAException extends CognitoIdentityProviderServiceException {
  name = "EnableSoftwareTokenMFAException";
  $fault = "client";
  constructor(opts) {
    super({
      name: "EnableSoftwareTokenMFAException",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, EnableSoftwareTokenMFAException.prototype);
  }
}
var ListUsersResponseFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.Users && { Users: obj.Users.map((item) => UserTypeFilterSensitiveLog(item)) }
});

// node_modules/@aws-sdk/client-cognito-identity-provider/dist-es/protocols/Aws_json1_1.js
var se_ListUsersCommand = async (input, context) => {
  const headers = sharedHeaders2("ListUsers");
  let body;
  body = JSON.stringify(import_smithy_client89._json(input));
  return buildHttpRpcRequest2(context, headers, "/", undefined, body);
};
var de_ListUsersCommand = async (output, context) => {
  if (output.statusCode >= 300) {
    return de_CommandError3(output, context);
  }
  const data = await import_core32.parseJsonBody(output.body, context);
  let contents = {};
  contents = de_ListUsersResponse(data, context);
  const response = {
    $metadata: deserializeMetadata3(output),
    ...contents
  };
  return response;
};
var de_CommandError3 = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await import_core32.parseJsonErrorBody(output.body, context)
  };
  const errorCode = import_core32.loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalErrorException":
    case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
      throw await de_InternalErrorExceptionRes(parsedOutput, context);
    case "InvalidParameterException":
    case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
      throw await de_InvalidParameterExceptionRes(parsedOutput, context);
    case "NotAuthorizedException":
    case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
      throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
    case "ResourceNotFoundException":
    case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes3(parsedOutput, context);
    case "TooManyRequestsException":
    case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
      throw await de_TooManyRequestsExceptionRes2(parsedOutput, context);
    case "UserImportInProgressException":
    case "com.amazonaws.cognitoidentityprovider#UserImportInProgressException":
      throw await de_UserImportInProgressExceptionRes(parsedOutput, context);
    case "UserNotFoundException":
    case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
      throw await de_UserNotFoundExceptionRes(parsedOutput, context);
    case "InvalidLambdaResponseException":
    case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
      throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
    case "LimitExceededException":
    case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
      throw await de_LimitExceededExceptionRes2(parsedOutput, context);
    case "TooManyFailedAttemptsException":
    case "com.amazonaws.cognitoidentityprovider#TooManyFailedAttemptsException":
      throw await de_TooManyFailedAttemptsExceptionRes(parsedOutput, context);
    case "UnexpectedLambdaException":
    case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
      throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
    case "UserLambdaValidationException":
    case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
      throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
    case "CodeDeliveryFailureException":
    case "com.amazonaws.cognitoidentityprovider#CodeDeliveryFailureException":
      throw await de_CodeDeliveryFailureExceptionRes(parsedOutput, context);
    case "InvalidPasswordException":
    case "com.amazonaws.cognitoidentityprovider#InvalidPasswordException":
      throw await de_InvalidPasswordExceptionRes(parsedOutput, context);
    case "InvalidSmsRoleAccessPolicyException":
    case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
      throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
    case "InvalidSmsRoleTrustRelationshipException":
    case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
      throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
    case "PreconditionNotMetException":
    case "com.amazonaws.cognitoidentityprovider#PreconditionNotMetException":
      throw await de_PreconditionNotMetExceptionRes(parsedOutput, context);
    case "UnsupportedUserStateException":
    case "com.amazonaws.cognitoidentityprovider#UnsupportedUserStateException":
      throw await de_UnsupportedUserStateExceptionRes(parsedOutput, context);
    case "UsernameExistsException":
    case "com.amazonaws.cognitoidentityprovider#UsernameExistsException":
      throw await de_UsernameExistsExceptionRes(parsedOutput, context);
    case "AliasExistsException":
    case "com.amazonaws.cognitoidentityprovider#AliasExistsException":
      throw await de_AliasExistsExceptionRes(parsedOutput, context);
    case "InvalidUserPoolConfigurationException":
    case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
      throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
    case "InvalidEmailRoleAccessPolicyException":
    case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
      throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput, context);
    case "MFAMethodNotFoundException":
    case "com.amazonaws.cognitoidentityprovider#MFAMethodNotFoundException":
      throw await de_MFAMethodNotFoundExceptionRes(parsedOutput, context);
    case "PasswordResetRequiredException":
    case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
      throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
    case "UnsupportedOperationException":
    case "com.amazonaws.cognitoidentityprovider#UnsupportedOperationException":
      throw await de_UnsupportedOperationExceptionRes(parsedOutput, context);
    case "UserNotConfirmedException":
    case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
      throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
    case "UserPoolAddOnNotEnabledException":
    case "com.amazonaws.cognitoidentityprovider#UserPoolAddOnNotEnabledException":
      throw await de_UserPoolAddOnNotEnabledExceptionRes(parsedOutput, context);
    case "CodeMismatchException":
    case "com.amazonaws.cognitoidentityprovider#CodeMismatchException":
      throw await de_CodeMismatchExceptionRes(parsedOutput, context);
    case "ExpiredCodeException":
    case "com.amazonaws.cognitoidentityprovider#ExpiredCodeException":
      throw await de_ExpiredCodeExceptionRes(parsedOutput, context);
    case "PasswordHistoryPolicyViolationException":
    case "com.amazonaws.cognitoidentityprovider#PasswordHistoryPolicyViolationException":
      throw await de_PasswordHistoryPolicyViolationExceptionRes(parsedOutput, context);
    case "SoftwareTokenMFANotFoundException":
    case "com.amazonaws.cognitoidentityprovider#SoftwareTokenMFANotFoundException":
      throw await de_SoftwareTokenMFANotFoundExceptionRes(parsedOutput, context);
    case "ConcurrentModificationException":
    case "com.amazonaws.cognitoidentityprovider#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
    case "ForbiddenException":
    case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
      throw await de_ForbiddenExceptionRes(parsedOutput, context);
    case "WebAuthnChallengeNotFoundException":
    case "com.amazonaws.cognitoidentityprovider#WebAuthnChallengeNotFoundException":
      throw await de_WebAuthnChallengeNotFoundExceptionRes(parsedOutput, context);
    case "WebAuthnClientMismatchException":
    case "com.amazonaws.cognitoidentityprovider#WebAuthnClientMismatchException":
      throw await de_WebAuthnClientMismatchExceptionRes(parsedOutput, context);
    case "WebAuthnCredentialNotSupportedException":
    case "com.amazonaws.cognitoidentityprovider#WebAuthnCredentialNotSupportedException":
      throw await de_WebAuthnCredentialNotSupportedExceptionRes(parsedOutput, context);
    case "WebAuthnNotEnabledException":
    case "com.amazonaws.cognitoidentityprovider#WebAuthnNotEnabledException":
      throw await de_WebAuthnNotEnabledExceptionRes(parsedOutput, context);
    case "WebAuthnOriginNotAllowedException":
    case "com.amazonaws.cognitoidentityprovider#WebAuthnOriginNotAllowedException":
      throw await de_WebAuthnOriginNotAllowedExceptionRes(parsedOutput, context);
    case "WebAuthnRelyingPartyMismatchException":
    case "com.amazonaws.cognitoidentityprovider#WebAuthnRelyingPartyMismatchException":
      throw await de_WebAuthnRelyingPartyMismatchExceptionRes(parsedOutput, context);
    case "DeviceKeyExistsException":
    case "com.amazonaws.cognitoidentityprovider#DeviceKeyExistsException":
      throw await de_DeviceKeyExistsExceptionRes(parsedOutput, context);
    case "GroupExistsException":
    case "com.amazonaws.cognitoidentityprovider#GroupExistsException":
      throw await de_GroupExistsExceptionRes(parsedOutput, context);
    case "DuplicateProviderException":
    case "com.amazonaws.cognitoidentityprovider#DuplicateProviderException":
      throw await de_DuplicateProviderExceptionRes(parsedOutput, context);
    case "ManagedLoginBrandingExistsException":
    case "com.amazonaws.cognitoidentityprovider#ManagedLoginBrandingExistsException":
      throw await de_ManagedLoginBrandingExistsExceptionRes(parsedOutput, context);
    case "TermsExistsException":
    case "com.amazonaws.cognitoidentityprovider#TermsExistsException":
      throw await de_TermsExistsExceptionRes(parsedOutput, context);
    case "FeatureUnavailableInTierException":
    case "com.amazonaws.cognitoidentityprovider#FeatureUnavailableInTierException":
      throw await de_FeatureUnavailableInTierExceptionRes(parsedOutput, context);
    case "TierChangeNotAllowedException":
    case "com.amazonaws.cognitoidentityprovider#TierChangeNotAllowedException":
      throw await de_TierChangeNotAllowedExceptionRes(parsedOutput, context);
    case "UserPoolTaggingException":
    case "com.amazonaws.cognitoidentityprovider#UserPoolTaggingException":
      throw await de_UserPoolTaggingExceptionRes(parsedOutput, context);
    case "InvalidOAuthFlowException":
    case "com.amazonaws.cognitoidentityprovider#InvalidOAuthFlowException":
      throw await de_InvalidOAuthFlowExceptionRes(parsedOutput, context);
    case "ScopeDoesNotExistException":
    case "com.amazonaws.cognitoidentityprovider#ScopeDoesNotExistException":
      throw await de_ScopeDoesNotExistExceptionRes(parsedOutput, context);
    case "UnsupportedIdentityProviderException":
    case "com.amazonaws.cognitoidentityprovider#UnsupportedIdentityProviderException":
      throw await de_UnsupportedIdentityProviderExceptionRes(parsedOutput, context);
    case "RefreshTokenReuseException":
    case "com.amazonaws.cognitoidentityprovider#RefreshTokenReuseException":
      throw await de_RefreshTokenReuseExceptionRes(parsedOutput, context);
    case "UnauthorizedException":
    case "com.amazonaws.cognitoidentityprovider#UnauthorizedException":
      throw await de_UnauthorizedExceptionRes2(parsedOutput, context);
    case "UnsupportedTokenTypeException":
    case "com.amazonaws.cognitoidentityprovider#UnsupportedTokenTypeException":
      throw await de_UnsupportedTokenTypeExceptionRes(parsedOutput, context);
    case "WebAuthnConfigurationMissingException":
    case "com.amazonaws.cognitoidentityprovider#WebAuthnConfigurationMissingException":
      throw await de_WebAuthnConfigurationMissingExceptionRes(parsedOutput, context);
    case "EnableSoftwareTokenMFAException":
    case "com.amazonaws.cognitoidentityprovider#EnableSoftwareTokenMFAException":
      throw await de_EnableSoftwareTokenMFAExceptionRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError3({
        output,
        parsedBody,
        errorCode
      });
  }
};
var de_AliasExistsExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new AliasExistsException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_CodeDeliveryFailureExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new CodeDeliveryFailureException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_CodeMismatchExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new CodeMismatchException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_ConcurrentModificationExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new ConcurrentModificationException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_DeviceKeyExistsExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new DeviceKeyExistsException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_DuplicateProviderExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new DuplicateProviderException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_EnableSoftwareTokenMFAExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new EnableSoftwareTokenMFAException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_ExpiredCodeExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new ExpiredCodeException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_FeatureUnavailableInTierExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new FeatureUnavailableInTierException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_ForbiddenExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new ForbiddenException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_GroupExistsExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new GroupExistsException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_InternalErrorExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new InternalErrorException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_InvalidEmailRoleAccessPolicyExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new InvalidEmailRoleAccessPolicyException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_InvalidLambdaResponseExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new InvalidLambdaResponseException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_InvalidOAuthFlowExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new InvalidOAuthFlowException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_InvalidParameterExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new InvalidParameterException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_InvalidPasswordExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new InvalidPasswordException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_InvalidSmsRoleAccessPolicyExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new InvalidSmsRoleAccessPolicyException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_InvalidSmsRoleTrustRelationshipExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new InvalidSmsRoleTrustRelationshipException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_InvalidUserPoolConfigurationExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new InvalidUserPoolConfigurationException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_LimitExceededExceptionRes2 = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new LimitExceededException2({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_ManagedLoginBrandingExistsExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new ManagedLoginBrandingExistsException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_MFAMethodNotFoundExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new MFAMethodNotFoundException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_NotAuthorizedExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new NotAuthorizedException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_PasswordHistoryPolicyViolationExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new PasswordHistoryPolicyViolationException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_PasswordResetRequiredExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new PasswordResetRequiredException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_PreconditionNotMetExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new PreconditionNotMetException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_RefreshTokenReuseExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new RefreshTokenReuseException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_ResourceNotFoundExceptionRes3 = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new ResourceNotFoundException3({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_ScopeDoesNotExistExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new ScopeDoesNotExistException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_SoftwareTokenMFANotFoundExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new SoftwareTokenMFANotFoundException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_TermsExistsExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new TermsExistsException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_TierChangeNotAllowedExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new TierChangeNotAllowedException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_TooManyFailedAttemptsExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new TooManyFailedAttemptsException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_TooManyRequestsExceptionRes2 = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new TooManyRequestsException2({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_UnauthorizedExceptionRes2 = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new UnauthorizedException2({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_UnexpectedLambdaExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new UnexpectedLambdaException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_UnsupportedIdentityProviderExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new UnsupportedIdentityProviderException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_UnsupportedOperationExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new UnsupportedOperationException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_UnsupportedTokenTypeExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new UnsupportedTokenTypeException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_UnsupportedUserStateExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new UnsupportedUserStateException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_UserImportInProgressExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new UserImportInProgressException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_UserLambdaValidationExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new UserLambdaValidationException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_UsernameExistsExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new UsernameExistsException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_UserNotConfirmedExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new UserNotConfirmedException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_UserNotFoundExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new UserNotFoundException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_UserPoolAddOnNotEnabledExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new UserPoolAddOnNotEnabledException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_UserPoolTaggingExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new UserPoolTaggingException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_WebAuthnChallengeNotFoundExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new WebAuthnChallengeNotFoundException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_WebAuthnClientMismatchExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new WebAuthnClientMismatchException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_WebAuthnConfigurationMissingExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new WebAuthnConfigurationMissingException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_WebAuthnCredentialNotSupportedExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new WebAuthnCredentialNotSupportedException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_WebAuthnNotEnabledExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new WebAuthnNotEnabledException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_WebAuthnOriginNotAllowedExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new WebAuthnOriginNotAllowedException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_WebAuthnRelyingPartyMismatchExceptionRes = async (parsedOutput, context) => {
  const body = parsedOutput.body;
  const deserialized = import_smithy_client89._json(body);
  const exception = new WebAuthnRelyingPartyMismatchException({
    $metadata: deserializeMetadata3(parsedOutput),
    ...deserialized
  });
  return import_smithy_client89.decorateServiceException(exception, body);
};
var de_ListUsersResponse = (output, context) => {
  return import_smithy_client89.take(output, {
    PaginationToken: import_smithy_client89.expectString,
    Users: (_2) => de_UsersListType(_2, context)
  });
};
var de_UsersListType = (output, context) => {
  const retVal = (output || []).filter((e4) => e4 != null).map((entry) => {
    return de_UserType(entry, context);
  });
  return retVal;
};
var de_UserType = (output, context) => {
  return import_smithy_client89.take(output, {
    Attributes: import_smithy_client89._json,
    Enabled: import_smithy_client89.expectBoolean,
    MFAOptions: import_smithy_client89._json,
    UserCreateDate: (_2) => import_smithy_client89.expectNonNull(import_smithy_client89.parseEpochTimestamp(import_smithy_client89.expectNumber(_2))),
    UserLastModifiedDate: (_2) => import_smithy_client89.expectNonNull(import_smithy_client89.parseEpochTimestamp(import_smithy_client89.expectNumber(_2))),
    UserStatus: import_smithy_client89.expectString,
    Username: import_smithy_client89.expectString
  });
};
var deserializeMetadata3 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var throwDefaultError3 = import_smithy_client89.withBaseException(CognitoIdentityProviderServiceException);
var buildHttpRpcRequest2 = async (context, headers, path, resolvedHostname, body) => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const contents = {
    protocol,
    hostname,
    port,
    method: "POST",
    path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
    headers
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new import_protocol_http6.HttpRequest(contents);
};
function sharedHeaders2(operation) {
  return {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": `AWSCognitoIdentityProviderService.${operation}`
  };
}

// node_modules/@aws-sdk/client-cognito-identity-provider/dist-es/commands/ListUsersCommand.js
var import_middleware_endpoint65 = __toESM(require_dist_cjs37(), 1);
var import_middleware_serde62 = __toESM(require_dist_cjs7(), 1);
var import_smithy_client90 = __toESM(require_dist_cjs28(), 1);
class ListUsersCommand extends import_smithy_client90.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o4) {
  return [
    import_middleware_serde62.getSerdePlugin(config, this.serialize, this.deserialize),
    import_middleware_endpoint65.getEndpointPlugin(config, Command.getEndpointParameterInstructions())
  ];
}).s("AWSCognitoIdentityProviderService", "ListUsers", {}).n("CognitoIdentityProviderClient", "ListUsersCommand").f(undefined, ListUsersResponseFilterSensitiveLog).ser(se_ListUsersCommand).de(de_ListUsersCommand).build() {
}

// node_modules/@aws-sdk/middleware-expect-continue/dist-es/index.js
var import_protocol_http7 = __toESM(require_dist_cjs3(), 1);
function addExpectContinueMiddleware(options) {
  return (next) => async (args) => {
    const { request: request2 } = args;
    if (import_protocol_http7.HttpRequest.isInstance(request2) && request2.body && options.runtime === "node") {
      if (options.requestHandler?.constructor?.name !== "FetchHttpHandler") {
        request2.headers = {
          ...request2.headers,
          Expect: "100-continue"
        };
      }
    }
    return next({
      ...args,
      request: request2
    });
  };
}
var addExpectContinueMiddlewareOptions = {
  step: "build",
  tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"],
  name: "addExpectContinueMiddleware",
  override: true
};
var getAddExpectContinuePlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(addExpectContinueMiddleware(options), addExpectContinueMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/constants.js
var RequestChecksumCalculation = {
  WHEN_SUPPORTED: "WHEN_SUPPORTED",
  WHEN_REQUIRED: "WHEN_REQUIRED"
};
var DEFAULT_REQUEST_CHECKSUM_CALCULATION = RequestChecksumCalculation.WHEN_SUPPORTED;
var ResponseChecksumValidation = {
  WHEN_SUPPORTED: "WHEN_SUPPORTED",
  WHEN_REQUIRED: "WHEN_REQUIRED"
};
var DEFAULT_RESPONSE_CHECKSUM_VALIDATION = RequestChecksumCalculation.WHEN_SUPPORTED;
var ChecksumAlgorithm;
(function(ChecksumAlgorithm2) {
  ChecksumAlgorithm2["MD5"] = "MD5";
  ChecksumAlgorithm2["CRC32"] = "CRC32";
  ChecksumAlgorithm2["CRC32C"] = "CRC32C";
  ChecksumAlgorithm2["CRC64NVME"] = "CRC64NVME";
  ChecksumAlgorithm2["SHA1"] = "SHA1";
  ChecksumAlgorithm2["SHA256"] = "SHA256";
})(ChecksumAlgorithm || (ChecksumAlgorithm = {}));
var ChecksumLocation;
(function(ChecksumLocation2) {
  ChecksumLocation2["HEADER"] = "header";
  ChecksumLocation2["TRAILER"] = "trailer";
})(ChecksumLocation || (ChecksumLocation = {}));
var DEFAULT_CHECKSUM_ALGORITHM = ChecksumAlgorithm.CRC32;

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/stringUnionSelector.js
var SelectorType;
(function(SelectorType2) {
  SelectorType2["ENV"] = "env";
  SelectorType2["CONFIG"] = "shared config entry";
})(SelectorType || (SelectorType = {}));
var stringUnionSelector = (obj, key, union, type) => {
  if (!(key in obj))
    return;
  const value = obj[key].toUpperCase();
  if (!Object.values(union).includes(value)) {
    throw new TypeError(`Cannot load ${type} '${key}'. Expected one of ${Object.values(union)}, got '${obj[key]}'.`);
  }
  return value;
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS.js
var ENV_REQUEST_CHECKSUM_CALCULATION = "AWS_REQUEST_CHECKSUM_CALCULATION";
var CONFIG_REQUEST_CHECKSUM_CALCULATION = "request_checksum_calculation";
var NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => stringUnionSelector(env3, ENV_REQUEST_CHECKSUM_CALCULATION, RequestChecksumCalculation, SelectorType.ENV),
  configFileSelector: (profile) => stringUnionSelector(profile, CONFIG_REQUEST_CHECKSUM_CALCULATION, RequestChecksumCalculation, SelectorType.CONFIG),
  default: DEFAULT_REQUEST_CHECKSUM_CALCULATION
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS.js
var ENV_RESPONSE_CHECKSUM_VALIDATION = "AWS_RESPONSE_CHECKSUM_VALIDATION";
var CONFIG_RESPONSE_CHECKSUM_VALIDATION = "response_checksum_validation";
var NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => stringUnionSelector(env3, ENV_RESPONSE_CHECKSUM_VALIDATION, ResponseChecksumValidation, SelectorType.ENV),
  configFileSelector: (profile) => stringUnionSelector(profile, CONFIG_RESPONSE_CHECKSUM_VALIDATION, ResponseChecksumValidation, SelectorType.CONFIG),
  default: DEFAULT_RESPONSE_CHECKSUM_VALIDATION
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/crc64-nvme-crt-container.js
var crc64NvmeCrtContainer = {
  CrtCrc64Nvme: null
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsMiddleware.js
var import_core33 = __toESM(require_dist_cjs30(), 1);
var import_protocol_http8 = __toESM(require_dist_cjs3(), 1);
var import_util_stream2 = __toESM(require_dist_cjs17(), 1);

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/types.js
var CLIENT_SUPPORTED_ALGORITHMS = [
  ChecksumAlgorithm.CRC32,
  ChecksumAlgorithm.CRC32C,
  ChecksumAlgorithm.CRC64NVME,
  ChecksumAlgorithm.SHA1,
  ChecksumAlgorithm.SHA256
];
var PRIORITY_ORDER_ALGORITHMS = [
  ChecksumAlgorithm.SHA256,
  ChecksumAlgorithm.SHA1,
  ChecksumAlgorithm.CRC32,
  ChecksumAlgorithm.CRC32C,
  ChecksumAlgorithm.CRC64NVME
];

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmForRequest.js
var getChecksumAlgorithmForRequest = (input, { requestChecksumRequired, requestAlgorithmMember, requestChecksumCalculation }) => {
  if (!requestAlgorithmMember) {
    return requestChecksumCalculation === RequestChecksumCalculation.WHEN_SUPPORTED || requestChecksumRequired ? DEFAULT_CHECKSUM_ALGORITHM : undefined;
  }
  if (!input[requestAlgorithmMember]) {
    return;
  }
  const checksumAlgorithm = input[requestAlgorithmMember];
  if (!CLIENT_SUPPORTED_ALGORITHMS.includes(checksumAlgorithm)) {
    throw new Error(`The checksum algorithm "${checksumAlgorithm}" is not supported by the client.` + ` Select one of ${CLIENT_SUPPORTED_ALGORITHMS}.`);
  }
  return checksumAlgorithm;
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumLocationName.js
var getChecksumLocationName = (algorithm) => algorithm === ChecksumAlgorithm.MD5 ? "content-md5" : `x-amz-checksum-${algorithm.toLowerCase()}`;

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/hasHeader.js
var hasHeader = (header, headers) => {
  const soughtHeader = header.toLowerCase();
  for (const headerName of Object.keys(headers)) {
    if (soughtHeader === headerName.toLowerCase()) {
      return true;
    }
  }
  return false;
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/hasHeaderWithPrefix.js
var hasHeaderWithPrefix = (headerPrefix, headers) => {
  const soughtHeaderPrefix = headerPrefix.toLowerCase();
  for (const headerName of Object.keys(headers)) {
    if (headerName.toLowerCase().startsWith(soughtHeaderPrefix)) {
      return true;
    }
  }
  return false;
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/isStreaming.js
var import_is_array_buffer = __toESM(require_dist_cjs8(), 1);
var isStreaming = (body) => body !== undefined && typeof body !== "string" && !ArrayBuffer.isView(body) && !import_is_array_buffer.isArrayBuffer(body);

// node_modules/tslib/modules/index.js
var import_tslib = __toESM(require_tslib(), 1);
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet: __classPrivateFieldGet2,
  __classPrivateFieldSet: __classPrivateFieldSet2,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension
} = import_tslib.default;

// node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/node_modules/@smithy/util-buffer-from/dist-es/index.js
import { Buffer as Buffer3 } from "buffer";
var fromString = (input, encoding) => {
  if (typeof input !== "string") {
    throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
  }
  return encoding ? Buffer3.from(input, encoding) : Buffer3.from(input);
};

// node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-es/fromUtf8.js
var fromUtf84 = (input) => {
  const buf = fromString(input, "utf8");
  return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};
// node_modules/@aws-crypto/util/build/module/convertToBuffer.js
var fromUtf86 = typeof Buffer !== "undefined" && Buffer.from ? function(input) {
  return Buffer.from(input, "utf8");
} : fromUtf84;
function convertToBuffer(data) {
  if (data instanceof Uint8Array)
    return data;
  if (typeof data === "string") {
    return fromUtf86(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
}
// node_modules/@aws-crypto/util/build/module/isEmptyData.js
function isEmptyData(data) {
  if (typeof data === "string") {
    return data.length === 0;
  }
  return data.byteLength === 0;
}
// node_modules/@aws-crypto/util/build/module/numToUint8.js
function numToUint8(num) {
  return new Uint8Array([
    (num & 4278190080) >> 24,
    (num & 16711680) >> 16,
    (num & 65280) >> 8,
    num & 255
  ]);
}
// node_modules/@aws-crypto/util/build/module/uint32ArrayFrom.js
function uint32ArrayFrom(a_lookUpTable) {
  if (!Uint32Array.from) {
    var return_array = new Uint32Array(a_lookUpTable.length);
    var a_index = 0;
    while (a_index < a_lookUpTable.length) {
      return_array[a_index] = a_lookUpTable[a_index];
      a_index += 1;
    }
    return return_array;
  }
  return Uint32Array.from(a_lookUpTable);
}
// node_modules/@aws-crypto/crc32c/build/module/aws_crc32c.js
var AwsCrc32c = function() {
  function AwsCrc32c2() {
    this.crc32c = new Crc32c;
  }
  AwsCrc32c2.prototype.update = function(toHash) {
    if (isEmptyData(toHash))
      return;
    this.crc32c.update(convertToBuffer(toHash));
  };
  AwsCrc32c2.prototype.digest = function() {
    return __awaiter(this, undefined, undefined, function() {
      return __generator(this, function(_a2) {
        return [2, numToUint8(this.crc32c.digest())];
      });
    });
  };
  AwsCrc32c2.prototype.reset = function() {
    this.crc32c = new Crc32c;
  };
  return AwsCrc32c2;
}();
// node_modules/@aws-crypto/crc32c/build/module/index.js
var Crc32c = function() {
  function Crc32c2() {
    this.checksum = 4294967295;
  }
  Crc32c2.prototype.update = function(data) {
    var e_1, _a2;
    try {
      for (var data_1 = __values(data), data_1_1 = data_1.next();!data_1_1.done; data_1_1 = data_1.next()) {
        var byte2 = data_1_1.value;
        this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte2) & 255];
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (data_1_1 && !data_1_1.done && (_a2 = data_1.return))
          _a2.call(data_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return this;
  };
  Crc32c2.prototype.digest = function() {
    return (this.checksum ^ 4294967295) >>> 0;
  };
  return Crc32c2;
}();
var a_lookupTable = [
  0,
  4067132163,
  3778769143,
  324072436,
  3348797215,
  904991772,
  648144872,
  3570033899,
  2329499855,
  2024987596,
  1809983544,
  2575936315,
  1296289744,
  3207089363,
  2893594407,
  1578318884,
  274646895,
  3795141740,
  4049975192,
  51262619,
  3619967088,
  632279923,
  922689671,
  3298075524,
  2592579488,
  1760304291,
  2075979607,
  2312596564,
  1562183871,
  2943781820,
  3156637768,
  1313733451,
  549293790,
  3537243613,
  3246849577,
  871202090,
  3878099393,
  357341890,
  102525238,
  4101499445,
  2858735121,
  1477399826,
  1264559846,
  3107202533,
  1845379342,
  2677391885,
  2361733625,
  2125378298,
  820201905,
  3263744690,
  3520608582,
  598981189,
  4151959214,
  85089709,
  373468761,
  3827903834,
  3124367742,
  1213305469,
  1526817161,
  2842354314,
  2107672161,
  2412447074,
  2627466902,
  1861252501,
  1098587580,
  3004210879,
  2688576843,
  1378610760,
  2262928035,
  1955203488,
  1742404180,
  2511436119,
  3416409459,
  969524848,
  714683780,
  3639785095,
  205050476,
  4266873199,
  3976438427,
  526918040,
  1361435347,
  2739821008,
  2954799652,
  1114974503,
  2529119692,
  1691668175,
  2005155131,
  2247081528,
  3690758684,
  697762079,
  986182379,
  3366744552,
  476452099,
  3993867776,
  4250756596,
  255256311,
  1640403810,
  2477592673,
  2164122517,
  1922457750,
  2791048317,
  1412925310,
  1197962378,
  3037525897,
  3944729517,
  427051182,
  170179418,
  4165941337,
  746937522,
  3740196785,
  3451792453,
  1070968646,
  1905808397,
  2213795598,
  2426610938,
  1657317369,
  3053634322,
  1147748369,
  1463399397,
  2773627110,
  4215344322,
  153784257,
  444234805,
  3893493558,
  1021025245,
  3467647198,
  3722505002,
  797665321,
  2197175160,
  1889384571,
  1674398607,
  2443626636,
  1164749927,
  3070701412,
  2757221520,
  1446797203,
  137323447,
  4198817972,
  3910406976,
  461344835,
  3484808360,
  1037989803,
  781091935,
  3705997148,
  2460548119,
  1623424788,
  1939049696,
  2180517859,
  1429367560,
  2807687179,
  3020495871,
  1180866812,
  410100952,
  3927582683,
  4182430767,
  186734380,
  3756733383,
  763408580,
  1053836080,
  3434856499,
  2722870694,
  1344288421,
  1131464017,
  2971354706,
  1708204729,
  2545590714,
  2229949006,
  1988219213,
  680717673,
  3673779818,
  3383336350,
  1002577565,
  4010310262,
  493091189,
  238226049,
  4233660802,
  2987750089,
  1082061258,
  1395524158,
  2705686845,
  1972364758,
  2279892693,
  2494862625,
  1725896226,
  952904198,
  3399985413,
  3656866545,
  731699698,
  4283874585,
  222117402,
  510512622,
  3959836397,
  3280807620,
  837199303,
  582374963,
  3504198960,
  68661723,
  4135334616,
  3844915500,
  390545967,
  1230274059,
  3141532936,
  2825850620,
  1510247935,
  2395924756,
  2091215383,
  1878366691,
  2644384480,
  3553878443,
  565732008,
  854102364,
  3229815391,
  340358836,
  3861050807,
  4117890627,
  119113024,
  1493875044,
  2875275879,
  3090270611,
  1247431312,
  2660249211,
  1828433272,
  2141937292,
  2378227087,
  3811616794,
  291187481,
  34330861,
  4032846830,
  615137029,
  3603020806,
  3314634738,
  939183345,
  1776939221,
  2609017814,
  2295496738,
  2058945313,
  2926798794,
  1545135305,
  1330124605,
  3173225534,
  4084100981,
  17165430,
  307568514,
  3762199681,
  888469610,
  3332340585,
  3587147933,
  665062302,
  2042050490,
  2346497209,
  2559330125,
  1793573966,
  3190661285,
  1279665062,
  1595330642,
  2910671697
];
var lookupTable = uint32ArrayFrom(a_lookupTable);

// node_modules/@aws-crypto/crc32/build/module/aws_crc32.js
var AwsCrc32 = function() {
  function AwsCrc322() {
    this.crc32 = new Crc32;
  }
  AwsCrc322.prototype.update = function(toHash) {
    if (isEmptyData(toHash))
      return;
    this.crc32.update(convertToBuffer(toHash));
  };
  AwsCrc322.prototype.digest = function() {
    return __awaiter(this, undefined, undefined, function() {
      return __generator(this, function(_a2) {
        return [2, numToUint8(this.crc32.digest())];
      });
    });
  };
  AwsCrc322.prototype.reset = function() {
    this.crc32 = new Crc32;
  };
  return AwsCrc322;
}();
// node_modules/@aws-crypto/crc32/build/module/index.js
var Crc32 = function() {
  function Crc322() {
    this.checksum = 4294967295;
  }
  Crc322.prototype.update = function(data) {
    var e_1, _a2;
    try {
      for (var data_1 = __values(data), data_1_1 = data_1.next();!data_1_1.done; data_1_1 = data_1.next()) {
        var byte2 = data_1_1.value;
        this.checksum = this.checksum >>> 8 ^ lookupTable2[(this.checksum ^ byte2) & 255];
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (data_1_1 && !data_1_1.done && (_a2 = data_1.return))
          _a2.call(data_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return this;
  };
  Crc322.prototype.digest = function() {
    return (this.checksum ^ 4294967295) >>> 0;
  };
  return Crc322;
}();
var a_lookUpTable = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918000,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
var lookupTable2 = uint32ArrayFrom(a_lookUpTable);

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getCrc32ChecksumAlgorithmFunction.js
import * as zlib from "zlib";

class NodeCrc32 {
  checksum = 0;
  update(data) {
    this.checksum = zlib.crc32(data, this.checksum);
  }
  async digest() {
    return numToUint8(this.checksum);
  }
  reset() {
    this.checksum = 0;
  }
}
var getCrc32ChecksumAlgorithmFunction = () => {
  if (typeof zlib.crc32 === "undefined") {
    return AwsCrc32;
  }
  return NodeCrc32;
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/selectChecksumAlgorithmFunction.js
var selectChecksumAlgorithmFunction = (checksumAlgorithm, config) => {
  switch (checksumAlgorithm) {
    case ChecksumAlgorithm.MD5:
      return config.md5;
    case ChecksumAlgorithm.CRC32:
      return getCrc32ChecksumAlgorithmFunction();
    case ChecksumAlgorithm.CRC32C:
      return AwsCrc32c;
    case ChecksumAlgorithm.CRC64NVME:
      if (typeof crc64NvmeCrtContainer.CrtCrc64Nvme !== "function") {
        throw new Error(`Please check whether you have installed the "@aws-sdk/crc64-nvme-crt" package explicitly. 
` + `You must also register the package by calling [require("@aws-sdk/crc64-nvme-crt");] ` + `or an ESM equivalent such as [import "@aws-sdk/crc64-nvme-crt";]. 
` + "For more information please go to " + "https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt");
      }
      return crc64NvmeCrtContainer.CrtCrc64Nvme;
    case ChecksumAlgorithm.SHA1:
      return config.sha1;
    case ChecksumAlgorithm.SHA256:
      return config.sha256;
    default:
      throw new Error(`Unsupported checksum algorithm: ${checksumAlgorithm}`);
  }
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/stringHasher.js
var import_util_utf85 = __toESM(require_dist_cjs10(), 1);
var stringHasher = (checksumAlgorithmFn, body) => {
  const hash2 = new checksumAlgorithmFn;
  hash2.update(import_util_utf85.toUint8Array(body || ""));
  return hash2.digest();
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsMiddleware.js
var flexibleChecksumsMiddlewareOptions = {
  name: "flexibleChecksumsMiddleware",
  step: "build",
  tags: ["BODY_CHECKSUM"],
  override: true
};
var flexibleChecksumsMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {
  if (!import_protocol_http8.HttpRequest.isInstance(args.request)) {
    return next(args);
  }
  if (hasHeaderWithPrefix("x-amz-checksum-", args.request.headers)) {
    return next(args);
  }
  const { request: request2, input } = args;
  const { body: requestBody, headers } = request2;
  const { base64Encoder, streamHasher } = config;
  const { requestChecksumRequired, requestAlgorithmMember } = middlewareConfig;
  const requestChecksumCalculation = await config.requestChecksumCalculation();
  const requestAlgorithmMemberName = requestAlgorithmMember?.name;
  const requestAlgorithmMemberHttpHeader = requestAlgorithmMember?.httpHeader;
  if (requestAlgorithmMemberName && !input[requestAlgorithmMemberName]) {
    if (requestChecksumCalculation === RequestChecksumCalculation.WHEN_SUPPORTED || requestChecksumRequired) {
      input[requestAlgorithmMemberName] = DEFAULT_CHECKSUM_ALGORITHM;
      if (requestAlgorithmMemberHttpHeader) {
        headers[requestAlgorithmMemberHttpHeader] = DEFAULT_CHECKSUM_ALGORITHM;
      }
    }
  }
  const checksumAlgorithm = getChecksumAlgorithmForRequest(input, {
    requestChecksumRequired,
    requestAlgorithmMember: requestAlgorithmMember?.name,
    requestChecksumCalculation
  });
  let updatedBody = requestBody;
  let updatedHeaders = headers;
  if (checksumAlgorithm) {
    switch (checksumAlgorithm) {
      case ChecksumAlgorithm.CRC32:
        import_core33.setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_CRC32", "U");
        break;
      case ChecksumAlgorithm.CRC32C:
        import_core33.setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_CRC32C", "V");
        break;
      case ChecksumAlgorithm.CRC64NVME:
        import_core33.setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_CRC64", "W");
        break;
      case ChecksumAlgorithm.SHA1:
        import_core33.setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_SHA1", "X");
        break;
      case ChecksumAlgorithm.SHA256:
        import_core33.setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_SHA256", "Y");
        break;
    }
    const checksumLocationName = getChecksumLocationName(checksumAlgorithm);
    const checksumAlgorithmFn = selectChecksumAlgorithmFunction(checksumAlgorithm, config);
    if (isStreaming(requestBody)) {
      const { getAwsChunkedEncodingStream, bodyLengthChecker } = config;
      updatedBody = getAwsChunkedEncodingStream(typeof config.requestStreamBufferSize === "number" && config.requestStreamBufferSize >= 8 * 1024 ? import_util_stream2.createBufferedReadable(requestBody, config.requestStreamBufferSize, context.logger) : requestBody, {
        base64Encoder,
        bodyLengthChecker,
        checksumLocationName,
        checksumAlgorithmFn,
        streamHasher
      });
      updatedHeaders = {
        ...headers,
        "content-encoding": headers["content-encoding"] ? `${headers["content-encoding"]},aws-chunked` : "aws-chunked",
        "transfer-encoding": "chunked",
        "x-amz-decoded-content-length": headers["content-length"],
        "x-amz-content-sha256": "STREAMING-UNSIGNED-PAYLOAD-TRAILER",
        "x-amz-trailer": checksumLocationName
      };
      delete updatedHeaders["content-length"];
    } else if (!hasHeader(checksumLocationName, headers)) {
      const rawChecksum = await stringHasher(checksumAlgorithmFn, requestBody);
      updatedHeaders = {
        ...headers,
        [checksumLocationName]: base64Encoder(rawChecksum)
      };
    }
  }
  const result = await next({
    ...args,
    request: {
      ...request2,
      headers: updatedHeaders,
      body: updatedBody
    }
  });
  return result;
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsInputMiddleware.js
var import_core34 = __toESM(require_dist_cjs30(), 1);
var flexibleChecksumsInputMiddlewareOptions = {
  name: "flexibleChecksumsInputMiddleware",
  toMiddleware: "serializerMiddleware",
  relation: "before",
  tags: ["BODY_CHECKSUM"],
  override: true
};
var flexibleChecksumsInputMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {
  const input = args.input;
  const { requestValidationModeMember } = middlewareConfig;
  const requestChecksumCalculation = await config.requestChecksumCalculation();
  const responseChecksumValidation = await config.responseChecksumValidation();
  switch (requestChecksumCalculation) {
    case RequestChecksumCalculation.WHEN_REQUIRED:
      import_core34.setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_WHEN_REQUIRED", "a");
      break;
    case RequestChecksumCalculation.WHEN_SUPPORTED:
      import_core34.setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_WHEN_SUPPORTED", "Z");
      break;
  }
  switch (responseChecksumValidation) {
    case ResponseChecksumValidation.WHEN_REQUIRED:
      import_core34.setFeature(context, "FLEXIBLE_CHECKSUMS_RES_WHEN_REQUIRED", "c");
      break;
    case ResponseChecksumValidation.WHEN_SUPPORTED:
      import_core34.setFeature(context, "FLEXIBLE_CHECKSUMS_RES_WHEN_SUPPORTED", "b");
      break;
  }
  if (requestValidationModeMember && !input[requestValidationModeMember]) {
    if (responseChecksumValidation === ResponseChecksumValidation.WHEN_SUPPORTED) {
      input[requestValidationModeMember] = "ENABLED";
    }
  }
  return next(args);
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsResponseMiddleware.js
var import_protocol_http9 = __toESM(require_dist_cjs3(), 1);

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksumAlgorithmListForResponse.js
var getChecksumAlgorithmListForResponse = (responseAlgorithms = []) => {
  const validChecksumAlgorithms = [];
  for (const algorithm of PRIORITY_ORDER_ALGORITHMS) {
    if (!responseAlgorithms.includes(algorithm) || !CLIENT_SUPPORTED_ALGORITHMS.includes(algorithm)) {
      continue;
    }
    validChecksumAlgorithms.push(algorithm);
  }
  return validChecksumAlgorithms;
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/isChecksumWithPartNumber.js
var isChecksumWithPartNumber = (checksum2) => {
  const lastHyphenIndex = checksum2.lastIndexOf("-");
  if (lastHyphenIndex !== -1) {
    const numberPart = checksum2.slice(lastHyphenIndex + 1);
    if (!numberPart.startsWith("0")) {
      const number = parseInt(numberPart, 10);
      if (!isNaN(number) && number >= 1 && number <= 1e4) {
        return true;
      }
    }
  }
  return false;
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/validateChecksumFromResponse.js
var import_util_stream3 = __toESM(require_dist_cjs17(), 1);

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getChecksum.js
var getChecksum = async (body, { checksumAlgorithmFn, base64Encoder }) => base64Encoder(await stringHasher(checksumAlgorithmFn, body));

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/validateChecksumFromResponse.js
var validateChecksumFromResponse = async (response, { config, responseAlgorithms, logger }) => {
  const checksumAlgorithms = getChecksumAlgorithmListForResponse(responseAlgorithms);
  const { body: responseBody, headers: responseHeaders } = response;
  for (const algorithm of checksumAlgorithms) {
    const responseHeader = getChecksumLocationName(algorithm);
    const checksumFromResponse = responseHeaders[responseHeader];
    if (checksumFromResponse) {
      let checksumAlgorithmFn;
      try {
        checksumAlgorithmFn = selectChecksumAlgorithmFunction(algorithm, config);
      } catch (error) {
        if (algorithm === ChecksumAlgorithm.CRC64NVME) {
          logger?.warn(`Skipping ${ChecksumAlgorithm.CRC64NVME} checksum validation: ${error.message}`);
          continue;
        }
        throw error;
      }
      const { base64Encoder } = config;
      if (isStreaming(responseBody)) {
        response.body = import_util_stream3.createChecksumStream({
          expectedChecksum: checksumFromResponse,
          checksumSourceLocation: responseHeader,
          checksum: new checksumAlgorithmFn,
          source: responseBody,
          base64Encoder
        });
        return;
      }
      const checksum2 = await getChecksum(responseBody, { checksumAlgorithmFn, base64Encoder });
      if (checksum2 === checksumFromResponse) {
        break;
      }
      throw new Error(`Checksum mismatch: expected "${checksum2}" but received "${checksumFromResponse}"` + ` in response header "${responseHeader}".`);
    }
  }
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/flexibleChecksumsResponseMiddleware.js
var flexibleChecksumsResponseMiddlewareOptions = {
  name: "flexibleChecksumsResponseMiddleware",
  toMiddleware: "deserializerMiddleware",
  relation: "after",
  tags: ["BODY_CHECKSUM"],
  override: true
};
var flexibleChecksumsResponseMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {
  if (!import_protocol_http9.HttpRequest.isInstance(args.request)) {
    return next(args);
  }
  const input = args.input;
  const result = await next(args);
  const response = result.response;
  const { requestValidationModeMember, responseAlgorithms } = middlewareConfig;
  if (requestValidationModeMember && input[requestValidationModeMember] === "ENABLED") {
    const { clientName, commandName } = context;
    const isS3WholeObjectMultipartGetResponseChecksum = clientName === "S3Client" && commandName === "GetObjectCommand" && getChecksumAlgorithmListForResponse(responseAlgorithms).every((algorithm) => {
      const responseHeader = getChecksumLocationName(algorithm);
      const checksumFromResponse = response.headers[responseHeader];
      return !checksumFromResponse || isChecksumWithPartNumber(checksumFromResponse);
    });
    if (isS3WholeObjectMultipartGetResponseChecksum) {
      return result;
    }
    await validateChecksumFromResponse(response, {
      config,
      responseAlgorithms,
      logger: context.logger
    });
  }
  return result;
};

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/getFlexibleChecksumsPlugin.js
var getFlexibleChecksumsPlugin = (config, middlewareConfig) => ({
  applyToStack: (clientStack) => {
    clientStack.add(flexibleChecksumsMiddleware(config, middlewareConfig), flexibleChecksumsMiddlewareOptions);
    clientStack.addRelativeTo(flexibleChecksumsInputMiddleware(config, middlewareConfig), flexibleChecksumsInputMiddlewareOptions);
    clientStack.addRelativeTo(flexibleChecksumsResponseMiddleware(config, middlewareConfig), flexibleChecksumsResponseMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-flexible-checksums/dist-es/resolveFlexibleChecksumsConfig.js
var import_util_middleware4 = __toESM(require_dist_cjs2(), 1);
var resolveFlexibleChecksumsConfig = (input) => {
  const { requestChecksumCalculation, responseChecksumValidation, requestStreamBufferSize } = input;
  return Object.assign(input, {
    requestChecksumCalculation: import_util_middleware4.normalizeProvider(requestChecksumCalculation ?? DEFAULT_REQUEST_CHECKSUM_CALCULATION),
    responseChecksumValidation: import_util_middleware4.normalizeProvider(responseChecksumValidation ?? DEFAULT_RESPONSE_CHECKSUM_VALIDATION),
    requestStreamBufferSize: Number(requestStreamBufferSize ?? 0)
  });
};

// node_modules/@aws-sdk/client-s3/dist-es/S3Client.js
var import_middleware_host_header4 = __toESM(require_dist_cjs4(), 1);
var import_middleware_logger4 = __toESM(require_dist_cjs5(), 1);
var import_middleware_recursion_detection4 = __toESM(require_dist_cjs6(), 1);

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/check-content-length-header.js
var import_protocol_http10 = __toESM(require_dist_cjs3(), 1);
var import_smithy_client91 = __toESM(require_dist_cjs28(), 1);
var CONTENT_LENGTH_HEADER = "content-length";
var DECODED_CONTENT_LENGTH_HEADER = "x-amz-decoded-content-length";
function checkContentLengthHeader() {
  return (next, context) => async (args) => {
    const { request: request2 } = args;
    if (import_protocol_http10.HttpRequest.isInstance(request2)) {
      if (!(CONTENT_LENGTH_HEADER in request2.headers) && !(DECODED_CONTENT_LENGTH_HEADER in request2.headers)) {
        const message = `Are you using a Stream of unknown length as the Body of a PutObject request? Consider using Upload instead from @aws-sdk/lib-storage.`;
        if (typeof context?.logger?.warn === "function" && !(context.logger instanceof import_smithy_client91.NoOpLogger)) {
          context.logger.warn(message);
        } else {
          console.warn(message);
        }
      }
    }
    return next({ ...args });
  };
}
var checkContentLengthHeaderMiddlewareOptions = {
  step: "finalizeRequest",
  tags: ["CHECK_CONTENT_LENGTH_HEADER"],
  name: "getCheckContentLengthHeaderPlugin",
  override: true
};
var getCheckContentLengthHeaderPlugin = (unused) => ({
  applyToStack: (clientStack) => {
    clientStack.add(checkContentLengthHeader(), checkContentLengthHeaderMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-endpoint-middleware.js
var regionRedirectEndpointMiddleware = (config) => {
  return (next, context) => async (args) => {
    const originalRegion = await config.region();
    const regionProviderRef = config.region;
    let unlock = () => {};
    if (context.__s3RegionRedirect) {
      Object.defineProperty(config, "region", {
        writable: false,
        value: async () => {
          return context.__s3RegionRedirect;
        }
      });
      unlock = () => Object.defineProperty(config, "region", {
        writable: true,
        value: regionProviderRef
      });
    }
    try {
      const result = await next(args);
      if (context.__s3RegionRedirect) {
        unlock();
        const region = await config.region();
        if (originalRegion !== region) {
          throw new Error("Region was not restored following S3 region redirect.");
        }
      }
      return result;
    } catch (e4) {
      unlock();
      throw e4;
    }
  };
};
var regionRedirectEndpointMiddlewareOptions = {
  tags: ["REGION_REDIRECT", "S3"],
  name: "regionRedirectEndpointMiddleware",
  override: true,
  relation: "before",
  toMiddleware: "endpointV2Middleware"
};

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/region-redirect-middleware.js
function regionRedirectMiddleware(clientConfig) {
  return (next, context) => async (args) => {
    try {
      return await next(args);
    } catch (err3) {
      if (clientConfig.followRegionRedirects) {
        const statusCode = err3?.$metadata?.httpStatusCode;
        const isHeadBucket = context.commandName === "HeadBucketCommand";
        const bucketRegionHeader = err3?.$response?.headers?.["x-amz-bucket-region"];
        if (bucketRegionHeader) {
          if (statusCode === 301 || statusCode === 400 && (err3?.name === "IllegalLocationConstraintException" || isHeadBucket)) {
            try {
              const actualRegion = bucketRegionHeader;
              context.logger?.debug(`Redirecting from ${await clientConfig.region()} to ${actualRegion}`);
              context.__s3RegionRedirect = actualRegion;
            } catch (e4) {
              throw new Error("Region redirect failed: " + e4);
            }
            return next(args);
          }
        }
      }
      throw err3;
    }
  };
}
var regionRedirectMiddlewareOptions = {
  step: "initialize",
  tags: ["REGION_REDIRECT", "S3"],
  name: "regionRedirectMiddleware",
  override: true
};
var getRegionRedirectMiddlewarePlugin = (clientConfig) => ({
  applyToStack: (clientStack) => {
    clientStack.add(regionRedirectMiddleware(clientConfig), regionRedirectMiddlewareOptions);
    clientStack.addRelativeTo(regionRedirectEndpointMiddleware(clientConfig), regionRedirectEndpointMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-expires-middleware.js
var import_protocol_http11 = __toESM(require_dist_cjs3(), 1);
var import_smithy_client92 = __toESM(require_dist_cjs28(), 1);
var s3ExpiresMiddleware = (config) => {
  return (next, context) => async (args) => {
    const result = await next(args);
    const { response } = result;
    if (import_protocol_http11.HttpResponse.isInstance(response)) {
      if (response.headers.expires) {
        response.headers.expiresstring = response.headers.expires;
        try {
          import_smithy_client92.parseRfc7231DateTime(response.headers.expires);
        } catch (e4) {
          context.logger?.warn(`AWS SDK Warning for ${context.clientName}::${context.commandName} response parsing (${response.headers.expires}): ${e4}`);
          delete response.headers.expires;
        }
      }
    }
    return result;
  };
};
var s3ExpiresMiddlewareOptions = {
  tags: ["S3"],
  name: "s3ExpiresMiddleware",
  override: true,
  relation: "after",
  toMiddleware: "deserializerMiddleware"
};
var getS3ExpiresMiddlewarePlugin = (clientConfig) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(s3ExpiresMiddleware(clientConfig), s3ExpiresMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCache.js
class S3ExpressIdentityCache {
  data;
  lastPurgeTime = Date.now();
  static EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS = 30000;
  constructor(data = {}) {
    this.data = data;
  }
  get(key) {
    const entry = this.data[key];
    if (!entry) {
      return;
    }
    return entry;
  }
  set(key, entry) {
    this.data[key] = entry;
    return entry;
  }
  delete(key) {
    delete this.data[key];
  }
  async purgeExpired() {
    const now = Date.now();
    if (this.lastPurgeTime + S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS > now) {
      return;
    }
    for (const key in this.data) {
      const entry = this.data[key];
      if (!entry.isRefreshing) {
        const credential = await entry.identity;
        if (credential.expiration) {
          if (credential.expiration.getTime() < now) {
            delete this.data[key];
          }
        }
      }
    }
  }
}

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityCacheEntry.js
class S3ExpressIdentityCacheEntry {
  _identity;
  isRefreshing;
  accessed;
  constructor(_identity, isRefreshing = false, accessed = Date.now()) {
    this._identity = _identity;
    this.isRefreshing = isRefreshing;
    this.accessed = accessed;
  }
  get identity() {
    this.accessed = Date.now();
    return this._identity;
  }
}

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/S3ExpressIdentityProviderImpl.js
class S3ExpressIdentityProviderImpl {
  createSessionFn;
  cache;
  static REFRESH_WINDOW_MS = 60000;
  constructor(createSessionFn, cache4 = new S3ExpressIdentityCache) {
    this.createSessionFn = createSessionFn;
    this.cache = cache4;
  }
  async getS3ExpressIdentity(awsIdentity, identityProperties) {
    const key = identityProperties.Bucket;
    const { cache: cache4 } = this;
    const entry = cache4.get(key);
    if (entry) {
      return entry.identity.then((identity) => {
        const isExpired = (identity.expiration?.getTime() ?? 0) < Date.now();
        if (isExpired) {
          return cache4.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
        }
        const isExpiringSoon = (identity.expiration?.getTime() ?? 0) < Date.now() + S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS;
        if (isExpiringSoon && !entry.isRefreshing) {
          entry.isRefreshing = true;
          this.getIdentity(key).then((id) => {
            cache4.set(key, new S3ExpressIdentityCacheEntry(Promise.resolve(id)));
          });
        }
        return identity;
      });
    }
    return cache4.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
  }
  async getIdentity(key) {
    await this.cache.purgeExpired().catch((error) => {
      console.warn(`Error while clearing expired entries in S3ExpressIdentityCache: 
` + error);
    });
    const session = await this.createSessionFn(key);
    if (!session.Credentials?.AccessKeyId || !session.Credentials?.SecretAccessKey) {
      throw new Error("s3#createSession response credential missing AccessKeyId or SecretAccessKey.");
    }
    const identity = {
      accessKeyId: session.Credentials.AccessKeyId,
      secretAccessKey: session.Credentials.SecretAccessKey,
      sessionToken: session.Credentials.SessionToken,
      expiration: session.Credentials.Expiration ? new Date(session.Credentials.Expiration) : undefined
    };
    return identity;
  }
}
// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/SignatureV4S3Express.js
var import_signature_v4 = __toESM(require_dist_cjs25(), 1);

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/constants.js
var import_util_config_provider = __toESM(require_dist_cjs32(), 1);
var S3_EXPRESS_BUCKET_TYPE = "Directory";
var S3_EXPRESS_BACKEND = "S3Express";
var S3_EXPRESS_AUTH_SCHEME = "sigv4-s3express";
var SESSION_TOKEN_QUERY_PARAM = "X-Amz-S3session-Token";
var SESSION_TOKEN_HEADER = SESSION_TOKEN_QUERY_PARAM.toLowerCase();
var NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_ENV_NAME = "AWS_S3_DISABLE_EXPRESS_SESSION_AUTH";
var NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_INI_NAME = "s3_disable_express_session_auth";
var NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS = {
  environmentVariableSelector: (env3) => import_util_config_provider.booleanSelector(env3, NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_ENV_NAME, import_util_config_provider.SelectorType.ENV),
  configFileSelector: (profile) => import_util_config_provider.booleanSelector(profile, NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_INI_NAME, import_util_config_provider.SelectorType.CONFIG),
  default: false
};

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/classes/SignatureV4S3Express.js
class SignatureV4S3Express extends import_signature_v4.SignatureV4 {
  async signWithCredentials(requestToSign, credentials, options) {
    const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
    requestToSign.headers[SESSION_TOKEN_HEADER] = credentials.sessionToken;
    const privateAccess = this;
    setSingleOverride(privateAccess, credentialsWithoutSessionToken);
    return privateAccess.signRequest(requestToSign, options ?? {});
  }
  async presignWithCredentials(requestToSign, credentials, options) {
    const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
    delete requestToSign.headers[SESSION_TOKEN_HEADER];
    requestToSign.headers[SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
    requestToSign.query = requestToSign.query ?? {};
    requestToSign.query[SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
    const privateAccess = this;
    setSingleOverride(privateAccess, credentialsWithoutSessionToken);
    return this.presign(requestToSign, options);
  }
}
function getCredentialsWithoutSessionToken(credentials) {
  const credentialsWithoutSessionToken = {
    accessKeyId: credentials.accessKeyId,
    secretAccessKey: credentials.secretAccessKey,
    expiration: credentials.expiration
  };
  return credentialsWithoutSessionToken;
}
function setSingleOverride(privateAccess, credentialsWithoutSessionToken) {
  const id = setTimeout(() => {
    throw new Error("SignatureV4S3Express credential override was created but not called.");
  }, 10);
  const currentCredentialProvider = privateAccess.credentialProvider;
  const overrideCredentialsProviderOnce = () => {
    clearTimeout(id);
    privateAccess.credentialProvider = currentCredentialProvider;
    return Promise.resolve(credentialsWithoutSessionToken);
  };
  privateAccess.credentialProvider = overrideCredentialsProviderOnce;
}
// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/s3ExpressMiddleware.js
var import_core35 = __toESM(require_dist_cjs30(), 1);
var import_protocol_http12 = __toESM(require_dist_cjs3(), 1);
var s3ExpressMiddleware = (options) => {
  return (next, context) => async (args) => {
    if (context.endpointV2) {
      const endpoint = context.endpointV2;
      const isS3ExpressAuth = endpoint.properties?.authSchemes?.[0]?.name === S3_EXPRESS_AUTH_SCHEME;
      const isS3ExpressBucket = endpoint.properties?.backend === S3_EXPRESS_BACKEND || endpoint.properties?.bucketType === S3_EXPRESS_BUCKET_TYPE;
      if (isS3ExpressBucket) {
        import_core35.setFeature(context, "S3_EXPRESS_BUCKET", "J");
        context.isS3ExpressBucket = true;
      }
      if (isS3ExpressAuth) {
        const requestBucket = args.input.Bucket;
        if (requestBucket) {
          const s3ExpressIdentity = await options.s3ExpressIdentityProvider.getS3ExpressIdentity(await options.credentials(), {
            Bucket: requestBucket
          });
          context.s3ExpressIdentity = s3ExpressIdentity;
          if (import_protocol_http12.HttpRequest.isInstance(args.request) && s3ExpressIdentity.sessionToken) {
            args.request.headers[SESSION_TOKEN_HEADER] = s3ExpressIdentity.sessionToken;
          }
        }
      }
    }
    return next(args);
  };
};
var s3ExpressMiddlewareOptions = {
  name: "s3ExpressMiddleware",
  step: "build",
  tags: ["S3", "S3_EXPRESS"],
  override: true
};
var getS3ExpressPlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(s3ExpressMiddleware(options), s3ExpressMiddlewareOptions);
  }
});
// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/s3ExpressHttpSigningMiddleware.js
var import_core36 = __toESM(require_dist_cjs19(), 1);
var import_protocol_http13 = __toESM(require_dist_cjs3(), 1);
var import_util_middleware5 = __toESM(require_dist_cjs2(), 1);

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/signS3Express.js
var signS3Express = async (s3ExpressIdentity, signingOptions, request2, sigV4MultiRegionSigner) => {
  const signedRequest = await sigV4MultiRegionSigner.signWithCredentials(request2, s3ExpressIdentity, {});
  if (signedRequest.headers["X-Amz-Security-Token"] || signedRequest.headers["x-amz-security-token"]) {
    throw new Error("X-Amz-Security-Token must not be set for s3-express requests.");
  }
  return signedRequest;
};

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3-express/functions/s3ExpressHttpSigningMiddleware.js
var defaultErrorHandler = (signingProperties) => (error) => {
  throw error;
};
var defaultSuccessHandler = (httpResponse, signingProperties) => {};
var s3ExpressHttpSigningMiddleware = (config) => (next, context) => async (args) => {
  if (!import_protocol_http13.HttpRequest.isInstance(args.request)) {
    return next(args);
  }
  const smithyContext = import_util_middleware5.getSmithyContext(context);
  const scheme = smithyContext.selectedHttpAuthScheme;
  if (!scheme) {
    throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
  }
  const { httpAuthOption: { signingProperties = {} }, identity, signer } = scheme;
  let request2;
  if (context.s3ExpressIdentity) {
    request2 = await signS3Express(context.s3ExpressIdentity, signingProperties, args.request, await config.signer());
  } else {
    request2 = await signer.sign(args.request, identity, signingProperties);
  }
  const output = await next({
    ...args,
    request: request2
  }).catch((signer.errorHandler || defaultErrorHandler)(signingProperties));
  (signer.successHandler || defaultSuccessHandler)(output.response, signingProperties);
  return output;
};
var getS3ExpressHttpSigningPlugin = (config) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(s3ExpressHttpSigningMiddleware(config), import_core36.httpSigningMiddlewareOptions);
  }
});
// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/s3Configuration.js
var resolveS3Config = (input, { session }) => {
  const [s3ClientProvider, CreateSessionCommandCtor] = session;
  const { forcePathStyle, useAccelerateEndpoint, disableMultiregionAccessPoints, followRegionRedirects, s3ExpressIdentityProvider, bucketEndpoint } = input;
  return Object.assign(input, {
    forcePathStyle: forcePathStyle ?? false,
    useAccelerateEndpoint: useAccelerateEndpoint ?? false,
    disableMultiregionAccessPoints: disableMultiregionAccessPoints ?? false,
    followRegionRedirects: followRegionRedirects ?? false,
    s3ExpressIdentityProvider: s3ExpressIdentityProvider ?? new S3ExpressIdentityProviderImpl(async (key) => s3ClientProvider().send(new CreateSessionCommandCtor({
      Bucket: key
    }))),
    bucketEndpoint: bucketEndpoint ?? false
  });
};

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/throw-200-exceptions.js
var import_protocol_http14 = __toESM(require_dist_cjs3(), 1);
var import_util_stream4 = __toESM(require_dist_cjs17(), 1);
var THROW_IF_EMPTY_BODY = {
  CopyObjectCommand: true,
  UploadPartCopyCommand: true,
  CompleteMultipartUploadCommand: true
};
var MAX_BYTES_TO_INSPECT = 3000;
var throw200ExceptionsMiddleware = (config) => (next, context) => async (args) => {
  const result = await next(args);
  const { response } = result;
  if (!import_protocol_http14.HttpResponse.isInstance(response)) {
    return result;
  }
  const { statusCode, body: sourceBody } = response;
  if (statusCode < 200 || statusCode >= 300) {
    return result;
  }
  const isSplittableStream = typeof sourceBody?.stream === "function" || typeof sourceBody?.pipe === "function" || typeof sourceBody?.tee === "function";
  if (!isSplittableStream) {
    return result;
  }
  let bodyCopy = sourceBody;
  let body = sourceBody;
  if (sourceBody && typeof sourceBody === "object" && !(sourceBody instanceof Uint8Array)) {
    [bodyCopy, body] = await import_util_stream4.splitStream(sourceBody);
  }
  response.body = body;
  const bodyBytes = await collectBody4(bodyCopy, {
    streamCollector: async (stream) => {
      return import_util_stream4.headStream(stream, MAX_BYTES_TO_INSPECT);
    }
  });
  if (typeof bodyCopy?.destroy === "function") {
    bodyCopy.destroy();
  }
  const bodyStringTail = config.utf8Encoder(bodyBytes.subarray(bodyBytes.length - 16));
  if (bodyBytes.length === 0 && THROW_IF_EMPTY_BODY[context.commandName]) {
    const err3 = new Error("S3 aborted request");
    err3.name = "InternalError";
    throw err3;
  }
  if (bodyStringTail && bodyStringTail.endsWith("</Error>")) {
    response.statusCode = 400;
  }
  return result;
};
var collectBody4 = (streamBody = new Uint8Array, context) => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array);
};
var throw200ExceptionsMiddlewareOptions = {
  relation: "after",
  toMiddleware: "deserializerMiddleware",
  tags: ["THROW_200_EXCEPTIONS", "S3"],
  name: "throw200ExceptionsMiddleware",
  override: true
};
var getThrow200ExceptionsPlugin = (config) => ({
  applyToStack: (clientStack) => {
    clientStack.addRelativeTo(throw200ExceptionsMiddleware(config), throw200ExceptionsMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/util-arn-parser/dist-es/index.js
var validate = (str) => typeof str === "string" && str.indexOf("arn:") === 0 && str.split(":").length >= 6;

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/bucket-endpoint-middleware.js
function bucketEndpointMiddleware(options) {
  return (next, context) => async (args) => {
    if (options.bucketEndpoint) {
      const endpoint = context.endpointV2;
      if (endpoint) {
        const bucket = args.input.Bucket;
        if (typeof bucket === "string") {
          try {
            const bucketEndpointUrl = new URL(bucket);
            context.endpointV2 = {
              ...endpoint,
              url: bucketEndpointUrl
            };
          } catch (e4) {
            const warning = `@aws-sdk/middleware-sdk-s3: bucketEndpoint=true was set but Bucket=${bucket} could not be parsed as URL.`;
            if (context.logger?.constructor?.name === "NoOpLogger") {
              console.warn(warning);
            } else {
              context.logger?.warn?.(warning);
            }
            throw e4;
          }
        }
      }
    }
    return next(args);
  };
}
var bucketEndpointMiddlewareOptions = {
  name: "bucketEndpointMiddleware",
  override: true,
  relation: "after",
  toMiddleware: "endpointV2Middleware"
};

// node_modules/@aws-sdk/middleware-sdk-s3/dist-es/validate-bucket-name.js
function validateBucketNameMiddleware({ bucketEndpoint }) {
  return (next) => async (args) => {
    const { input: { Bucket } } = args;
    if (!bucketEndpoint && typeof Bucket === "string" && !validate(Bucket) && Bucket.indexOf("/") >= 0) {
      const err3 = new Error(`Bucket name shouldn't contain '/', received '${Bucket}'`);
      err3.name = "InvalidBucketName";
      throw err3;
    }
    return next({ ...args });
  };
}
var validateBucketNameMiddlewareOptions = {
  step: "initialize",
  tags: ["VALIDATE_BUCKET_NAME"],
  name: "validateBucketNameMiddleware",
  override: true
};
var getValidateBucketNamePlugin = (options) => ({
  applyToStack: (clientStack) => {
    clientStack.add(validateBucketNameMiddleware(options), validateBucketNameMiddlewareOptions);
    clientStack.addRelativeTo(bucketEndpointMiddleware(options), bucketEndpointMiddlewareOptions);
  }
});

// node_modules/@aws-sdk/client-s3/dist-es/S3Client.js
var import_middleware_user_agent4 = __toESM(require_dist_cjs31(), 1);
var import_config_resolver8 = __toESM(require_dist_cjs33(), 1);
var import_core42 = __toESM(require_dist_cjs19(), 1);

// node_modules/@smithy/eventstream-serde-config-resolver/dist-es/EventStreamSerdeConfig.js
var resolveEventStreamSerdeConfig = (input) => Object.assign(input, {
  eventStreamMarshaller: input.eventStreamSerdeProvider(input)
});

// node_modules/@aws-sdk/client-s3/dist-es/S3Client.js
var import_middleware_content_length4 = __toESM(require_dist_cjs34(), 1);
var import_middleware_endpoint68 = __toESM(require_dist_cjs37(), 1);
var import_middleware_retry8 = __toESM(require_dist_cjs40(), 1);
var import_smithy_client102 = __toESM(require_dist_cjs28(), 1);

// node_modules/@aws-sdk/client-s3/dist-es/auth/httpAuthSchemeProvider.js
var import_core37 = __toESM(require_dist_cjs30(), 1);

// node_modules/@aws-sdk/signature-v4-multi-region/dist-es/SignatureV4MultiRegion.js
var import_signature_v42 = __toESM(require_dist_cjs25(), 1);

// node_modules/@aws-sdk/signature-v4-multi-region/dist-es/signature-v4-crt-container.js
var signatureV4CrtContainer = {
  CrtSignerV4: null
};

// node_modules/@aws-sdk/signature-v4-multi-region/dist-es/SignatureV4MultiRegion.js
class SignatureV4MultiRegion {
  sigv4aSigner;
  sigv4Signer;
  signerOptions;
  static sigv4aDependency() {
    if (typeof signatureV4CrtContainer.CrtSignerV4 === "function") {
      return "crt";
    } else if (typeof import_signature_v42.signatureV4aContainer.SignatureV4a === "function") {
      return "js";
    }
    return "none";
  }
  constructor(options) {
    this.sigv4Signer = new SignatureV4S3Express(options);
    this.signerOptions = options;
  }
  async sign(requestToSign, options = {}) {
    if (options.signingRegion === "*") {
      return this.getSigv4aSigner().sign(requestToSign, options);
    }
    return this.sigv4Signer.sign(requestToSign, options);
  }
  async signWithCredentials(requestToSign, credentials, options = {}) {
    if (options.signingRegion === "*") {
      const signer = this.getSigv4aSigner();
      const CrtSignerV4 = signatureV4CrtContainer.CrtSignerV4;
      if (CrtSignerV4 && signer instanceof CrtSignerV4) {
        return signer.signWithCredentials(requestToSign, credentials, options);
      } else {
        throw new Error(`signWithCredentials with signingRegion '*' is only supported when using the CRT dependency @aws-sdk/signature-v4-crt. ` + `Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. ` + `You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] ` + `or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. ` + `For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`);
      }
    }
    return this.sigv4Signer.signWithCredentials(requestToSign, credentials, options);
  }
  async presign(originalRequest, options = {}) {
    if (options.signingRegion === "*") {
      const signer = this.getSigv4aSigner();
      const CrtSignerV4 = signatureV4CrtContainer.CrtSignerV4;
      if (CrtSignerV4 && signer instanceof CrtSignerV4) {
        return signer.presign(originalRequest, options);
      } else {
        throw new Error(`presign with signingRegion '*' is only supported when using the CRT dependency @aws-sdk/signature-v4-crt. ` + `Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. ` + `You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] ` + `or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. ` + `For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`);
      }
    }
    return this.sigv4Signer.presign(originalRequest, options);
  }
  async presignWithCredentials(originalRequest, credentials, options = {}) {
    if (options.signingRegion === "*") {
      throw new Error("Method presignWithCredentials is not supported for [signingRegion=*].");
    }
    return this.sigv4Signer.presignWithCredentials(originalRequest, credentials, options);
  }
  getSigv4aSigner() {
    if (!this.sigv4aSigner) {
      const CrtSignerV4 = signatureV4CrtContainer.CrtSignerV4;
      const JsSigV4aSigner = import_signature_v42.signatureV4aContainer.SignatureV4a;
      if (this.signerOptions.runtime === "node") {
        if (!CrtSignerV4 && !JsSigV4aSigner) {
          throw new Error("Neither CRT nor JS SigV4a implementation is available. " + "Please load either @aws-sdk/signature-v4-crt or @aws-sdk/signature-v4a. " + "For more information please go to " + "https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt");
        }
        if (CrtSignerV4 && typeof CrtSignerV4 === "function") {
          this.sigv4aSigner = new CrtSignerV4({
            ...this.signerOptions,
            signingAlgorithm: 1
          });
        } else if (JsSigV4aSigner && typeof JsSigV4aSigner === "function") {
          this.sigv4aSigner = new JsSigV4aSigner({
            ...this.signerOptions
          });
        } else {
          throw new Error("Available SigV4a implementation is not a valid constructor. " + "Please ensure you've properly imported @aws-sdk/signature-v4-crt or @aws-sdk/signature-v4a." + "For more information please go to " + "https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt");
        }
      } else {
        if (!JsSigV4aSigner || typeof JsSigV4aSigner !== "function") {
          throw new Error("JS SigV4a implementation is not available or not a valid constructor. " + "Please check whether you have installed the @aws-sdk/signature-v4a package explicitly. The CRT implementation is not available for browsers. " + "You must also register the package by calling [require('@aws-sdk/signature-v4a');] " + "or an ESM equivalent such as [import '@aws-sdk/signature-v4a';]. " + "For more information please go to " + "https://github.com/aws/aws-sdk-js-v3#using-javascript-non-crt-implementation-of-sigv4a");
        }
        this.sigv4aSigner = new JsSigV4aSigner({
          ...this.signerOptions
        });
      }
    }
    return this.sigv4aSigner;
  }
}

// node_modules/@aws-sdk/client-s3/dist-es/auth/httpAuthSchemeProvider.js
var import_middleware_endpoint66 = __toESM(require_dist_cjs37(), 1);
var import_util_middleware6 = __toESM(require_dist_cjs2(), 1);

// node_modules/@aws-sdk/client-s3/dist-es/endpoint/endpointResolver.js
var import_util_endpoints7 = __toESM(require_dist_cjs23(), 1);
var import_util_endpoints8 = __toESM(require_dist_cjs20(), 1);

// node_modules/@aws-sdk/client-s3/dist-es/endpoint/ruleset.js
var cp = "required";
var cq = "type";
var cr = "rules";
var cs = "conditions";
var ct = "fn";
var cu = "argv";
var cv = "ref";
var cw = "assign";
var cx = "url";
var cy = "properties";
var cz = "backend";
var cA = "authSchemes";
var cB = "disableDoubleEncoding";
var cC = "signingName";
var cD = "signingRegion";
var cE = "headers";
var cF = "signingRegionSet";
var a4 = 6;
var b4 = false;
var c4 = true;
var d4 = "isSet";
var e4 = "booleanEquals";
var f4 = "error";
var g4 = "aws.partition";
var h4 = "stringEquals";
var i5 = "getAttr";
var j4 = "name";
var k5 = "substring";
var l4 = "bucketSuffix";
var m4 = "parseURL";
var n4 = "endpoint";
var o4 = "tree";
var p4 = "aws.isVirtualHostableS3Bucket";
var q4 = "{url#scheme}://{Bucket}.{url#authority}{url#path}";
var r4 = "not";
var s4 = "accessPointSuffix";
var t5 = "{url#scheme}://{url#authority}{url#path}";
var u4 = "hardwareType";
var v4 = "regionPrefix";
var w4 = "bucketAliasSuffix";
var x5 = "outpostId";
var y3 = "isValidHostLabel";
var z3 = "sigv4a";
var A2 = "s3-outposts";
var B2 = "s3";
var C2 = "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}";
var D2 = "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}";
var E2 = "https://{Bucket}.s3.{partitionResult#dnsSuffix}";
var F2 = "aws.parseArn";
var G2 = "bucketArn";
var H2 = "arnType";
var I2 = "";
var J2 = "s3-object-lambda";
var K2 = "accesspoint";
var L2 = "accessPointName";
var M2 = "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}";
var N2 = "mrapPartition";
var O2 = "outpostType";
var P2 = "arnPrefix";
var Q2 = "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}";
var R2 = "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}";
var S2 = "https://s3.{partitionResult#dnsSuffix}";
var T3 = { [cp]: false, [cq]: "String" };
var U2 = { [cp]: true, default: false, [cq]: "Boolean" };
var V2 = { [cp]: false, [cq]: "Boolean" };
var W = { [ct]: e4, [cu]: [{ [cv]: "Accelerate" }, true] };
var X = { [ct]: e4, [cu]: [{ [cv]: "UseFIPS" }, true] };
var Y2 = { [ct]: e4, [cu]: [{ [cv]: "UseDualStack" }, true] };
var Z = { [ct]: d4, [cu]: [{ [cv]: "Endpoint" }] };
var aa = { [ct]: g4, [cu]: [{ [cv]: "Region" }], [cw]: "partitionResult" };
var ab = { [ct]: h4, [cu]: [{ [ct]: i5, [cu]: [{ [cv]: "partitionResult" }, j4] }, "aws-cn"] };
var ac = { [ct]: d4, [cu]: [{ [cv]: "Bucket" }] };
var ad = { [cv]: "Bucket" };
var ae = { [cs]: [Y2], [f4]: "S3Express does not support Dual-stack.", [cq]: f4 };
var af = { [cs]: [W], [f4]: "S3Express does not support S3 Accelerate.", [cq]: f4 };
var ag = { [cs]: [Z, { [ct]: m4, [cu]: [{ [cv]: "Endpoint" }], [cw]: "url" }], [cr]: [{ [cs]: [{ [ct]: d4, [cu]: [{ [cv]: "DisableS3ExpressSessionAuth" }] }, { [ct]: e4, [cu]: [{ [cv]: "DisableS3ExpressSessionAuth" }, true] }], [cr]: [{ [cs]: [{ [ct]: e4, [cu]: [{ [ct]: i5, [cu]: [{ [cv]: "url" }, "isIp"] }, true] }], [cr]: [{ [cs]: [{ [ct]: "uriEncode", [cu]: [ad], [cw]: "uri_encoded_bucket" }], [cr]: [{ [n4]: { [cx]: "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}", [cy]: { [cz]: "S3Express", [cA]: [{ [cB]: true, [j4]: "sigv4", [cC]: "s3express", [cD]: "{Region}" }] }, [cE]: {} }, [cq]: n4 }], [cq]: o4 }], [cq]: o4 }, { [cs]: [{ [ct]: p4, [cu]: [ad, false] }], [cr]: [{ [n4]: { [cx]: q4, [cy]: { [cz]: "S3Express", [cA]: [{ [cB]: true, [j4]: "sigv4", [cC]: "s3express", [cD]: "{Region}" }] }, [cE]: {} }, [cq]: n4 }], [cq]: o4 }, { [f4]: "S3Express bucket name is not a valid virtual hostable name.", [cq]: f4 }], [cq]: o4 }, { [cs]: [{ [ct]: e4, [cu]: [{ [ct]: i5, [cu]: [{ [cv]: "url" }, "isIp"] }, true] }], [cr]: [{ [cs]: [{ [ct]: "uriEncode", [cu]: [ad], [cw]: "uri_encoded_bucket" }], [cr]: [{ [n4]: { [cx]: "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}", [cy]: { [cz]: "S3Express", [cA]: [{ [cB]: true, [j4]: "sigv4-s3express", [cC]: "s3express", [cD]: "{Region}" }] }, [cE]: {} }, [cq]: n4 }], [cq]: o4 }], [cq]: o4 }, { [cs]: [{ [ct]: p4, [cu]: [ad, false] }], [cr]: [{ [n4]: { [cx]: q4, [cy]: { [cz]: "S3Express", [cA]: [{ [cB]: true, [j4]: "sigv4-s3express", [cC]: "s3express", [cD]: "{Region}" }] }, [cE]: {} }, [cq]: n4 }], [cq]: o4 }, { [f4]: "S3Express bucket name is not a valid virtual hostable name.", [cq]: f4 }], [cq]: o4 };
var ah = { [ct]: m4, [cu]: [{ [cv]: "Endpoint" }], [cw]: "url" };
var ai = { [ct]: e4, [cu]: [{ [ct]: i5, [cu]: [{ [cv]: "url" }, "isIp"] }, true] };
var aj = { [cv]: "url" };
var ak = { [ct]: "uriEncode", [cu]: [ad], [cw]: "uri_encoded_bucket" };
var al = { [cz]: "S3Express", [cA]: [{ [cB]: true, [j4]: "sigv4", [cC]: "s3express", [cD]: "{Region}" }] };
var am = {};
var an = { [ct]: p4, [cu]: [ad, false] };
var ao = { [f4]: "S3Express bucket name is not a valid virtual hostable name.", [cq]: f4 };
var ap = { [ct]: d4, [cu]: [{ [cv]: "UseS3ExpressControlEndpoint" }] };
var aq = { [ct]: e4, [cu]: [{ [cv]: "UseS3ExpressControlEndpoint" }, true] };
var ar = { [ct]: r4, [cu]: [Z] };
var as = { [f4]: "Unrecognized S3Express bucket name format.", [cq]: f4 };
var at = { [ct]: r4, [cu]: [ac] };
var au = { [cv]: u4 };
var av = { [cs]: [ar], [f4]: "Expected a endpoint to be specified but no endpoint was found", [cq]: f4 };
var aw = { [cA]: [{ [cB]: true, [j4]: z3, [cC]: A2, [cF]: ["*"] }, { [cB]: true, [j4]: "sigv4", [cC]: A2, [cD]: "{Region}" }] };
var ax = { [ct]: e4, [cu]: [{ [cv]: "ForcePathStyle" }, false] };
var ay = { [cv]: "ForcePathStyle" };
var az = { [ct]: e4, [cu]: [{ [cv]: "Accelerate" }, false] };
var aA = { [ct]: h4, [cu]: [{ [cv]: "Region" }, "aws-global"] };
var aB = { [cA]: [{ [cB]: true, [j4]: "sigv4", [cC]: B2, [cD]: "us-east-1" }] };
var aC = { [ct]: r4, [cu]: [aA] };
var aD = { [ct]: e4, [cu]: [{ [cv]: "UseGlobalEndpoint" }, true] };
var aE = { [cx]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cy]: { [cA]: [{ [cB]: true, [j4]: "sigv4", [cC]: B2, [cD]: "{Region}" }] }, [cE]: {} };
var aF = { [cA]: [{ [cB]: true, [j4]: "sigv4", [cC]: B2, [cD]: "{Region}" }] };
var aG = { [ct]: e4, [cu]: [{ [cv]: "UseGlobalEndpoint" }, false] };
var aH = { [ct]: e4, [cu]: [{ [cv]: "UseDualStack" }, false] };
var aI = { [cx]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}", [cy]: aF, [cE]: {} };
var aJ = { [ct]: e4, [cu]: [{ [cv]: "UseFIPS" }, false] };
var aK = { [cx]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}", [cy]: aF, [cE]: {} };
var aL = { [cx]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cy]: aF, [cE]: {} };
var aM = { [ct]: e4, [cu]: [{ [ct]: i5, [cu]: [aj, "isIp"] }, false] };
var aN = { [cx]: C2, [cy]: aF, [cE]: {} };
var aO = { [cx]: q4, [cy]: aF, [cE]: {} };
var aP = { [n4]: aO, [cq]: n4 };
var aQ = { [cx]: D2, [cy]: aF, [cE]: {} };
var aR = { [cx]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}", [cy]: aF, [cE]: {} };
var aS = { [f4]: "Invalid region: region was not a valid DNS name.", [cq]: f4 };
var aT = { [cv]: G2 };
var aU = { [cv]: H2 };
var aV = { [ct]: i5, [cu]: [aT, "service"] };
var aW = { [cv]: L2 };
var aX = { [cs]: [Y2], [f4]: "S3 Object Lambda does not support Dual-stack", [cq]: f4 };
var aY = { [cs]: [W], [f4]: "S3 Object Lambda does not support S3 Accelerate", [cq]: f4 };
var aZ = { [cs]: [{ [ct]: d4, [cu]: [{ [cv]: "DisableAccessPoints" }] }, { [ct]: e4, [cu]: [{ [cv]: "DisableAccessPoints" }, true] }], [f4]: "Access points are not supported for this operation", [cq]: f4 };
var ba = { [cs]: [{ [ct]: d4, [cu]: [{ [cv]: "UseArnRegion" }] }, { [ct]: e4, [cu]: [{ [cv]: "UseArnRegion" }, false] }, { [ct]: r4, [cu]: [{ [ct]: h4, [cu]: [{ [ct]: i5, [cu]: [aT, "region"] }, "{Region}"] }] }], [f4]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`", [cq]: f4 };
var bb = { [ct]: i5, [cu]: [{ [cv]: "bucketPartition" }, j4] };
var bc = { [ct]: i5, [cu]: [aT, "accountId"] };
var bd = { [cA]: [{ [cB]: true, [j4]: "sigv4", [cC]: J2, [cD]: "{bucketArn#region}" }] };
var be = { [f4]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`", [cq]: f4 };
var bf = { [f4]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`", [cq]: f4 };
var bg = { [f4]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)", [cq]: f4 };
var bh = { [f4]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`", [cq]: f4 };
var bi = { [f4]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.", [cq]: f4 };
var bj = { [f4]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided", [cq]: f4 };
var bk = { [cA]: [{ [cB]: true, [j4]: "sigv4", [cC]: B2, [cD]: "{bucketArn#region}" }] };
var bl = { [cA]: [{ [cB]: true, [j4]: z3, [cC]: A2, [cF]: ["*"] }, { [cB]: true, [j4]: "sigv4", [cC]: A2, [cD]: "{bucketArn#region}" }] };
var bm = { [ct]: F2, [cu]: [ad] };
var bn = { [cx]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cy]: aF, [cE]: {} };
var bo = { [cx]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cy]: aF, [cE]: {} };
var bp = { [cx]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cy]: aF, [cE]: {} };
var bq = { [cx]: Q2, [cy]: aF, [cE]: {} };
var br = { [cx]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cy]: aF, [cE]: {} };
var bs = { [cv]: "UseObjectLambdaEndpoint" };
var bt = { [cA]: [{ [cB]: true, [j4]: "sigv4", [cC]: J2, [cD]: "{Region}" }] };
var bu = { [cx]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cy]: aF, [cE]: {} };
var bv = { [cx]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}", [cy]: aF, [cE]: {} };
var bw = { [cx]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cy]: aF, [cE]: {} };
var bx = { [cx]: t5, [cy]: aF, [cE]: {} };
var by = { [cx]: "https://s3.{Region}.{partitionResult#dnsSuffix}", [cy]: aF, [cE]: {} };
var bz = [{ [cv]: "Region" }];
var bA = [{ [cv]: "Endpoint" }];
var bB = [ad];
var bC = [Y2];
var bD = [W];
var bE = [Z, ah];
var bF = [{ [ct]: d4, [cu]: [{ [cv]: "DisableS3ExpressSessionAuth" }] }, { [ct]: e4, [cu]: [{ [cv]: "DisableS3ExpressSessionAuth" }, true] }];
var bG = [ak];
var bH = [an];
var bI = [aa];
var bJ = [X];
var bK = [{ [ct]: k5, [cu]: [ad, 6, 14, true], [cw]: "s3expressAvailabilityZoneId" }, { [ct]: k5, [cu]: [ad, 14, 16, true], [cw]: "s3expressAvailabilityZoneDelim" }, { [ct]: h4, [cu]: [{ [cv]: "s3expressAvailabilityZoneDelim" }, "--"] }];
var bL = [{ [cs]: [X], [n4]: { [cx]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}", [cy]: al, [cE]: {} }, [cq]: n4 }, { [n4]: { [cx]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}", [cy]: al, [cE]: {} }, [cq]: n4 }];
var bM = [{ [ct]: k5, [cu]: [ad, 6, 15, true], [cw]: "s3expressAvailabilityZoneId" }, { [ct]: k5, [cu]: [ad, 15, 17, true], [cw]: "s3expressAvailabilityZoneDelim" }, { [ct]: h4, [cu]: [{ [cv]: "s3expressAvailabilityZoneDelim" }, "--"] }];
var bN = [{ [ct]: k5, [cu]: [ad, 6, 19, true], [cw]: "s3expressAvailabilityZoneId" }, { [ct]: k5, [cu]: [ad, 19, 21, true], [cw]: "s3expressAvailabilityZoneDelim" }, { [ct]: h4, [cu]: [{ [cv]: "s3expressAvailabilityZoneDelim" }, "--"] }];
var bO = [{ [ct]: k5, [cu]: [ad, 6, 20, true], [cw]: "s3expressAvailabilityZoneId" }, { [ct]: k5, [cu]: [ad, 20, 22, true], [cw]: "s3expressAvailabilityZoneDelim" }, { [ct]: h4, [cu]: [{ [cv]: "s3expressAvailabilityZoneDelim" }, "--"] }];
var bP = [{ [ct]: k5, [cu]: [ad, 6, 26, true], [cw]: "s3expressAvailabilityZoneId" }, { [ct]: k5, [cu]: [ad, 26, 28, true], [cw]: "s3expressAvailabilityZoneDelim" }, { [ct]: h4, [cu]: [{ [cv]: "s3expressAvailabilityZoneDelim" }, "--"] }];
var bQ = [{ [cs]: [X], [n4]: { [cx]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}", [cy]: { [cz]: "S3Express", [cA]: [{ [cB]: true, [j4]: "sigv4-s3express", [cC]: "s3express", [cD]: "{Region}" }] }, [cE]: {} }, [cq]: n4 }, { [n4]: { [cx]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}", [cy]: { [cz]: "S3Express", [cA]: [{ [cB]: true, [j4]: "sigv4-s3express", [cC]: "s3express", [cD]: "{Region}" }] }, [cE]: {} }, [cq]: n4 }];
var bR = [ad, 0, 7, true];
var bS = [{ [ct]: k5, [cu]: [ad, 7, 15, true], [cw]: "s3expressAvailabilityZoneId" }, { [ct]: k5, [cu]: [ad, 15, 17, true], [cw]: "s3expressAvailabilityZoneDelim" }, { [ct]: h4, [cu]: [{ [cv]: "s3expressAvailabilityZoneDelim" }, "--"] }];
var bT = [{ [ct]: k5, [cu]: [ad, 7, 16, true], [cw]: "s3expressAvailabilityZoneId" }, { [ct]: k5, [cu]: [ad, 16, 18, true], [cw]: "s3expressAvailabilityZoneDelim" }, { [ct]: h4, [cu]: [{ [cv]: "s3expressAvailabilityZoneDelim" }, "--"] }];
var bU = [{ [ct]: k5, [cu]: [ad, 7, 20, true], [cw]: "s3expressAvailabilityZoneId" }, { [ct]: k5, [cu]: [ad, 20, 22, true], [cw]: "s3expressAvailabilityZoneDelim" }, { [ct]: h4, [cu]: [{ [cv]: "s3expressAvailabilityZoneDelim" }, "--"] }];
var bV = [{ [ct]: k5, [cu]: [ad, 7, 21, true], [cw]: "s3expressAvailabilityZoneId" }, { [ct]: k5, [cu]: [ad, 21, 23, true], [cw]: "s3expressAvailabilityZoneDelim" }, { [ct]: h4, [cu]: [{ [cv]: "s3expressAvailabilityZoneDelim" }, "--"] }];
var bW = [{ [ct]: k5, [cu]: [ad, 7, 27, true], [cw]: "s3expressAvailabilityZoneId" }, { [ct]: k5, [cu]: [ad, 27, 29, true], [cw]: "s3expressAvailabilityZoneDelim" }, { [ct]: h4, [cu]: [{ [cv]: "s3expressAvailabilityZoneDelim" }, "--"] }];
var bX = [ac];
var bY = [{ [ct]: y3, [cu]: [{ [cv]: x5 }, false] }];
var bZ = [{ [ct]: h4, [cu]: [{ [cv]: v4 }, "beta"] }];
var ca = ["*"];
var cb = [{ [ct]: y3, [cu]: [{ [cv]: "Region" }, false] }];
var cc = [{ [ct]: h4, [cu]: [{ [cv]: "Region" }, "us-east-1"] }];
var cd = [{ [ct]: h4, [cu]: [aU, K2] }];
var ce = [{ [ct]: i5, [cu]: [aT, "resourceId[1]"], [cw]: L2 }, { [ct]: r4, [cu]: [{ [ct]: h4, [cu]: [aW, I2] }] }];
var cf = [aT, "resourceId[1]"];
var cg = [{ [ct]: r4, [cu]: [{ [ct]: h4, [cu]: [{ [ct]: i5, [cu]: [aT, "region"] }, I2] }] }];
var ch = [{ [ct]: r4, [cu]: [{ [ct]: d4, [cu]: [{ [ct]: i5, [cu]: [aT, "resourceId[2]"] }] }] }];
var ci = [aT, "resourceId[2]"];
var cj = [{ [ct]: g4, [cu]: [{ [ct]: i5, [cu]: [aT, "region"] }], [cw]: "bucketPartition" }];
var ck = [{ [ct]: h4, [cu]: [bb, { [ct]: i5, [cu]: [{ [cv]: "partitionResult" }, j4] }] }];
var cl = [{ [ct]: y3, [cu]: [{ [ct]: i5, [cu]: [aT, "region"] }, true] }];
var cm = [{ [ct]: y3, [cu]: [bc, false] }];
var cn = [{ [ct]: y3, [cu]: [aW, false] }];
var co = [{ [ct]: y3, [cu]: [{ [cv]: "Region" }, true] }];
var _data4 = { version: "1.0", parameters: { Bucket: T3, Region: T3, UseFIPS: U2, UseDualStack: U2, Endpoint: T3, ForcePathStyle: U2, Accelerate: U2, UseGlobalEndpoint: U2, UseObjectLambdaEndpoint: V2, Key: T3, Prefix: T3, CopySource: T3, DisableAccessPoints: V2, DisableMultiRegionAccessPoints: U2, UseArnRegion: V2, UseS3ExpressControlEndpoint: V2, DisableS3ExpressSessionAuth: V2 }, [cr]: [{ [cs]: [{ [ct]: d4, [cu]: bz }], [cr]: [{ [cs]: [W, X], error: "Accelerate cannot be used with FIPS", [cq]: f4 }, { [cs]: [Y2, Z], error: "Cannot set dual-stack in combination with a custom endpoint.", [cq]: f4 }, { [cs]: [Z, X], error: "A custom endpoint cannot be combined with FIPS", [cq]: f4 }, { [cs]: [Z, W], error: "A custom endpoint cannot be combined with S3 Accelerate", [cq]: f4 }, { [cs]: [X, aa, ab], error: "Partition does not support FIPS", [cq]: f4 }, { [cs]: [ac, { [ct]: k5, [cu]: [ad, 0, a4, c4], [cw]: l4 }, { [ct]: h4, [cu]: [{ [cv]: l4 }, "--x-s3"] }], [cr]: [ae, af, ag, { [cs]: [ap, aq], [cr]: [{ [cs]: bI, [cr]: [{ [cs]: [ak, ar], [cr]: [{ [cs]: bJ, endpoint: { [cx]: "https://s3express-control-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cy]: al, [cE]: am }, [cq]: n4 }, { endpoint: { [cx]: "https://s3express-control.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cy]: al, [cE]: am }, [cq]: n4 }], [cq]: o4 }], [cq]: o4 }], [cq]: o4 }, { [cs]: bH, [cr]: [{ [cs]: bI, [cr]: [{ [cs]: bF, [cr]: [{ [cs]: bK, [cr]: bL, [cq]: o4 }, { [cs]: bM, [cr]: bL, [cq]: o4 }, { [cs]: bN, [cr]: bL, [cq]: o4 }, { [cs]: bO, [cr]: bL, [cq]: o4 }, { [cs]: bP, [cr]: bL, [cq]: o4 }, as], [cq]: o4 }, { [cs]: bK, [cr]: bQ, [cq]: o4 }, { [cs]: bM, [cr]: bQ, [cq]: o4 }, { [cs]: bN, [cr]: bQ, [cq]: o4 }, { [cs]: bO, [cr]: bQ, [cq]: o4 }, { [cs]: bP, [cr]: bQ, [cq]: o4 }, as], [cq]: o4 }], [cq]: o4 }, ao], [cq]: o4 }, { [cs]: [ac, { [ct]: k5, [cu]: bR, [cw]: s4 }, { [ct]: h4, [cu]: [{ [cv]: s4 }, "--xa-s3"] }], [cr]: [ae, af, ag, { [cs]: bH, [cr]: [{ [cs]: bI, [cr]: [{ [cs]: bF, [cr]: [{ [cs]: bS, [cr]: bL, [cq]: o4 }, { [cs]: bT, [cr]: bL, [cq]: o4 }, { [cs]: bU, [cr]: bL, [cq]: o4 }, { [cs]: bV, [cr]: bL, [cq]: o4 }, { [cs]: bW, [cr]: bL, [cq]: o4 }, as], [cq]: o4 }, { [cs]: bS, [cr]: bQ, [cq]: o4 }, { [cs]: bT, [cr]: bQ, [cq]: o4 }, { [cs]: bU, [cr]: bQ, [cq]: o4 }, { [cs]: bV, [cr]: bQ, [cq]: o4 }, { [cs]: bW, [cr]: bQ, [cq]: o4 }, as], [cq]: o4 }], [cq]: o4 }, ao], [cq]: o4 }, { [cs]: [at, ap, aq], [cr]: [{ [cs]: bI, [cr]: [{ [cs]: bE, endpoint: { [cx]: t5, [cy]: al, [cE]: am }, [cq]: n4 }, { [cs]: bJ, endpoint: { [cx]: "https://s3express-control-fips.{Region}.{partitionResult#dnsSuffix}", [cy]: al, [cE]: am }, [cq]: n4 }, { endpoint: { [cx]: "https://s3express-control.{Region}.{partitionResult#dnsSuffix}", [cy]: al, [cE]: am }, [cq]: n4 }], [cq]: o4 }], [cq]: o4 }, { [cs]: [ac, { [ct]: k5, [cu]: [ad, 49, 50, c4], [cw]: u4 }, { [ct]: k5, [cu]: [ad, 8, 12, c4], [cw]: v4 }, { [ct]: k5, [cu]: bR, [cw]: w4 }, { [ct]: k5, [cu]: [ad, 32, 49, c4], [cw]: x5 }, { [ct]: g4, [cu]: bz, [cw]: "regionPartition" }, { [ct]: h4, [cu]: [{ [cv]: w4 }, "--op-s3"] }], [cr]: [{ [cs]: bY, [cr]: [{ [cs]: [{ [ct]: h4, [cu]: [au, "e"] }], [cr]: [{ [cs]: bZ, [cr]: [av, { [cs]: bE, endpoint: { [cx]: "https://{Bucket}.ec2.{url#authority}", [cy]: aw, [cE]: am }, [cq]: n4 }], [cq]: o4 }, { endpoint: { [cx]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cy]: aw, [cE]: am }, [cq]: n4 }], [cq]: o4 }, { [cs]: [{ [ct]: h4, [cu]: [au, "o"] }], [cr]: [{ [cs]: bZ, [cr]: [av, { [cs]: bE, endpoint: { [cx]: "https://{Bucket}.op-{outpostId}.{url#authority}", [cy]: aw, [cE]: am }, [cq]: n4 }], [cq]: o4 }, { endpoint: { [cx]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cy]: aw, [cE]: am }, [cq]: n4 }], [cq]: o4 }, { error: 'Unrecognized hardware type: "Expected hardware type o or e but got {hardwareType}"', [cq]: f4 }], [cq]: o4 }, { error: "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.", [cq]: f4 }], [cq]: o4 }, { [cs]: bX, [cr]: [{ [cs]: [Z, { [ct]: r4, [cu]: [{ [ct]: d4, [cu]: [{ [ct]: m4, [cu]: bA }] }] }], error: "Custom endpoint `{Endpoint}` was not a valid URI", [cq]: f4 }, { [cs]: [ax, an], [cr]: [{ [cs]: bI, [cr]: [{ [cs]: cb, [cr]: [{ [cs]: [W, ab], error: "S3 Accelerate cannot be used in this region", [cq]: f4 }, { [cs]: [Y2, X, az, ar, aA], endpoint: { [cx]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cy]: aB, [cE]: am }, [cq]: n4 }, { [cs]: [Y2, X, az, ar, aC, aD], [cr]: [{ endpoint: aE, [cq]: n4 }], [cq]: o4 }, { [cs]: [Y2, X, az, ar, aC, aG], endpoint: aE, [cq]: n4 }, { [cs]: [aH, X, az, ar, aA], endpoint: { [cx]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cy]: aB, [cE]: am }, [cq]: n4 }, { [cs]: [aH, X, az, ar, aC, aD], [cr]: [{ endpoint: aI, [cq]: n4 }], [cq]: o4 }, { [cs]: [aH, X, az, ar, aC, aG], endpoint: aI, [cq]: n4 }, { [cs]: [Y2, aJ, W, ar, aA], endpoint: { [cx]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cy]: aB, [cE]: am }, [cq]: n4 }, { [cs]: [Y2, aJ, W, ar, aC, aD], [cr]: [{ endpoint: aK, [cq]: n4 }], [cq]: o4 }, { [cs]: [Y2, aJ, W, ar, aC, aG], endpoint: aK, [cq]: n4 }, { [cs]: [Y2, aJ, az, ar, aA], endpoint: { [cx]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cy]: aB, [cE]: am }, [cq]: n4 }, { [cs]: [Y2, aJ, az, ar, aC, aD], [cr]: [{ endpoint: aL, [cq]: n4 }], [cq]: o4 }, { [cs]: [Y2, aJ, az, ar, aC, aG], endpoint: aL, [cq]: n4 }, { [cs]: [aH, aJ, az, Z, ah, ai, aA], endpoint: { [cx]: C2, [cy]: aB, [cE]: am }, [cq]: n4 }, { [cs]: [aH, aJ, az, Z, ah, aM, aA], endpoint: { [cx]: q4, [cy]: aB, [cE]: am }, [cq]: n4 }, { [cs]: [aH, aJ, az, Z, ah, ai, aC, aD], [cr]: [{ [cs]: cc, endpoint: aN, [cq]: n4 }, { endpoint: aN, [cq]: n4 }], [cq]: o4 }, { [cs]: [aH, aJ, az, Z, ah, aM, aC, aD], [cr]: [{ [cs]: cc, endpoint: aO, [cq]: n4 }, aP], [cq]: o4 }, { [cs]: [aH, aJ, az, Z, ah, ai, aC, aG], endpoint: aN, [cq]: n4 }, { [cs]: [aH, aJ, az, Z, ah, aM, aC, aG], endpoint: aO, [cq]: n4 }, { [cs]: [aH, aJ, W, ar, aA], endpoint: { [cx]: D2, [cy]: aB, [cE]: am }, [cq]: n4 }, { [cs]: [aH, aJ, W, ar, aC, aD], [cr]: [{ [cs]: cc, endpoint: aQ, [cq]: n4 }, { endpoint: aQ, [cq]: n4 }], [cq]: o4 }, { [cs]: [aH, aJ, W, ar, aC, aG], endpoint: aQ, [cq]: n4 }, { [cs]: [aH, aJ, az, ar, aA], endpoint: { [cx]: E2, [cy]: aB, [cE]: am }, [cq]: n4 }, { [cs]: [aH, aJ, az, ar, aC, aD], [cr]: [{ [cs]: cc, endpoint: { [cx]: E2, [cy]: aF, [cE]: am }, [cq]: n4 }, { endpoint: aR, [cq]: n4 }], [cq]: o4 }, { [cs]: [aH, aJ, az, ar, aC, aG], endpoint: aR, [cq]: n4 }], [cq]: o4 }, aS], [cq]: o4 }], [cq]: o4 }, { [cs]: [Z, ah, { [ct]: h4, [cu]: [{ [ct]: i5, [cu]: [aj, "scheme"] }, "http"] }, { [ct]: p4, [cu]: [ad, c4] }, ax, aJ, aH, az], [cr]: [{ [cs]: bI, [cr]: [{ [cs]: cb, [cr]: [aP], [cq]: o4 }, aS], [cq]: o4 }], [cq]: o4 }, { [cs]: [ax, { [ct]: F2, [cu]: bB, [cw]: G2 }], [cr]: [{ [cs]: [{ [ct]: i5, [cu]: [aT, "resourceId[0]"], [cw]: H2 }, { [ct]: r4, [cu]: [{ [ct]: h4, [cu]: [aU, I2] }] }], [cr]: [{ [cs]: [{ [ct]: h4, [cu]: [aV, J2] }], [cr]: [{ [cs]: cd, [cr]: [{ [cs]: ce, [cr]: [aX, aY, { [cs]: cg, [cr]: [aZ, { [cs]: ch, [cr]: [ba, { [cs]: cj, [cr]: [{ [cs]: bI, [cr]: [{ [cs]: ck, [cr]: [{ [cs]: cl, [cr]: [{ [cs]: [{ [ct]: h4, [cu]: [bc, I2] }], error: "Invalid ARN: Missing account id", [cq]: f4 }, { [cs]: cm, [cr]: [{ [cs]: cn, [cr]: [{ [cs]: bE, endpoint: { [cx]: M2, [cy]: bd, [cE]: am }, [cq]: n4 }, { [cs]: bJ, endpoint: { [cx]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cy]: bd, [cE]: am }, [cq]: n4 }, { endpoint: { [cx]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cy]: bd, [cE]: am }, [cq]: n4 }], [cq]: o4 }, be], [cq]: o4 }, bf], [cq]: o4 }, bg], [cq]: o4 }, bh], [cq]: o4 }], [cq]: o4 }], [cq]: o4 }, bi], [cq]: o4 }, { error: "Invalid ARN: bucket ARN is missing a region", [cq]: f4 }], [cq]: o4 }, bj], [cq]: o4 }, { error: "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`", [cq]: f4 }], [cq]: o4 }, { [cs]: cd, [cr]: [{ [cs]: ce, [cr]: [{ [cs]: cg, [cr]: [{ [cs]: cd, [cr]: [{ [cs]: cg, [cr]: [aZ, { [cs]: ch, [cr]: [ba, { [cs]: cj, [cr]: [{ [cs]: bI, [cr]: [{ [cs]: [{ [ct]: h4, [cu]: [bb, "{partitionResult#name}"] }], [cr]: [{ [cs]: cl, [cr]: [{ [cs]: [{ [ct]: h4, [cu]: [aV, B2] }], [cr]: [{ [cs]: cm, [cr]: [{ [cs]: cn, [cr]: [{ [cs]: bD, error: "Access Points do not support S3 Accelerate", [cq]: f4 }, { [cs]: [X, Y2], endpoint: { [cx]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cy]: bk, [cE]: am }, [cq]: n4 }, { [cs]: [X, aH], endpoint: { [cx]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cy]: bk, [cE]: am }, [cq]: n4 }, { [cs]: [aJ, Y2], endpoint: { [cx]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cy]: bk, [cE]: am }, [cq]: n4 }, { [cs]: [aJ, aH, Z, ah], endpoint: { [cx]: M2, [cy]: bk, [cE]: am }, [cq]: n4 }, { [cs]: [aJ, aH], endpoint: { [cx]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cy]: bk, [cE]: am }, [cq]: n4 }], [cq]: o4 }, be], [cq]: o4 }, bf], [cq]: o4 }, { error: "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}", [cq]: f4 }], [cq]: o4 }, bg], [cq]: o4 }, bh], [cq]: o4 }], [cq]: o4 }], [cq]: o4 }, bi], [cq]: o4 }], [cq]: o4 }], [cq]: o4 }, { [cs]: [{ [ct]: y3, [cu]: [aW, c4] }], [cr]: [{ [cs]: bC, error: "S3 MRAP does not support dual-stack", [cq]: f4 }, { [cs]: bJ, error: "S3 MRAP does not support FIPS", [cq]: f4 }, { [cs]: bD, error: "S3 MRAP does not support S3 Accelerate", [cq]: f4 }, { [cs]: [{ [ct]: e4, [cu]: [{ [cv]: "DisableMultiRegionAccessPoints" }, c4] }], error: "Invalid configuration: Multi-Region Access Point ARNs are disabled.", [cq]: f4 }, { [cs]: [{ [ct]: g4, [cu]: bz, [cw]: N2 }], [cr]: [{ [cs]: [{ [ct]: h4, [cu]: [{ [ct]: i5, [cu]: [{ [cv]: N2 }, j4] }, { [ct]: i5, [cu]: [aT, "partition"] }] }], [cr]: [{ endpoint: { [cx]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}", [cy]: { [cA]: [{ [cB]: c4, name: z3, [cC]: B2, [cF]: ca }] }, [cE]: am }, [cq]: n4 }], [cq]: o4 }, { error: "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`", [cq]: f4 }], [cq]: o4 }], [cq]: o4 }, { error: "Invalid Access Point Name", [cq]: f4 }], [cq]: o4 }, bj], [cq]: o4 }, { [cs]: [{ [ct]: h4, [cu]: [aV, A2] }], [cr]: [{ [cs]: bC, error: "S3 Outposts does not support Dual-stack", [cq]: f4 }, { [cs]: bJ, error: "S3 Outposts does not support FIPS", [cq]: f4 }, { [cs]: bD, error: "S3 Outposts does not support S3 Accelerate", [cq]: f4 }, { [cs]: [{ [ct]: d4, [cu]: [{ [ct]: i5, [cu]: [aT, "resourceId[4]"] }] }], error: "Invalid Arn: Outpost Access Point ARN contains sub resources", [cq]: f4 }, { [cs]: [{ [ct]: i5, [cu]: cf, [cw]: x5 }], [cr]: [{ [cs]: bY, [cr]: [ba, { [cs]: cj, [cr]: [{ [cs]: bI, [cr]: [{ [cs]: ck, [cr]: [{ [cs]: cl, [cr]: [{ [cs]: cm, [cr]: [{ [cs]: [{ [ct]: i5, [cu]: ci, [cw]: O2 }], [cr]: [{ [cs]: [{ [ct]: i5, [cu]: [aT, "resourceId[3]"], [cw]: L2 }], [cr]: [{ [cs]: [{ [ct]: h4, [cu]: [{ [cv]: O2 }, K2] }], [cr]: [{ [cs]: bE, endpoint: { [cx]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}", [cy]: bl, [cE]: am }, [cq]: n4 }, { endpoint: { [cx]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cy]: bl, [cE]: am }, [cq]: n4 }], [cq]: o4 }, { error: "Expected an outpost type `accesspoint`, found {outpostType}", [cq]: f4 }], [cq]: o4 }, { error: "Invalid ARN: expected an access point name", [cq]: f4 }], [cq]: o4 }, { error: "Invalid ARN: Expected a 4-component resource", [cq]: f4 }], [cq]: o4 }, bf], [cq]: o4 }, bg], [cq]: o4 }, bh], [cq]: o4 }], [cq]: o4 }], [cq]: o4 }, { error: "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`", [cq]: f4 }], [cq]: o4 }, { error: "Invalid ARN: The Outpost Id was not set", [cq]: f4 }], [cq]: o4 }, { error: "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})", [cq]: f4 }], [cq]: o4 }, { error: "Invalid ARN: No ARN type specified", [cq]: f4 }], [cq]: o4 }, { [cs]: [{ [ct]: k5, [cu]: [ad, 0, 4, b4], [cw]: P2 }, { [ct]: h4, [cu]: [{ [cv]: P2 }, "arn:"] }, { [ct]: r4, [cu]: [{ [ct]: d4, [cu]: [bm] }] }], error: "Invalid ARN: `{Bucket}` was not a valid ARN", [cq]: f4 }, { [cs]: [{ [ct]: e4, [cu]: [ay, c4] }, bm], error: "Path-style addressing cannot be used with ARN buckets", [cq]: f4 }, { [cs]: bG, [cr]: [{ [cs]: bI, [cr]: [{ [cs]: [az], [cr]: [{ [cs]: [Y2, ar, X, aA], endpoint: { [cx]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cy]: aB, [cE]: am }, [cq]: n4 }, { [cs]: [Y2, ar, X, aC, aD], [cr]: [{ endpoint: bn, [cq]: n4 }], [cq]: o4 }, { [cs]: [Y2, ar, X, aC, aG], endpoint: bn, [cq]: n4 }, { [cs]: [aH, ar, X, aA], endpoint: { [cx]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cy]: aB, [cE]: am }, [cq]: n4 }, { [cs]: [aH, ar, X, aC, aD], [cr]: [{ endpoint: bo, [cq]: n4 }], [cq]: o4 }, { [cs]: [aH, ar, X, aC, aG], endpoint: bo, [cq]: n4 }, { [cs]: [Y2, ar, aJ, aA], endpoint: { [cx]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cy]: aB, [cE]: am }, [cq]: n4 }, { [cs]: [Y2, ar, aJ, aC, aD], [cr]: [{ endpoint: bp, [cq]: n4 }], [cq]: o4 }, { [cs]: [Y2, ar, aJ, aC, aG], endpoint: bp, [cq]: n4 }, { [cs]: [aH, Z, ah, aJ, aA], endpoint: { [cx]: Q2, [cy]: aB, [cE]: am }, [cq]: n4 }, { [cs]: [aH, Z, ah, aJ, aC, aD], [cr]: [{ [cs]: cc, endpoint: bq, [cq]: n4 }, { endpoint: bq, [cq]: n4 }], [cq]: o4 }, { [cs]: [aH, Z, ah, aJ, aC, aG], endpoint: bq, [cq]: n4 }, { [cs]: [aH, ar, aJ, aA], endpoint: { [cx]: R2, [cy]: aB, [cE]: am }, [cq]: n4 }, { [cs]: [aH, ar, aJ, aC, aD], [cr]: [{ [cs]: cc, endpoint: { [cx]: R2, [cy]: aF, [cE]: am }, [cq]: n4 }, { endpoint: br, [cq]: n4 }], [cq]: o4 }, { [cs]: [aH, ar, aJ, aC, aG], endpoint: br, [cq]: n4 }], [cq]: o4 }, { error: "Path-style addressing cannot be used with S3 Accelerate", [cq]: f4 }], [cq]: o4 }], [cq]: o4 }], [cq]: o4 }, { [cs]: [{ [ct]: d4, [cu]: [bs] }, { [ct]: e4, [cu]: [bs, c4] }], [cr]: [{ [cs]: bI, [cr]: [{ [cs]: co, [cr]: [aX, aY, { [cs]: bE, endpoint: { [cx]: t5, [cy]: bt, [cE]: am }, [cq]: n4 }, { [cs]: bJ, endpoint: { [cx]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}", [cy]: bt, [cE]: am }, [cq]: n4 }, { endpoint: { [cx]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}", [cy]: bt, [cE]: am }, [cq]: n4 }], [cq]: o4 }, aS], [cq]: o4 }], [cq]: o4 }, { [cs]: [at], [cr]: [{ [cs]: bI, [cr]: [{ [cs]: co, [cr]: [{ [cs]: [X, Y2, ar, aA], endpoint: { [cx]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cy]: aB, [cE]: am }, [cq]: n4 }, { [cs]: [X, Y2, ar, aC, aD], [cr]: [{ endpoint: bu, [cq]: n4 }], [cq]: o4 }, { [cs]: [X, Y2, ar, aC, aG], endpoint: bu, [cq]: n4 }, { [cs]: [X, aH, ar, aA], endpoint: { [cx]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cy]: aB, [cE]: am }, [cq]: n4 }, { [cs]: [X, aH, ar, aC, aD], [cr]: [{ endpoint: bv, [cq]: n4 }], [cq]: o4 }, { [cs]: [X, aH, ar, aC, aG], endpoint: bv, [cq]: n4 }, { [cs]: [aJ, Y2, ar, aA], endpoint: { [cx]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cy]: aB, [cE]: am }, [cq]: n4 }, { [cs]: [aJ, Y2, ar, aC, aD], [cr]: [{ endpoint: bw, [cq]: n4 }], [cq]: o4 }, { [cs]: [aJ, Y2, ar, aC, aG], endpoint: bw, [cq]: n4 }, { [cs]: [aJ, aH, Z, ah, aA], endpoint: { [cx]: t5, [cy]: aB, [cE]: am }, [cq]: n4 }, { [cs]: [aJ, aH, Z, ah, aC, aD], [cr]: [{ [cs]: cc, endpoint: bx, [cq]: n4 }, { endpoint: bx, [cq]: n4 }], [cq]: o4 }, { [cs]: [aJ, aH, Z, ah, aC, aG], endpoint: bx, [cq]: n4 }, { [cs]: [aJ, aH, ar, aA], endpoint: { [cx]: S2, [cy]: aB, [cE]: am }, [cq]: n4 }, { [cs]: [aJ, aH, ar, aC, aD], [cr]: [{ [cs]: cc, endpoint: { [cx]: S2, [cy]: aF, [cE]: am }, [cq]: n4 }, { endpoint: by, [cq]: n4 }], [cq]: o4 }, { [cs]: [aJ, aH, ar, aC, aG], endpoint: by, [cq]: n4 }], [cq]: o4 }, aS], [cq]: o4 }], [cq]: o4 }], [cq]: o4 }, { error: "A region must be set when sending requests to S3.", [cq]: f4 }] };
var ruleSet4 = _data4;

// node_modules/@aws-sdk/client-s3/dist-es/endpoint/endpointResolver.js
var cache4 = new import_util_endpoints8.EndpointCache({
  size: 50,
  params: [
    "Accelerate",
    "Bucket",
    "DisableAccessPoints",
    "DisableMultiRegionAccessPoints",
    "DisableS3ExpressSessionAuth",
    "Endpoint",
    "ForcePathStyle",
    "Region",
    "UseArnRegion",
    "UseDualStack",
    "UseFIPS",
    "UseGlobalEndpoint",
    "UseObjectLambdaEndpoint",
    "UseS3ExpressControlEndpoint"
  ]
});
var defaultEndpointResolver4 = (endpointParams, context = {}) => {
  return cache4.get(endpointParams, () => import_util_endpoints8.resolveEndpoint(ruleSet4, {
    endpointParams,
    logger: context.logger
  }));
};
import_util_endpoints8.customEndpointFunctions.aws = import_util_endpoints7.awsEndpointFunctions;

// node_modules/@aws-sdk/client-s3/dist-es/auth/httpAuthSchemeProvider.js
var createEndpointRuleSetHttpAuthSchemeParametersProvider = (defaultHttpAuthSchemeParametersProvider) => async (config, context, input) => {
  if (!input) {
    throw new Error(`Could not find \`input\` for \`defaultEndpointRuleSetHttpAuthSchemeParametersProvider\``);
  }
  const defaultParameters = await defaultHttpAuthSchemeParametersProvider(config, context, input);
  const instructionsFn = import_util_middleware6.getSmithyContext(context)?.commandInstance?.constructor?.getEndpointParameterInstructions;
  if (!instructionsFn) {
    throw new Error(`getEndpointParameterInstructions() is not defined on \`${context.commandName}\``);
  }
  const endpointParameters = await import_middleware_endpoint66.resolveParams(input, { getEndpointParameterInstructions: instructionsFn }, config);
  return Object.assign(defaultParameters, endpointParameters);
};
var _defaultS3HttpAuthSchemeParametersProvider = async (config, context, input) => {
  return {
    operation: import_util_middleware6.getSmithyContext(context).operation,
    region: await import_util_middleware6.normalizeProvider(config.region)() || (() => {
      throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
    })()
  };
};
var defaultS3HttpAuthSchemeParametersProvider = createEndpointRuleSetHttpAuthSchemeParametersProvider(_defaultS3HttpAuthSchemeParametersProvider);
function createAwsAuthSigv4HttpAuthOption4(authParameters) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "s3",
      region: authParameters.region
    },
    propertiesExtractor: (config, context) => ({
      signingProperties: {
        config,
        context
      }
    })
  };
}
function createAwsAuthSigv4aHttpAuthOption(authParameters) {
  return {
    schemeId: "aws.auth#sigv4a",
    signingProperties: {
      name: "s3",
      region: authParameters.region
    },
    propertiesExtractor: (config, context) => ({
      signingProperties: {
        config,
        context
      }
    })
  };
}
var createEndpointRuleSetHttpAuthSchemeProvider = (defaultEndpointResolver5, defaultHttpAuthSchemeResolver, createHttpAuthOptionFunctions) => {
  const endpointRuleSetHttpAuthSchemeProvider = (authParameters) => {
    const endpoint = defaultEndpointResolver5(authParameters);
    const authSchemes = endpoint.properties?.authSchemes;
    if (!authSchemes) {
      return defaultHttpAuthSchemeResolver(authParameters);
    }
    const options = [];
    for (const scheme of authSchemes) {
      const { name: resolvedName, properties = {}, ...rest } = scheme;
      const name = resolvedName.toLowerCase();
      if (resolvedName !== name) {
        console.warn(`HttpAuthScheme has been normalized with lowercasing: \`${resolvedName}\` to \`${name}\``);
      }
      let schemeId;
      if (name === "sigv4a") {
        schemeId = "aws.auth#sigv4a";
        const sigv4Present = authSchemes.find((s5) => {
          const name2 = s5.name.toLowerCase();
          return name2 !== "sigv4a" && name2.startsWith("sigv4");
        });
        if (SignatureV4MultiRegion.sigv4aDependency() === "none" && sigv4Present) {
          continue;
        }
      } else if (name.startsWith("sigv4")) {
        schemeId = "aws.auth#sigv4";
      } else {
        throw new Error(`Unknown HttpAuthScheme found in \`@smithy.rules#endpointRuleSet\`: \`${name}\``);
      }
      const createOption = createHttpAuthOptionFunctions[schemeId];
      if (!createOption) {
        throw new Error(`Could not find HttpAuthOption create function for \`${schemeId}\``);
      }
      const option = createOption(authParameters);
      option.schemeId = schemeId;
      option.signingProperties = { ...option.signingProperties || {}, ...rest, ...properties };
      options.push(option);
    }
    return options;
  };
  return endpointRuleSetHttpAuthSchemeProvider;
};
var _defaultS3HttpAuthSchemeProvider = (authParameters) => {
  const options = [];
  switch (authParameters.operation) {
    default: {
      options.push(createAwsAuthSigv4HttpAuthOption4(authParameters));
      options.push(createAwsAuthSigv4aHttpAuthOption(authParameters));
    }
  }
  return options;
};
var defaultS3HttpAuthSchemeProvider = createEndpointRuleSetHttpAuthSchemeProvider(defaultEndpointResolver4, _defaultS3HttpAuthSchemeProvider, {
  "aws.auth#sigv4": createAwsAuthSigv4HttpAuthOption4,
  "aws.auth#sigv4a": createAwsAuthSigv4aHttpAuthOption
});
var resolveHttpAuthSchemeConfig4 = (config) => {
  const config_0 = import_core37.resolveAwsSdkSigV4Config(config);
  const config_1 = import_core37.resolveAwsSdkSigV4AConfig(config_0);
  return Object.assign(config_1, {
    authSchemePreference: import_util_middleware6.normalizeProvider(config.authSchemePreference ?? [])
  });
};

// node_modules/@aws-sdk/client-s3/dist-es/commands/CreateSessionCommand.js
var import_middleware_endpoint67 = __toESM(require_dist_cjs37(), 1);
var import_middleware_serde63 = __toESM(require_dist_cjs7(), 1);
var import_smithy_client97 = __toESM(require_dist_cjs28(), 1);

// node_modules/@aws-sdk/client-s3/dist-es/endpoint/EndpointParameters.js
var resolveClientEndpointParameters4 = (options) => {
  return Object.assign(options, {
    useFipsEndpoint: options.useFipsEndpoint ?? false,
    useDualstackEndpoint: options.useDualstackEndpoint ?? false,
    forcePathStyle: options.forcePathStyle ?? false,
    useAccelerateEndpoint: options.useAccelerateEndpoint ?? false,
    useGlobalEndpoint: options.useGlobalEndpoint ?? false,
    disableMultiregionAccessPoints: options.disableMultiregionAccessPoints ?? false,
    defaultSigningName: "s3"
  });
};
var commonParams4 = {
  ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
  UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
  DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
  Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
  DisableS3ExpressSessionAuth: { type: "clientContextParams", name: "disableS3ExpressSessionAuth" },
  UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
  UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
  Endpoint: { type: "builtInParams", name: "endpoint" },
  Region: { type: "builtInParams", name: "region" },
  UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
};

// node_modules/@aws-sdk/client-s3/dist-es/models/models_0.js
var import_smithy_client94 = __toESM(require_dist_cjs28(), 1);

// node_modules/@aws-sdk/client-s3/dist-es/models/S3ServiceException.js
var import_smithy_client93 = __toESM(require_dist_cjs28(), 1);
class S3ServiceException extends import_smithy_client93.ServiceException {
  constructor(options) {
    super(options);
    Object.setPrototypeOf(this, S3ServiceException.prototype);
  }
}

// node_modules/@aws-sdk/client-s3/dist-es/models/models_0.js
class NoSuchUpload extends S3ServiceException {
  name = "NoSuchUpload";
  $fault = "client";
  constructor(opts) {
    super({
      name: "NoSuchUpload",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, NoSuchUpload.prototype);
  }
}
class ObjectNotInActiveTierError extends S3ServiceException {
  name = "ObjectNotInActiveTierError";
  $fault = "client";
  constructor(opts) {
    super({
      name: "ObjectNotInActiveTierError",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, ObjectNotInActiveTierError.prototype);
  }
}

class BucketAlreadyExists extends S3ServiceException {
  name = "BucketAlreadyExists";
  $fault = "client";
  constructor(opts) {
    super({
      name: "BucketAlreadyExists",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, BucketAlreadyExists.prototype);
  }
}

class BucketAlreadyOwnedByYou extends S3ServiceException {
  name = "BucketAlreadyOwnedByYou";
  $fault = "client";
  constructor(opts) {
    super({
      name: "BucketAlreadyOwnedByYou",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, BucketAlreadyOwnedByYou.prototype);
  }
}
class NoSuchBucket extends S3ServiceException {
  name = "NoSuchBucket";
  $fault = "client";
  constructor(opts) {
    super({
      name: "NoSuchBucket",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, NoSuchBucket.prototype);
  }
}
var AnalyticsFilter;
(function(AnalyticsFilter2) {
  AnalyticsFilter2.visit = (value, visitor) => {
    if (value.Prefix !== undefined)
      return visitor.Prefix(value.Prefix);
    if (value.Tag !== undefined)
      return visitor.Tag(value.Tag);
    if (value.And !== undefined)
      return visitor.And(value.And);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(AnalyticsFilter || (AnalyticsFilter = {}));
var MetricsFilter;
(function(MetricsFilter2) {
  MetricsFilter2.visit = (value, visitor) => {
    if (value.Prefix !== undefined)
      return visitor.Prefix(value.Prefix);
    if (value.Tag !== undefined)
      return visitor.Tag(value.Tag);
    if (value.AccessPointArn !== undefined)
      return visitor.AccessPointArn(value.AccessPointArn);
    if (value.And !== undefined)
      return visitor.And(value.And);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(MetricsFilter || (MetricsFilter = {}));
class InvalidObjectState extends S3ServiceException {
  name = "InvalidObjectState";
  $fault = "client";
  StorageClass;
  AccessTier;
  constructor(opts) {
    super({
      name: "InvalidObjectState",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidObjectState.prototype);
    this.StorageClass = opts.StorageClass;
    this.AccessTier = opts.AccessTier;
  }
}

class NoSuchKey extends S3ServiceException {
  name = "NoSuchKey";
  $fault = "client";
  constructor(opts) {
    super({
      name: "NoSuchKey",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, NoSuchKey.prototype);
  }
}
class NotFound extends S3ServiceException {
  name = "NotFound";
  $fault = "client";
  constructor(opts) {
    super({
      name: "NotFound",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, NotFound.prototype);
  }
}
var SessionCredentialsFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SecretAccessKey && { SecretAccessKey: import_smithy_client94.SENSITIVE_STRING },
  ...obj.SessionToken && { SessionToken: import_smithy_client94.SENSITIVE_STRING }
});
var CreateSessionOutputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SSEKMSKeyId && { SSEKMSKeyId: import_smithy_client94.SENSITIVE_STRING },
  ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: import_smithy_client94.SENSITIVE_STRING },
  ...obj.Credentials && { Credentials: SessionCredentialsFilterSensitiveLog(obj.Credentials) }
});
var CreateSessionRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SSEKMSKeyId && { SSEKMSKeyId: import_smithy_client94.SENSITIVE_STRING },
  ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: import_smithy_client94.SENSITIVE_STRING }
});
var GetObjectOutputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SSEKMSKeyId && { SSEKMSKeyId: import_smithy_client94.SENSITIVE_STRING }
});
var GetObjectRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SSECustomerKey && { SSECustomerKey: import_smithy_client94.SENSITIVE_STRING }
});

// node_modules/@aws-sdk/client-s3/dist-es/protocols/Aws_restXml.js
var import_core38 = __toESM(require_dist_cjs30(), 1);
var import_core39 = __toESM(require_dist_cjs19(), 1);
var import_smithy_client96 = __toESM(require_dist_cjs28(), 1);

// node_modules/@aws-sdk/client-s3/dist-es/models/models_1.js
var import_smithy_client95 = __toESM(require_dist_cjs28(), 1);
class EncryptionTypeMismatch extends S3ServiceException {
  name = "EncryptionTypeMismatch";
  $fault = "client";
  constructor(opts) {
    super({
      name: "EncryptionTypeMismatch",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, EncryptionTypeMismatch.prototype);
  }
}

class InvalidRequest extends S3ServiceException {
  name = "InvalidRequest";
  $fault = "client";
  constructor(opts) {
    super({
      name: "InvalidRequest",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidRequest.prototype);
  }
}

class InvalidWriteOffset extends S3ServiceException {
  name = "InvalidWriteOffset";
  $fault = "client";
  constructor(opts) {
    super({
      name: "InvalidWriteOffset",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, InvalidWriteOffset.prototype);
  }
}

class TooManyParts extends S3ServiceException {
  name = "TooManyParts";
  $fault = "client";
  constructor(opts) {
    super({
      name: "TooManyParts",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, TooManyParts.prototype);
  }
}

class IdempotencyParameterMismatch extends S3ServiceException {
  name = "IdempotencyParameterMismatch";
  $fault = "client";
  constructor(opts) {
    super({
      name: "IdempotencyParameterMismatch",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, IdempotencyParameterMismatch.prototype);
  }
}

class ObjectAlreadyInActiveTierError extends S3ServiceException {
  name = "ObjectAlreadyInActiveTierError";
  $fault = "client";
  constructor(opts) {
    super({
      name: "ObjectAlreadyInActiveTierError",
      $fault: "client",
      ...opts
    });
    Object.setPrototypeOf(this, ObjectAlreadyInActiveTierError.prototype);
  }
}
var SelectObjectContentEventStream;
(function(SelectObjectContentEventStream2) {
  SelectObjectContentEventStream2.visit = (value, visitor) => {
    if (value.Records !== undefined)
      return visitor.Records(value.Records);
    if (value.Stats !== undefined)
      return visitor.Stats(value.Stats);
    if (value.Progress !== undefined)
      return visitor.Progress(value.Progress);
    if (value.Cont !== undefined)
      return visitor.Cont(value.Cont);
    if (value.End !== undefined)
      return visitor.End(value.End);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
})(SelectObjectContentEventStream || (SelectObjectContentEventStream = {}));
var PutObjectOutputFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SSEKMSKeyId && { SSEKMSKeyId: import_smithy_client95.SENSITIVE_STRING },
  ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: import_smithy_client95.SENSITIVE_STRING }
});
var PutObjectRequestFilterSensitiveLog = (obj) => ({
  ...obj,
  ...obj.SSECustomerKey && { SSECustomerKey: import_smithy_client95.SENSITIVE_STRING },
  ...obj.SSEKMSKeyId && { SSEKMSKeyId: import_smithy_client95.SENSITIVE_STRING },
  ...obj.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: import_smithy_client95.SENSITIVE_STRING }
});

// node_modules/@aws-sdk/client-s3/dist-es/protocols/Aws_restXml.js
var se_CreateSessionCommand = async (input, context) => {
  const b5 = import_core39.requestBuilder(input, context);
  const headers = import_smithy_client96.map({}, import_smithy_client96.isSerializableHeaderValue, {
    [_xacsm]: input[_SM],
    [_xasse]: input[_SSE],
    [_xasseakki]: input[_SSEKMSKI],
    [_xassec]: input[_SSEKMSEC],
    [_xassebke]: [() => import_smithy_client96.isSerializableHeaderValue(input[_BKE]), () => input[_BKE].toString()]
  });
  b5.bp("/");
  b5.p("Bucket", () => input.Bucket, "{Bucket}", false);
  const query = import_smithy_client96.map({
    [_s]: [, ""]
  });
  let body;
  b5.m("GET").h(headers).q(query).b(body);
  return b5.build();
};
var se_GetObjectCommand = async (input, context) => {
  const b5 = import_core39.requestBuilder(input, context);
  const headers = import_smithy_client96.map({}, import_smithy_client96.isSerializableHeaderValue, {
    [_im]: input[_IM],
    [_ims]: [() => import_smithy_client96.isSerializableHeaderValue(input[_IMSf]), () => import_smithy_client96.dateToUtcString(input[_IMSf]).toString()],
    [_inm]: input[_INM],
    [_ius]: [() => import_smithy_client96.isSerializableHeaderValue(input[_IUS]), () => import_smithy_client96.dateToUtcString(input[_IUS]).toString()],
    [_ra]: input[_R],
    [_xasseca]: input[_SSECA],
    [_xasseck]: input[_SSECK],
    [_xasseckm]: input[_SSECKMD],
    [_xarp]: input[_RP],
    [_xaebo]: input[_EBO],
    [_xacm]: input[_CM]
  });
  b5.bp("/{Key+}");
  b5.p("Bucket", () => input.Bucket, "{Bucket}", false);
  b5.p("Key", () => input.Key, "{Key+}", true);
  const query = import_smithy_client96.map({
    [_xi]: [, "GetObject"],
    [_rcc]: [, input[_RCC]],
    [_rcd]: [, input[_RCD]],
    [_rce]: [, input[_RCE]],
    [_rcl]: [, input[_RCL]],
    [_rct]: [, input[_RCT]],
    [_re]: [() => input.ResponseExpires !== undefined, () => import_smithy_client96.dateToUtcString(input[_RE]).toString()],
    [_vI]: [, input[_VI]],
    [_pN]: [() => input.PartNumber !== undefined, () => input[_PN].toString()]
  });
  let body;
  b5.m("GET").h(headers).q(query).b(body);
  return b5.build();
};
var se_PutObjectCommand = async (input, context) => {
  const b5 = import_core39.requestBuilder(input, context);
  const headers = import_smithy_client96.map({}, import_smithy_client96.isSerializableHeaderValue, {
    ...input.Metadata !== undefined && Object.keys(input.Metadata).reduce((acc, suffix) => {
      acc[`x-amz-meta-${suffix.toLowerCase()}`] = input.Metadata[suffix];
      return acc;
    }, {}),
    [_ct]: input[_CTo] || "application/octet-stream",
    [_xaa]: input[_ACL],
    [_cc]: input[_CC],
    [_cd]: input[_CD],
    [_ce]: input[_CE],
    [_cl]: input[_CL],
    [_cl_]: [() => import_smithy_client96.isSerializableHeaderValue(input[_CLo]), () => input[_CLo].toString()],
    [_cm]: input[_CMD],
    [_xasca]: input[_CA],
    [_xacc]: input[_CCRC],
    [_xacc_]: input[_CCRCC],
    [_xacc__]: input[_CCRCNVME],
    [_xacs]: input[_CSHA],
    [_xacs_]: input[_CSHAh],
    [_e]: [() => import_smithy_client96.isSerializableHeaderValue(input[_E]), () => import_smithy_client96.dateToUtcString(input[_E]).toString()],
    [_im]: input[_IM],
    [_inm]: input[_INM],
    [_xagfc]: input[_GFC],
    [_xagr]: input[_GR],
    [_xagra]: input[_GRACP],
    [_xagwa]: input[_GWACP],
    [_xawob]: [() => import_smithy_client96.isSerializableHeaderValue(input[_WOB]), () => input[_WOB].toString()],
    [_xasse]: input[_SSE],
    [_xasc]: input[_SC],
    [_xawrl]: input[_WRL],
    [_xasseca]: input[_SSECA],
    [_xasseck]: input[_SSECK],
    [_xasseckm]: input[_SSECKMD],
    [_xasseakki]: input[_SSEKMSKI],
    [_xassec]: input[_SSEKMSEC],
    [_xassebke]: [() => import_smithy_client96.isSerializableHeaderValue(input[_BKE]), () => input[_BKE].toString()],
    [_xarp]: input[_RP],
    [_xat]: input[_T],
    [_xaolm]: input[_OLM],
    [_xaolrud]: [() => import_smithy_client96.isSerializableHeaderValue(input[_OLRUD]), () => import_smithy_client96.serializeDateTime(input[_OLRUD]).toString()],
    [_xaollh]: input[_OLLHS],
    [_xaebo]: input[_EBO]
  });
  b5.bp("/{Key+}");
  b5.p("Bucket", () => input.Bucket, "{Bucket}", false);
  b5.p("Key", () => input.Key, "{Key+}", true);
  const query = import_smithy_client96.map({
    [_xi]: [, "PutObject"]
  });
  let body;
  let contents;
  if (input.Body !== undefined) {
    contents = input.Body;
    body = contents;
  }
  b5.m("PUT").h(headers).q(query).b(body);
  return b5.build();
};
var de_CreateSessionCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError4(output, context);
  }
  const contents = import_smithy_client96.map({
    $metadata: deserializeMetadata4(output),
    [_SSE]: [, output.headers[_xasse]],
    [_SSEKMSKI]: [, output.headers[_xasseakki]],
    [_SSEKMSEC]: [, output.headers[_xassec]],
    [_BKE]: [() => output.headers[_xassebke] !== undefined, () => import_smithy_client96.parseBoolean(output.headers[_xassebke])]
  });
  const data = import_smithy_client96.expectNonNull(import_smithy_client96.expectObject(await import_core38.parseXmlBody(output.body, context)), "body");
  if (data[_C] != null) {
    contents[_C] = de_SessionCredentials(data[_C], context);
  }
  return contents;
};
var de_GetObjectCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError4(output, context);
  }
  const contents = import_smithy_client96.map({
    $metadata: deserializeMetadata4(output),
    [_DM]: [() => output.headers[_xadm] !== undefined, () => import_smithy_client96.parseBoolean(output.headers[_xadm])],
    [_AR]: [, output.headers[_ar]],
    [_Exp]: [, output.headers[_xae]],
    [_Re]: [, output.headers[_xar]],
    [_LM]: [() => output.headers[_lm] !== undefined, () => import_smithy_client96.expectNonNull(import_smithy_client96.parseRfc7231DateTime(output.headers[_lm]))],
    [_CLo]: [() => output.headers[_cl_] !== undefined, () => import_smithy_client96.strictParseLong(output.headers[_cl_])],
    [_ETa]: [, output.headers[_eta]],
    [_CCRC]: [, output.headers[_xacc]],
    [_CCRCC]: [, output.headers[_xacc_]],
    [_CCRCNVME]: [, output.headers[_xacc__]],
    [_CSHA]: [, output.headers[_xacs]],
    [_CSHAh]: [, output.headers[_xacs_]],
    [_CT]: [, output.headers[_xact]],
    [_MM]: [() => output.headers[_xamm] !== undefined, () => import_smithy_client96.strictParseInt32(output.headers[_xamm])],
    [_VI]: [, output.headers[_xavi]],
    [_CC]: [, output.headers[_cc]],
    [_CD]: [, output.headers[_cd]],
    [_CE]: [, output.headers[_ce]],
    [_CL]: [, output.headers[_cl]],
    [_CR]: [, output.headers[_cr]],
    [_CTo]: [, output.headers[_ct]],
    [_E]: [() => output.headers[_e] !== undefined, () => import_smithy_client96.expectNonNull(import_smithy_client96.parseRfc7231DateTime(output.headers[_e]))],
    [_ES]: [, output.headers[_ex]],
    [_WRL]: [, output.headers[_xawrl]],
    [_SSE]: [, output.headers[_xasse]],
    [_SSECA]: [, output.headers[_xasseca]],
    [_SSECKMD]: [, output.headers[_xasseckm]],
    [_SSEKMSKI]: [, output.headers[_xasseakki]],
    [_BKE]: [() => output.headers[_xassebke] !== undefined, () => import_smithy_client96.parseBoolean(output.headers[_xassebke])],
    [_SC]: [, output.headers[_xasc]],
    [_RC]: [, output.headers[_xarc]],
    [_RSe]: [, output.headers[_xars_]],
    [_PC]: [() => output.headers[_xampc] !== undefined, () => import_smithy_client96.strictParseInt32(output.headers[_xampc])],
    [_TC]: [() => output.headers[_xatc] !== undefined, () => import_smithy_client96.strictParseInt32(output.headers[_xatc])],
    [_OLM]: [, output.headers[_xaolm]],
    [_OLRUD]: [
      () => output.headers[_xaolrud] !== undefined,
      () => import_smithy_client96.expectNonNull(import_smithy_client96.parseRfc3339DateTimeWithOffset(output.headers[_xaolrud]))
    ],
    [_OLLHS]: [, output.headers[_xaollh]],
    Metadata: [
      ,
      Object.keys(output.headers).filter((header) => header.startsWith("x-amz-meta-")).reduce((acc, header) => {
        acc[header.substring(11)] = output.headers[header];
        return acc;
      }, {})
    ]
  });
  const data = output.body;
  context.sdkStreamMixin(data);
  contents.Body = data;
  return contents;
};
var de_PutObjectCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return de_CommandError4(output, context);
  }
  const contents = import_smithy_client96.map({
    $metadata: deserializeMetadata4(output),
    [_Exp]: [, output.headers[_xae]],
    [_ETa]: [, output.headers[_eta]],
    [_CCRC]: [, output.headers[_xacc]],
    [_CCRCC]: [, output.headers[_xacc_]],
    [_CCRCNVME]: [, output.headers[_xacc__]],
    [_CSHA]: [, output.headers[_xacs]],
    [_CSHAh]: [, output.headers[_xacs_]],
    [_CT]: [, output.headers[_xact]],
    [_SSE]: [, output.headers[_xasse]],
    [_VI]: [, output.headers[_xavi]],
    [_SSECA]: [, output.headers[_xasseca]],
    [_SSECKMD]: [, output.headers[_xasseckm]],
    [_SSEKMSKI]: [, output.headers[_xasseakki]],
    [_SSEKMSEC]: [, output.headers[_xassec]],
    [_BKE]: [() => output.headers[_xassebke] !== undefined, () => import_smithy_client96.parseBoolean(output.headers[_xassebke])],
    [_Si]: [() => output.headers[_xaos] !== undefined, () => import_smithy_client96.strictParseLong(output.headers[_xaos])],
    [_RC]: [, output.headers[_xarc]]
  });
  await import_smithy_client96.collectBody(output.body, context);
  return contents;
};
var de_CommandError4 = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await import_core38.parseXmlErrorBody(output.body, context)
  };
  const errorCode = import_core38.loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NoSuchUpload":
    case "com.amazonaws.s3#NoSuchUpload":
      throw await de_NoSuchUploadRes(parsedOutput, context);
    case "ObjectNotInActiveTierError":
    case "com.amazonaws.s3#ObjectNotInActiveTierError":
      throw await de_ObjectNotInActiveTierErrorRes(parsedOutput, context);
    case "BucketAlreadyExists":
    case "com.amazonaws.s3#BucketAlreadyExists":
      throw await de_BucketAlreadyExistsRes(parsedOutput, context);
    case "BucketAlreadyOwnedByYou":
    case "com.amazonaws.s3#BucketAlreadyOwnedByYou":
      throw await de_BucketAlreadyOwnedByYouRes(parsedOutput, context);
    case "NoSuchBucket":
    case "com.amazonaws.s3#NoSuchBucket":
      throw await de_NoSuchBucketRes(parsedOutput, context);
    case "InvalidObjectState":
    case "com.amazonaws.s3#InvalidObjectState":
      throw await de_InvalidObjectStateRes(parsedOutput, context);
    case "NoSuchKey":
    case "com.amazonaws.s3#NoSuchKey":
      throw await de_NoSuchKeyRes(parsedOutput, context);
    case "NotFound":
    case "com.amazonaws.s3#NotFound":
      throw await de_NotFoundRes(parsedOutput, context);
    case "EncryptionTypeMismatch":
    case "com.amazonaws.s3#EncryptionTypeMismatch":
      throw await de_EncryptionTypeMismatchRes(parsedOutput, context);
    case "InvalidRequest":
    case "com.amazonaws.s3#InvalidRequest":
      throw await de_InvalidRequestRes(parsedOutput, context);
    case "InvalidWriteOffset":
    case "com.amazonaws.s3#InvalidWriteOffset":
      throw await de_InvalidWriteOffsetRes(parsedOutput, context);
    case "TooManyParts":
    case "com.amazonaws.s3#TooManyParts":
      throw await de_TooManyPartsRes(parsedOutput, context);
    case "IdempotencyParameterMismatch":
    case "com.amazonaws.s3#IdempotencyParameterMismatch":
      throw await de_IdempotencyParameterMismatchRes(parsedOutput, context);
    case "ObjectAlreadyInActiveTierError":
    case "com.amazonaws.s3#ObjectAlreadyInActiveTierError":
      throw await de_ObjectAlreadyInActiveTierErrorRes(parsedOutput, context);
    default:
      const parsedBody = parsedOutput.body;
      return throwDefaultError4({
        output,
        parsedBody,
        errorCode
      });
  }
};
var throwDefaultError4 = import_smithy_client96.withBaseException(S3ServiceException);
var de_BucketAlreadyExistsRes = async (parsedOutput, context) => {
  const contents = import_smithy_client96.map({});
  const data = parsedOutput.body;
  const exception = new BucketAlreadyExists({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return import_smithy_client96.decorateServiceException(exception, parsedOutput.body);
};
var de_BucketAlreadyOwnedByYouRes = async (parsedOutput, context) => {
  const contents = import_smithy_client96.map({});
  const data = parsedOutput.body;
  const exception = new BucketAlreadyOwnedByYou({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return import_smithy_client96.decorateServiceException(exception, parsedOutput.body);
};
var de_EncryptionTypeMismatchRes = async (parsedOutput, context) => {
  const contents = import_smithy_client96.map({});
  const data = parsedOutput.body;
  const exception = new EncryptionTypeMismatch({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return import_smithy_client96.decorateServiceException(exception, parsedOutput.body);
};
var de_IdempotencyParameterMismatchRes = async (parsedOutput, context) => {
  const contents = import_smithy_client96.map({});
  const data = parsedOutput.body;
  const exception = new IdempotencyParameterMismatch({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return import_smithy_client96.decorateServiceException(exception, parsedOutput.body);
};
var de_InvalidObjectStateRes = async (parsedOutput, context) => {
  const contents = import_smithy_client96.map({});
  const data = parsedOutput.body;
  if (data[_AT] != null) {
    contents[_AT] = import_smithy_client96.expectString(data[_AT]);
  }
  if (data[_SC] != null) {
    contents[_SC] = import_smithy_client96.expectString(data[_SC]);
  }
  const exception = new InvalidObjectState({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return import_smithy_client96.decorateServiceException(exception, parsedOutput.body);
};
var de_InvalidRequestRes = async (parsedOutput, context) => {
  const contents = import_smithy_client96.map({});
  const data = parsedOutput.body;
  const exception = new InvalidRequest({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return import_smithy_client96.decorateServiceException(exception, parsedOutput.body);
};
var de_InvalidWriteOffsetRes = async (parsedOutput, context) => {
  const contents = import_smithy_client96.map({});
  const data = parsedOutput.body;
  const exception = new InvalidWriteOffset({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return import_smithy_client96.decorateServiceException(exception, parsedOutput.body);
};
var de_NoSuchBucketRes = async (parsedOutput, context) => {
  const contents = import_smithy_client96.map({});
  const data = parsedOutput.body;
  const exception = new NoSuchBucket({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return import_smithy_client96.decorateServiceException(exception, parsedOutput.body);
};
var de_NoSuchKeyRes = async (parsedOutput, context) => {
  const contents = import_smithy_client96.map({});
  const data = parsedOutput.body;
  const exception = new NoSuchKey({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return import_smithy_client96.decorateServiceException(exception, parsedOutput.body);
};
var de_NoSuchUploadRes = async (parsedOutput, context) => {
  const contents = import_smithy_client96.map({});
  const data = parsedOutput.body;
  const exception = new NoSuchUpload({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return import_smithy_client96.decorateServiceException(exception, parsedOutput.body);
};
var de_NotFoundRes = async (parsedOutput, context) => {
  const contents = import_smithy_client96.map({});
  const data = parsedOutput.body;
  const exception = new NotFound({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return import_smithy_client96.decorateServiceException(exception, parsedOutput.body);
};
var de_ObjectAlreadyInActiveTierErrorRes = async (parsedOutput, context) => {
  const contents = import_smithy_client96.map({});
  const data = parsedOutput.body;
  const exception = new ObjectAlreadyInActiveTierError({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return import_smithy_client96.decorateServiceException(exception, parsedOutput.body);
};
var de_ObjectNotInActiveTierErrorRes = async (parsedOutput, context) => {
  const contents = import_smithy_client96.map({});
  const data = parsedOutput.body;
  const exception = new ObjectNotInActiveTierError({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return import_smithy_client96.decorateServiceException(exception, parsedOutput.body);
};
var de_TooManyPartsRes = async (parsedOutput, context) => {
  const contents = import_smithy_client96.map({});
  const data = parsedOutput.body;
  const exception = new TooManyParts({
    $metadata: deserializeMetadata4(parsedOutput),
    ...contents
  });
  return import_smithy_client96.decorateServiceException(exception, parsedOutput.body);
};
var de_SessionCredentials = (output, context) => {
  const contents = {};
  if (output[_AKI] != null) {
    contents[_AKI] = import_smithy_client96.expectString(output[_AKI]);
  }
  if (output[_SAK] != null) {
    contents[_SAK] = import_smithy_client96.expectString(output[_SAK]);
  }
  if (output[_ST] != null) {
    contents[_ST] = import_smithy_client96.expectString(output[_ST]);
  }
  if (output[_Exp] != null) {
    contents[_Exp] = import_smithy_client96.expectNonNull(import_smithy_client96.parseRfc3339DateTimeWithOffset(output[_Exp]));
  }
  return contents;
};
var deserializeMetadata4 = (output) => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"]
});
var _ACL = "ACL";
var _AKI = "AccessKeyId";
var _AR = "AcceptRanges";
var _AT = "AccessTier";
var _BKE = "BucketKeyEnabled";
var _C = "Credentials";
var _CA = "ChecksumAlgorithm";
var _CC = "CacheControl";
var _CCRC = "ChecksumCRC32";
var _CCRCC = "ChecksumCRC32C";
var _CCRCNVME = "ChecksumCRC64NVME";
var _CD = "ContentDisposition";
var _CE = "ContentEncoding";
var _CL = "ContentLanguage";
var _CLo = "ContentLength";
var _CM = "ChecksumMode";
var _CMD = "ContentMD5";
var _CR = "ContentRange";
var _CSHA = "ChecksumSHA1";
var _CSHAh = "ChecksumSHA256";
var _CT = "ChecksumType";
var _CTo = "ContentType";
var _DM = "DeleteMarker";
var _E = "Expires";
var _EBO = "ExpectedBucketOwner";
var _ES = "ExpiresString";
var _ETa = "ETag";
var _Exp = "Expiration";
var _GFC = "GrantFullControl";
var _GR = "GrantRead";
var _GRACP = "GrantReadACP";
var _GWACP = "GrantWriteACP";
var _IM = "IfMatch";
var _IMSf = "IfModifiedSince";
var _INM = "IfNoneMatch";
var _IUS = "IfUnmodifiedSince";
var _LM = "LastModified";
var _MM = "MissingMeta";
var _OLLHS = "ObjectLockLegalHoldStatus";
var _OLM = "ObjectLockMode";
var _OLRUD = "ObjectLockRetainUntilDate";
var _PC = "PartsCount";
var _PN = "PartNumber";
var _R = "Range";
var _RC = "RequestCharged";
var _RCC = "ResponseCacheControl";
var _RCD = "ResponseContentDisposition";
var _RCE = "ResponseContentEncoding";
var _RCL = "ResponseContentLanguage";
var _RCT = "ResponseContentType";
var _RE = "ResponseExpires";
var _RP = "RequestPayer";
var _RSe = "ReplicationStatus";
var _Re = "Restore";
var _SAK = "SecretAccessKey";
var _SC = "StorageClass";
var _SM = "SessionMode";
var _SSE = "ServerSideEncryption";
var _SSECA = "SSECustomerAlgorithm";
var _SSECK = "SSECustomerKey";
var _SSECKMD = "SSECustomerKeyMD5";
var _SSEKMSEC = "SSEKMSEncryptionContext";
var _SSEKMSKI = "SSEKMSKeyId";
var _ST = "SessionToken";
var _Si = "Size";
var _T = "Tagging";
var _TC = "TagCount";
var _VI = "VersionId";
var _WOB = "WriteOffsetBytes";
var _WRL = "WebsiteRedirectLocation";
var _ar = "accept-ranges";
var _cc = "cache-control";
var _cd = "content-disposition";
var _ce = "content-encoding";
var _cl = "content-language";
var _cl_ = "content-length";
var _cm = "content-md5";
var _cr = "content-range";
var _ct = "content-type";
var _e = "expires";
var _eta = "etag";
var _ex = "expiresstring";
var _im = "if-match";
var _ims = "if-modified-since";
var _inm = "if-none-match";
var _ius = "if-unmodified-since";
var _lm = "last-modified";
var _pN = "partNumber";
var _ra = "range";
var _rcc = "response-cache-control";
var _rcd = "response-content-disposition";
var _rce = "response-content-encoding";
var _rcl = "response-content-language";
var _rct = "response-content-type";
var _re = "response-expires";
var _s = "session";
var _vI = "versionId";
var _xaa = "x-amz-acl";
var _xacc = "x-amz-checksum-crc32";
var _xacc_ = "x-amz-checksum-crc32c";
var _xacc__ = "x-amz-checksum-crc64nvme";
var _xacm = "x-amz-checksum-mode";
var _xacs = "x-amz-checksum-sha1";
var _xacs_ = "x-amz-checksum-sha256";
var _xacsm = "x-amz-create-session-mode";
var _xact = "x-amz-checksum-type";
var _xadm = "x-amz-delete-marker";
var _xae = "x-amz-expiration";
var _xaebo = "x-amz-expected-bucket-owner";
var _xagfc = "x-amz-grant-full-control";
var _xagr = "x-amz-grant-read";
var _xagra = "x-amz-grant-read-acp";
var _xagwa = "x-amz-grant-write-acp";
var _xamm = "x-amz-missing-meta";
var _xampc = "x-amz-mp-parts-count";
var _xaollh = "x-amz-object-lock-legal-hold";
var _xaolm = "x-amz-object-lock-mode";
var _xaolrud = "x-amz-object-lock-retain-until-date";
var _xaos = "x-amz-object-size";
var _xar = "x-amz-restore";
var _xarc = "x-amz-request-charged";
var _xarp = "x-amz-request-payer";
var _xars_ = "x-amz-replication-status";
var _xasc = "x-amz-storage-class";
var _xasca = "x-amz-sdk-checksum-algorithm";
var _xasse = "x-amz-server-side-encryption";
var _xasseakki = "x-amz-server-side-encryption-aws-kms-key-id";
var _xassebke = "x-amz-server-side-encryption-bucket-key-enabled";
var _xassec = "x-amz-server-side-encryption-context";
var _xasseca = "x-amz-server-side-encryption-customer-algorithm";
var _xasseck = "x-amz-server-side-encryption-customer-key";
var _xasseckm = "x-amz-server-side-encryption-customer-key-md5";
var _xat = "x-amz-tagging";
var _xatc = "x-amz-tagging-count";
var _xavi = "x-amz-version-id";
var _xawob = "x-amz-write-offset-bytes";
var _xawrl = "x-amz-website-redirect-location";
var _xi = "x-id";

// node_modules/@aws-sdk/client-s3/dist-es/commands/CreateSessionCommand.js
class CreateSessionCommand extends import_smithy_client97.Command.classBuilder().ep({
  ...commonParams4,
  DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
  Bucket: { type: "contextParams", name: "Bucket" }
}).m(function(Command, cs2, config, o5) {
  return [
    import_middleware_serde63.getSerdePlugin(config, this.serialize, this.deserialize),
    import_middleware_endpoint67.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    getThrow200ExceptionsPlugin(config)
  ];
}).s("AmazonS3", "CreateSession", {}).n("S3Client", "CreateSessionCommand").f(CreateSessionRequestFilterSensitiveLog, CreateSessionOutputFilterSensitiveLog).ser(se_CreateSessionCommand).de(de_CreateSessionCommand).build() {
}
// node_modules/@aws-sdk/client-s3/package.json
var package_default4 = {
  name: "@aws-sdk/client-s3",
  description: "AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native",
  version: "3.914.0",
  scripts: {
    build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline client-s3",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo s3",
    test: "yarn g:vitest run",
    "test:browser": "node ./test/browser-build/esbuild && yarn g:vitest run -c vitest.config.browser.mts",
    "test:browser:watch": "node ./test/browser-build/esbuild && yarn g:vitest watch -c vitest.config.browser.mts",
    "test:e2e": "yarn g:vitest run -c vitest.config.e2e.mts && yarn test:browser",
    "test:e2e:watch": "yarn g:vitest watch -c vitest.config.e2e.mts",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts",
    "test:watch": "yarn g:vitest watch"
  },
  main: "./dist-cjs/index.js",
  types: "./dist-types/index.d.ts",
  module: "./dist-es/index.js",
  sideEffects: false,
  dependencies: {
    "@aws-crypto/sha1-browser": "5.2.0",
    "@aws-crypto/sha256-browser": "5.2.0",
    "@aws-crypto/sha256-js": "5.2.0",
    "@aws-sdk/core": "3.914.0",
    "@aws-sdk/credential-provider-node": "3.914.0",
    "@aws-sdk/middleware-bucket-endpoint": "3.914.0",
    "@aws-sdk/middleware-expect-continue": "3.914.0",
    "@aws-sdk/middleware-flexible-checksums": "3.914.0",
    "@aws-sdk/middleware-host-header": "3.914.0",
    "@aws-sdk/middleware-location-constraint": "3.914.0",
    "@aws-sdk/middleware-logger": "3.914.0",
    "@aws-sdk/middleware-recursion-detection": "3.914.0",
    "@aws-sdk/middleware-sdk-s3": "3.914.0",
    "@aws-sdk/middleware-ssec": "3.914.0",
    "@aws-sdk/middleware-user-agent": "3.914.0",
    "@aws-sdk/region-config-resolver": "3.914.0",
    "@aws-sdk/signature-v4-multi-region": "3.914.0",
    "@aws-sdk/types": "3.914.0",
    "@aws-sdk/util-endpoints": "3.914.0",
    "@aws-sdk/util-user-agent-browser": "3.914.0",
    "@aws-sdk/util-user-agent-node": "3.914.0",
    "@aws-sdk/xml-builder": "3.914.0",
    "@smithy/config-resolver": "^4.4.0",
    "@smithy/core": "^3.17.0",
    "@smithy/eventstream-serde-browser": "^4.2.3",
    "@smithy/eventstream-serde-config-resolver": "^4.3.3",
    "@smithy/eventstream-serde-node": "^4.2.3",
    "@smithy/fetch-http-handler": "^5.3.4",
    "@smithy/hash-blob-browser": "^4.2.4",
    "@smithy/hash-node": "^4.2.3",
    "@smithy/hash-stream-node": "^4.2.3",
    "@smithy/invalid-dependency": "^4.2.3",
    "@smithy/md5-js": "^4.2.3",
    "@smithy/middleware-content-length": "^4.2.3",
    "@smithy/middleware-endpoint": "^4.3.4",
    "@smithy/middleware-retry": "^4.4.4",
    "@smithy/middleware-serde": "^4.2.3",
    "@smithy/middleware-stack": "^4.2.3",
    "@smithy/node-config-provider": "^4.3.3",
    "@smithy/node-http-handler": "^4.4.2",
    "@smithy/protocol-http": "^5.3.3",
    "@smithy/smithy-client": "^4.9.0",
    "@smithy/types": "^4.8.0",
    "@smithy/url-parser": "^4.2.3",
    "@smithy/util-base64": "^4.3.0",
    "@smithy/util-body-length-browser": "^4.2.0",
    "@smithy/util-body-length-node": "^4.2.1",
    "@smithy/util-defaults-mode-browser": "^4.3.3",
    "@smithy/util-defaults-mode-node": "^4.2.5",
    "@smithy/util-endpoints": "^3.2.3",
    "@smithy/util-middleware": "^4.2.3",
    "@smithy/util-retry": "^4.2.3",
    "@smithy/util-stream": "^4.5.3",
    "@smithy/util-utf8": "^4.2.0",
    "@smithy/util-waiter": "^4.2.3",
    "@smithy/uuid": "^1.1.0",
    tslib: "^2.6.2"
  },
  devDependencies: {
    "@aws-sdk/signature-v4-crt": "3.914.0",
    "@tsconfig/node18": "18.2.4",
    "@types/node": "^18.19.69",
    concurrently: "7.0.0",
    "downlevel-dts": "0.10.1",
    rimraf: "3.0.2",
    typescript: "~5.8.3"
  },
  engines: {
    node: ">=18.0.0"
  },
  typesVersions: {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  files: [
    "dist-*/**"
  ],
  author: {
    name: "AWS SDK for JavaScript Team",
    url: "https://aws.amazon.com/javascript/"
  },
  license: "Apache-2.0",
  browser: {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3",
  repository: {
    type: "git",
    url: "https://github.com/aws/aws-sdk-js-v3.git",
    directory: "clients/client-s3"
  }
};

// node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.js
init_dist_es12();
var import_core41 = __toESM(require_dist_cjs30(), 1);

// node_modules/@aws-sdk/middleware-bucket-endpoint/dist-es/NodeUseArnRegionConfigOptions.js
var import_util_config_provider2 = __toESM(require_dist_cjs32(), 1);
var NODE_USE_ARN_REGION_ENV_NAME = "AWS_S3_USE_ARN_REGION";
var NODE_USE_ARN_REGION_INI_NAME = "s3_use_arn_region";
var NODE_USE_ARN_REGION_CONFIG_OPTIONS = {
  environmentVariableSelector: (env3) => import_util_config_provider2.booleanSelector(env3, NODE_USE_ARN_REGION_ENV_NAME, import_util_config_provider2.SelectorType.ENV),
  configFileSelector: (profile) => import_util_config_provider2.booleanSelector(profile, NODE_USE_ARN_REGION_INI_NAME, import_util_config_provider2.SelectorType.CONFIG),
  default: undefined
};

// node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.js
var import_util_user_agent_node4 = __toESM(require_dist_cjs41(), 1);
var import_config_resolver7 = __toESM(require_dist_cjs33(), 1);

// node_modules/@smithy/eventstream-codec/dist-es/HeaderMarshaller.js
var import_util_hex_encoding2 = __toESM(require_dist_cjs16(), 1);

// node_modules/@smithy/eventstream-codec/dist-es/Int64.js
var import_util_hex_encoding = __toESM(require_dist_cjs16(), 1);

class Int64 {
  bytes;
  constructor(bytes) {
    this.bytes = bytes;
    if (bytes.byteLength !== 8) {
      throw new Error("Int64 buffers must be exactly 8 bytes");
    }
  }
  static fromNumber(number) {
    if (number > 9223372036854776000 || number < -9223372036854776000) {
      throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
    }
    const bytes = new Uint8Array(8);
    for (let i6 = 7, remaining = Math.abs(Math.round(number));i6 > -1 && remaining > 0; i6--, remaining /= 256) {
      bytes[i6] = remaining;
    }
    if (number < 0) {
      negate(bytes);
    }
    return new Int64(bytes);
  }
  valueOf() {
    const bytes = this.bytes.slice(0);
    const negative = bytes[0] & 128;
    if (negative) {
      negate(bytes);
    }
    return parseInt(import_util_hex_encoding.toHex(bytes), 16) * (negative ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
}
function negate(bytes) {
  for (let i6 = 0;i6 < 8; i6++) {
    bytes[i6] ^= 255;
  }
  for (let i6 = 7;i6 > -1; i6--) {
    bytes[i6]++;
    if (bytes[i6] !== 0)
      break;
  }
}

// node_modules/@smithy/eventstream-codec/dist-es/HeaderMarshaller.js
class HeaderMarshaller {
  toUtf8;
  fromUtf8;
  constructor(toUtf85, fromUtf87) {
    this.toUtf8 = toUtf85;
    this.fromUtf8 = fromUtf87;
  }
  format(headers) {
    const chunks = [];
    for (const headerName of Object.keys(headers)) {
      const bytes = this.fromUtf8(headerName);
      chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
    }
    const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
    let position = 0;
    for (const chunk of chunks) {
      out.set(chunk, position);
      position += chunk.byteLength;
    }
    return out;
  }
  formatHeaderValue(header) {
    switch (header.type) {
      case "boolean":
        return Uint8Array.from([header.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, header.value]);
      case "short":
        const shortView = new DataView(new ArrayBuffer(3));
        shortView.setUint8(0, 3);
        shortView.setInt16(1, header.value, false);
        return new Uint8Array(shortView.buffer);
      case "integer":
        const intView = new DataView(new ArrayBuffer(5));
        intView.setUint8(0, 4);
        intView.setInt32(1, header.value, false);
        return new Uint8Array(intView.buffer);
      case "long":
        const longBytes = new Uint8Array(9);
        longBytes[0] = 5;
        longBytes.set(header.value.bytes, 1);
        return longBytes;
      case "binary":
        const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
        binView.setUint8(0, 6);
        binView.setUint16(1, header.value.byteLength, false);
        const binBytes = new Uint8Array(binView.buffer);
        binBytes.set(header.value, 3);
        return binBytes;
      case "string":
        const utf8Bytes = this.fromUtf8(header.value);
        const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
        strView.setUint8(0, 7);
        strView.setUint16(1, utf8Bytes.byteLength, false);
        const strBytes = new Uint8Array(strView.buffer);
        strBytes.set(utf8Bytes, 3);
        return strBytes;
      case "timestamp":
        const tsBytes = new Uint8Array(9);
        tsBytes[0] = 8;
        tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
        return tsBytes;
      case "uuid":
        if (!UUID_PATTERN.test(header.value)) {
          throw new Error(`Invalid UUID received: ${header.value}`);
        }
        const uuidBytes = new Uint8Array(17);
        uuidBytes[0] = 9;
        uuidBytes.set(import_util_hex_encoding2.fromHex(header.value.replace(/\-/g, "")), 1);
        return uuidBytes;
    }
  }
  parse(headers) {
    const out = {};
    let position = 0;
    while (position < headers.byteLength) {
      const nameLength = headers.getUint8(position++);
      const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));
      position += nameLength;
      switch (headers.getUint8(position++)) {
        case 0:
          out[name] = {
            type: BOOLEAN_TAG,
            value: true
          };
          break;
        case 1:
          out[name] = {
            type: BOOLEAN_TAG,
            value: false
          };
          break;
        case 2:
          out[name] = {
            type: BYTE_TAG,
            value: headers.getInt8(position++)
          };
          break;
        case 3:
          out[name] = {
            type: SHORT_TAG,
            value: headers.getInt16(position, false)
          };
          position += 2;
          break;
        case 4:
          out[name] = {
            type: INT_TAG,
            value: headers.getInt32(position, false)
          };
          position += 4;
          break;
        case 5:
          out[name] = {
            type: LONG_TAG,
            value: new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8))
          };
          position += 8;
          break;
        case 6:
          const binaryLength = headers.getUint16(position, false);
          position += 2;
          out[name] = {
            type: BINARY_TAG,
            value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength)
          };
          position += binaryLength;
          break;
        case 7:
          const stringLength = headers.getUint16(position, false);
          position += 2;
          out[name] = {
            type: STRING_TAG,
            value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength))
          };
          position += stringLength;
          break;
        case 8:
          out[name] = {
            type: TIMESTAMP_TAG,
            value: new Date(new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf())
          };
          position += 8;
          break;
        case 9:
          const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);
          position += 16;
          out[name] = {
            type: UUID_TAG,
            value: `${import_util_hex_encoding2.toHex(uuidBytes.subarray(0, 4))}-${import_util_hex_encoding2.toHex(uuidBytes.subarray(4, 6))}-${import_util_hex_encoding2.toHex(uuidBytes.subarray(6, 8))}-${import_util_hex_encoding2.toHex(uuidBytes.subarray(8, 10))}-${import_util_hex_encoding2.toHex(uuidBytes.subarray(10))}`
          };
          break;
        default:
          throw new Error(`Unrecognized header type tag`);
      }
    }
    return out;
  }
}
var HEADER_VALUE_TYPE;
(function(HEADER_VALUE_TYPE2) {
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolTrue"] = 0] = "boolTrue";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["boolFalse"] = 1] = "boolFalse";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byte"] = 2] = "byte";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["short"] = 3] = "short";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["integer"] = 4] = "integer";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["long"] = 5] = "long";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["byteArray"] = 6] = "byteArray";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["string"] = 7] = "string";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["timestamp"] = 8] = "timestamp";
  HEADER_VALUE_TYPE2[HEADER_VALUE_TYPE2["uuid"] = 9] = "uuid";
})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
var BOOLEAN_TAG = "boolean";
var BYTE_TAG = "byte";
var SHORT_TAG = "short";
var INT_TAG = "integer";
var LONG_TAG = "long";
var BINARY_TAG = "binary";
var STRING_TAG = "string";
var TIMESTAMP_TAG = "timestamp";
var UUID_TAG = "uuid";
var UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;

// node_modules/@smithy/eventstream-codec/dist-es/splitMessage.js
var PRELUDE_MEMBER_LENGTH = 4;
var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
var CHECKSUM_LENGTH = 4;
var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
function splitMessage({ byteLength, byteOffset, buffer }) {
  if (byteLength < MINIMUM_MESSAGE_LENGTH) {
    throw new Error("Provided message too short to accommodate event stream message overhead");
  }
  const view = new DataView(buffer, byteOffset, byteLength);
  const messageLength = view.getUint32(0, false);
  if (byteLength !== messageLength) {
    throw new Error("Reported message length does not match received message length");
  }
  const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);
  const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);
  const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);
  const checksummer = new Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));
  if (expectedPreludeChecksum !== checksummer.digest()) {
    throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);
  }
  checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));
  if (expectedMessageChecksum !== checksummer.digest()) {
    throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);
  }
  return {
    headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),
    body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))
  };
}

// node_modules/@smithy/eventstream-codec/dist-es/EventStreamCodec.js
class EventStreamCodec {
  headerMarshaller;
  messageBuffer;
  isEndOfStream;
  constructor(toUtf85, fromUtf87) {
    this.headerMarshaller = new HeaderMarshaller(toUtf85, fromUtf87);
    this.messageBuffer = [];
    this.isEndOfStream = false;
  }
  feed(message) {
    this.messageBuffer.push(this.decode(message));
  }
  endOfStream() {
    this.isEndOfStream = true;
  }
  getMessage() {
    const message = this.messageBuffer.pop();
    const isEndOfStream = this.isEndOfStream;
    return {
      getMessage() {
        return message;
      },
      isEndOfStream() {
        return isEndOfStream;
      }
    };
  }
  getAvailableMessages() {
    const messages = this.messageBuffer;
    this.messageBuffer = [];
    const isEndOfStream = this.isEndOfStream;
    return {
      getMessages() {
        return messages;
      },
      isEndOfStream() {
        return isEndOfStream;
      }
    };
  }
  encode({ headers: rawHeaders, body }) {
    const headers = this.headerMarshaller.format(rawHeaders);
    const length = headers.byteLength + body.byteLength + 16;
    const out = new Uint8Array(length);
    const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    const checksum2 = new Crc32;
    view.setUint32(0, length, false);
    view.setUint32(4, headers.byteLength, false);
    view.setUint32(8, checksum2.update(out.subarray(0, 8)).digest(), false);
    out.set(headers, 12);
    out.set(body, headers.byteLength + 12);
    view.setUint32(length - 4, checksum2.update(out.subarray(8, length - 4)).digest(), false);
    return out;
  }
  decode(message) {
    const { headers, body } = splitMessage(message);
    return { headers: this.headerMarshaller.parse(headers), body };
  }
  formatHeaders(rawHeaders) {
    return this.headerMarshaller.format(rawHeaders);
  }
}

// node_modules/@smithy/eventstream-codec/dist-es/MessageDecoderStream.js
class MessageDecoderStream {
  options;
  constructor(options) {
    this.options = options;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async* asyncIterator() {
    for await (const bytes of this.options.inputStream) {
      const decoded = this.options.decoder.decode(bytes);
      yield decoded;
    }
  }
}

// node_modules/@smithy/eventstream-codec/dist-es/MessageEncoderStream.js
class MessageEncoderStream {
  options;
  constructor(options) {
    this.options = options;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async* asyncIterator() {
    for await (const msg of this.options.messageStream) {
      const encoded = this.options.encoder.encode(msg);
      yield encoded;
    }
    if (this.options.includeEndFrame) {
      yield new Uint8Array(0);
    }
  }
}

// node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageDecoderStream.js
class SmithyMessageDecoderStream {
  options;
  constructor(options) {
    this.options = options;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async* asyncIterator() {
    for await (const message of this.options.messageStream) {
      const deserialized = await this.options.deserializer(message);
      if (deserialized === undefined)
        continue;
      yield deserialized;
    }
  }
}

// node_modules/@smithy/eventstream-codec/dist-es/SmithyMessageEncoderStream.js
class SmithyMessageEncoderStream {
  options;
  constructor(options) {
    this.options = options;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async* asyncIterator() {
    for await (const chunk of this.options.inputStream) {
      const payloadBuf = this.options.serializer(chunk);
      yield payloadBuf;
    }
  }
}

// node_modules/@smithy/eventstream-serde-universal/dist-es/getChunkedStream.js
function getChunkedStream(source) {
  let currentMessageTotalLength = 0;
  let currentMessagePendingLength = 0;
  let currentMessage = null;
  let messageLengthBuffer = null;
  const allocateMessage = (size) => {
    if (typeof size !== "number") {
      throw new Error("Attempted to allocate an event message where size was not a number: " + size);
    }
    currentMessageTotalLength = size;
    currentMessagePendingLength = 4;
    currentMessage = new Uint8Array(size);
    const currentMessageView = new DataView(currentMessage.buffer);
    currentMessageView.setUint32(0, size, false);
  };
  const iterator = async function* () {
    const sourceIterator = source[Symbol.asyncIterator]();
    while (true) {
      const { value, done } = await sourceIterator.next();
      if (done) {
        if (!currentMessageTotalLength) {
          return;
        } else if (currentMessageTotalLength === currentMessagePendingLength) {
          yield currentMessage;
        } else {
          throw new Error("Truncated event message received.");
        }
        return;
      }
      const chunkLength = value.length;
      let currentOffset = 0;
      while (currentOffset < chunkLength) {
        if (!currentMessage) {
          const bytesRemaining = chunkLength - currentOffset;
          if (!messageLengthBuffer) {
            messageLengthBuffer = new Uint8Array(4);
          }
          const numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);
          messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);
          currentMessagePendingLength += numBytesForTotal;
          currentOffset += numBytesForTotal;
          if (currentMessagePendingLength < 4) {
            break;
          }
          allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));
          messageLengthBuffer = null;
        }
        const numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);
        currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);
        currentMessagePendingLength += numBytesToWrite;
        currentOffset += numBytesToWrite;
        if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {
          yield currentMessage;
          currentMessage = null;
          currentMessageTotalLength = 0;
          currentMessagePendingLength = 0;
        }
      }
    }
  };
  return {
    [Symbol.asyncIterator]: iterator
  };
}

// node_modules/@smithy/eventstream-serde-universal/dist-es/getUnmarshalledStream.js
function getMessageUnmarshaller(deserializer, toUtf85) {
  return async function(message) {
    const { value: messageType } = message.headers[":message-type"];
    if (messageType === "error") {
      const unmodeledError = new Error(message.headers[":error-message"].value || "UnknownError");
      unmodeledError.name = message.headers[":error-code"].value;
      throw unmodeledError;
    } else if (messageType === "exception") {
      const code = message.headers[":exception-type"].value;
      const exception = { [code]: message };
      const deserializedException = await deserializer(exception);
      if (deserializedException.$unknown) {
        const error = new Error(toUtf85(message.body));
        error.name = code;
        throw error;
      }
      throw deserializedException[code];
    } else if (messageType === "event") {
      const event = {
        [message.headers[":event-type"].value]: message
      };
      const deserialized = await deserializer(event);
      if (deserialized.$unknown)
        return;
      return deserialized;
    } else {
      throw Error(`Unrecognizable event type: ${message.headers[":event-type"].value}`);
    }
  };
}

// node_modules/@smithy/eventstream-serde-universal/dist-es/EventStreamMarshaller.js
class EventStreamMarshaller {
  eventStreamCodec;
  utfEncoder;
  constructor({ utf8Encoder, utf8Decoder }) {
    this.eventStreamCodec = new EventStreamCodec(utf8Encoder, utf8Decoder);
    this.utfEncoder = utf8Encoder;
  }
  deserialize(body, deserializer) {
    const inputStream = getChunkedStream(body);
    return new SmithyMessageDecoderStream({
      messageStream: new MessageDecoderStream({ inputStream, decoder: this.eventStreamCodec }),
      deserializer: getMessageUnmarshaller(deserializer, this.utfEncoder)
    });
  }
  serialize(inputStream, serializer) {
    return new MessageEncoderStream({
      messageStream: new SmithyMessageEncoderStream({ inputStream, serializer }),
      encoder: this.eventStreamCodec,
      includeEndFrame: true
    });
  }
}

// node_modules/@smithy/eventstream-serde-node/dist-es/EventStreamMarshaller.js
import { Readable as Readable2 } from "stream";

// node_modules/@smithy/eventstream-serde-node/dist-es/utils.js
async function* readabletoIterable(readStream) {
  let streamEnded = false;
  let generationEnded = false;
  const records = new Array;
  readStream.on("error", (err3) => {
    if (!streamEnded) {
      streamEnded = true;
    }
    if (err3) {
      throw err3;
    }
  });
  readStream.on("data", (data) => {
    records.push(data);
  });
  readStream.on("end", () => {
    streamEnded = true;
  });
  while (!generationEnded) {
    const value = await new Promise((resolve) => setTimeout(() => resolve(records.shift()), 0));
    if (value) {
      yield value;
    }
    generationEnded = streamEnded && records.length === 0;
  }
}

// node_modules/@smithy/eventstream-serde-node/dist-es/EventStreamMarshaller.js
class EventStreamMarshaller2 {
  universalMarshaller;
  constructor({ utf8Encoder, utf8Decoder }) {
    this.universalMarshaller = new EventStreamMarshaller({
      utf8Decoder,
      utf8Encoder
    });
  }
  deserialize(body, deserializer) {
    const bodyIterable = typeof body[Symbol.asyncIterator] === "function" ? body : readabletoIterable(body);
    return this.universalMarshaller.deserialize(bodyIterable, deserializer);
  }
  serialize(input, serializer) {
    return Readable2.from(this.universalMarshaller.serialize(input, serializer));
  }
}

// node_modules/@smithy/eventstream-serde-node/dist-es/provider.js
var eventStreamSerdeProvider = (options) => new EventStreamMarshaller2(options);

// node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.js
var import_hash_node4 = __toESM(require_dist_cjs42(), 1);

// node_modules/@smithy/hash-stream-node/dist-es/HashCalculator.js
var import_util_utf86 = __toESM(require_dist_cjs10(), 1);
import { Writable } from "stream";

class HashCalculator extends Writable {
  hash;
  constructor(hash2, options) {
    super(options);
    this.hash = hash2;
  }
  _write(chunk, encoding, callback) {
    try {
      this.hash.update(import_util_utf86.toUint8Array(chunk));
    } catch (err3) {
      return callback(err3);
    }
    callback();
  }
}

// node_modules/@smithy/hash-stream-node/dist-es/readableStreamHasher.js
var readableStreamHasher = (hashCtor, readableStream) => {
  if (readableStream.readableFlowing !== null) {
    throw new Error("Unable to calculate hash for flowing readable stream");
  }
  const hash2 = new hashCtor;
  const hashCalculator = new HashCalculator(hash2);
  readableStream.pipe(hashCalculator);
  return new Promise((resolve, reject) => {
    readableStream.on("error", (err3) => {
      hashCalculator.end();
      reject(err3);
    });
    hashCalculator.on("error", reject);
    hashCalculator.on("finish", () => {
      hash2.digest().then(resolve).catch(reject);
    });
  });
};

// node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.js
var import_middleware_retry7 = __toESM(require_dist_cjs40(), 1);
var import_node_config_provider6 = __toESM(require_dist_cjs36(), 1);
var import_node_http_handler5 = __toESM(require_dist_cjs14(), 1);
var import_util_body_length_node4 = __toESM(require_dist_cjs43(), 1);
var import_util_retry4 = __toESM(require_dist_cjs39(), 1);

// node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.shared.js
var import_core40 = __toESM(require_dist_cjs30(), 1);
var import_smithy_client98 = __toESM(require_dist_cjs28(), 1);
var import_url_parser5 = __toESM(require_dist_cjs22(), 1);
var import_util_base644 = __toESM(require_dist_cjs11(), 1);
var import_util_stream5 = __toESM(require_dist_cjs17(), 1);
var import_util_utf87 = __toESM(require_dist_cjs10(), 1);
var getRuntimeConfig7 = (config) => {
  return {
    apiVersion: "2006-03-01",
    base64Decoder: config?.base64Decoder ?? import_util_base644.fromBase64,
    base64Encoder: config?.base64Encoder ?? import_util_base644.toBase64,
    disableHostPrefix: config?.disableHostPrefix ?? false,
    endpointProvider: config?.endpointProvider ?? defaultEndpointResolver4,
    extensions: config?.extensions ?? [],
    getAwsChunkedEncodingStream: config?.getAwsChunkedEncodingStream ?? import_util_stream5.getAwsChunkedEncodingStream,
    httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultS3HttpAuthSchemeProvider,
    httpAuthSchemes: config?.httpAuthSchemes ?? [
      {
        schemeId: "aws.auth#sigv4",
        identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
        signer: new import_core40.AwsSdkSigV4Signer
      },
      {
        schemeId: "aws.auth#sigv4a",
        identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4a"),
        signer: new import_core40.AwsSdkSigV4ASigner
      }
    ],
    logger: config?.logger ?? new import_smithy_client98.NoOpLogger,
    sdkStreamMixin: config?.sdkStreamMixin ?? import_util_stream5.sdkStreamMixin,
    serviceId: config?.serviceId ?? "S3",
    signerConstructor: config?.signerConstructor ?? SignatureV4MultiRegion,
    signingEscapePath: config?.signingEscapePath ?? false,
    urlParser: config?.urlParser ?? import_url_parser5.parseUrl,
    useArnRegion: config?.useArnRegion ?? undefined,
    utf8Decoder: config?.utf8Decoder ?? import_util_utf87.fromUtf8,
    utf8Encoder: config?.utf8Encoder ?? import_util_utf87.toUtf8
  };
};

// node_modules/@aws-sdk/client-s3/dist-es/runtimeConfig.js
var import_smithy_client99 = __toESM(require_dist_cjs28(), 1);
var import_util_defaults_mode_node4 = __toESM(require_dist_cjs44(), 1);
var import_smithy_client100 = __toESM(require_dist_cjs28(), 1);
var getRuntimeConfig8 = (config) => {
  import_smithy_client100.emitWarningIfUnsupportedVersion(process.version);
  const defaultsMode = import_util_defaults_mode_node4.resolveDefaultsModeConfig(config);
  const defaultConfigProvider = () => defaultsMode().then(import_smithy_client99.loadConfigsForDefaultMode);
  const clientSharedValues = getRuntimeConfig7(config);
  import_core41.emitWarningIfUnsupportedVersion(process.version);
  const loaderConfig = {
    profile: config?.profile,
    logger: clientSharedValues.logger
  };
  return {
    ...clientSharedValues,
    ...config,
    runtime: "node",
    defaultsMode,
    authSchemePreference: config?.authSchemePreference ?? import_node_config_provider6.loadConfig(import_core41.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
    bodyLengthChecker: config?.bodyLengthChecker ?? import_util_body_length_node4.calculateBodyLength,
    credentialDefaultProvider: config?.credentialDefaultProvider ?? defaultProvider,
    defaultUserAgentProvider: config?.defaultUserAgentProvider ?? import_util_user_agent_node4.createDefaultUserAgentProvider({ serviceId: clientSharedValues.serviceId, clientVersion: package_default4.version }),
    disableS3ExpressSessionAuth: config?.disableS3ExpressSessionAuth ?? import_node_config_provider6.loadConfig(NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS, loaderConfig),
    eventStreamSerdeProvider: config?.eventStreamSerdeProvider ?? eventStreamSerdeProvider,
    maxAttempts: config?.maxAttempts ?? import_node_config_provider6.loadConfig(import_middleware_retry7.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
    md5: config?.md5 ?? import_hash_node4.Hash.bind(null, "md5"),
    region: config?.region ?? import_node_config_provider6.loadConfig(import_config_resolver7.NODE_REGION_CONFIG_OPTIONS, { ...import_config_resolver7.NODE_REGION_CONFIG_FILE_OPTIONS, ...loaderConfig }),
    requestChecksumCalculation: config?.requestChecksumCalculation ?? import_node_config_provider6.loadConfig(NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS, loaderConfig),
    requestHandler: import_node_http_handler5.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
    responseChecksumValidation: config?.responseChecksumValidation ?? import_node_config_provider6.loadConfig(NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS, loaderConfig),
    retryMode: config?.retryMode ?? import_node_config_provider6.loadConfig({
      ...import_middleware_retry7.NODE_RETRY_MODE_CONFIG_OPTIONS,
      default: async () => (await defaultConfigProvider()).retryMode || import_util_retry4.DEFAULT_RETRY_MODE
    }, config),
    sha1: config?.sha1 ?? import_hash_node4.Hash.bind(null, "sha1"),
    sha256: config?.sha256 ?? import_hash_node4.Hash.bind(null, "sha256"),
    sigv4aSigningRegionSet: config?.sigv4aSigningRegionSet ?? import_node_config_provider6.loadConfig(import_core41.NODE_SIGV4A_CONFIG_OPTIONS, loaderConfig),
    streamCollector: config?.streamCollector ?? import_node_http_handler5.streamCollector,
    streamHasher: config?.streamHasher ?? readableStreamHasher,
    useArnRegion: config?.useArnRegion ?? import_node_config_provider6.loadConfig(NODE_USE_ARN_REGION_CONFIG_OPTIONS, loaderConfig),
    useDualstackEndpoint: config?.useDualstackEndpoint ?? import_node_config_provider6.loadConfig(import_config_resolver7.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
    useFipsEndpoint: config?.useFipsEndpoint ?? import_node_config_provider6.loadConfig(import_config_resolver7.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
    userAgentAppId: config?.userAgentAppId ?? import_node_config_provider6.loadConfig(import_util_user_agent_node4.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
  };
};

// node_modules/@aws-sdk/client-s3/dist-es/runtimeExtensions.js
var import_region_config_resolver4 = __toESM(require_dist_cjs45(), 1);
var import_protocol_http15 = __toESM(require_dist_cjs3(), 1);
var import_smithy_client101 = __toESM(require_dist_cjs28(), 1);

// node_modules/@aws-sdk/client-s3/dist-es/auth/httpAuthExtensionConfiguration.js
var getHttpAuthExtensionConfiguration4 = (runtimeConfig) => {
  const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
  let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
  let _credentials = runtimeConfig.credentials;
  return {
    setHttpAuthScheme(httpAuthScheme) {
      const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
      if (index === -1) {
        _httpAuthSchemes.push(httpAuthScheme);
      } else {
        _httpAuthSchemes.splice(index, 1, httpAuthScheme);
      }
    },
    httpAuthSchemes() {
      return _httpAuthSchemes;
    },
    setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
      _httpAuthSchemeProvider = httpAuthSchemeProvider;
    },
    httpAuthSchemeProvider() {
      return _httpAuthSchemeProvider;
    },
    setCredentials(credentials) {
      _credentials = credentials;
    },
    credentials() {
      return _credentials;
    }
  };
};
var resolveHttpAuthRuntimeConfig4 = (config) => {
  return {
    httpAuthSchemes: config.httpAuthSchemes(),
    httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
    credentials: config.credentials()
  };
};

// node_modules/@aws-sdk/client-s3/dist-es/runtimeExtensions.js
var resolveRuntimeExtensions4 = (runtimeConfig, extensions2) => {
  const extensionConfiguration = Object.assign(import_region_config_resolver4.getAwsRegionExtensionConfiguration(runtimeConfig), import_smithy_client101.getDefaultExtensionConfiguration(runtimeConfig), import_protocol_http15.getHttpHandlerExtensionConfiguration(runtimeConfig), getHttpAuthExtensionConfiguration4(runtimeConfig));
  extensions2.forEach((extension) => extension.configure(extensionConfiguration));
  return Object.assign(runtimeConfig, import_region_config_resolver4.resolveAwsRegionExtensionConfiguration(extensionConfiguration), import_smithy_client101.resolveDefaultRuntimeConfig(extensionConfiguration), import_protocol_http15.resolveHttpHandlerRuntimeConfig(extensionConfiguration), resolveHttpAuthRuntimeConfig4(extensionConfiguration));
};

// node_modules/@aws-sdk/client-s3/dist-es/S3Client.js
class S3Client extends import_smithy_client102.Client {
  config;
  constructor(...[configuration]) {
    const _config_0 = getRuntimeConfig8(configuration || {});
    super(_config_0);
    this.initConfig = _config_0;
    const _config_1 = resolveClientEndpointParameters4(_config_0);
    const _config_2 = import_middleware_user_agent4.resolveUserAgentConfig(_config_1);
    const _config_3 = resolveFlexibleChecksumsConfig(_config_2);
    const _config_4 = import_middleware_retry8.resolveRetryConfig(_config_3);
    const _config_5 = import_config_resolver8.resolveRegionConfig(_config_4);
    const _config_6 = import_middleware_host_header4.resolveHostHeaderConfig(_config_5);
    const _config_7 = import_middleware_endpoint68.resolveEndpointConfig(_config_6);
    const _config_8 = resolveEventStreamSerdeConfig(_config_7);
    const _config_9 = resolveHttpAuthSchemeConfig4(_config_8);
    const _config_10 = resolveS3Config(_config_9, { session: [() => this, CreateSessionCommand] });
    const _config_11 = resolveRuntimeExtensions4(_config_10, configuration?.extensions || []);
    this.config = _config_11;
    this.middlewareStack.use(import_middleware_user_agent4.getUserAgentPlugin(this.config));
    this.middlewareStack.use(import_middleware_retry8.getRetryPlugin(this.config));
    this.middlewareStack.use(import_middleware_content_length4.getContentLengthPlugin(this.config));
    this.middlewareStack.use(import_middleware_host_header4.getHostHeaderPlugin(this.config));
    this.middlewareStack.use(import_middleware_logger4.getLoggerPlugin(this.config));
    this.middlewareStack.use(import_middleware_recursion_detection4.getRecursionDetectionPlugin(this.config));
    this.middlewareStack.use(import_core42.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
      httpAuthSchemeParametersProvider: defaultS3HttpAuthSchemeParametersProvider,
      identityProviderConfigProvider: async (config) => new import_core42.DefaultIdentityProviderConfig({
        "aws.auth#sigv4": config.credentials,
        "aws.auth#sigv4a": config.credentials
      })
    }));
    this.middlewareStack.use(import_core42.getHttpSigningPlugin(this.config));
    this.middlewareStack.use(getValidateBucketNamePlugin(this.config));
    this.middlewareStack.use(getAddExpectContinuePlugin(this.config));
    this.middlewareStack.use(getRegionRedirectMiddlewarePlugin(this.config));
    this.middlewareStack.use(getS3ExpressPlugin(this.config));
    this.middlewareStack.use(getS3ExpressHttpSigningPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
}

// node_modules/@aws-sdk/middleware-ssec/dist-es/index.js
function ssecMiddleware(options) {
  return (next) => async (args) => {
    const input = { ...args.input };
    const properties = [
      {
        target: "SSECustomerKey",
        hash: "SSECustomerKeyMD5"
      },
      {
        target: "CopySourceSSECustomerKey",
        hash: "CopySourceSSECustomerKeyMD5"
      }
    ];
    for (const prop of properties) {
      const value = input[prop.target];
      if (value) {
        let valueForHash;
        if (typeof value === "string") {
          if (isValidBase64EncodedSSECustomerKey(value, options)) {
            valueForHash = options.base64Decoder(value);
          } else {
            valueForHash = options.utf8Decoder(value);
            input[prop.target] = options.base64Encoder(valueForHash);
          }
        } else {
          valueForHash = ArrayBuffer.isView(value) ? new Uint8Array(value.buffer, value.byteOffset, value.byteLength) : new Uint8Array(value);
          input[prop.target] = options.base64Encoder(valueForHash);
        }
        const hash2 = new options.md5;
        hash2.update(valueForHash);
        input[prop.hash] = options.base64Encoder(await hash2.digest());
      }
    }
    return next({
      ...args,
      input
    });
  };
}
var ssecMiddlewareOptions = {
  name: "ssecMiddleware",
  step: "initialize",
  tags: ["SSE"],
  override: true
};
var getSsecPlugin = (config) => ({
  applyToStack: (clientStack) => {
    clientStack.add(ssecMiddleware(config), ssecMiddlewareOptions);
  }
});
function isValidBase64EncodedSSECustomerKey(str, options) {
  const base64Regex = /^(?:[A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
  if (!base64Regex.test(str))
    return false;
  try {
    const decodedBytes = options.base64Decoder(str);
    return decodedBytes.length === 32;
  } catch {
    return false;
  }
}

// node_modules/@aws-sdk/client-s3/dist-es/commands/GetObjectCommand.js
var import_middleware_endpoint69 = __toESM(require_dist_cjs37(), 1);
var import_middleware_serde64 = __toESM(require_dist_cjs7(), 1);
var import_smithy_client103 = __toESM(require_dist_cjs28(), 1);
class GetObjectCommand extends import_smithy_client103.Command.classBuilder().ep({
  ...commonParams4,
  Bucket: { type: "contextParams", name: "Bucket" },
  Key: { type: "contextParams", name: "Key" }
}).m(function(Command, cs2, config, o5) {
  return [
    import_middleware_serde64.getSerdePlugin(config, this.serialize, this.deserialize),
    import_middleware_endpoint69.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    getFlexibleChecksumsPlugin(config, {
      requestChecksumRequired: false,
      requestValidationModeMember: "ChecksumMode",
      responseAlgorithms: ["CRC64NVME", "CRC32", "CRC32C", "SHA256", "SHA1"]
    }),
    getSsecPlugin(config),
    getS3ExpiresMiddlewarePlugin(config)
  ];
}).s("AmazonS3", "GetObject", {}).n("S3Client", "GetObjectCommand").f(GetObjectRequestFilterSensitiveLog, GetObjectOutputFilterSensitiveLog).ser(se_GetObjectCommand).de(de_GetObjectCommand).build() {
}

// node_modules/@aws-sdk/client-s3/dist-es/commands/PutObjectCommand.js
var import_middleware_endpoint70 = __toESM(require_dist_cjs37(), 1);
var import_middleware_serde65 = __toESM(require_dist_cjs7(), 1);
var import_smithy_client104 = __toESM(require_dist_cjs28(), 1);
class PutObjectCommand extends import_smithy_client104.Command.classBuilder().ep({
  ...commonParams4,
  Bucket: { type: "contextParams", name: "Bucket" },
  Key: { type: "contextParams", name: "Key" }
}).m(function(Command, cs2, config, o5) {
  return [
    import_middleware_serde65.getSerdePlugin(config, this.serialize, this.deserialize),
    import_middleware_endpoint70.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    getFlexibleChecksumsPlugin(config, {
      requestAlgorithmMember: { httpHeader: "x-amz-sdk-checksum-algorithm", name: "ChecksumAlgorithm" },
      requestChecksumRequired: false
    }),
    getCheckContentLengthHeaderPlugin(config),
    getThrow200ExceptionsPlugin(config),
    getSsecPlugin(config)
  ];
}).s("AmazonS3", "PutObject", {}).n("S3Client", "PutObjectCommand").f(PutObjectRequestFilterSensitiveLog, PutObjectOutputFilterSensitiveLog).ser(se_PutObjectCommand).de(de_PutObjectCommand).build() {
}

// node_modules/@aws-sdk/util-format-url/dist-es/index.js
var import_querystring_builder = __toESM(require_dist_cjs13(), 1);
function formatUrl(request2) {
  const { port, query } = request2;
  let { protocol, path, hostname } = request2;
  if (protocol && protocol.slice(-1) !== ":") {
    protocol += ":";
  }
  if (port) {
    hostname += `:${port}`;
  }
  if (path && path.charAt(0) !== "/") {
    path = `/${path}`;
  }
  let queryString = query ? import_querystring_builder.buildQueryString(query) : "";
  if (queryString && queryString[0] !== "?") {
    queryString = `?${queryString}`;
  }
  let auth = "";
  if (request2.username != null || request2.password != null) {
    const username = request2.username ?? "";
    const password = request2.password ?? "";
    auth = `${username}:${password}@`;
  }
  let fragment = "";
  if (request2.fragment) {
    fragment = `#${request2.fragment}`;
  }
  return `${protocol}//${auth}${hostname}${path}${queryString}${fragment}`;
}

// node_modules/@aws-sdk/s3-request-presigner/dist-es/getSignedUrl.js
var import_middleware_endpoint71 = __toESM(require_dist_cjs37(), 1);
var import_protocol_http16 = __toESM(require_dist_cjs3(), 1);

// node_modules/@aws-sdk/s3-request-presigner/dist-es/constants.js
var UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
var SHA256_HEADER = "X-Amz-Content-Sha256";

// node_modules/@aws-sdk/s3-request-presigner/dist-es/presigner.js
class S3RequestPresigner {
  signer;
  constructor(options) {
    const resolvedOptions = {
      service: options.signingName || options.service || "s3",
      uriEscapePath: options.uriEscapePath || false,
      applyChecksum: options.applyChecksum || false,
      ...options
    };
    this.signer = new SignatureV4MultiRegion(resolvedOptions);
  }
  presign(requestToSign, { unsignableHeaders = new Set, hoistableHeaders = new Set, unhoistableHeaders = new Set, ...options } = {}) {
    this.prepareRequest(requestToSign, {
      unsignableHeaders,
      unhoistableHeaders,
      hoistableHeaders
    });
    return this.signer.presign(requestToSign, {
      expiresIn: 900,
      unsignableHeaders,
      unhoistableHeaders,
      ...options
    });
  }
  presignWithCredentials(requestToSign, credentials, { unsignableHeaders = new Set, hoistableHeaders = new Set, unhoistableHeaders = new Set, ...options } = {}) {
    this.prepareRequest(requestToSign, {
      unsignableHeaders,
      unhoistableHeaders,
      hoistableHeaders
    });
    return this.signer.presignWithCredentials(requestToSign, credentials, {
      expiresIn: 900,
      unsignableHeaders,
      unhoistableHeaders,
      ...options
    });
  }
  prepareRequest(requestToSign, { unsignableHeaders = new Set, unhoistableHeaders = new Set, hoistableHeaders = new Set } = {}) {
    unsignableHeaders.add("content-type");
    Object.keys(requestToSign.headers).map((header) => header.toLowerCase()).filter((header) => header.startsWith("x-amz-server-side-encryption")).forEach((header) => {
      if (!hoistableHeaders.has(header)) {
        unhoistableHeaders.add(header);
      }
    });
    requestToSign.headers[SHA256_HEADER] = UNSIGNED_PAYLOAD;
    const currentHostHeader = requestToSign.headers.host;
    const port = requestToSign.port;
    const expectedHostHeader = `${requestToSign.hostname}${requestToSign.port != null ? ":" + port : ""}`;
    if (!currentHostHeader || currentHostHeader === requestToSign.hostname && requestToSign.port != null) {
      requestToSign.headers.host = expectedHostHeader;
    }
  }
}

// node_modules/@aws-sdk/s3-request-presigner/dist-es/getSignedUrl.js
var getSignedUrl = async (client2, command, options = {}) => {
  let s3Presigner;
  let region;
  if (typeof client2.config.endpointProvider === "function") {
    const endpointV2 = await import_middleware_endpoint71.getEndpointFromInstructions(command.input, command.constructor, client2.config);
    const authScheme = endpointV2.properties?.authSchemes?.[0];
    if (authScheme?.name === "sigv4a") {
      region = authScheme?.signingRegionSet?.join(",");
    } else {
      region = authScheme?.signingRegion;
    }
    s3Presigner = new S3RequestPresigner({
      ...client2.config,
      signingName: authScheme?.signingName,
      region: async () => region
    });
  } else {
    s3Presigner = new S3RequestPresigner(client2.config);
  }
  const presignInterceptMiddleware = (next, context) => async (args) => {
    const { request: request2 } = args;
    if (!import_protocol_http16.HttpRequest.isInstance(request2)) {
      throw new Error("Request to be presigned is not an valid HTTP request.");
    }
    delete request2.headers["amz-sdk-invocation-id"];
    delete request2.headers["amz-sdk-request"];
    delete request2.headers["x-amz-user-agent"];
    let presigned2;
    const presignerOptions = {
      ...options,
      signingRegion: options.signingRegion ?? context["signing_region"] ?? region,
      signingService: options.signingService ?? context["signing_service"]
    };
    if (context.s3ExpressIdentity) {
      presigned2 = await s3Presigner.presignWithCredentials(request2, context.s3ExpressIdentity, presignerOptions);
    } else {
      presigned2 = await s3Presigner.presign(request2, presignerOptions);
    }
    return {
      response: {},
      output: {
        $metadata: { httpStatusCode: 200 },
        presigned: presigned2
      }
    };
  };
  const middlewareName = "presignInterceptMiddleware";
  const clientStack = client2.middlewareStack.clone();
  clientStack.addRelativeTo(presignInterceptMiddleware, {
    name: middlewareName,
    relation: "before",
    toMiddleware: "awsAuthMiddleware",
    override: true
  });
  const handler = command.resolveMiddleware(clientStack, client2.config, {});
  const { output } = await handler({ input: command.input });
  const { presigned } = output;
  return formatUrl(presigned);
};

// src/config/s3.ts
var s3Client = new S3Client({
  region: process.env.AWS_REGION || "us-east-1"
});
var S3_BUCKET_NAME = process.env.S3_BUCKET_NAME || "pff-storage-uploads";
var S3_REGION = process.env.AWS_REGION || "us-east-1";
var S3_FOLDERS = {
  PAYMENT_SLIPS: "payment-slips",
  WAREHOUSE_IMAGES: "warehouse-images",
  USER_DOCUMENTS: "user-documents"
};

// src/utils/s3Upload.ts
var uploadFileToS3 = async (file, fileName, folder = S3_FOLDERS.PAYMENT_SLIPS, userId) => {
  try {
    const timestamp = Date.now();
    const sanitizedFileName = fileName.replace(/[^a-zA-Z0-9.-]/g, "_");
    const fileKey = userId ? `${folder}/${userId}/${timestamp}_${sanitizedFileName}` : `${folder}/${timestamp}_${sanitizedFileName}`;
    console.log("\uD83D\uDD27 S3 Upload Details:");
    console.log("   Bucket:", S3_BUCKET_NAME);
    console.log("   Key:", fileKey);
    console.log("   Size:", file.length, "bytes");
    const contentType = getContentType(fileName);
    console.log("   Content-Type:", contentType);
    const command = new PutObjectCommand({
      Bucket: S3_BUCKET_NAME,
      Key: fileKey,
      Body: file,
      ContentType: contentType
    });
    console.log("\uD83D\uDE80 Sending to S3...");
    await s3Client.send(command);
    console.log("\u2705 S3 upload complete!");
    const url = `https://${S3_BUCKET_NAME}.s3.${process.env.AWS_REGION || "us-east-1"}.amazonaws.com/${fileKey}`;
    return {
      success: true,
      key: fileKey,
      url
    };
  } catch (error) {
    console.error("\u274C Error uploading file to S3:", error);
    console.error("   Error name:", error.name);
    console.error("   Error message:", error.message);
    console.error("   Error code:", error.code);
    return {
      success: false,
      error: error.message || "Failed to upload file"
    };
  }
};
var getPresignedUrl = async (key, expiresIn = 3600) => {
  try {
    const command = new GetObjectCommand({
      Bucket: S3_BUCKET_NAME,
      Key: key
    });
    const url = await getSignedUrl(s3Client, command, { expiresIn });
    return url;
  } catch (error) {
    console.error("Error generating presigned URL:", error);
    throw new Error("Failed to generate presigned URL");
  }
};
function getContentType(fileName) {
  const ext = fileName.split(".").pop()?.toLowerCase();
  const contentTypes = {
    jpg: "image/jpeg",
    jpeg: "image/jpeg",
    png: "image/png",
    gif: "image/gif",
    webp: "image/webp",
    svg: "image/svg+xml",
    pdf: "application/pdf",
    doc: "application/msword",
    docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    xls: "application/vnd.ms-excel",
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    txt: "text/plain"
  };
  return contentTypes[ext || ""] || "application/octet-stream";
}
var validateFileType = (fileName, allowedTypes) => {
  const ext = fileName.split(".").pop()?.toLowerCase();
  return allowedTypes.includes(ext || "");
};
var validateFileSize = (fileSize, maxSizeMB) => {
  const maxSizeBytes = maxSizeMB * 1024 * 1024;
  return fileSize <= maxSizeBytes;
};

// src/controllers/admin.controller.ts
var getDashboardStats = async () => {
  try {
    const warehouseStats = await getStats();
    const allRentals = await findAll3();
    const activeRentals = allRentals.filter((r5) => r5.status === "ACTIVE");
    const pendingRentals = allRentals.filter((r5) => r5.status === "PENDING");
    const uniqueUsers = new Set(allRentals.map((r5) => r5.userId)).size;
    let monthlyRevenue = 0;
    for (const rental of activeRentals) {
      const rentalData = rental;
      const warehouse = await findById2(rentalData.warehouseId);
      if (warehouse) {
        monthlyRevenue += warehouse.price || 0;
      }
    }
    return {
      success: true,
      stats: {
        totalWarehouses: warehouseStats.total,
        availableWarehouses: warehouseStats.available,
        available: warehouseStats.available,
        rented: warehouseStats.rented,
        totalUsers: uniqueUsers,
        activeRentals: activeRentals.length,
        pendingApprovals: pendingRentals.length,
        monthlyRevenue,
        newUsersThisMonth: Math.floor(uniqueUsers * 0.2),
        expiredThisMonth: Math.floor(activeRentals.length * 0.1)
      }
    };
  } catch (error) {
    console.error("Error fetching dashboard stats:", error);
    return {
      error: "Failed to fetch dashboard stats",
      details: error.message,
      status: 500
    };
  }
};
var getAllUsers2 = async () => {
  try {
    const allRentals = await findAll3();
    const userMap = new Map;
    for (const rental of allRentals) {
      const userId = rental.userId;
      if (!userMap.has(userId)) {
        const warehouse = await findById2(rental.warehouseId);
        userMap.set(userId, {
          userId,
          email: `${userId}@example.com`,
          company: "\u0E1A\u0E23\u0E34\u0E29\u0E31\u0E17\u0E15\u0E31\u0E27\u0E2D\u0E22\u0E48\u0E32\u0E07 \u0E08\u0E33\u0E01\u0E31\u0E14",
          warehouseName: warehouse?.name || "Unknown",
          startDate: rental.startDate,
          endDate: rental.endDate,
          status: rental.status,
          totalRentals: 0
        });
      }
      const user = userMap.get(userId);
      user.totalRentals++;
    }
    return {
      success: true,
      users: Array.from(userMap.values())
    };
  } catch (error) {
    console.error("Error fetching users:", error);
    return {
      error: "Failed to fetch users",
      details: error.message,
      status: 500
    };
  }
};
var getPendingRentals = async () => {
  try {
    const pendingRentals = await findPendingRentals();
    console.log("\uD83D\uDCCB Found pending rentals:", pendingRentals.length);
    const enrichedRentals = await Promise.all(pendingRentals.map(async (rental) => {
      try {
        const warehouse = await findById2(rental.warehouseId);
        const rooms = await getRoomsByWarehouseId(rental.warehouseId);
        const room = rooms.find((r5) => r5.roomId === rental.roomId);
        let paymentSlipUrl = null;
        if (rental.paymentSlip) {
          try {
            const url = new URL(rental.paymentSlip);
            const key = url.pathname.substring(1);
            paymentSlipUrl = await getPresignedUrl(key, 3600);
            console.log(`\u2705 Generated presigned URL for ${rental.rentalId}`);
          } catch (error) {
            console.error(`\u274C Error generating presigned URL:`, error);
            paymentSlipUrl = rental.paymentSlip;
          }
        }
        console.log(`\uD83D\uDCC4 Rental ${rental.rentalId}:`, {
          hasPaymentSlip: !!rental.paymentSlip,
          paymentSlipUrl
        });
        return {
          ...rental,
          warehouseName: warehouse?.name || "Unknown",
          roomNumber: room?.roomNumber || "Unknown",
          roomSize: room?.size || "Unknown",
          paymentSlip: paymentSlipUrl
        };
      } catch (error) {
        return rental;
      }
    }));
    return {
      success: true,
      rentals: enrichedRentals
    };
  } catch (error) {
    console.error("Error fetching pending rentals:", error);
    return {
      error: "Failed to fetch pending rentals",
      details: error.message,
      status: 500
    };
  }
};
var approveRental2 = async ({ params, body }) => {
  try {
    const { userId, rentalId } = params;
    const { approvedBy } = body;
    if (!userId || !rentalId) {
      return {
        error: "Missing userId or rentalId",
        status: 400
      };
    }
    if (!approvedBy) {
      return {
        error: "approvedBy (admin ID) is required",
        status: 400
      };
    }
    const rental = await findById3(userId, rentalId);
    if (!rental) {
      return {
        error: "Rental not found",
        status: 404
      };
    }
    if (rental.status !== "PENDING") {
      return {
        error: `Rental is already ${rental.status}`,
        status: 400
      };
    }
    const rooms = await getRoomsByWarehouseId(rental.warehouseId);
    const room = rooms.find((r5) => r5.roomId === rental.roomId);
    if (!room) {
      return {
        error: "Room not found",
        status: 404
      };
    }
    if (room.status !== "AVAILABLE") {
      return {
        error: "Room is no longer available",
        status: 400
      };
    }
    await approveRental(userId, rentalId, approvedBy);
    await updateRoomStatus(rental.warehouseId, rental.roomId, "OCCUPIED");
    return {
      success: true,
      message: "Rental approved successfully"
    };
  } catch (error) {
    console.error("Error approving rental:", error);
    return {
      error: "Failed to approve rental",
      details: error.message,
      status: 500
    };
  }
};
var rejectRental2 = async ({ params, body }) => {
  try {
    const { userId, rentalId } = params;
    const { rejectedBy } = body;
    if (!userId || !rentalId) {
      return {
        error: "Missing userId or rentalId",
        status: 400
      };
    }
    if (!rejectedBy) {
      return {
        error: "rejectedBy (admin ID) is required",
        status: 400
      };
    }
    const rental = await findById3(userId, rentalId);
    if (!rental) {
      return {
        error: "Rental not found",
        status: 404
      };
    }
    if (rental.status !== "PENDING") {
      return {
        error: `Rental is already ${rental.status}`,
        status: 400
      };
    }
    await rejectRental(userId, rentalId, rejectedBy);
    return {
      success: true,
      message: "Rental rejected successfully"
    };
  } catch (error) {
    console.error("Error rejecting rental:", error);
    return {
      error: "Failed to reject rental",
      details: error.message,
      status: 500
    };
  }
};
var getAllWarehouses2 = async () => {
  try {
    const warehouses = await findAll2();
    const warehousesWithDetails = await Promise.all(warehouses.map(async (warehouse) => {
      const rooms = await getRoomsByWarehouseId(warehouse.warehouseId);
      const availableRooms = rooms.filter((room) => room.status === "AVAILABLE").length;
      const occupiedRooms = rooms.filter((room) => room.status === "OCCUPIED").length;
      return {
        ...warehouse,
        totalRooms: rooms.length,
        availableRooms,
        occupiedRooms
      };
    }));
    return {
      success: true,
      warehouses: warehousesWithDetails
    };
  } catch (error) {
    console.error("Error fetching warehouses:", error);
    return {
      error: "Failed to fetch warehouses",
      details: error.message,
      status: 500
    };
  }
};
var getAllCognitoUsers = async () => {
  try {
    const cognitoClient = new CognitoIdentityProviderClient({
      region: process.env.AWS_REGION || "us-east-1"
    });
    const userPoolId = process.env.USER_POOL_ID;
    if (!userPoolId) {
      console.error("USER_POOL_ID environment variable is not set");
      return {
        error: "User pool configuration missing",
        status: 500
      };
    }
    const command = new ListUsersCommand({
      UserPoolId: userPoolId,
      Limit: 60
    });
    const response = await cognitoClient.send(command);
    const allRentals = await findAll3();
    const users = (response.Users || []).map((cognitoUser) => {
      const email = cognitoUser.Attributes?.find((attr) => attr.Name === "email")?.Value || "";
      const sub = cognitoUser.Attributes?.find((attr) => attr.Name === "sub")?.Value || "";
      const name = cognitoUser.Attributes?.find((attr) => attr.Name === "name")?.Value || "";
      const userRentals = allRentals.filter((rental) => rental.userId === sub || rental.userId === cognitoUser.Username);
      const activeRentals = userRentals.filter((r5) => r5.status === "ACTIVE");
      const pendingRentals = userRentals.filter((r5) => r5.status === "PENDING");
      return {
        userId: sub || cognitoUser.Username,
        username: cognitoUser.Username,
        email,
        name,
        status: cognitoUser.UserStatus,
        enabled: cognitoUser.Enabled,
        createdAt: cognitoUser.UserCreateDate,
        lastModified: cognitoUser.UserLastModifiedDate,
        totalRentals: userRentals.length,
        activeRentals: activeRentals.length,
        pendingRentals: pendingRentals.length
      };
    });
    return {
      success: true,
      users,
      count: users.length
    };
  } catch (error) {
    console.error("Error fetching Cognito users:", error);
    return {
      error: "Failed to fetch users from Cognito",
      details: error.message,
      status: 500
    };
  }
};

// src/routes/admin.routes.ts
var admin_routes_default = new Elysia({ prefix: "/api/admin" }).get("/stats", getDashboardStats).get("/users", getAllUsers2).get("/users/cognito", getAllCognitoUsers).get("/warehouses", getAllWarehouses2).get("/rentals/pending", getPendingRentals).post("/rentals/:userId/:rentalId/approve", approveRental2).post("/rentals/:userId/:rentalId/reject", rejectRental2);

// src/controllers/upload.controller.ts
var ALLOWED_PAYMENT_SLIP_TYPES = ["jpg", "jpeg", "png", "pdf"];
var MAX_FILE_SIZE_MB = 20;
var uploadPaymentSlip = async ({ body, set: set2 }) => {
  try {
    console.log("\uD83D\uDCE4 Upload Payment Slip Request Received");
    console.log("Body keys:", Object.keys(body));
    const { file, userId, rentalId } = body;
    if (!file) {
      console.log("\u274C No file provided");
      set2.status = 400;
      return {
        success: false,
        error: "No file provided"
      };
    }
    if (!userId) {
      console.log("\u274C No userId provided");
      set2.status = 400;
      return {
        success: false,
        error: "User ID is required"
      };
    }
    const fileName = file.name || "payment-slip.jpg";
    const fileBuffer = Buffer.from(await file.arrayBuffer());
    const fileSize = fileBuffer.length;
    console.log("\uD83D\uDCC4 File Info:", {
      fileName,
      fileSize: `${(fileSize / 1024).toFixed(2)} KB`,
      userId,
      rentalId
    });
    if (!validateFileType(fileName, ALLOWED_PAYMENT_SLIP_TYPES)) {
      console.log("\u274C Invalid file type:", fileName);
      set2.status = 400;
      return {
        success: false,
        error: `Invalid file type. Allowed types: ${ALLOWED_PAYMENT_SLIP_TYPES.join(", ")}`
      };
    }
    if (!validateFileSize(fileSize, MAX_FILE_SIZE_MB)) {
      console.log("\u274C File too large:", fileSize);
      set2.status = 400;
      return {
        success: false,
        error: `File size exceeds ${MAX_FILE_SIZE_MB}MB limit`
      };
    }
    const folder = rentalId ? `${S3_FOLDERS.PAYMENT_SLIPS}/${userId}/${rentalId}` : `${S3_FOLDERS.PAYMENT_SLIPS}/${userId}`;
    console.log("\uD83D\uDCC1 Uploading to folder:", folder);
    const result = await uploadFileToS3(fileBuffer, fileName, folder, undefined);
    if (!result.success) {
      console.log("\u274C Upload failed:", result.error);
      set2.status = 500;
      return {
        success: false,
        error: result.error || "Failed to upload file"
      };
    }
    console.log("\u2705 Upload successful!");
    console.log("   Key:", result.key);
    console.log("   URL:", result.url);
    return {
      success: true,
      data: {
        key: result.key,
        url: result.url,
        fileName,
        fileSize,
        uploadedAt: new Date().toISOString()
      }
    };
  } catch (error) {
    console.error("\u274C Error in uploadPaymentSlip:", error);
    set2.status = 500;
    return {
      success: false,
      error: error.message || "Failed to upload payment slip"
    };
  }
};
var uploadWarehouseImage = async ({ body, set: set2 }) => {
  try {
    const { file, warehouseId } = body;
    if (!file) {
      set2.status = 400;
      return {
        success: false,
        error: "No file provided"
      };
    }
    if (!warehouseId) {
      set2.status = 400;
      return {
        success: false,
        error: "Warehouse ID is required"
      };
    }
    const fileName = file.name || "warehouse-image.jpg";
    const fileBuffer = Buffer.from(await file.arrayBuffer());
    if (!validateFileType(fileName, ["jpg", "jpeg", "png", "webp"])) {
      set2.status = 400;
      return {
        success: false,
        error: "Invalid image type. Allowed: jpg, jpeg, png, webp"
      };
    }
    if (!validateFileSize(fileBuffer.length, 10)) {
      set2.status = 400;
      return {
        success: false,
        error: "Image size exceeds 10MB limit"
      };
    }
    const folder = `${S3_FOLDERS.WAREHOUSE_IMAGES}/${warehouseId}`;
    const result = await uploadFileToS3(fileBuffer, fileName, folder, undefined);
    if (!result.success) {
      set2.status = 500;
      return {
        success: false,
        error: result.error || "Failed to upload image"
      };
    }
    return {
      success: true,
      data: {
        key: result.key,
        url: result.url,
        fileName,
        uploadedAt: new Date().toISOString()
      }
    };
  } catch (error) {
    console.error("Error in uploadWarehouseImage:", error);
    set2.status = 500;
    return {
      success: false,
      error: error.message || "Failed to upload warehouse image"
    };
  }
};

// src/routes/upload.routes.ts
var upload_routes_default = new Elysia({ prefix: "/api/upload" }).post("/payment-slip", uploadPaymentSlip).post("/warehouse-image", uploadWarehouseImage);

// src/app.ts
var app = new Elysia().use(cors({
  origin: "https://www.pff-storage.enddown.online",
  methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization"]
})).use(cors()).get("/", () => {
  return new Response(JSON.stringify({ message: "Welcome to PFF-Storage API" }), {
    headers: { "Content-Type": "application/json" },
    status: 200
  });
}).get("/health", () => new Response("healthy", { status: 200 })).use(user_routes_default).use(warehouse_routes_default).use(booking_routes_default).use(admin_routes_default).use(upload_routes_default);

// lambda.ts
var lambda_default = {
  async fetch(request2) {
    try {
      return await app.handle(request2);
    } catch (err3) {
      console.error("Lambda Error:", err3);
      return new Response(JSON.stringify({ error: String(err3) }), { status: 500, headers: { "Content-Type": "application/json" } });
    }
  }
};
export {
  lambda_default as default
};
